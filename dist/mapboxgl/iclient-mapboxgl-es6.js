/*!
 * 
 *          iclient-mapboxgl
 *          Copyright© 2000 - 2023 SuperMap Software Co.Ltd
 *          license: Apache-2.0
 *          version: v11.1.1
 *
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 932:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const validator = __webpack_require__(501);
const XMLParser = __webpack_require__(844);
const XMLBuilder = __webpack_require__(192);

module.exports = {
  XMLParser: XMLParser,
  XMLValidator: validator,
  XMLBuilder: XMLBuilder
}

/***/ }),

/***/ 849:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


const nameStartChar = ':A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD';
const nameChar = nameStartChar + '\\-.\\d\\u00B7\\u0300-\\u036F\\u203F-\\u2040';
const nameRegexp = '[' + nameStartChar + '][' + nameChar + ']*'
const regexName = new RegExp('^' + nameRegexp + '$');

const getAllMatches = function(string, regex) {
  const matches = [];
  let match = regex.exec(string);
  while (match) {
    const allmatches = [];
    allmatches.startIndex = regex.lastIndex - match[0].length;
    const len = match.length;
    for (let index = 0; index < len; index++) {
      allmatches.push(match[index]);
    }
    matches.push(allmatches);
    match = regex.exec(string);
  }
  return matches;
};

const isName = function(string) {
  const match = regexName.exec(string);
  return !(match === null || typeof match === 'undefined');
};

exports.isExist = function(v) {
  return typeof v !== 'undefined';
};

exports.isEmptyObject = function(obj) {
  return Object.keys(obj).length === 0;
};

/**
 * Copy all the properties of a into b.
 * @param {*} target
 * @param {*} a
 */
exports.merge = function(target, a, arrayMode) {
  if (a) {
    const keys = Object.keys(a); // will return an array of own properties
    const len = keys.length; //don't make it inline
    for (let i = 0; i < len; i++) {
      if (arrayMode === 'strict') {
        target[keys[i]] = [ a[keys[i]] ];
      } else {
        target[keys[i]] = a[keys[i]];
      }
    }
  }
};
/* exports.merge =function (b,a){
  return Object.assign(b,a);
} */

exports.getValue = function(v) {
  if (exports.isExist(v)) {
    return v;
  } else {
    return '';
  }
};

// const fakeCall = function(a) {return a;};
// const fakeCallNoReturn = function() {};

exports.isName = isName;
exports.getAllMatches = getAllMatches;
exports.nameRegexp = nameRegexp;


/***/ }),

/***/ 501:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


const util = __webpack_require__(849);

const defaultOptions = {
  allowBooleanAttributes: false, //A tag can have attributes without any value
  unpairedTags: []
};

//const tagsPattern = new RegExp("<\\/?([\\w:\\-_\.]+)\\s*\/?>","g");
exports.validate = function (xmlData, options) {
  options = Object.assign({}, defaultOptions, options);

  //xmlData = xmlData.replace(/(\r\n|\n|\r)/gm,"");//make it single line
  //xmlData = xmlData.replace(/(^\s*<\?xml.*?\?>)/g,"");//Remove XML starting tag
  //xmlData = xmlData.replace(/(<!DOCTYPE[\s\w\"\.\/\-\:]+(\[.*\])*\s*>)/g,"");//Remove DOCTYPE
  const tags = [];
  let tagFound = false;

  //indicates that the root tag has been closed (aka. depth 0 has been reached)
  let reachedRoot = false;

  if (xmlData[0] === '\ufeff') {
    // check for byte order mark (BOM)
    xmlData = xmlData.substr(1);
  }
  
  for (let i = 0; i < xmlData.length; i++) {

    if (xmlData[i] === '<' && xmlData[i+1] === '?') {
      i+=2;
      i = readPI(xmlData,i);
      if (i.err) return i;
    }else if (xmlData[i] === '<') {
      //starting of tag
      //read until you reach to '>' avoiding any '>' in attribute value
      let tagStartPos = i;
      i++;
      
      if (xmlData[i] === '!') {
        i = readCommentAndCDATA(xmlData, i);
        continue;
      } else {
        let closingTag = false;
        if (xmlData[i] === '/') {
          //closing tag
          closingTag = true;
          i++;
        }
        //read tagname
        let tagName = '';
        for (; i < xmlData.length &&
          xmlData[i] !== '>' &&
          xmlData[i] !== ' ' &&
          xmlData[i] !== '\t' &&
          xmlData[i] !== '\n' &&
          xmlData[i] !== '\r'; i++
        ) {
          tagName += xmlData[i];
        }
        tagName = tagName.trim();
        //console.log(tagName);

        if (tagName[tagName.length - 1] === '/') {
          //self closing tag without attributes
          tagName = tagName.substring(0, tagName.length - 1);
          //continue;
          i--;
        }
        if (!validateTagName(tagName)) {
          let msg;
          if (tagName.trim().length === 0) {
            msg = "Invalid space after '<'.";
          } else {
            msg = "Tag '"+tagName+"' is an invalid name.";
          }
          return getErrorObject('InvalidTag', msg, getLineNumberForPosition(xmlData, i));
        }

        const result = readAttributeStr(xmlData, i);
        if (result === false) {
          return getErrorObject('InvalidAttr', "Attributes for '"+tagName+"' have open quote.", getLineNumberForPosition(xmlData, i));
        }
        let attrStr = result.value;
        i = result.index;

        if (attrStr[attrStr.length - 1] === '/') {
          //self closing tag
          const attrStrStart = i - attrStr.length;
          attrStr = attrStr.substring(0, attrStr.length - 1);
          const isValid = validateAttributeString(attrStr, options);
          if (isValid === true) {
            tagFound = true;
            //continue; //text may presents after self closing tag
          } else {
            //the result from the nested function returns the position of the error within the attribute
            //in order to get the 'true' error line, we need to calculate the position where the attribute begins (i - attrStr.length) and then add the position within the attribute
            //this gives us the absolute index in the entire xml, which we can use to find the line at last
            return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, attrStrStart + isValid.err.line));
          }
        } else if (closingTag) {
          if (!result.tagClosed) {
            return getErrorObject('InvalidTag', "Closing tag '"+tagName+"' doesn't have proper closing.", getLineNumberForPosition(xmlData, i));
          } else if (attrStr.trim().length > 0) {
            return getErrorObject('InvalidTag', "Closing tag '"+tagName+"' can't have attributes or invalid starting.", getLineNumberForPosition(xmlData, tagStartPos));
          } else {
            const otg = tags.pop();
            if (tagName !== otg.tagName) {
              let openPos = getLineNumberForPosition(xmlData, otg.tagStartPos);
              return getErrorObject('InvalidTag',
                "Expected closing tag '"+otg.tagName+"' (opened in line "+openPos.line+", col "+openPos.col+") instead of closing tag '"+tagName+"'.",
                getLineNumberForPosition(xmlData, tagStartPos));
            }

            //when there are no more tags, we reached the root level.
            if (tags.length == 0) {
              reachedRoot = true;
            }
          }
        } else {
          const isValid = validateAttributeString(attrStr, options);
          if (isValid !== true) {
            //the result from the nested function returns the position of the error within the attribute
            //in order to get the 'true' error line, we need to calculate the position where the attribute begins (i - attrStr.length) and then add the position within the attribute
            //this gives us the absolute index in the entire xml, which we can use to find the line at last
            return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, i - attrStr.length + isValid.err.line));
          }

          //if the root level has been reached before ...
          if (reachedRoot === true) {
            return getErrorObject('InvalidXml', 'Multiple possible root nodes found.', getLineNumberForPosition(xmlData, i));
          } else if(options.unpairedTags.indexOf(tagName) !== -1){
            //don't push into stack
          } else {
            tags.push({tagName, tagStartPos});
          }
          tagFound = true;
        }

        //skip tag text value
        //It may include comments and CDATA value
        for (i++; i < xmlData.length; i++) {
          if (xmlData[i] === '<') {
            if (xmlData[i + 1] === '!') {
              //comment or CADATA
              i++;
              i = readCommentAndCDATA(xmlData, i);
              continue;
            } else if (xmlData[i+1] === '?') {
              i = readPI(xmlData, ++i);
              if (i.err) return i;
            } else{
              break;
            }
          } else if (xmlData[i] === '&') {
            const afterAmp = validateAmpersand(xmlData, i);
            if (afterAmp == -1)
              return getErrorObject('InvalidChar', "char '&' is not expected.", getLineNumberForPosition(xmlData, i));
            i = afterAmp;
          }else{
            if (reachedRoot === true && !isWhiteSpace(xmlData[i])) {
              return getErrorObject('InvalidXml', "Extra text at the end", getLineNumberForPosition(xmlData, i));
            }
          }
        } //end of reading tag text value
        if (xmlData[i] === '<') {
          i--;
        }
      }
    } else {
      if ( isWhiteSpace(xmlData[i])) {
        continue;
      }
      return getErrorObject('InvalidChar', "char '"+xmlData[i]+"' is not expected.", getLineNumberForPosition(xmlData, i));
    }
  }

  if (!tagFound) {
    return getErrorObject('InvalidXml', 'Start tag expected.', 1);
  }else if (tags.length == 1) {
      return getErrorObject('InvalidTag', "Unclosed tag '"+tags[0].tagName+"'.", getLineNumberForPosition(xmlData, tags[0].tagStartPos));
  }else if (tags.length > 0) {
      return getErrorObject('InvalidXml', "Invalid '"+
          JSON.stringify(tags.map(t => t.tagName), null, 4).replace(/\r?\n/g, '')+
          "' found.", {line: 1, col: 1});
  }

  return true;
};

function isWhiteSpace(char){
  return char === ' ' || char === '\t' || char === '\n'  || char === '\r';
}
/**
 * Read Processing insstructions and skip
 * @param {*} xmlData
 * @param {*} i
 */
function readPI(xmlData, i) {
  const start = i;
  for (; i < xmlData.length; i++) {
    if (xmlData[i] == '?' || xmlData[i] == ' ') {
      //tagname
      const tagname = xmlData.substr(start, i - start);
      if (i > 5 && tagname === 'xml') {
        return getErrorObject('InvalidXml', 'XML declaration allowed only at the start of the document.', getLineNumberForPosition(xmlData, i));
      } else if (xmlData[i] == '?' && xmlData[i + 1] == '>') {
        //check if valid attribut string
        i++;
        break;
      } else {
        continue;
      }
    }
  }
  return i;
}

function readCommentAndCDATA(xmlData, i) {
  if (xmlData.length > i + 5 && xmlData[i + 1] === '-' && xmlData[i + 2] === '-') {
    //comment
    for (i += 3; i < xmlData.length; i++) {
      if (xmlData[i] === '-' && xmlData[i + 1] === '-' && xmlData[i + 2] === '>') {
        i += 2;
        break;
      }
    }
  } else if (
    xmlData.length > i + 8 &&
    xmlData[i + 1] === 'D' &&
    xmlData[i + 2] === 'O' &&
    xmlData[i + 3] === 'C' &&
    xmlData[i + 4] === 'T' &&
    xmlData[i + 5] === 'Y' &&
    xmlData[i + 6] === 'P' &&
    xmlData[i + 7] === 'E'
  ) {
    let angleBracketsCount = 1;
    for (i += 8; i < xmlData.length; i++) {
      if (xmlData[i] === '<') {
        angleBracketsCount++;
      } else if (xmlData[i] === '>') {
        angleBracketsCount--;
        if (angleBracketsCount === 0) {
          break;
        }
      }
    }
  } else if (
    xmlData.length > i + 9 &&
    xmlData[i + 1] === '[' &&
    xmlData[i + 2] === 'C' &&
    xmlData[i + 3] === 'D' &&
    xmlData[i + 4] === 'A' &&
    xmlData[i + 5] === 'T' &&
    xmlData[i + 6] === 'A' &&
    xmlData[i + 7] === '['
  ) {
    for (i += 8; i < xmlData.length; i++) {
      if (xmlData[i] === ']' && xmlData[i + 1] === ']' && xmlData[i + 2] === '>') {
        i += 2;
        break;
      }
    }
  }

  return i;
}

const doubleQuote = '"';
const singleQuote = "'";

/**
 * Keep reading xmlData until '<' is found outside the attribute value.
 * @param {string} xmlData
 * @param {number} i
 */
function readAttributeStr(xmlData, i) {
  let attrStr = '';
  let startChar = '';
  let tagClosed = false;
  for (; i < xmlData.length; i++) {
    if (xmlData[i] === doubleQuote || xmlData[i] === singleQuote) {
      if (startChar === '') {
        startChar = xmlData[i];
      } else if (startChar !== xmlData[i]) {
        //if vaue is enclosed with double quote then single quotes are allowed inside the value and vice versa
      } else {
        startChar = '';
      }
    } else if (xmlData[i] === '>') {
      if (startChar === '') {
        tagClosed = true;
        break;
      }
    }
    attrStr += xmlData[i];
  }
  if (startChar !== '') {
    return false;
  }

  return {
    value: attrStr,
    index: i,
    tagClosed: tagClosed
  };
}

/**
 * Select all the attributes whether valid or invalid.
 */
const validAttrStrRegxp = new RegExp('(\\s*)([^\\s=]+)(\\s*=)?(\\s*([\'"])(([\\s\\S])*?)\\5)?', 'g');

//attr, ="sd", a="amit's", a="sd"b="saf", ab  cd=""

function validateAttributeString(attrStr, options) {
  //console.log("start:"+attrStr+":end");

  //if(attrStr.trim().length === 0) return true; //empty string

  const matches = util.getAllMatches(attrStr, validAttrStrRegxp);
  const attrNames = {};

  for (let i = 0; i < matches.length; i++) {
    if (matches[i][1].length === 0) {
      //nospace before attribute name: a="sd"b="saf"
      return getErrorObject('InvalidAttr', "Attribute '"+matches[i][2]+"' has no space in starting.", getPositionFromMatch(matches[i]))
    } else if (matches[i][3] !== undefined && matches[i][4] === undefined) {
      return getErrorObject('InvalidAttr', "Attribute '"+matches[i][2]+"' is without value.", getPositionFromMatch(matches[i]));
    } else if (matches[i][3] === undefined && !options.allowBooleanAttributes) {
      //independent attribute: ab
      return getErrorObject('InvalidAttr', "boolean attribute '"+matches[i][2]+"' is not allowed.", getPositionFromMatch(matches[i]));
    }
    /* else if(matches[i][6] === undefined){//attribute without value: ab=
                    return { err: { code:"InvalidAttr",msg:"attribute " + matches[i][2] + " has no value assigned."}};
                } */
    const attrName = matches[i][2];
    if (!validateAttrName(attrName)) {
      return getErrorObject('InvalidAttr', "Attribute '"+attrName+"' is an invalid name.", getPositionFromMatch(matches[i]));
    }
    if (!attrNames.hasOwnProperty(attrName)) {
      //check for duplicate attribute.
      attrNames[attrName] = 1;
    } else {
      return getErrorObject('InvalidAttr', "Attribute '"+attrName+"' is repeated.", getPositionFromMatch(matches[i]));
    }
  }

  return true;
}

function validateNumberAmpersand(xmlData, i) {
  let re = /\d/;
  if (xmlData[i] === 'x') {
    i++;
    re = /[\da-fA-F]/;
  }
  for (; i < xmlData.length; i++) {
    if (xmlData[i] === ';')
      return i;
    if (!xmlData[i].match(re))
      break;
  }
  return -1;
}

function validateAmpersand(xmlData, i) {
  // https://www.w3.org/TR/xml/#dt-charref
  i++;
  if (xmlData[i] === ';')
    return -1;
  if (xmlData[i] === '#') {
    i++;
    return validateNumberAmpersand(xmlData, i);
  }
  let count = 0;
  for (; i < xmlData.length; i++, count++) {
    if (xmlData[i].match(/\w/) && count < 20)
      continue;
    if (xmlData[i] === ';')
      break;
    return -1;
  }
  return i;
}

function getErrorObject(code, message, lineNumber) {
  return {
    err: {
      code: code,
      msg: message,
      line: lineNumber.line || lineNumber,
      col: lineNumber.col,
    },
  };
}

function validateAttrName(attrName) {
  return util.isName(attrName);
}

// const startsWithXML = /^xml/i;

function validateTagName(tagname) {
  return util.isName(tagname) /* && !tagname.match(startsWithXML) */;
}

//this function returns the line number for the character at the given index
function getLineNumberForPosition(xmlData, index) {
  const lines = xmlData.substring(0, index).split(/\r?\n/);
  return {
    line: lines.length,

    // column number is last line's length + 1, because column numbering starts at 1:
    col: lines[lines.length - 1].length + 1
  };
}

//this function returns the position of the first character of match within attrStr
function getPositionFromMatch(match) {
  return match.startIndex + match[1].length;
}


/***/ }),

/***/ 192:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

//parse Empty Node as self closing node
const buildFromOrderedJs = __webpack_require__(592);

const defaultOptions = {
  attributeNamePrefix: '@_',
  attributesGroupName: false,
  textNodeName: '#text',
  ignoreAttributes: true,
  cdataPropName: false,
  format: false,
  indentBy: '  ',
  suppressEmptyNode: false,
  suppressUnpairedNode: true,
  suppressBooleanAttributes: true,
  tagValueProcessor: function(key, a) {
    return a;
  },
  attributeValueProcessor: function(attrName, a) {
    return a;
  },
  preserveOrder: false,
  commentPropName: false,
  unpairedTags: [],
  entities: [
    { regex: new RegExp("&", "g"), val: "&amp;" },//it must be on top
    { regex: new RegExp(">", "g"), val: "&gt;" },
    { regex: new RegExp("<", "g"), val: "&lt;" },
    { regex: new RegExp("\'", "g"), val: "&apos;" },
    { regex: new RegExp("\"", "g"), val: "&quot;" }
  ],
  processEntities: true,
  stopNodes: [],
  // transformTagName: false,
  // transformAttributeName: false,
  oneListGroup: false
};

function Builder(options) {
  this.options = Object.assign({}, defaultOptions, options);
  if (this.options.ignoreAttributes || this.options.attributesGroupName) {
    this.isAttribute = function(/*a*/) {
      return false;
    };
  } else {
    this.attrPrefixLen = this.options.attributeNamePrefix.length;
    this.isAttribute = isAttribute;
  }

  this.processTextOrObjNode = processTextOrObjNode

  if (this.options.format) {
    this.indentate = indentate;
    this.tagEndChar = '>\n';
    this.newLine = '\n';
  } else {
    this.indentate = function() {
      return '';
    };
    this.tagEndChar = '>';
    this.newLine = '';
  }
}

Builder.prototype.build = function(jObj) {
  if(this.options.preserveOrder){
    return buildFromOrderedJs(jObj, this.options);
  }else {
    if(Array.isArray(jObj) && this.options.arrayNodeName && this.options.arrayNodeName.length > 1){
      jObj = {
        [this.options.arrayNodeName] : jObj
      }
    }
    return this.j2x(jObj, 0).val;
  }
};

Builder.prototype.j2x = function(jObj, level) {
  let attrStr = '';
  let val = '';
  for (let key in jObj) {
    if (typeof jObj[key] === 'undefined') {
      // supress undefined node only if it is not an attribute
      if (this.isAttribute(key)) {
        val += '';
      }
    } else if (jObj[key] === null) {
      // null attribute should be ignored by the attribute list, but should not cause the tag closing
      if (this.isAttribute(key)) {
        val += '';
      } else if (key[0] === '?') {
        val += this.indentate(level) + '<' + key + '?' + this.tagEndChar;
      } else {
        val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;
      }
      // val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;
    } else if (jObj[key] instanceof Date) {
      val += this.buildTextValNode(jObj[key], key, '', level);
    } else if (typeof jObj[key] !== 'object') {
      //premitive type
      const attr = this.isAttribute(key);
      if (attr) {
        attrStr += this.buildAttrPairStr(attr, '' + jObj[key]);
      }else {
        //tag value
        if (key === this.options.textNodeName) {
          let newval = this.options.tagValueProcessor(key, '' + jObj[key]);
          val += this.replaceEntitiesValue(newval);
        } else {
          val += this.buildTextValNode(jObj[key], key, '', level);
        }
      }
    } else if (Array.isArray(jObj[key])) {
      //repeated nodes
      const arrLen = jObj[key].length;
      let listTagVal = "";
      for (let j = 0; j < arrLen; j++) {
        const item = jObj[key][j];
        if (typeof item === 'undefined') {
          // supress undefined node
        } else if (item === null) {
          if(key[0] === "?") val += this.indentate(level) + '<' + key + '?' + this.tagEndChar;
          else val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;
          // val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;
        } else if (typeof item === 'object') {
          if(this.options.oneListGroup ){
            listTagVal += this.j2x(item, level + 1).val;
          }else{
            listTagVal += this.processTextOrObjNode(item, key, level)
          }
        } else {
          listTagVal += this.buildTextValNode(item, key, '', level);
        }
      }
      if(this.options.oneListGroup){
        listTagVal = this.buildObjectNode(listTagVal, key, '', level);
      }
      val += listTagVal;
    } else {
      //nested node
      if (this.options.attributesGroupName && key === this.options.attributesGroupName) {
        const Ks = Object.keys(jObj[key]);
        const L = Ks.length;
        for (let j = 0; j < L; j++) {
          attrStr += this.buildAttrPairStr(Ks[j], '' + jObj[key][Ks[j]]);
        }
      } else {
        val += this.processTextOrObjNode(jObj[key], key, level)
      }
    }
  }
  return {attrStr: attrStr, val: val};
};

Builder.prototype.buildAttrPairStr = function(attrName, val){
  val = this.options.attributeValueProcessor(attrName, '' + val);
  val = this.replaceEntitiesValue(val);
  if (this.options.suppressBooleanAttributes && val === "true") {
    return ' ' + attrName;
  } else return ' ' + attrName + '="' + val + '"';
}

function processTextOrObjNode (object, key, level) {
  const result = this.j2x(object, level + 1);
  if (object[this.options.textNodeName] !== undefined && Object.keys(object).length === 1) {
    return this.buildTextValNode(object[this.options.textNodeName], key, result.attrStr, level);
  } else {
    return this.buildObjectNode(result.val, key, result.attrStr, level);
  }
}

Builder.prototype.buildObjectNode = function(val, key, attrStr, level) {
  if(val === ""){
    if(key[0] === "?") return  this.indentate(level) + '<' + key + attrStr+ '?' + this.tagEndChar;
    else {
      return this.indentate(level) + '<' + key + attrStr + this.closeTag(key) + this.tagEndChar;
    }
  }else{

    let tagEndExp = '</' + key + this.tagEndChar;
    let piClosingChar = "";
    
    if(key[0] === "?") {
      piClosingChar = "?";
      tagEndExp = "";
    }
  
    // attrStr is an empty string in case the attribute came as undefined or null
    if ((attrStr || attrStr === '') && val.indexOf('<') === -1) {
      return ( this.indentate(level) + '<' +  key + attrStr + piClosingChar + '>' + val + tagEndExp );
    } else if (this.options.commentPropName !== false && key === this.options.commentPropName && piClosingChar.length === 0) {
      return this.indentate(level) + `<!--${val}-->` + this.newLine;
    }else {
      return (
        this.indentate(level) + '<' + key + attrStr + piClosingChar + this.tagEndChar +
        val +
        this.indentate(level) + tagEndExp    );
    }
  }
}

Builder.prototype.closeTag = function(key){
  let closeTag = "";
  if(this.options.unpairedTags.indexOf(key) !== -1){ //unpaired
    if(!this.options.suppressUnpairedNode) closeTag = "/"
  }else if(this.options.suppressEmptyNode){ //empty
    closeTag = "/";
  }else{
    closeTag = `></${key}`
  }
  return closeTag;
}

function buildEmptyObjNode(val, key, attrStr, level) {
  if (val !== '') {
    return this.buildObjectNode(val, key, attrStr, level);
  } else {
    if(key[0] === "?") return  this.indentate(level) + '<' + key + attrStr+ '?' + this.tagEndChar;
    else {
      return  this.indentate(level) + '<' + key + attrStr + '/' + this.tagEndChar;
      // return this.buildTagStr(level,key, attrStr);
    }
  }
}

Builder.prototype.buildTextValNode = function(val, key, attrStr, level) {
  if (this.options.cdataPropName !== false && key === this.options.cdataPropName) {
    return this.indentate(level) + `<![CDATA[${val}]]>` +  this.newLine;
  }else if (this.options.commentPropName !== false && key === this.options.commentPropName) {
    return this.indentate(level) + `<!--${val}-->` +  this.newLine;
  }else if(key[0] === "?") {//PI tag
    return  this.indentate(level) + '<' + key + attrStr+ '?' + this.tagEndChar; 
  }else{
    let textValue = this.options.tagValueProcessor(key, val);
    textValue = this.replaceEntitiesValue(textValue);
  
    if( textValue === ''){
      return this.indentate(level) + '<' + key + attrStr + this.closeTag(key) + this.tagEndChar;
    }else{
      return this.indentate(level) + '<' + key + attrStr + '>' +
         textValue +
        '</' + key + this.tagEndChar;
    }
  }
}

Builder.prototype.replaceEntitiesValue = function(textValue){
  if(textValue && textValue.length > 0 && this.options.processEntities){
    for (let i=0; i<this.options.entities.length; i++) {
      const entity = this.options.entities[i];
      textValue = textValue.replace(entity.regex, entity.val);
    }
  }
  return textValue;
}

function indentate(level) {
  return this.options.indentBy.repeat(level);
}

function isAttribute(name /*, options*/) {
  if (name.startsWith(this.options.attributeNamePrefix) && name !== this.options.textNodeName) {
    return name.substr(this.attrPrefixLen);
  } else {
    return false;
  }
}

module.exports = Builder;


/***/ }),

/***/ 592:
/***/ ((module) => {

const EOL = "\n";

/**
 * 
 * @param {array} jArray 
 * @param {any} options 
 * @returns 
 */
function toXml(jArray, options) {
    let indentation = "";
    if (options.format && options.indentBy.length > 0) {
        indentation = EOL;
    }
    return arrToStr(jArray, options, "", indentation);
}

function arrToStr(arr, options, jPath, indentation) {
    let xmlStr = "";
    let isPreviousElementTag = false;

    for (let i = 0; i < arr.length; i++) {
        const tagObj = arr[i];
        const tagName = propName(tagObj);
        let newJPath = "";
        if (jPath.length === 0) newJPath = tagName
        else newJPath = `${jPath}.${tagName}`;

        if (tagName === options.textNodeName) {
            let tagText = tagObj[tagName];
            if (!isStopNode(newJPath, options)) {
                tagText = options.tagValueProcessor(tagName, tagText);
                tagText = replaceEntitiesValue(tagText, options);
            }
            if (isPreviousElementTag) {
                xmlStr += indentation;
            }
            xmlStr += tagText;
            isPreviousElementTag = false;
            continue;
        } else if (tagName === options.cdataPropName) {
            if (isPreviousElementTag) {
                xmlStr += indentation;
            }
            xmlStr += `<![CDATA[${tagObj[tagName][0][options.textNodeName]}]]>`;
            isPreviousElementTag = false;
            continue;
        } else if (tagName === options.commentPropName) {
            xmlStr += indentation + `<!--${tagObj[tagName][0][options.textNodeName]}-->`;
            isPreviousElementTag = true;
            continue;
        } else if (tagName[0] === "?") {
            const attStr = attr_to_str(tagObj[":@"], options);
            const tempInd = tagName === "?xml" ? "" : indentation;
            let piTextNodeName = tagObj[tagName][0][options.textNodeName];
            piTextNodeName = piTextNodeName.length !== 0 ? " " + piTextNodeName : ""; //remove extra spacing
            xmlStr += tempInd + `<${tagName}${piTextNodeName}${attStr}?>`;
            isPreviousElementTag = true;
            continue;
        }
        let newIdentation = indentation;
        if (newIdentation !== "") {
            newIdentation += options.indentBy;
        }
        const attStr = attr_to_str(tagObj[":@"], options);
        const tagStart = indentation + `<${tagName}${attStr}`;
        const tagValue = arrToStr(tagObj[tagName], options, newJPath, newIdentation);
        if (options.unpairedTags.indexOf(tagName) !== -1) {
            if (options.suppressUnpairedNode) xmlStr += tagStart + ">";
            else xmlStr += tagStart + "/>";
        } else if ((!tagValue || tagValue.length === 0) && options.suppressEmptyNode) {
            xmlStr += tagStart + "/>";
        } else if (tagValue && tagValue.endsWith(">")) {
            xmlStr += tagStart + `>${tagValue}${indentation}</${tagName}>`;
        } else {
            xmlStr += tagStart + ">";
            if (tagValue && indentation !== "" && (tagValue.includes("/>") || tagValue.includes("</"))) {
                xmlStr += indentation + options.indentBy + tagValue + indentation;
            } else {
                xmlStr += tagValue;
            }
            xmlStr += `</${tagName}>`;
        }
        isPreviousElementTag = true;
    }

    return xmlStr;
}

function propName(obj) {
    const keys = Object.keys(obj);
    for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        if (key !== ":@") return key;
    }
}

function attr_to_str(attrMap, options) {
    let attrStr = "";
    if (attrMap && !options.ignoreAttributes) {
        for (let attr in attrMap) {
            let attrVal = options.attributeValueProcessor(attr, attrMap[attr]);
            attrVal = replaceEntitiesValue(attrVal, options);
            if (attrVal === true && options.suppressBooleanAttributes) {
                attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}`;
            } else {
                attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}="${attrVal}"`;
            }
        }
    }
    return attrStr;
}

function isStopNode(jPath, options) {
    jPath = jPath.substr(0, jPath.length - options.textNodeName.length - 1);
    let tagName = jPath.substr(jPath.lastIndexOf(".") + 1);
    for (let index in options.stopNodes) {
        if (options.stopNodes[index] === jPath || options.stopNodes[index] === "*." + tagName) return true;
    }
    return false;
}

function replaceEntitiesValue(textValue, options) {
    if (textValue && textValue.length > 0 && options.processEntities) {
        for (let i = 0; i < options.entities.length; i++) {
            const entity = options.entities[i];
            textValue = textValue.replace(entity.regex, entity.val);
        }
    }
    return textValue;
}
module.exports = toXml;


/***/ }),

/***/ 780:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const util = __webpack_require__(849);

//TODO: handle comments
function readDocType(xmlData, i){
    
    const entities = {};
    if( xmlData[i + 3] === 'O' &&
         xmlData[i + 4] === 'C' &&
         xmlData[i + 5] === 'T' &&
         xmlData[i + 6] === 'Y' &&
         xmlData[i + 7] === 'P' &&
         xmlData[i + 8] === 'E')
    {    
        i = i+9;
        let angleBracketsCount = 1;
        let hasBody = false, comment = false;
        let exp = "";
        for(;i<xmlData.length;i++){
            if (xmlData[i] === '<' && !comment) { //Determine the tag type
                if( hasBody && isEntity(xmlData, i)){
                    i += 7; 
                    [entityName, val,i] = readEntityExp(xmlData,i+1);
                    if(val.indexOf("&") === -1) //Parameter entities are not supported
                        entities[ validateEntityName(entityName) ] = {
                            regx : RegExp( `&${entityName};`,"g"),
                            val: val
                        };
                }
                else if( hasBody && isElement(xmlData, i))  i += 8;//Not supported
                else if( hasBody && isAttlist(xmlData, i))  i += 8;//Not supported
                else if( hasBody && isNotation(xmlData, i)) i += 9;//Not supported
                else if( isComment)                         comment = true;
                else                                        throw new Error("Invalid DOCTYPE");

                angleBracketsCount++;
                exp = "";
            } else if (xmlData[i] === '>') { //Read tag content
                if(comment){
                    if( xmlData[i - 1] === "-" && xmlData[i - 2] === "-"){
                        comment = false;
                        angleBracketsCount--;
                    }
                }else{
                    angleBracketsCount--;
                }
                if (angleBracketsCount === 0) {
                  break;
                }
            }else if( xmlData[i] === '['){
                hasBody = true;
            }else{
                exp += xmlData[i];
            }
        }
        if(angleBracketsCount !== 0){
            throw new Error(`Unclosed DOCTYPE`);
        }
    }else{
        throw new Error(`Invalid Tag instead of DOCTYPE`);
    }
    return {entities, i};
}

function readEntityExp(xmlData,i){
    //External entities are not supported
    //    <!ENTITY ext SYSTEM "http://normal-website.com" >

    //Parameter entities are not supported
    //    <!ENTITY entityname "&anotherElement;">

    //Internal entities are supported
    //    <!ENTITY entityname "replacement text">
    
    //read EntityName
    let entityName = "";
    for (; i < xmlData.length && (xmlData[i] !== "'" && xmlData[i] !== '"' ); i++) {
        // if(xmlData[i] === " ") continue;
        // else 
        entityName += xmlData[i];
    }
    entityName = entityName.trim();
    if(entityName.indexOf(" ") !== -1) throw new Error("External entites are not supported");

    //read Entity Value
    const startChar = xmlData[i++];
    let val = ""
    for (; i < xmlData.length && xmlData[i] !== startChar ; i++) {
        val += xmlData[i];
    }
    return [entityName, val, i];
}

function isComment(xmlData, i){
    if(xmlData[i+1] === '!' &&
    xmlData[i+2] === '-' &&
    xmlData[i+3] === '-') return true
    return false
}
function isEntity(xmlData, i){
    if(xmlData[i+1] === '!' &&
    xmlData[i+2] === 'E' &&
    xmlData[i+3] === 'N' &&
    xmlData[i+4] === 'T' &&
    xmlData[i+5] === 'I' &&
    xmlData[i+6] === 'T' &&
    xmlData[i+7] === 'Y') return true
    return false
}
function isElement(xmlData, i){
    if(xmlData[i+1] === '!' &&
    xmlData[i+2] === 'E' &&
    xmlData[i+3] === 'L' &&
    xmlData[i+4] === 'E' &&
    xmlData[i+5] === 'M' &&
    xmlData[i+6] === 'E' &&
    xmlData[i+7] === 'N' &&
    xmlData[i+8] === 'T') return true
    return false
}

function isAttlist(xmlData, i){
    if(xmlData[i+1] === '!' &&
    xmlData[i+2] === 'A' &&
    xmlData[i+3] === 'T' &&
    xmlData[i+4] === 'T' &&
    xmlData[i+5] === 'L' &&
    xmlData[i+6] === 'I' &&
    xmlData[i+7] === 'S' &&
    xmlData[i+8] === 'T') return true
    return false
}
function isNotation(xmlData, i){
    if(xmlData[i+1] === '!' &&
    xmlData[i+2] === 'N' &&
    xmlData[i+3] === 'O' &&
    xmlData[i+4] === 'T' &&
    xmlData[i+5] === 'A' &&
    xmlData[i+6] === 'T' &&
    xmlData[i+7] === 'I' &&
    xmlData[i+8] === 'O' &&
    xmlData[i+9] === 'N') return true
    return false
}

function validateEntityName(name){
    if (util.isName(name))
	return name;
    else
        throw new Error(`Invalid entity name ${name}`);
}

module.exports = readDocType;


/***/ }),

/***/ 745:
/***/ ((__unused_webpack_module, exports) => {


const defaultOptions = {
    preserveOrder: false,
    attributeNamePrefix: '@_',
    attributesGroupName: false,
    textNodeName: '#text',
    ignoreAttributes: true,
    removeNSPrefix: false, // remove NS from tag name or attribute name if true
    allowBooleanAttributes: false, //a tag can have attributes without any value
    //ignoreRootElement : false,
    parseTagValue: true,
    parseAttributeValue: false,
    trimValues: true, //Trim string values of tag and attributes
    cdataPropName: false,
    numberParseOptions: {
      hex: true,
      leadingZeros: true,
      eNotation: true
    },
    tagValueProcessor: function(tagName, val) {
      return val;
    },
    attributeValueProcessor: function(attrName, val) {
      return val;
    },
    stopNodes: [], //nested tags will not be parsed even for errors
    alwaysCreateTextNode: false,
    isArray: () => false,
    commentPropName: false,
    unpairedTags: [],
    processEntities: true,
    htmlEntities: false,
    ignoreDeclaration: false,
    ignorePiTags: false,
    transformTagName: false,
    transformAttributeName: false,
    updateTag: function(tagName, jPath, attrs){
      return tagName
    },
    // skipEmptyListItem: false
};
   
const buildOptions = function(options) {
    return Object.assign({}, defaultOptions, options);
};

exports.buildOptions = buildOptions;
exports.defaultOptions = defaultOptions;

/***/ }),

/***/ 78:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

///@ts-check

const util = __webpack_require__(849);
const xmlNode = __webpack_require__(311);
const readDocType = __webpack_require__(780);
const toNumber = __webpack_require__(153);

const regx =
  '<((!\\[CDATA\\[([\\s\\S]*?)(]]>))|((NAME:)?(NAME))([^>]*)>|((\\/)(NAME)\\s*>))([^<]*)'
  .replace(/NAME/g, util.nameRegexp);

//const tagsRegx = new RegExp("<(\\/?[\\w:\\-\._]+)([^>]*)>(\\s*"+cdataRegx+")*([^<]+)?","g");
//const tagsRegx = new RegExp("<(\\/?)((\\w*:)?([\\w:\\-\._]+))([^>]*)>([^<]*)("+cdataRegx+"([^<]*))*([^<]+)?","g");

class OrderedObjParser{
  constructor(options){
    this.options = options;
    this.currentNode = null;
    this.tagsNodeStack = [];
    this.docTypeEntities = {};
    this.lastEntities = {
      "apos" : { regex: /&(apos|#39|#x27);/g, val : "'"},
      "gt" : { regex: /&(gt|#62|#x3E);/g, val : ">"},
      "lt" : { regex: /&(lt|#60|#x3C);/g, val : "<"},
      "quot" : { regex: /&(quot|#34|#x22);/g, val : "\""},
    };
    this.ampEntity = { regex: /&(amp|#38|#x26);/g, val : "&"};
    this.htmlEntities = {
      "space": { regex: /&(nbsp|#160);/g, val: " " },
      // "lt" : { regex: /&(lt|#60);/g, val: "<" },
      // "gt" : { regex: /&(gt|#62);/g, val: ">" },
      // "amp" : { regex: /&(amp|#38);/g, val: "&" },
      // "quot" : { regex: /&(quot|#34);/g, val: "\"" },
      // "apos" : { regex: /&(apos|#39);/g, val: "'" },
      "cent" : { regex: /&(cent|#162);/g, val: "¢" },
      "pound" : { regex: /&(pound|#163);/g, val: "£" },
      "yen" : { regex: /&(yen|#165);/g, val: "¥" },
      "euro" : { regex: /&(euro|#8364);/g, val: "€" },
      "copyright" : { regex: /&(copy|#169);/g, val: "©" },
      "reg" : { regex: /&(reg|#174);/g, val: "®" },
      "inr" : { regex: /&(inr|#8377);/g, val: "₹" },
    };
    this.addExternalEntities = addExternalEntities;
    this.parseXml = parseXml;
    this.parseTextData = parseTextData;
    this.resolveNameSpace = resolveNameSpace;
    this.buildAttributesMap = buildAttributesMap;
    this.isItStopNode = isItStopNode;
    this.replaceEntitiesValue = replaceEntitiesValue;
    this.readStopNodeData = readStopNodeData;
    this.saveTextToParentTag = saveTextToParentTag;
    this.addChild = addChild;
  }

}

function addExternalEntities(externalEntities){
  const entKeys = Object.keys(externalEntities);
  for (let i = 0; i < entKeys.length; i++) {
    const ent = entKeys[i];
    this.lastEntities[ent] = {
       regex: new RegExp("&"+ent+";","g"),
       val : externalEntities[ent]
    }
  }
}

/**
 * @param {string} val
 * @param {string} tagName
 * @param {string} jPath
 * @param {boolean} dontTrim
 * @param {boolean} hasAttributes
 * @param {boolean} isLeafNode
 * @param {boolean} escapeEntities
 */
function parseTextData(val, tagName, jPath, dontTrim, hasAttributes, isLeafNode, escapeEntities) {
  if (val !== undefined) {
    if (this.options.trimValues && !dontTrim) {
      val = val.trim();
    }
    if(val.length > 0){
      if(!escapeEntities) val = this.replaceEntitiesValue(val);
      
      const newval = this.options.tagValueProcessor(tagName, val, jPath, hasAttributes, isLeafNode);
      if(newval === null || newval === undefined){
        //don't parse
        return val;
      }else if(typeof newval !== typeof val || newval !== val){
        //overwrite
        return newval;
      }else if(this.options.trimValues){
        return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);
      }else{
        const trimmedVal = val.trim();
        if(trimmedVal === val){
          return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);
        }else{
          return val;
        }
      }
    }
  }
}

function resolveNameSpace(tagname) {
  if (this.options.removeNSPrefix) {
    const tags = tagname.split(':');
    const prefix = tagname.charAt(0) === '/' ? '/' : '';
    if (tags[0] === 'xmlns') {
      return '';
    }
    if (tags.length === 2) {
      tagname = prefix + tags[1];
    }
  }
  return tagname;
}

//TODO: change regex to capture NS
//const attrsRegx = new RegExp("([\\w\\-\\.\\:]+)\\s*=\\s*(['\"])((.|\n)*?)\\2","gm");
const attrsRegx = new RegExp('([^\\s=]+)\\s*(=\\s*([\'"])([\\s\\S]*?)\\3)?', 'gm');

function buildAttributesMap(attrStr, jPath, tagName) {
  if (!this.options.ignoreAttributes && typeof attrStr === 'string') {
    // attrStr = attrStr.replace(/\r?\n/g, ' ');
    //attrStr = attrStr || attrStr.trim();

    const matches = util.getAllMatches(attrStr, attrsRegx);
    const len = matches.length; //don't make it inline
    const attrs = {};
    for (let i = 0; i < len; i++) {
      const attrName = this.resolveNameSpace(matches[i][1]);
      let oldVal = matches[i][4];
      let aName = this.options.attributeNamePrefix + attrName;
      if (attrName.length) {
        if (this.options.transformAttributeName) {
          aName = this.options.transformAttributeName(aName);
        }
        if(aName === "__proto__") aName  = "#__proto__";
        if (oldVal !== undefined) {
          if (this.options.trimValues) {
            oldVal = oldVal.trim();
          }
          oldVal = this.replaceEntitiesValue(oldVal);
          const newVal = this.options.attributeValueProcessor(attrName, oldVal, jPath);
          if(newVal === null || newVal === undefined){
            //don't parse
            attrs[aName] = oldVal;
          }else if(typeof newVal !== typeof oldVal || newVal !== oldVal){
            //overwrite
            attrs[aName] = newVal;
          }else{
            //parse
            attrs[aName] = parseValue(
              oldVal,
              this.options.parseAttributeValue,
              this.options.numberParseOptions
            );
          }
        } else if (this.options.allowBooleanAttributes) {
          attrs[aName] = true;
        }
      }
    }
    if (!Object.keys(attrs).length) {
      return;
    }
    if (this.options.attributesGroupName) {
      const attrCollection = {};
      attrCollection[this.options.attributesGroupName] = attrs;
      return attrCollection;
    }
    return attrs
  }
}

const parseXml = function(xmlData) {
  xmlData = xmlData.replace(/\r\n?/g, "\n"); //TODO: remove this line
  const xmlObj = new xmlNode('!xml');
  let currentNode = xmlObj;
  let textData = "";
  let jPath = "";
  for(let i=0; i< xmlData.length; i++){//for each char in XML data
    const ch = xmlData[i];
    if(ch === '<'){
      // const nextIndex = i+1;
      // const _2ndChar = xmlData[nextIndex];
      if( xmlData[i+1] === '/') {//Closing Tag
        const closeIndex = findClosingIndex(xmlData, ">", i, "Closing Tag is not closed.")
        let tagName = xmlData.substring(i+2,closeIndex).trim();

        if(this.options.removeNSPrefix){
          const colonIndex = tagName.indexOf(":");
          if(colonIndex !== -1){
            tagName = tagName.substr(colonIndex+1);
          }
        }

        if(this.options.transformTagName) {
          tagName = this.options.transformTagName(tagName);
        }

        if(currentNode){
          textData = this.saveTextToParentTag(textData, currentNode, jPath);
        }

        //check if last tag of nested tag was unpaired tag
        const lastTagName = jPath.substring(jPath.lastIndexOf(".")+1);
        if(tagName && this.options.unpairedTags.indexOf(tagName) !== -1 ){
          throw new Error(`Unpaired tag can not be used as closing tag: </${tagName}>`);
        }
        let propIndex = 0
        if(lastTagName && this.options.unpairedTags.indexOf(lastTagName) !== -1 ){
          propIndex = jPath.lastIndexOf('.', jPath.lastIndexOf('.')-1)
          this.tagsNodeStack.pop();
        }else{
          propIndex = jPath.lastIndexOf(".");
        }
        jPath = jPath.substring(0, propIndex);

        currentNode = this.tagsNodeStack.pop();//avoid recursion, set the parent tag scope
        textData = "";
        i = closeIndex;
      } else if( xmlData[i+1] === '?') {

        let tagData = readTagExp(xmlData,i, false, "?>");
        if(!tagData) throw new Error("Pi Tag is not closed.");

        textData = this.saveTextToParentTag(textData, currentNode, jPath);
        if( (this.options.ignoreDeclaration && tagData.tagName === "?xml") || this.options.ignorePiTags){

        }else{
  
          const childNode = new xmlNode(tagData.tagName);
          childNode.add(this.options.textNodeName, "");
          
          if(tagData.tagName !== tagData.tagExp && tagData.attrExpPresent){
            childNode[":@"] = this.buildAttributesMap(tagData.tagExp, jPath, tagData.tagName);
          }
          this.addChild(currentNode, childNode, jPath)

        }


        i = tagData.closeIndex + 1;
      } else if(xmlData.substr(i + 1, 3) === '!--') {
        const endIndex = findClosingIndex(xmlData, "-->", i+4, "Comment is not closed.")
        if(this.options.commentPropName){
          const comment = xmlData.substring(i + 4, endIndex - 2);

          textData = this.saveTextToParentTag(textData, currentNode, jPath);

          currentNode.add(this.options.commentPropName, [ { [this.options.textNodeName] : comment } ]);
        }
        i = endIndex;
      } else if( xmlData.substr(i + 1, 2) === '!D') {
        const result = readDocType(xmlData, i);
        this.docTypeEntities = result.entities;
        i = result.i;
      }else if(xmlData.substr(i + 1, 2) === '![') {
        const closeIndex = findClosingIndex(xmlData, "]]>", i, "CDATA is not closed.") - 2;
        const tagExp = xmlData.substring(i + 9,closeIndex);

        textData = this.saveTextToParentTag(textData, currentNode, jPath);

        //cdata should be set even if it is 0 length string
        if(this.options.cdataPropName){
          // let val = this.parseTextData(tagExp, this.options.cdataPropName, jPath + "." + this.options.cdataPropName, true, false, true);
          // if(!val) val = "";
          currentNode.add(this.options.cdataPropName, [ { [this.options.textNodeName] : tagExp } ]);
        }else{
          let val = this.parseTextData(tagExp, currentNode.tagname, jPath, true, false, true);
          if(val == undefined) val = "";
          currentNode.add(this.options.textNodeName, val);
        }
        
        i = closeIndex + 2;
      }else {//Opening tag
        let result = readTagExp(xmlData,i, this.options.removeNSPrefix);
        let tagName= result.tagName;
        let tagExp = result.tagExp;
        let attrExpPresent = result.attrExpPresent;
        let closeIndex = result.closeIndex;

        if (this.options.transformTagName) {
          tagName = this.options.transformTagName(tagName);
        }
        
        //save text as child node
        if (currentNode && textData) {
          if(currentNode.tagname !== '!xml'){
            //when nested tag is found
            textData = this.saveTextToParentTag(textData, currentNode, jPath, false);
          }
        }

        //check if last tag was unpaired tag
        const lastTag = currentNode;
        if(lastTag && this.options.unpairedTags.indexOf(lastTag.tagname) !== -1 ){
          currentNode = this.tagsNodeStack.pop();
          jPath = jPath.substring(0, jPath.lastIndexOf("."));
        }
        if(tagName !== xmlObj.tagname){
          jPath += jPath ? "." + tagName : tagName;
        }
        if (this.isItStopNode(this.options.stopNodes, jPath, tagName)) { //TODO: namespace
          let tagContent = "";
          //self-closing tag
          if(tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1){
            i = result.closeIndex;
          }
          //unpaired tag
          else if(this.options.unpairedTags.indexOf(tagName) !== -1){
            i = result.closeIndex;
          }
          //normal tag
          else{
            //read until closing tag is found
            const result = this.readStopNodeData(xmlData, tagName, closeIndex + 1);
            if(!result) throw new Error(`Unexpected end of ${tagName}`);
            i = result.i;
            tagContent = result.tagContent;
          }

          const childNode = new xmlNode(tagName);
          if(tagName !== tagExp && attrExpPresent){
            childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
          }
          if(tagContent) {
            tagContent = this.parseTextData(tagContent, tagName, jPath, true, attrExpPresent, true, true);
          }
          
          jPath = jPath.substr(0, jPath.lastIndexOf("."));
          childNode.add(this.options.textNodeName, tagContent);
          
          this.addChild(currentNode, childNode, jPath)
        }else{
  //selfClosing tag
          if(tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1){
            if(tagName[tagName.length - 1] === "/"){ //remove trailing '/'
              tagName = tagName.substr(0, tagName.length - 1);
              jPath = jPath.substr(0, jPath.length - 1);
              tagExp = tagName;
            }else{
              tagExp = tagExp.substr(0, tagExp.length - 1);
            }
            
            if(this.options.transformTagName) {
              tagName = this.options.transformTagName(tagName);
            }

            const childNode = new xmlNode(tagName);
            if(tagName !== tagExp && attrExpPresent){
              childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
            }
            this.addChild(currentNode, childNode, jPath)
            jPath = jPath.substr(0, jPath.lastIndexOf("."));
          }
    //opening tag
          else{
            const childNode = new xmlNode( tagName);
            this.tagsNodeStack.push(currentNode);
            
            if(tagName !== tagExp && attrExpPresent){
              childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
            }
            this.addChild(currentNode, childNode, jPath)
            currentNode = childNode;
          }
          textData = "";
          i = closeIndex;
        }
      }
    }else{
      textData += xmlData[i];
    }
  }
  return xmlObj.child;
}

function addChild(currentNode, childNode, jPath){
  const result = this.options.updateTag(childNode.tagname, jPath, childNode[":@"])
  if(result === false){
  }else if(typeof result === "string"){
    childNode.tagname = result
    currentNode.addChild(childNode);
  }else{
    currentNode.addChild(childNode);
  }
}

const replaceEntitiesValue = function(val){

  if(this.options.processEntities){
    for(let entityName in this.docTypeEntities){
      const entity = this.docTypeEntities[entityName];
      val = val.replace( entity.regx, entity.val);
    }
    for(let entityName in this.lastEntities){
      const entity = this.lastEntities[entityName];
      val = val.replace( entity.regex, entity.val);
    }
    if(this.options.htmlEntities){
      for(let entityName in this.htmlEntities){
        const entity = this.htmlEntities[entityName];
        val = val.replace( entity.regex, entity.val);
      }
    }
    val = val.replace( this.ampEntity.regex, this.ampEntity.val);
  }
  return val;
}
function saveTextToParentTag(textData, currentNode, jPath, isLeafNode) {
  if (textData) { //store previously collected data as textNode
    if(isLeafNode === undefined) isLeafNode = Object.keys(currentNode.child).length === 0
    
    textData = this.parseTextData(textData,
      currentNode.tagname,
      jPath,
      false,
      currentNode[":@"] ? Object.keys(currentNode[":@"]).length !== 0 : false,
      isLeafNode);

    if (textData !== undefined && textData !== "")
      currentNode.add(this.options.textNodeName, textData);
    textData = "";
  }
  return textData;
}

//TODO: use jPath to simplify the logic
/**
 * 
 * @param {string[]} stopNodes 
 * @param {string} jPath
 * @param {string} currentTagName 
 */
function isItStopNode(stopNodes, jPath, currentTagName){
  const allNodesExp = "*." + currentTagName;
  for (const stopNodePath in stopNodes) {
    const stopNodeExp = stopNodes[stopNodePath];
    if( allNodesExp === stopNodeExp || jPath === stopNodeExp  ) return true;
  }
  return false;
}

/**
 * Returns the tag Expression and where it is ending handling single-double quotes situation
 * @param {string} xmlData 
 * @param {number} i starting index
 * @returns 
 */
function tagExpWithClosingIndex(xmlData, i, closingChar = ">"){
  let attrBoundary;
  let tagExp = "";
  for (let index = i; index < xmlData.length; index++) {
    let ch = xmlData[index];
    if (attrBoundary) {
        if (ch === attrBoundary) attrBoundary = "";//reset
    } else if (ch === '"' || ch === "'") {
        attrBoundary = ch;
    } else if (ch === closingChar[0]) {
      if(closingChar[1]){
        if(xmlData[index + 1] === closingChar[1]){
          return {
            data: tagExp,
            index: index
          }
        }
      }else{
        return {
          data: tagExp,
          index: index
        }
      }
    } else if (ch === '\t') {
      ch = " "
    }
    tagExp += ch;
  }
}

function findClosingIndex(xmlData, str, i, errMsg){
  const closingIndex = xmlData.indexOf(str, i);
  if(closingIndex === -1){
    throw new Error(errMsg)
  }else{
    return closingIndex + str.length - 1;
  }
}

function readTagExp(xmlData,i, removeNSPrefix, closingChar = ">"){
  const result = tagExpWithClosingIndex(xmlData, i+1, closingChar);
  if(!result) return;
  let tagExp = result.data;
  const closeIndex = result.index;
  const separatorIndex = tagExp.search(/\s/);
  let tagName = tagExp;
  let attrExpPresent = true;
  if(separatorIndex !== -1){//separate tag name and attributes expression
    tagName = tagExp.substr(0, separatorIndex).replace(/\s\s*$/, '');
    tagExp = tagExp.substr(separatorIndex + 1);
  }

  if(removeNSPrefix){
    const colonIndex = tagName.indexOf(":");
    if(colonIndex !== -1){
      tagName = tagName.substr(colonIndex+1);
      attrExpPresent = tagName !== result.data.substr(colonIndex + 1);
    }
  }

  return {
    tagName: tagName,
    tagExp: tagExp,
    closeIndex: closeIndex,
    attrExpPresent: attrExpPresent,
  }
}
/**
 * find paired tag for a stop node
 * @param {string} xmlData 
 * @param {string} tagName 
 * @param {number} i 
 */
function readStopNodeData(xmlData, tagName, i){
  const startIndex = i;
  // Starting at 1 since we already have an open tag
  let openTagCount = 1;

  for (; i < xmlData.length; i++) {
    if( xmlData[i] === "<"){ 
      if (xmlData[i+1] === "/") {//close tag
          const closeIndex = findClosingIndex(xmlData, ">", i, `${tagName} is not closed`);
          let closeTagName = xmlData.substring(i+2,closeIndex).trim();
          if(closeTagName === tagName){
            openTagCount--;
            if (openTagCount === 0) {
              return {
                tagContent: xmlData.substring(startIndex, i),
                i : closeIndex
              }
            }
          }
          i=closeIndex;
        } else if(xmlData[i+1] === '?') { 
          const closeIndex = findClosingIndex(xmlData, "?>", i+1, "StopNode is not closed.")
          i=closeIndex;
        } else if(xmlData.substr(i + 1, 3) === '!--') { 
          const closeIndex = findClosingIndex(xmlData, "-->", i+3, "StopNode is not closed.")
          i=closeIndex;
        } else if(xmlData.substr(i + 1, 2) === '![') { 
          const closeIndex = findClosingIndex(xmlData, "]]>", i, "StopNode is not closed.") - 2;
          i=closeIndex;
        } else {
          const tagData = readTagExp(xmlData, i, '>')

          if (tagData) {
            const openTagName = tagData && tagData.tagName;
            if (openTagName === tagName && tagData.tagExp[tagData.tagExp.length-1] !== "/") {
              openTagCount++;
            }
            i=tagData.closeIndex;
          }
        }
      }
  }//end for loop
}

function parseValue(val, shouldParse, options) {
  if (shouldParse && typeof val === 'string') {
    //console.log(options)
    const newval = val.trim();
    if(newval === 'true' ) return true;
    else if(newval === 'false' ) return false;
    else return toNumber(val, options);
  } else {
    if (util.isExist(val)) {
      return val;
    } else {
      return '';
    }
  }
}


module.exports = OrderedObjParser;


/***/ }),

/***/ 844:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { buildOptions} = __webpack_require__(745);
const OrderedObjParser = __webpack_require__(78);
const { prettify} = __webpack_require__(997);
const validator = __webpack_require__(501);

class XMLParser{
    
    constructor(options){
        this.externalEntities = {};
        this.options = buildOptions(options);
        
    }
    /**
     * Parse XML dats to JS object 
     * @param {string|Buffer} xmlData 
     * @param {boolean|Object} validationOption 
     */
    parse(xmlData,validationOption){
        if(typeof xmlData === "string"){
        }else if( xmlData.toString){
            xmlData = xmlData.toString();
        }else{
            throw new Error("XML data is accepted in String or Bytes[] form.")
        }
        if( validationOption){
            if(validationOption === true) validationOption = {}; //validate with default options
            
            const result = validator.validate(xmlData, validationOption);
            if (result !== true) {
              throw Error( `${result.err.msg}:${result.err.line}:${result.err.col}` )
            }
          }
        const orderedObjParser = new OrderedObjParser(this.options);
        orderedObjParser.addExternalEntities(this.externalEntities);
        const orderedResult = orderedObjParser.parseXml(xmlData);
        if(this.options.preserveOrder || orderedResult === undefined) return orderedResult;
        else return prettify(orderedResult, this.options);
    }

    /**
     * Add Entity which is not by default supported by this library
     * @param {string} key 
     * @param {string} value 
     */
    addEntity(key, value){
        if(value.indexOf("&") !== -1){
            throw new Error("Entity value can't have '&'")
        }else if(key.indexOf("&") !== -1 || key.indexOf(";") !== -1){
            throw new Error("An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'")
        }else if(value === "&"){
            throw new Error("An entity with value '&' is not permitted");
        }else{
            this.externalEntities[key] = value;
        }
    }
}

module.exports = XMLParser;

/***/ }),

/***/ 997:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


/**
 * 
 * @param {array} node 
 * @param {any} options 
 * @returns 
 */
function prettify(node, options){
  return compress( node, options);
}

/**
 * 
 * @param {array} arr 
 * @param {object} options 
 * @param {string} jPath 
 * @returns object
 */
function compress(arr, options, jPath){
  let text;
  const compressedObj = {};
  for (let i = 0; i < arr.length; i++) {
    const tagObj = arr[i];
    const property = propName(tagObj);
    let newJpath = "";
    if(jPath === undefined) newJpath = property;
    else newJpath = jPath + "." + property;

    if(property === options.textNodeName){
      if(text === undefined) text = tagObj[property];
      else text += "" + tagObj[property];
    }else if(property === undefined){
      continue;
    }else if(tagObj[property]){
      
      let val = compress(tagObj[property], options, newJpath);
      const isLeaf = isLeafTag(val, options);

      if(tagObj[":@"]){
        assignAttributes( val, tagObj[":@"], newJpath, options);
      }else if(Object.keys(val).length === 1 && val[options.textNodeName] !== undefined && !options.alwaysCreateTextNode){
        val = val[options.textNodeName];
      }else if(Object.keys(val).length === 0){
        if(options.alwaysCreateTextNode) val[options.textNodeName] = "";
        else val = "";
      }

      if(compressedObj[property] !== undefined && compressedObj.hasOwnProperty(property)) {
        if(!Array.isArray(compressedObj[property])) {
            compressedObj[property] = [ compressedObj[property] ];
        }
        compressedObj[property].push(val);
      }else{
        //TODO: if a node is not an array, then check if it should be an array
        //also determine if it is a leaf node
        if (options.isArray(property, newJpath, isLeaf )) {
          compressedObj[property] = [val];
        }else{
          compressedObj[property] = val;
        }
      }
    }
    
  }
  // if(text && text.length > 0) compressedObj[options.textNodeName] = text;
  if(typeof text === "string"){
    if(text.length > 0) compressedObj[options.textNodeName] = text;
  }else if(text !== undefined) compressedObj[options.textNodeName] = text;
  return compressedObj;
}

function propName(obj){
  const keys = Object.keys(obj);
  for (let i = 0; i < keys.length; i++) {
    const key = keys[i];
    if(key !== ":@") return key;
  }
}

function assignAttributes(obj, attrMap, jpath, options){
  if (attrMap) {
    const keys = Object.keys(attrMap);
    const len = keys.length; //don't make it inline
    for (let i = 0; i < len; i++) {
      const atrrName = keys[i];
      if (options.isArray(atrrName, jpath + "." + atrrName, true, true)) {
        obj[atrrName] = [ attrMap[atrrName] ];
      } else {
        obj[atrrName] = attrMap[atrrName];
      }
    }
  }
}

function isLeafTag(obj, options){
  const { textNodeName } = options;
  const propCount = Object.keys(obj).length;
  
  if (propCount === 0) {
    return true;
  }

  if (
    propCount === 1 &&
    (obj[textNodeName] || typeof obj[textNodeName] === "boolean" || obj[textNodeName] === 0)
  ) {
    return true;
  }

  return false;
}
exports.prettify = prettify;


/***/ }),

/***/ 311:
/***/ ((module) => {

"use strict";


class XmlNode{
  constructor(tagname) {
    this.tagname = tagname;
    this.child = []; //nested tags, text, cdata, comments in order
    this[":@"] = {}; //attributes map
  }
  add(key,val){
    // this.child.push( {name : key, val: val, isCdata: isCdata });
    if(key === "__proto__") key = "#__proto__";
    this.child.push( {[key]: val });
  }
  addChild(node) {
    if(node.tagname === "__proto__") node.tagname = "#__proto__";
    if(node[":@"] && Object.keys(node[":@"]).length > 0){
      this.child.push( { [node.tagname]: node.child, [":@"]: node[":@"] });
    }else{
      this.child.push( { [node.tagname]: node.child });
    }
  };
};


module.exports = XmlNode;

/***/ }),

/***/ 693:
/***/ (function(module) {

(function(self) {
  'use strict';

  // if __disableNativeFetch is set to true, the it will always polyfill fetch
  // with Ajax.
  if (!self.__disableNativeFetch && self.fetch) {
    return
  }

  function normalizeName(name) {
    if (typeof name !== 'string') {
      name = String(name)
    }
    if (/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name)) {
      throw new TypeError('Invalid character in header field name')
    }
    return name.toLowerCase()
  }

  function normalizeValue(value) {
    if (typeof value !== 'string') {
      value = String(value)
    }
    return value
  }

  function Headers(headers) {
    this.map = {}

    if (headers instanceof Headers) {
      headers.forEach(function(value, name) {
        this.append(name, value)
      }, this)

    } else if (headers) {
      Object.getOwnPropertyNames(headers).forEach(function(name) {
        this.append(name, headers[name])
      }, this)
    }
  }

  Headers.prototype.append = function(name, value) {
    name = normalizeName(name)
    value = normalizeValue(value)
    var list = this.map[name]
    if (!list) {
      list = []
      this.map[name] = list
    }
    list.push(value)
  }

  Headers.prototype['delete'] = function(name) {
    delete this.map[normalizeName(name)]
  }

  Headers.prototype.get = function(name) {
    var values = this.map[normalizeName(name)]
    return values ? values[0] : null
  }

  Headers.prototype.getAll = function(name) {
    return this.map[normalizeName(name)] || []
  }

  Headers.prototype.has = function(name) {
    return this.map.hasOwnProperty(normalizeName(name))
  }

  Headers.prototype.set = function(name, value) {
    this.map[normalizeName(name)] = [normalizeValue(value)]
  }

  Headers.prototype.forEach = function(callback, thisArg) {
    Object.getOwnPropertyNames(this.map).forEach(function(name) {
      this.map[name].forEach(function(value) {
        callback.call(thisArg, value, name, this)
      }, this)
    }, this)
  }

  function consumed(body) {
    if (body.bodyUsed) {
      return Promise.reject(new TypeError('Already read'))
    }
    body.bodyUsed = true
  }

  function fileReaderReady(reader) {
    return new Promise(function(resolve, reject) {
      reader.onload = function() {
        resolve(reader.result)
      }
      reader.onerror = function() {
        reject(reader.error)
      }
    })
  }

  function readBlobAsArrayBuffer(blob) {
    var reader = new FileReader()
    reader.readAsArrayBuffer(blob)
    return fileReaderReady(reader)
  }

  function readBlobAsText(blob, options) {
    var reader = new FileReader()
    var contentType = options.headers.map['content-type'] ? options.headers.map['content-type'].toString() : ''
    var regex = /charset\=[0-9a-zA-Z\-\_]*;?/
    var _charset = blob.type.match(regex) || contentType.match(regex)
    var args = [blob]

    if(_charset) {
      args.push(_charset[0].replace(/^charset\=/, '').replace(/;$/, ''))
    }

    reader.readAsText.apply(reader, args)
    return fileReaderReady(reader)
  }

  var support = {
    blob: 'FileReader' in self && 'Blob' in self && (function() {
      try {
        new Blob();
        return true
      } catch(e) {
        return false
      }
    })(),
    formData: 'FormData' in self,
    arrayBuffer: 'ArrayBuffer' in self
  }

  function Body() {
    this.bodyUsed = false


    this._initBody = function(body, options) {
      this._bodyInit = body
      if (typeof body === 'string') {
        this._bodyText = body
      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
        this._bodyBlob = body
        this._options = options
      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
        this._bodyFormData = body
      } else if (!body) {
        this._bodyText = ''
      } else if (support.arrayBuffer && ArrayBuffer.prototype.isPrototypeOf(body)) {
        // Only support ArrayBuffers for POST method.
        // Receiving ArrayBuffers happens via Blobs, instead.
      } else {
        throw new Error('unsupported BodyInit type')
      }
    }

    if (support.blob) {
      this.blob = function() {
        var rejected = consumed(this)
        if (rejected) {
          return rejected
        }

        if (this._bodyBlob) {
          return Promise.resolve(this._bodyBlob)
        } else if (this._bodyFormData) {
          throw new Error('could not read FormData body as blob')
        } else {
          return Promise.resolve(new Blob([this._bodyText]))
        }
      }

      this.arrayBuffer = function() {
        return this.blob().then(readBlobAsArrayBuffer)
      }

      this.text = function() {
        var rejected = consumed(this)
        if (rejected) {
          return rejected
        }

        if (this._bodyBlob) {
          return readBlobAsText(this._bodyBlob, this._options)
        } else if (this._bodyFormData) {
          throw new Error('could not read FormData body as text')
        } else {
          return Promise.resolve(this._bodyText)
        }
      }
    } else {
      this.text = function() {
        var rejected = consumed(this)
        return rejected ? rejected : Promise.resolve(this._bodyText)
      }
    }

    if (support.formData) {
      this.formData = function() {
        return this.text().then(decode)
      }
    }

    this.json = function() {
      return this.text().then(JSON.parse)
    }

    return this
  }

  // HTTP methods whose capitalization should be normalized
  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']

  function normalizeMethod(method) {
    var upcased = method.toUpperCase()
    return (methods.indexOf(upcased) > -1) ? upcased : method
  }

  function Request(input, options) {
    options = options || {}
    var body = options.body
    if (Request.prototype.isPrototypeOf(input)) {
      if (input.bodyUsed) {
        throw new TypeError('Already read')
      }
      this.url = input.url
      this.credentials = input.credentials
      if (!options.headers) {
        this.headers = new Headers(input.headers)
      }
      this.method = input.method
      this.mode = input.mode
      if (!body) {
        body = input._bodyInit
        input.bodyUsed = true
      }
    } else {
      this.url = input
    }

    this.credentials = options.credentials || this.credentials || 'omit'
    if (options.headers || !this.headers) {
      this.headers = new Headers(options.headers)
    }
    this.method = normalizeMethod(options.method || this.method || 'GET')
    this.mode = options.mode || this.mode || null
    this.referrer = null

    if ((this.method === 'GET' || this.method === 'HEAD') && body) {
      throw new TypeError('Body not allowed for GET or HEAD requests')
    }
    this._initBody(body, options)
  }

  Request.prototype.clone = function() {
    return new Request(this)
  }

  function decode(body) {
    var form = new FormData()
    body.trim().split('&').forEach(function(bytes) {
      if (bytes) {
        var split = bytes.split('=')
        var name = split.shift().replace(/\+/g, ' ')
        var value = split.join('=').replace(/\+/g, ' ')
        form.append(decodeURIComponent(name), decodeURIComponent(value))
      }
    })
    return form
  }

  function headers(xhr) {
    var head = new Headers()
    var pairs = xhr.getAllResponseHeaders().trim().split('\n')
    pairs.forEach(function(header) {
      var split = header.trim().split(':')
      var key = split.shift().trim()
      var value = split.join(':').trim()
      head.append(key, value)
    })
    return head
  }

  Body.call(Request.prototype)

  function Response(bodyInit, options) {
    if (!options) {
      options = {}
    }

    this._initBody(bodyInit, options)
    this.type = 'default'
    this.status = options.status
    this.ok = this.status >= 200 && this.status < 300
    this.statusText = options.statusText
    this.headers = options.headers instanceof Headers ? options.headers : new Headers(options.headers)
    this.url = options.url || ''
  }

  Body.call(Response.prototype)

  Response.prototype.clone = function() {
    return new Response(this._bodyInit, {
      status: this.status,
      statusText: this.statusText,
      headers: new Headers(this.headers),
      url: this.url
    })
  }

  Response.error = function() {
    var response = new Response(null, {status: 0, statusText: ''})
    response.type = 'error'
    return response
  }

  var redirectStatuses = [301, 302, 303, 307, 308]

  Response.redirect = function(url, status) {
    if (redirectStatuses.indexOf(status) === -1) {
      throw new RangeError('Invalid status code')
    }

    return new Response(null, {status: status, headers: {location: url}})
  }

  self.Headers = Headers;
  self.Request = Request;
  self.Response = Response;

  self.fetch = function(input, init) {
    return new Promise(function(resolve, reject) {
      var request
      if (Request.prototype.isPrototypeOf(input) && !init) {
        request = input
      } else {
        request = new Request(input, init)
      }

      var xhr = new XMLHttpRequest()

      function responseURL() {
        if ('responseURL' in xhr) {
          return xhr.responseURL
        }

        // Avoid security warnings on getResponseHeader when not allowed by CORS
        if (/^X-Request-URL:/m.test(xhr.getAllResponseHeaders())) {
          return xhr.getResponseHeader('X-Request-URL')
        }

        return;
      }

      var __onLoadHandled = false;

      function onload() {
        if (xhr.readyState !== 4) {
          return
        }
        var status = (xhr.status === 1223) ? 204 : xhr.status
        if (status < 100 || status > 599) {
          if (__onLoadHandled) { return; } else { __onLoadHandled = true; }
          reject(new TypeError('Network request failed'))
          return
        }
        var options = {
          status: status,
          statusText: xhr.statusText,
          headers: headers(xhr),
          url: responseURL()
        }
        var body = 'response' in xhr ? xhr.response : xhr.responseText;

        if (__onLoadHandled) { return; } else { __onLoadHandled = true; }
        resolve(new Response(body, options))
      }
      xhr.onreadystatechange = onload;
      xhr.onload = onload;
      xhr.onerror = function() {
        if (__onLoadHandled) { return; } else { __onLoadHandled = true; }
        reject(new TypeError('Network request failed'))
      }

      xhr.open(request.method, request.url, true)

      // `withCredentials` should be setted after calling `.open` in IE10
      // http://stackoverflow.com/a/19667959/1219343
      try {
        if (request.credentials === 'include') {
          if ('withCredentials' in xhr) {
            xhr.withCredentials = true;
          } else {
            console && console.warn && console.warn('withCredentials is not supported, you can ignore this warning');
          }
        }
      } catch (e) {
        console && console.warn && console.warn('set withCredentials error:' + e);
      }

      if ('responseType' in xhr && support.blob) {
        xhr.responseType = 'blob'
      }

      request.headers.forEach(function(value, name) {
        xhr.setRequestHeader(name, value)
      })

      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)
    })
  }
  self.fetch.polyfill = true

  // Support CommonJS
  if ( true && module.exports) {
    module.exports = self.fetch;
  }
})(typeof self !== 'undefined' ? self : this);


/***/ }),

/***/ 144:
/***/ (function(module, exports) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (global, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, module], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else { var mod; }
})(this, function (exports, module) {
  'use strict';

  var defaultOptions = {
    timeout: 5000,
    jsonpCallback: 'callback',
    jsonpCallbackFunction: null
  };

  function generateCallbackFunction() {
    return 'jsonp_' + Date.now() + '_' + Math.ceil(Math.random() * 100000);
  }

  function clearFunction(functionName) {
    // IE8 throws an exception when you try to delete a property on window
    // http://stackoverflow.com/a/1824228/751089
    try {
      delete window[functionName];
    } catch (e) {
      window[functionName] = undefined;
    }
  }

  function removeScript(scriptId) {
    var script = document.getElementById(scriptId);
    if (script) {
      document.getElementsByTagName('head')[0].removeChild(script);
    }
  }

  function fetchJsonp(_url) {
    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

    // to avoid param reassign
    var url = _url;
    var timeout = options.timeout || defaultOptions.timeout;
    var jsonpCallback = options.jsonpCallback || defaultOptions.jsonpCallback;

    var timeoutId = undefined;

    return new Promise(function (resolve, reject) {
      var callbackFunction = options.jsonpCallbackFunction || generateCallbackFunction();
      var scriptId = jsonpCallback + '_' + callbackFunction;

      window[callbackFunction] = function (response) {
        resolve({
          ok: true,
          // keep consistent with fetch API
          json: function json() {
            return Promise.resolve(response);
          }
        });

        if (timeoutId) clearTimeout(timeoutId);

        removeScript(scriptId);

        clearFunction(callbackFunction);
      };

      // Check if the user set their own params, and if not add a ? to start a list of params
      url += url.indexOf('?') === -1 ? '?' : '&';

      var jsonpScript = document.createElement('script');
      jsonpScript.setAttribute('src', '' + url + jsonpCallback + '=' + callbackFunction);
      if (options.charset) {
        jsonpScript.setAttribute('charset', options.charset);
      }
      jsonpScript.id = scriptId;
      document.getElementsByTagName('head')[0].appendChild(jsonpScript);

      timeoutId = setTimeout(function () {
        reject(new Error('JSONP request to ' + _url + ' timed out'));

        clearFunction(callbackFunction);
        removeScript(scriptId);
        window[callbackFunction] = function () {
          clearFunction(callbackFunction);
        };
      }, timeout);

      // Caught if got 404/500
      jsonpScript.onerror = function () {
        reject(new Error('JSONP request to ' + _url + ' failed'));

        clearFunction(callbackFunction);
        removeScript(scriptId);
        if (timeoutId) clearTimeout(timeoutId);
      };
    });
  }

  // export as global function
  /*
  let local;
  if (typeof global !== 'undefined') {
    local = global;
  } else if (typeof self !== 'undefined') {
    local = self;
  } else {
    try {
      local = Function('return this')();
    } catch (e) {
      throw new Error('polyfill failed because global object is unavailable in this environment');
    }
  }
  local.fetchJsonp = fetchJsonp;
  */

  module.exports = fetchJsonp;
});

/***/ }),

/***/ 186:
/***/ ((module) => {

var containers = []; // will store container HTMLElement references
var styleElements = []; // will store {prepend: HTMLElement, append: HTMLElement}

var usage = 'insert-css: You need to provide a CSS string. Usage: insertCss(cssString[, options]).';

function insertCss(css, options) {
    options = options || {};

    if (css === undefined) {
        throw new Error(usage);
    }

    var position = options.prepend === true ? 'prepend' : 'append';
    var container = options.container !== undefined ? options.container : document.querySelector('head');
    var containerId = containers.indexOf(container);

    // first time we see this container, create the necessary entries
    if (containerId === -1) {
        containerId = containers.push(container) - 1;
        styleElements[containerId] = {};
    }

    // try to get the correponding container + position styleElement, create it otherwise
    var styleElement;

    if (styleElements[containerId] !== undefined && styleElements[containerId][position] !== undefined) {
        styleElement = styleElements[containerId][position];
    } else {
        styleElement = styleElements[containerId][position] = createStyleElement();

        if (position === 'prepend') {
            container.insertBefore(styleElement, container.childNodes[0]);
        } else {
            container.appendChild(styleElement);
        }
    }

    // strip potential UTF-8 BOM if css was read from a file
    if (css.charCodeAt(0) === 0xFEFF) { css = css.substr(1, css.length); }

    // actually add the stylesheet
    if (styleElement.styleSheet) {
        styleElement.styleSheet.cssText += css
    } else {
        styleElement.textContent += css;
    }

    return styleElement;
};

function createStyleElement() {
    var styleElement = document.createElement('style');
    styleElement.setAttribute('type', 'text/css');
    return styleElement;
}

module.exports = insertCss;
module.exports.insertCss = insertCss;


/***/ }),

/***/ 465:
/***/ ((module, exports, __webpack_require__) => {

/* module decorator */ module = __webpack_require__.nmd(module);
/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to match `RegExp` flags from their coerced string values. */
var reFlags = /\w*$/;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/** Used to identify `toStringTag` values supported by `_.clone`. */
var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] =
cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
cloneableTags[boolTag] = cloneableTags[dateTag] =
cloneableTags[float32Tag] = cloneableTags[float64Tag] =
cloneableTags[int8Tag] = cloneableTags[int16Tag] =
cloneableTags[int32Tag] = cloneableTags[mapTag] =
cloneableTags[numberTag] = cloneableTags[objectTag] =
cloneableTags[regexpTag] = cloneableTags[setTag] =
cloneableTags[stringTag] = cloneableTags[symbolTag] =
cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] =
cloneableTags[weakMapTag] = false;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g && __webpack_require__.g.Object === Object && __webpack_require__.g;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/** Detect free variable `exports`. */
var freeExports =  true && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && "object" == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/**
 * Adds the key-value `pair` to `map`.
 *
 * @private
 * @param {Object} map The map to modify.
 * @param {Array} pair The key-value pair to add.
 * @returns {Object} Returns `map`.
 */
function addMapEntry(map, pair) {
  // Don't return `map.set` because it's not chainable in IE 11.
  map.set(pair[0], pair[1]);
  return map;
}

/**
 * Adds `value` to `set`.
 *
 * @private
 * @param {Object} set The set to modify.
 * @param {*} value The value to add.
 * @returns {Object} Returns `set`.
 */
function addSetEntry(set, value) {
  // Don't return `set.add` because it's not chainable in IE 11.
  set.add(value);
  return set;
}

/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array ? array.length : 0;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

/**
 * A specialized version of `_.reduce` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @param {boolean} [initAccum] Specify using the first element of `array` as
 *  the initial value.
 * @returns {*} Returns the accumulated value.
 */
function arrayReduce(array, iteratee, accumulator, initAccum) {
  var index = -1,
      length = array ? array.length : 0;

  if (initAccum && length) {
    accumulator = array[++index];
  }
  while (++index < length) {
    accumulator = iteratee(accumulator, array[index], index, array);
  }
  return accumulator;
}

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */
function isHostObject(value) {
  // Many host objects are `Object` objects that can coerce to strings
  // despite having improperly defined `toString` methods.
  var result = false;
  if (value != null && typeof value.toString != 'function') {
    try {
      result = !!(value + '');
    } catch (e) {}
  }
  return result;
}

/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);

  map.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}

/** Used for built-in method references. */
var arrayProto = Array.prototype,
    funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined,
    Symbol = root.Symbol,
    Uint8Array = root.Uint8Array,
    getPrototype = overArg(Object.getPrototypeOf, Object),
    objectCreate = Object.create,
    propertyIsEnumerable = objectProto.propertyIsEnumerable,
    splice = arrayProto.splice;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols,
    nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
    nativeKeys = overArg(Object.keys, Object);

/* Built-in method references that are verified to be native. */
var DataView = getNative(root, 'DataView'),
    Map = getNative(root, 'Map'),
    Promise = getNative(root, 'Promise'),
    Set = getNative(root, 'Set'),
    WeakMap = getNative(root, 'WeakMap'),
    nativeCreate = getNative(Object, 'create');

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise),
    setCtorString = toSource(Set),
    weakMapCtorString = toSource(WeakMap);

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  return this.has(key) && delete this.__data__[key];
}

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
}

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  return getMapData(this, key)['delete'](key);
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  getMapData(this, key).set(key, value);
  return this;
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  this.__data__ = new ListCache(entries);
}

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
}

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  return this.__data__['delete'](key);
}

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var cache = this.__data__;
  if (cache instanceof ListCache) {
    var pairs = cache.__data__;
    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      return this;
    }
    cache = this.__data__ = new MapCache(pairs);
  }
  cache.set(key, value);
  return this;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
  // Safari 9 makes `arguments.length` enumerable in strict mode.
  var result = (isArray(value) || isArguments(value))
    ? baseTimes(value.length, String)
    : [];

  var length = result.length,
      skipIndexes = !!length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (key == 'length' || isIndex(key, length)))) {
      result.push(key);
    }
  }
  return result;
}

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
      (value === undefined && !(key in object))) {
    object[key] = value;
  }
}

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.assign` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssign(object, source) {
  return object && copyObject(source, keys(source), object);
}

/**
 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
 * traversed objects.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @param {boolean} [isFull] Specify a clone including symbols.
 * @param {Function} [customizer] The function to customize cloning.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The parent object of `value`.
 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
 * @returns {*} Returns the cloned value.
 */
function baseClone(value, isDeep, isFull, customizer, key, object, stack) {
  var result;
  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result !== undefined) {
    return result;
  }
  if (!isObject(value)) {
    return value;
  }
  var isArr = isArray(value);
  if (isArr) {
    result = initCloneArray(value);
    if (!isDeep) {
      return copyArray(value, result);
    }
  } else {
    var tag = getTag(value),
        isFunc = tag == funcTag || tag == genTag;

    if (isBuffer(value)) {
      return cloneBuffer(value, isDeep);
    }
    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
      if (isHostObject(value)) {
        return object ? value : {};
      }
      result = initCloneObject(isFunc ? {} : value);
      if (!isDeep) {
        return copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result = initCloneByTag(value, tag, baseClone, isDeep);
    }
  }
  // Check for circular references and return its corresponding clone.
  stack || (stack = new Stack);
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);

  if (!isArr) {
    var props = isFull ? getAllKeys(value) : keys(value);
  }
  arrayEach(props || value, function(subValue, key) {
    if (props) {
      key = subValue;
      subValue = value[key];
    }
    // Recursively populate clone (susceptible to call stack limits).
    assignValue(result, key, baseClone(subValue, isDeep, isFull, customizer, key, value, stack));
  });
  return result;
}

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} prototype The object to inherit from.
 * @returns {Object} Returns the new object.
 */
function baseCreate(proto) {
  return isObject(proto) ? objectCreate(proto) : {};
}

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}

/**
 * The base implementation of `getTag`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  return objectToString.call(value);
}

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var result = new buffer.constructor(buffer.length);
  buffer.copy(result);
  return result;
}

/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
  return result;
}

/**
 * Creates a clone of `dataView`.
 *
 * @private
 * @param {Object} dataView The data view to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned data view.
 */
function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}

/**
 * Creates a clone of `map`.
 *
 * @private
 * @param {Object} map The map to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned map.
 */
function cloneMap(map, isDeep, cloneFunc) {
  var array = isDeep ? cloneFunc(mapToArray(map), true) : mapToArray(map);
  return arrayReduce(array, addMapEntry, new map.constructor);
}

/**
 * Creates a clone of `regexp`.
 *
 * @private
 * @param {Object} regexp The regexp to clone.
 * @returns {Object} Returns the cloned regexp.
 */
function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}

/**
 * Creates a clone of `set`.
 *
 * @private
 * @param {Object} set The set to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned set.
 */
function cloneSet(set, isDeep, cloneFunc) {
  var array = isDeep ? cloneFunc(setToArray(set), true) : setToArray(set);
  return arrayReduce(array, addSetEntry, new set.constructor);
}

/**
 * Creates a clone of the `symbol` object.
 *
 * @private
 * @param {Object} symbol The symbol object to clone.
 * @returns {Object} Returns the cloned symbol object.
 */
function cloneSymbol(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}

/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : undefined;

    assignValue(object, key, newValue === undefined ? source[key] : newValue);
  }
  return object;
}

/**
 * Copies own symbol properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbols(source, object) {
  return copyObject(source, getSymbols(source), object);
}

/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

/**
 * Creates an array of the own enumerable symbol properties of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11,
// for data views in Edge < 14, and promises in Node.js.
if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
    (Map && getTag(new Map) != mapTag) ||
    (Promise && getTag(Promise.resolve()) != promiseTag) ||
    (Set && getTag(new Set) != setTag) ||
    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
  getTag = function(value) {
    var result = objectToString.call(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : undefined;

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag;
        case mapCtorString: return mapTag;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag;
        case weakMapCtorString: return weakMapTag;
      }
    }
    return result;
  };
}

/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */
function initCloneArray(array) {
  var length = array.length,
      result = array.constructor(length);

  // Add properties assigned by `RegExp#exec`.
  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}

/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneObject(object) {
  return (typeof object.constructor == 'function' && !isPrototype(object))
    ? baseCreate(getPrototype(object))
    : {};
}

/**
 * Initializes an object clone based on its `toStringTag`.
 *
 * **Note:** This function only supports cloning values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The `toStringTag` of the object to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneByTag(object, tag, cloneFunc, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag:
      return cloneArrayBuffer(object);

    case boolTag:
    case dateTag:
      return new Ctor(+object);

    case dataViewTag:
      return cloneDataView(object, isDeep);

    case float32Tag: case float64Tag:
    case int8Tag: case int16Tag: case int32Tag:
    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
      return cloneTypedArray(object, isDeep);

    case mapTag:
      return cloneMap(object, isDeep, cloneFunc);

    case numberTag:
    case stringTag:
      return new Ctor(object);

    case regexpTag:
      return cloneRegExp(object);

    case setTag:
      return cloneSet(object, isDeep, cloneFunc);

    case symbolTag:
      return cloneSymbol(object);
  }
}

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length &&
    (typeof value == 'number' || reIsUint.test(value)) &&
    (value > -1 && value % 1 == 0 && value < length);
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

/**
 * This method is like `_.clone` except that it recursively clones `value`.
 *
 * @static
 * @memberOf _
 * @since 1.0.0
 * @category Lang
 * @param {*} value The value to recursively clone.
 * @returns {*} Returns the deep cloned value.
 * @see _.clone
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var deep = _.cloneDeep(objects);
 * console.log(deep[0] === objects[0]);
 * // => false
 */
function cloneDeep(value) {
  return baseClone(value, true, true);
}

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
function isArguments(value) {
  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&
    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8-9 which returns 'object' for typed array and other constructors.
  var tag = isObject(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = cloneDeep;


/***/ }),

/***/ 52:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    setTag = '[object Set]',
    weakMapTag = '[object WeakMap]';

var dataViewTag = '[object DataView]';

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g && __webpack_require__.g.Object === Object && __webpack_require__.g;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array ? array.length : 0,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

/**
 * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array
 * of key-value pairs for `object` corresponding to the property names of `props`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} props The property names to get values for.
 * @returns {Object} Returns the key-value pairs.
 */
function baseToPairs(object, props) {
  return arrayMap(props, function(key) {
    return [key, object[key]];
  });
}

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */
function isHostObject(value) {
  // Many host objects are `Object` objects that can coerce to strings
  // despite having improperly defined `toString` methods.
  var result = false;
  if (value != null && typeof value.toString != 'function') {
    try {
      result = !!(value + '');
    } catch (e) {}
  }
  return result;
}

/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);

  map.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

/**
 * Converts `set` to its value-value pairs.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the value-value pairs.
 */
function setToPairs(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = [value, value];
  });
  return result;
}

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = overArg(Object.keys, Object);

/* Built-in method references that are verified to be native. */
var DataView = getNative(root, 'DataView'),
    Map = getNative(root, 'Map'),
    Promise = getNative(root, 'Promise'),
    Set = getNative(root, 'Set'),
    WeakMap = getNative(root, 'WeakMap');

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise),
    setCtorString = toSource(Set),
    weakMapCtorString = toSource(WeakMap);

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
  // Safari 9 makes `arguments.length` enumerable in strict mode.
  var result = (isArray(value) || isArguments(value))
    ? baseTimes(value.length, String)
    : [];

  var length = result.length,
      skipIndexes = !!length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (key == 'length' || isIndex(key, length)))) {
      result.push(key);
    }
  }
  return result;
}

/**
 * The base implementation of `getTag`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  return objectToString.call(value);
}

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

/**
 * Creates a `_.toPairs` or `_.toPairsIn` function.
 *
 * @private
 * @param {Function} keysFunc The function to get the keys of a given object.
 * @returns {Function} Returns the new pairs function.
 */
function createToPairs(keysFunc) {
  return function(object) {
    var tag = getTag(object);
    if (tag == mapTag) {
      return mapToArray(object);
    }
    if (tag == setTag) {
      return setToPairs(object);
    }
    return baseToPairs(object, keysFunc(object));
  };
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11,
// for data views in Edge < 14, and promises in Node.js.
if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
    (Map && getTag(new Map) != mapTag) ||
    (Promise && getTag(Promise.resolve()) != promiseTag) ||
    (Set && getTag(new Set) != setTag) ||
    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
  getTag = function(value) {
    var result = objectToString.call(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : undefined;

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag;
        case mapCtorString: return mapTag;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag;
        case weakMapCtorString: return weakMapTag;
      }
    }
    return result;
  };
}

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length &&
    (typeof value == 'number' || reIsUint.test(value)) &&
    (value > -1 && value % 1 == 0 && value < length);
}

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
function isArguments(value) {
  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&
    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8-9 which returns 'object' for typed array and other constructors.
  var tag = isObject(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

/**
 * Creates an array of own enumerable string keyed-value pairs for `object`
 * which can be consumed by `_.fromPairs`. If `object` is a map or set, its
 * entries are returned.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @alias entries
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the key-value pairs.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.toPairs(new Foo);
 * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)
 */
var toPairs = createToPairs(keys);

module.exports = toPairs;


/***/ }),

/***/ 618:
/***/ ((module, exports, __webpack_require__) => {

/* module decorator */ module = __webpack_require__.nmd(module);
/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used to compose bitmasks for comparison styles. */
var UNORDERED_COMPARE_FLAG = 1,
    PARTIAL_COMPARE_FLAG = 2;

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0,
    MAX_SAFE_INTEGER = 9007199254740991;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to match property names within property paths. */
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/,
    reLeadingDot = /^\./,
    rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to match backslashes in property paths. */
var reEscapeChar = /\\(\\)?/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g && __webpack_require__.g.Object === Object && __webpack_require__.g;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/** Detect free variable `exports`. */
var freeExports =  true && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && "object" == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    return freeProcess && freeProcess.binding('util');
  } catch (e) {}
}());

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * A specialized version of `_.includes` for arrays without support for
 * specifying an index to search from.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludes(array, value) {
  var length = array ? array.length : 0;
  return !!length && baseIndexOf(array, value, 0) > -1;
}

/**
 * This function is like `arrayIncludes` except that it accepts a comparator.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @param {Function} comparator The comparator invoked per element.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludesWith(array, value, comparator) {
  var index = -1,
      length = array ? array.length : 0;

  while (++index < length) {
    if (comparator(value, array[index])) {
      return true;
    }
  }
  return false;
}

/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
      length = array ? array.length : 0;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}

/**
 * The base implementation of `_.findIndex` and `_.findLastIndex` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseFindIndex(array, predicate, fromIndex, fromRight) {
  var length = array.length,
      index = fromIndex + (fromRight ? 1 : -1);

  while ((fromRight ? index-- : ++index < length)) {
    if (predicate(array[index], index, array)) {
      return index;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseIndexOf(array, value, fromIndex) {
  if (value !== value) {
    return baseFindIndex(array, baseIsNaN, fromIndex);
  }
  var index = fromIndex - 1,
      length = array.length;

  while (++index < length) {
    if (array[index] === value) {
      return index;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.isNaN` without support for number objects.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
 */
function baseIsNaN(value) {
  return value !== value;
}

/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function baseProperty(key) {
  return function(object) {
    return object == null ? undefined : object[key];
  };
}

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

/**
 * Checks if a cache value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */
function isHostObject(value) {
  // Many host objects are `Object` objects that can coerce to strings
  // despite having improperly defined `toString` methods.
  var result = false;
  if (value != null && typeof value.toString != 'function') {
    try {
      result = !!(value + '');
    } catch (e) {}
  }
  return result;
}

/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);

  map.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}

/** Used for built-in method references. */
var arrayProto = Array.prototype,
    funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/** Built-in value references. */
var Symbol = root.Symbol,
    Uint8Array = root.Uint8Array,
    propertyIsEnumerable = objectProto.propertyIsEnumerable,
    splice = arrayProto.splice;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = overArg(Object.keys, Object);

/* Built-in method references that are verified to be native. */
var DataView = getNative(root, 'DataView'),
    Map = getNative(root, 'Map'),
    Promise = getNative(root, 'Promise'),
    Set = getNative(root, 'Set'),
    WeakMap = getNative(root, 'WeakMap'),
    nativeCreate = getNative(Object, 'create');

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise),
    setCtorString = toSource(Set),
    weakMapCtorString = toSource(WeakMap);

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  return this.has(key) && delete this.__data__[key];
}

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
}

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  return getMapData(this, key)['delete'](key);
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  getMapData(this, key).set(key, value);
  return this;
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
  var index = -1,
      length = values ? values.length : 0;

  this.__data__ = new MapCache;
  while (++index < length) {
    this.add(values[index]);
  }
}

/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}

/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  this.__data__ = new ListCache(entries);
}

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
}

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  return this.__data__['delete'](key);
}

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var cache = this.__data__;
  if (cache instanceof ListCache) {
    var pairs = cache.__data__;
    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      return this;
    }
    cache = this.__data__ = new MapCache(pairs);
  }
  cache.set(key, value);
  return this;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
  // Safari 9 makes `arguments.length` enumerable in strict mode.
  var result = (isArray(value) || isArguments(value))
    ? baseTimes(value.length, String)
    : [];

  var length = result.length,
      skipIndexes = !!length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (key == 'length' || isIndex(key, length)))) {
      result.push(key);
    }
  }
  return result;
}

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */
function baseGet(object, path) {
  path = isKey(path, object) ? [path] : castPath(path);

  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[toKey(path[index++])];
  }
  return (index && index == length) ? object : undefined;
}

/**
 * The base implementation of `getTag`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  return objectToString.call(value);
}

/**
 * The base implementation of `_.hasIn` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}

/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {boolean} [bitmask] The bitmask of comparison flags.
 *  The bitmask may be composed of the following flags:
 *     1 - Unordered comparison
 *     2 - Partial comparison
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */
function baseIsEqual(value, other, customizer, bitmask, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack);
}

/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {number} [bitmask] The bitmask of comparison flags. See `baseIsEqual`
 *  for more details.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function baseIsEqualDeep(object, other, equalFunc, customizer, bitmask, stack) {
  var objIsArr = isArray(object),
      othIsArr = isArray(other),
      objTag = arrayTag,
      othTag = arrayTag;

  if (!objIsArr) {
    objTag = getTag(object);
    objTag = objTag == argsTag ? objectTag : objTag;
  }
  if (!othIsArr) {
    othTag = getTag(other);
    othTag = othTag == argsTag ? objectTag : othTag;
  }
  var objIsObj = objTag == objectTag && !isHostObject(object),
      othIsObj = othTag == objectTag && !isHostObject(other),
      isSameTag = objTag == othTag;

  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack);
    return (objIsArr || isTypedArray(object))
      ? equalArrays(object, other, equalFunc, customizer, bitmask, stack)
      : equalByTag(object, other, objTag, equalFunc, customizer, bitmask, stack);
  }
  if (!(bitmask & PARTIAL_COMPARE_FLAG)) {
    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;

      stack || (stack = new Stack);
      return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack);
  return equalObjects(object, other, equalFunc, customizer, bitmask, stack);
}

/**
 * The base implementation of `_.isMatch` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to inspect.
 * @param {Object} source The object of property values to match.
 * @param {Array} matchData The property names, values, and compare flags to match.
 * @param {Function} [customizer] The function to customize comparisons.
 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
 */
function baseIsMatch(object, source, matchData, customizer) {
  var index = matchData.length,
      length = index,
      noCustomizer = !customizer;

  if (object == null) {
    return !length;
  }
  object = Object(object);
  while (index--) {
    var data = matchData[index];
    if ((noCustomizer && data[2])
          ? data[1] !== object[data[0]]
          : !(data[0] in object)
        ) {
      return false;
    }
  }
  while (++index < length) {
    data = matchData[index];
    var key = data[0],
        objValue = object[key],
        srcValue = data[1];

    if (noCustomizer && data[2]) {
      if (objValue === undefined && !(key in object)) {
        return false;
      }
    } else {
      var stack = new Stack;
      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack);
      }
      if (!(result === undefined
            ? baseIsEqual(srcValue, objValue, customizer, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG, stack)
            : result
          )) {
        return false;
      }
    }
  }
  return true;
}

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[objectToString.call(value)];
}

/**
 * The base implementation of `_.iteratee`.
 *
 * @private
 * @param {*} [value=_.identity] The value to convert to an iteratee.
 * @returns {Function} Returns the iteratee.
 */
function baseIteratee(value) {
  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
  if (typeof value == 'function') {
    return value;
  }
  if (value == null) {
    return identity;
  }
  if (typeof value == 'object') {
    return isArray(value)
      ? baseMatchesProperty(value[0], value[1])
      : baseMatches(value);
  }
  return property(value);
}

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

/**
 * The base implementation of `_.matches` which doesn't clone `source`.
 *
 * @private
 * @param {Object} source The object of property values to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatches(source) {
  var matchData = getMatchData(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
  }
  return function(object) {
    return object === source || baseIsMatch(object, source, matchData);
  };
}

/**
 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
 *
 * @private
 * @param {string} path The path of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatchesProperty(path, srcValue) {
  if (isKey(path) && isStrictComparable(srcValue)) {
    return matchesStrictComparable(toKey(path), srcValue);
  }
  return function(object) {
    var objValue = get(object, path);
    return (objValue === undefined && objValue === srcValue)
      ? hasIn(object, path)
      : baseIsEqual(srcValue, objValue, undefined, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG);
  };
}

/**
 * A specialized version of `baseProperty` which supports deep paths.
 *
 * @private
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function basePropertyDeep(path) {
  return function(object) {
    return baseGet(object, path);
  };
}

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

/**
 * The base implementation of `_.uniqBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new duplicate free array.
 */
function baseUniq(array, iteratee, comparator) {
  var index = -1,
      includes = arrayIncludes,
      length = array.length,
      isCommon = true,
      result = [],
      seen = result;

  if (comparator) {
    isCommon = false;
    includes = arrayIncludesWith;
  }
  else if (length >= LARGE_ARRAY_SIZE) {
    var set = iteratee ? null : createSet(array);
    if (set) {
      return setToArray(set);
    }
    isCommon = false;
    includes = cacheHas;
    seen = new SetCache;
  }
  else {
    seen = iteratee ? [] : result;
  }
  outer:
  while (++index < length) {
    var value = array[index],
        computed = iteratee ? iteratee(value) : value;

    value = (comparator || value !== 0) ? value : 0;
    if (isCommon && computed === computed) {
      var seenIndex = seen.length;
      while (seenIndex--) {
        if (seen[seenIndex] === computed) {
          continue outer;
        }
      }
      if (iteratee) {
        seen.push(computed);
      }
      result.push(value);
    }
    else if (!includes(seen, computed, comparator)) {
      if (seen !== result) {
        seen.push(computed);
      }
      result.push(value);
    }
  }
  return result;
}

/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {Array} Returns the cast property path array.
 */
function castPath(value) {
  return isArray(value) ? value : stringToPath(value);
}

/**
 * Creates a set object of `values`.
 *
 * @private
 * @param {Array} values The values to add to the set.
 * @returns {Object} Returns the new set.
 */
var createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {
  return new Set(values);
};

/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} customizer The function to customize comparisons.
 * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
 *  for more details.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */
function equalArrays(array, other, equalFunc, customizer, bitmask, stack) {
  var isPartial = bitmask & PARTIAL_COMPARE_FLAG,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(array);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var index = -1,
      result = true,
      seen = (bitmask & UNORDERED_COMPARE_FLAG) ? new SetCache : undefined;

  stack.set(array, other);
  stack.set(other, array);

  // Ignore non-index properties.
  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, arrValue, index, other, array, stack)
        : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== undefined) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    // Recursively compare arrays (susceptible to call stack limits).
    if (seen) {
      if (!arraySome(other, function(othValue, othIndex) {
            if (!seen.has(othIndex) &&
                (arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
              return seen.add(othIndex);
            }
          })) {
        result = false;
        break;
      }
    } else if (!(
          arrValue === othValue ||
            equalFunc(arrValue, othValue, customizer, bitmask, stack)
        )) {
      result = false;
      break;
    }
  }
  stack['delete'](array);
  stack['delete'](other);
  return result;
}

/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} customizer The function to customize comparisons.
 * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
 *  for more details.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalByTag(object, other, tag, equalFunc, customizer, bitmask, stack) {
  switch (tag) {
    case dataViewTag:
      if ((object.byteLength != other.byteLength) ||
          (object.byteOffset != other.byteOffset)) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;

    case arrayBufferTag:
      if ((object.byteLength != other.byteLength) ||
          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
        return false;
      }
      return true;

    case boolTag:
    case dateTag:
    case numberTag:
      // Coerce booleans to `1` or `0` and dates to milliseconds.
      // Invalid dates are coerced to `NaN`.
      return eq(+object, +other);

    case errorTag:
      return object.name == other.name && object.message == other.message;

    case regexpTag:
    case stringTag:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == (other + '');

    case mapTag:
      var convert = mapToArray;

    case setTag:
      var isPartial = bitmask & PARTIAL_COMPARE_FLAG;
      convert || (convert = setToArray);

      if (object.size != other.size && !isPartial) {
        return false;
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= UNORDERED_COMPARE_FLAG;

      // Recursively compare objects (susceptible to call stack limits).
      stack.set(object, other);
      var result = equalArrays(convert(object), convert(other), equalFunc, customizer, bitmask, stack);
      stack['delete'](object);
      return result;

    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}

/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} customizer The function to customize comparisons.
 * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
 *  for more details.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalObjects(object, other, equalFunc, customizer, bitmask, stack) {
  var isPartial = bitmask & PARTIAL_COMPARE_FLAG,
      objProps = keys(object),
      objLength = objProps.length,
      othProps = keys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
      return false;
    }
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(object);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);

  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, objValue, key, other, object, stack)
        : customizer(objValue, othValue, key, object, other, stack);
    }
    // Recursively compare objects (susceptible to call stack limits).
    if (!(compared === undefined
          ? (objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack))
          : compared
        )) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == 'constructor');
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor;

    // Non `Object` object instances with different constructors are not equal.
    if (objCtor != othCtor &&
        ('constructor' in object && 'constructor' in other) &&
        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack['delete'](object);
  stack['delete'](other);
  return result;
}

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

/**
 * Gets the property names, values, and compare flags of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the match data of `object`.
 */
function getMatchData(object) {
  var result = keys(object),
      length = result.length;

  while (length--) {
    var key = result[length],
        value = object[key];

    result[length] = [key, value, isStrictComparable(value)];
  }
  return result;
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11,
// for data views in Edge < 14, and promises in Node.js.
if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
    (Map && getTag(new Map) != mapTag) ||
    (Promise && getTag(Promise.resolve()) != promiseTag) ||
    (Set && getTag(new Set) != setTag) ||
    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
  getTag = function(value) {
    var result = objectToString.call(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : undefined;

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag;
        case mapCtorString: return mapTag;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag;
        case weakMapCtorString: return weakMapTag;
      }
    }
    return result;
  };
}

/**
 * Checks if `path` exists on `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @param {Function} hasFunc The function to check properties.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 */
function hasPath(object, path, hasFunc) {
  path = isKey(path, object) ? [path] : castPath(path);

  var result,
      index = -1,
      length = path.length;

  while (++index < length) {
    var key = toKey(path[index]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result) {
    return result;
  }
  var length = object ? object.length : 0;
  return !!length && isLength(length) && isIndex(key, length) &&
    (isArray(object) || isArguments(object));
}

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length &&
    (typeof value == 'number' || reIsUint.test(value)) &&
    (value > -1 && value % 1 == 0 && value < length);
}

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function isKey(value, object) {
  if (isArray(value)) {
    return false;
  }
  var type = typeof value;
  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
      value == null || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
    (object != null && value in Object(object));
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

/**
 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` if suitable for strict
 *  equality comparisons, else `false`.
 */
function isStrictComparable(value) {
  return value === value && !isObject(value);
}

/**
 * A specialized version of `matchesProperty` for source values suitable
 * for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function matchesStrictComparable(key, srcValue) {
  return function(object) {
    if (object == null) {
      return false;
    }
    return object[key] === srcValue &&
      (srcValue !== undefined || (key in Object(object)));
  };
}

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
var stringToPath = memoize(function(string) {
  string = toString(string);

  var result = [];
  if (reLeadingDot.test(string)) {
    result.push('');
  }
  string.replace(rePropName, function(match, number, quote, string) {
    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
  });
  return result;
});

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

/**
 * This method is like `_.uniq` except that it accepts `iteratee` which is
 * invoked for each element in `array` to generate the criterion by which
 * uniqueness is computed. The iteratee is invoked with one argument: (value).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {Function} [iteratee=_.identity]
 *  The iteratee invoked per element.
 * @returns {Array} Returns the new duplicate free array.
 * @example
 *
 * _.uniqBy([2.1, 1.2, 2.3], Math.floor);
 * // => [2.1, 1.2]
 *
 * // The `_.property` iteratee shorthand.
 * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
 * // => [{ 'x': 1 }, { 'x': 2 }]
 */
function uniqBy(array, iteratee) {
  return (array && array.length)
    ? baseUniq(array, baseIteratee(iteratee, 2))
    : [];
}

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize(func, resolver) {
  if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result);
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache);
  return memoized;
}

// Assign cache to `_.memoize`.
memoize.Cache = MapCache;

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
function isArguments(value) {
  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&
    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8-9 which returns 'object' for typed array and other constructors.
  var tag = isObject(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */
function get(object, path, defaultValue) {
  var result = object == null ? undefined : baseGet(object, path);
  return result === undefined ? defaultValue : result;
}

/**
 * Checks if `path` is a direct or inherited property of `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.hasIn(object, 'a');
 * // => true
 *
 * _.hasIn(object, 'a.b');
 * // => true
 *
 * _.hasIn(object, ['a', 'b']);
 * // => true
 *
 * _.hasIn(object, 'b');
 * // => false
 */
function hasIn(object, path) {
  return object != null && hasPath(object, path, baseHasIn);
}

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

/**
 * This method returns `undefined`.
 *
 * @static
 * @memberOf _
 * @since 2.3.0
 * @category Util
 * @example
 *
 * _.times(2, _.noop);
 * // => [undefined, undefined]
 */
function noop() {
  // No operation performed.
}

/**
 * Creates a function that returns the value at `path` of a given object.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 * @example
 *
 * var objects = [
 *   { 'a': { 'b': 2 } },
 *   { 'a': { 'b': 1 } }
 * ];
 *
 * _.map(objects, _.property('a.b'));
 * // => [2, 1]
 *
 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
 * // => [1, 2]
 */
function property(path) {
  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
}

module.exports = uniqBy;


/***/ }),

/***/ 107:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

(function (global, factory) {
	 true ? factory() :
	0;
}(this, (function () { 'use strict';

/**
 * @this {Promise}
 */
function finallyConstructor(callback) {
  var constructor = this.constructor;
  return this.then(
    function(value) {
      // @ts-ignore
      return constructor.resolve(callback()).then(function() {
        return value;
      });
    },
    function(reason) {
      // @ts-ignore
      return constructor.resolve(callback()).then(function() {
        // @ts-ignore
        return constructor.reject(reason);
      });
    }
  );
}

function allSettled(arr) {
  var P = this;
  return new P(function(resolve, reject) {
    if (!(arr && typeof arr.length !== 'undefined')) {
      return reject(
        new TypeError(
          typeof arr +
            ' ' +
            arr +
            ' is not iterable(cannot read property Symbol(Symbol.iterator))'
        )
      );
    }
    var args = Array.prototype.slice.call(arr);
    if (args.length === 0) return resolve([]);
    var remaining = args.length;

    function res(i, val) {
      if (val && (typeof val === 'object' || typeof val === 'function')) {
        var then = val.then;
        if (typeof then === 'function') {
          then.call(
            val,
            function(val) {
              res(i, val);
            },
            function(e) {
              args[i] = { status: 'rejected', reason: e };
              if (--remaining === 0) {
                resolve(args);
              }
            }
          );
          return;
        }
      }
      args[i] = { status: 'fulfilled', value: val };
      if (--remaining === 0) {
        resolve(args);
      }
    }

    for (var i = 0; i < args.length; i++) {
      res(i, args[i]);
    }
  });
}

// Store setTimeout reference so promise-polyfill will be unaffected by
// other code modifying setTimeout (like sinon.useFakeTimers())
var setTimeoutFunc = setTimeout;

function isArray(x) {
  return Boolean(x && typeof x.length !== 'undefined');
}

function noop() {}

// Polyfill for Function.prototype.bind
function bind(fn, thisArg) {
  return function() {
    fn.apply(thisArg, arguments);
  };
}

/**
 * @constructor
 * @param {Function} fn
 */
function Promise(fn) {
  if (!(this instanceof Promise))
    throw new TypeError('Promises must be constructed via new');
  if (typeof fn !== 'function') throw new TypeError('not a function');
  /** @type {!number} */
  this._state = 0;
  /** @type {!boolean} */
  this._handled = false;
  /** @type {Promise|undefined} */
  this._value = undefined;
  /** @type {!Array<!Function>} */
  this._deferreds = [];

  doResolve(fn, this);
}

function handle(self, deferred) {
  while (self._state === 3) {
    self = self._value;
  }
  if (self._state === 0) {
    self._deferreds.push(deferred);
    return;
  }
  self._handled = true;
  Promise._immediateFn(function() {
    var cb = self._state === 1 ? deferred.onFulfilled : deferred.onRejected;
    if (cb === null) {
      (self._state === 1 ? resolve : reject)(deferred.promise, self._value);
      return;
    }
    var ret;
    try {
      ret = cb(self._value);
    } catch (e) {
      reject(deferred.promise, e);
      return;
    }
    resolve(deferred.promise, ret);
  });
}

function resolve(self, newValue) {
  try {
    // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
    if (newValue === self)
      throw new TypeError('A promise cannot be resolved with itself.');
    if (
      newValue &&
      (typeof newValue === 'object' || typeof newValue === 'function')
    ) {
      var then = newValue.then;
      if (newValue instanceof Promise) {
        self._state = 3;
        self._value = newValue;
        finale(self);
        return;
      } else if (typeof then === 'function') {
        doResolve(bind(then, newValue), self);
        return;
      }
    }
    self._state = 1;
    self._value = newValue;
    finale(self);
  } catch (e) {
    reject(self, e);
  }
}

function reject(self, newValue) {
  self._state = 2;
  self._value = newValue;
  finale(self);
}

function finale(self) {
  if (self._state === 2 && self._deferreds.length === 0) {
    Promise._immediateFn(function() {
      if (!self._handled) {
        Promise._unhandledRejectionFn(self._value);
      }
    });
  }

  for (var i = 0, len = self._deferreds.length; i < len; i++) {
    handle(self, self._deferreds[i]);
  }
  self._deferreds = null;
}

/**
 * @constructor
 */
function Handler(onFulfilled, onRejected, promise) {
  this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
  this.onRejected = typeof onRejected === 'function' ? onRejected : null;
  this.promise = promise;
}

/**
 * Take a potentially misbehaving resolver function and make sure
 * onFulfilled and onRejected are only called once.
 *
 * Makes no guarantees about asynchrony.
 */
function doResolve(fn, self) {
  var done = false;
  try {
    fn(
      function(value) {
        if (done) return;
        done = true;
        resolve(self, value);
      },
      function(reason) {
        if (done) return;
        done = true;
        reject(self, reason);
      }
    );
  } catch (ex) {
    if (done) return;
    done = true;
    reject(self, ex);
  }
}

Promise.prototype['catch'] = function(onRejected) {
  return this.then(null, onRejected);
};

Promise.prototype.then = function(onFulfilled, onRejected) {
  // @ts-ignore
  var prom = new this.constructor(noop);

  handle(this, new Handler(onFulfilled, onRejected, prom));
  return prom;
};

Promise.prototype['finally'] = finallyConstructor;

Promise.all = function(arr) {
  return new Promise(function(resolve, reject) {
    if (!isArray(arr)) {
      return reject(new TypeError('Promise.all accepts an array'));
    }

    var args = Array.prototype.slice.call(arr);
    if (args.length === 0) return resolve([]);
    var remaining = args.length;

    function res(i, val) {
      try {
        if (val && (typeof val === 'object' || typeof val === 'function')) {
          var then = val.then;
          if (typeof then === 'function') {
            then.call(
              val,
              function(val) {
                res(i, val);
              },
              reject
            );
            return;
          }
        }
        args[i] = val;
        if (--remaining === 0) {
          resolve(args);
        }
      } catch (ex) {
        reject(ex);
      }
    }

    for (var i = 0; i < args.length; i++) {
      res(i, args[i]);
    }
  });
};

Promise.allSettled = allSettled;

Promise.resolve = function(value) {
  if (value && typeof value === 'object' && value.constructor === Promise) {
    return value;
  }

  return new Promise(function(resolve) {
    resolve(value);
  });
};

Promise.reject = function(value) {
  return new Promise(function(resolve, reject) {
    reject(value);
  });
};

Promise.race = function(arr) {
  return new Promise(function(resolve, reject) {
    if (!isArray(arr)) {
      return reject(new TypeError('Promise.race accepts an array'));
    }

    for (var i = 0, len = arr.length; i < len; i++) {
      Promise.resolve(arr[i]).then(resolve, reject);
    }
  });
};

// Use polyfill for setImmediate for performance gains
Promise._immediateFn =
  // @ts-ignore
  (typeof setImmediate === 'function' &&
    function(fn) {
      // @ts-ignore
      setImmediate(fn);
    }) ||
  function(fn) {
    setTimeoutFunc(fn, 0);
  };

Promise._unhandledRejectionFn = function _unhandledRejectionFn(err) {
  if (typeof console !== 'undefined' && console) {
    console.warn('Possible Unhandled Promise Rejection:', err); // eslint-disable-line no-console
  }
};

/** @suppress {undefinedVars} */
var globalNS = (function() {
  // the only reliable means to get the global object is
  // `Function('return this')()`
  // However, this causes CSP violations in Chrome apps.
  if (typeof self !== 'undefined') {
    return self;
  }
  if (typeof window !== 'undefined') {
    return window;
  }
  if (typeof __webpack_require__.g !== 'undefined') {
    return __webpack_require__.g;
  }
  throw new Error('unable to locate global object');
})();

// Expose the polyfill if Promise is undefined or set to a
// non-function value. The latter can be due to a named HTMLElement
// being exposed by browsers for legacy reasons.
// https://github.com/taylorhakes/promise-polyfill/issues/114
if (typeof globalNS['Promise'] !== 'function') {
  globalNS['Promise'] = Promise;
} else {
  if (!globalNS.Promise.prototype['finally']) {
    globalNS.Promise.prototype['finally'] = finallyConstructor;
  } 
  if (!globalNS.Promise.allSettled) {
    globalNS.Promise.allSettled = allSettled;
  }
}

})));


/***/ }),

/***/ 166:
/***/ (function(module) {

(function (global, factory) {
	 true ? module.exports = factory() :
	0;
}(this, (function () { 'use strict';

function quickselect(arr, k, left, right, compare) {
    quickselectStep(arr, k, left || 0, right || (arr.length - 1), compare || defaultCompare);
}

function quickselectStep(arr, k, left, right, compare) {

    while (right > left) {
        if (right - left > 600) {
            var n = right - left + 1;
            var m = k - left + 1;
            var z = Math.log(n);
            var s = 0.5 * Math.exp(2 * z / 3);
            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
            quickselectStep(arr, k, newLeft, newRight, compare);
        }

        var t = arr[k];
        var i = left;
        var j = right;

        swap(arr, left, k);
        if (compare(arr[right], t) > 0) swap(arr, left, right);

        while (i < j) {
            swap(arr, i, j);
            i++;
            j--;
            while (compare(arr[i], t) < 0) i++;
            while (compare(arr[j], t) > 0) j--;
        }

        if (compare(arr[left], t) === 0) swap(arr, left, j);
        else {
            j++;
            swap(arr, j, right);
        }

        if (j <= k) left = j + 1;
        if (k <= j) right = j - 1;
    }
}

function swap(arr, i, j) {
    var tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
}

function defaultCompare(a, b) {
    return a < b ? -1 : a > b ? 1 : 0;
}

return quickselect;

})));


/***/ }),

/***/ 510:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


module.exports = rbush;
module.exports["default"] = rbush;

var quickselect = __webpack_require__(166);

function rbush(maxEntries, format) {
    if (!(this instanceof rbush)) return new rbush(maxEntries, format);

    // max entries in a node is 9 by default; min node fill is 40% for best performance
    this._maxEntries = Math.max(4, maxEntries || 9);
    this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));

    if (format) {
        this._initFormat(format);
    }

    this.clear();
}

rbush.prototype = {

    all: function () {
        return this._all(this.data, []);
    },

    search: function (bbox) {

        var node = this.data,
            result = [],
            toBBox = this.toBBox;

        if (!intersects(bbox, node)) return result;

        var nodesToSearch = [],
            i, len, child, childBBox;

        while (node) {
            for (i = 0, len = node.children.length; i < len; i++) {

                child = node.children[i];
                childBBox = node.leaf ? toBBox(child) : child;

                if (intersects(bbox, childBBox)) {
                    if (node.leaf) result.push(child);
                    else if (contains(bbox, childBBox)) this._all(child, result);
                    else nodesToSearch.push(child);
                }
            }
            node = nodesToSearch.pop();
        }

        return result;
    },

    collides: function (bbox) {

        var node = this.data,
            toBBox = this.toBBox;

        if (!intersects(bbox, node)) return false;

        var nodesToSearch = [],
            i, len, child, childBBox;

        while (node) {
            for (i = 0, len = node.children.length; i < len; i++) {

                child = node.children[i];
                childBBox = node.leaf ? toBBox(child) : child;

                if (intersects(bbox, childBBox)) {
                    if (node.leaf || contains(bbox, childBBox)) return true;
                    nodesToSearch.push(child);
                }
            }
            node = nodesToSearch.pop();
        }

        return false;
    },

    load: function (data) {
        if (!(data && data.length)) return this;

        if (data.length < this._minEntries) {
            for (var i = 0, len = data.length; i < len; i++) {
                this.insert(data[i]);
            }
            return this;
        }

        // recursively build the tree with the given data from scratch using OMT algorithm
        var node = this._build(data.slice(), 0, data.length - 1, 0);

        if (!this.data.children.length) {
            // save as is if tree is empty
            this.data = node;

        } else if (this.data.height === node.height) {
            // split root if trees have the same height
            this._splitRoot(this.data, node);

        } else {
            if (this.data.height < node.height) {
                // swap trees if inserted one is bigger
                var tmpNode = this.data;
                this.data = node;
                node = tmpNode;
            }

            // insert the small tree into the large tree at appropriate level
            this._insert(node, this.data.height - node.height - 1, true);
        }

        return this;
    },

    insert: function (item) {
        if (item) this._insert(item, this.data.height - 1);
        return this;
    },

    clear: function () {
        this.data = createNode([]);
        return this;
    },

    remove: function (item, equalsFn) {
        if (!item) return this;

        var node = this.data,
            bbox = this.toBBox(item),
            path = [],
            indexes = [],
            i, parent, index, goingUp;

        // depth-first iterative tree traversal
        while (node || path.length) {

            if (!node) { // go up
                node = path.pop();
                parent = path[path.length - 1];
                i = indexes.pop();
                goingUp = true;
            }

            if (node.leaf) { // check current node
                index = findItem(item, node.children, equalsFn);

                if (index !== -1) {
                    // item found, remove the item and condense tree upwards
                    node.children.splice(index, 1);
                    path.push(node);
                    this._condense(path);
                    return this;
                }
            }

            if (!goingUp && !node.leaf && contains(node, bbox)) { // go down
                path.push(node);
                indexes.push(i);
                i = 0;
                parent = node;
                node = node.children[0];

            } else if (parent) { // go right
                i++;
                node = parent.children[i];
                goingUp = false;

            } else node = null; // nothing found
        }

        return this;
    },

    toBBox: function (item) { return item; },

    compareMinX: compareNodeMinX,
    compareMinY: compareNodeMinY,

    toJSON: function () { return this.data; },

    fromJSON: function (data) {
        this.data = data;
        return this;
    },

    _all: function (node, result) {
        var nodesToSearch = [];
        while (node) {
            if (node.leaf) result.push.apply(result, node.children);
            else nodesToSearch.push.apply(nodesToSearch, node.children);

            node = nodesToSearch.pop();
        }
        return result;
    },

    _build: function (items, left, right, height) {

        var N = right - left + 1,
            M = this._maxEntries,
            node;

        if (N <= M) {
            // reached leaf level; return leaf
            node = createNode(items.slice(left, right + 1));
            calcBBox(node, this.toBBox);
            return node;
        }

        if (!height) {
            // target height of the bulk-loaded tree
            height = Math.ceil(Math.log(N) / Math.log(M));

            // target number of root entries to maximize storage utilization
            M = Math.ceil(N / Math.pow(M, height - 1));
        }

        node = createNode([]);
        node.leaf = false;
        node.height = height;

        // split the items into M mostly square tiles

        var N2 = Math.ceil(N / M),
            N1 = N2 * Math.ceil(Math.sqrt(M)),
            i, j, right2, right3;

        multiSelect(items, left, right, N1, this.compareMinX);

        for (i = left; i <= right; i += N1) {

            right2 = Math.min(i + N1 - 1, right);

            multiSelect(items, i, right2, N2, this.compareMinY);

            for (j = i; j <= right2; j += N2) {

                right3 = Math.min(j + N2 - 1, right2);

                // pack each entry recursively
                node.children.push(this._build(items, j, right3, height - 1));
            }
        }

        calcBBox(node, this.toBBox);

        return node;
    },

    _chooseSubtree: function (bbox, node, level, path) {

        var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;

        while (true) {
            path.push(node);

            if (node.leaf || path.length - 1 === level) break;

            minArea = minEnlargement = Infinity;

            for (i = 0, len = node.children.length; i < len; i++) {
                child = node.children[i];
                area = bboxArea(child);
                enlargement = enlargedArea(bbox, child) - area;

                // choose entry with the least area enlargement
                if (enlargement < minEnlargement) {
                    minEnlargement = enlargement;
                    minArea = area < minArea ? area : minArea;
                    targetNode = child;

                } else if (enlargement === minEnlargement) {
                    // otherwise choose one with the smallest area
                    if (area < minArea) {
                        minArea = area;
                        targetNode = child;
                    }
                }
            }

            node = targetNode || node.children[0];
        }

        return node;
    },

    _insert: function (item, level, isNode) {

        var toBBox = this.toBBox,
            bbox = isNode ? item : toBBox(item),
            insertPath = [];

        // find the best node for accommodating the item, saving all nodes along the path too
        var node = this._chooseSubtree(bbox, this.data, level, insertPath);

        // put the item into the node
        node.children.push(item);
        extend(node, bbox);

        // split on node overflow; propagate upwards if necessary
        while (level >= 0) {
            if (insertPath[level].children.length > this._maxEntries) {
                this._split(insertPath, level);
                level--;
            } else break;
        }

        // adjust bboxes along the insertion path
        this._adjustParentBBoxes(bbox, insertPath, level);
    },

    // split overflowed node into two
    _split: function (insertPath, level) {

        var node = insertPath[level],
            M = node.children.length,
            m = this._minEntries;

        this._chooseSplitAxis(node, m, M);

        var splitIndex = this._chooseSplitIndex(node, m, M);

        var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));
        newNode.height = node.height;
        newNode.leaf = node.leaf;

        calcBBox(node, this.toBBox);
        calcBBox(newNode, this.toBBox);

        if (level) insertPath[level - 1].children.push(newNode);
        else this._splitRoot(node, newNode);
    },

    _splitRoot: function (node, newNode) {
        // split root node
        this.data = createNode([node, newNode]);
        this.data.height = node.height + 1;
        this.data.leaf = false;
        calcBBox(this.data, this.toBBox);
    },

    _chooseSplitIndex: function (node, m, M) {

        var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;

        minOverlap = minArea = Infinity;

        for (i = m; i <= M - m; i++) {
            bbox1 = distBBox(node, 0, i, this.toBBox);
            bbox2 = distBBox(node, i, M, this.toBBox);

            overlap = intersectionArea(bbox1, bbox2);
            area = bboxArea(bbox1) + bboxArea(bbox2);

            // choose distribution with minimum overlap
            if (overlap < minOverlap) {
                minOverlap = overlap;
                index = i;

                minArea = area < minArea ? area : minArea;

            } else if (overlap === minOverlap) {
                // otherwise choose distribution with minimum area
                if (area < minArea) {
                    minArea = area;
                    index = i;
                }
            }
        }

        return index;
    },

    // sorts node children by the best axis for split
    _chooseSplitAxis: function (node, m, M) {

        var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX,
            compareMinY = node.leaf ? this.compareMinY : compareNodeMinY,
            xMargin = this._allDistMargin(node, m, M, compareMinX),
            yMargin = this._allDistMargin(node, m, M, compareMinY);

        // if total distributions margin value is minimal for x, sort by minX,
        // otherwise it's already sorted by minY
        if (xMargin < yMargin) node.children.sort(compareMinX);
    },

    // total margin of all possible split distributions where each node is at least m full
    _allDistMargin: function (node, m, M, compare) {

        node.children.sort(compare);

        var toBBox = this.toBBox,
            leftBBox = distBBox(node, 0, m, toBBox),
            rightBBox = distBBox(node, M - m, M, toBBox),
            margin = bboxMargin(leftBBox) + bboxMargin(rightBBox),
            i, child;

        for (i = m; i < M - m; i++) {
            child = node.children[i];
            extend(leftBBox, node.leaf ? toBBox(child) : child);
            margin += bboxMargin(leftBBox);
        }

        for (i = M - m - 1; i >= m; i--) {
            child = node.children[i];
            extend(rightBBox, node.leaf ? toBBox(child) : child);
            margin += bboxMargin(rightBBox);
        }

        return margin;
    },

    _adjustParentBBoxes: function (bbox, path, level) {
        // adjust bboxes along the given tree path
        for (var i = level; i >= 0; i--) {
            extend(path[i], bbox);
        }
    },

    _condense: function (path) {
        // go through the path, removing empty nodes and updating bboxes
        for (var i = path.length - 1, siblings; i >= 0; i--) {
            if (path[i].children.length === 0) {
                if (i > 0) {
                    siblings = path[i - 1].children;
                    siblings.splice(siblings.indexOf(path[i]), 1);

                } else this.clear();

            } else calcBBox(path[i], this.toBBox);
        }
    },

    _initFormat: function (format) {
        // data format (minX, minY, maxX, maxY accessors)

        // uses eval-type function compilation instead of just accepting a toBBox function
        // because the algorithms are very sensitive to sorting functions performance,
        // so they should be dead simple and without inner calls

        var compareArr = ['return a', ' - b', ';'];

        this.compareMinX = new Function('a', 'b', compareArr.join(format[0]));
        this.compareMinY = new Function('a', 'b', compareArr.join(format[1]));

        this.toBBox = new Function('a',
            'return {minX: a' + format[0] +
            ', minY: a' + format[1] +
            ', maxX: a' + format[2] +
            ', maxY: a' + format[3] + '};');
    }
};

function findItem(item, items, equalsFn) {
    if (!equalsFn) return items.indexOf(item);

    for (var i = 0; i < items.length; i++) {
        if (equalsFn(item, items[i])) return i;
    }
    return -1;
}

// calculate node's bbox from bboxes of its children
function calcBBox(node, toBBox) {
    distBBox(node, 0, node.children.length, toBBox, node);
}

// min bounding rectangle of node children from k to p-1
function distBBox(node, k, p, toBBox, destNode) {
    if (!destNode) destNode = createNode(null);
    destNode.minX = Infinity;
    destNode.minY = Infinity;
    destNode.maxX = -Infinity;
    destNode.maxY = -Infinity;

    for (var i = k, child; i < p; i++) {
        child = node.children[i];
        extend(destNode, node.leaf ? toBBox(child) : child);
    }

    return destNode;
}

function extend(a, b) {
    a.minX = Math.min(a.minX, b.minX);
    a.minY = Math.min(a.minY, b.minY);
    a.maxX = Math.max(a.maxX, b.maxX);
    a.maxY = Math.max(a.maxY, b.maxY);
    return a;
}

function compareNodeMinX(a, b) { return a.minX - b.minX; }
function compareNodeMinY(a, b) { return a.minY - b.minY; }

function bboxArea(a)   { return (a.maxX - a.minX) * (a.maxY - a.minY); }
function bboxMargin(a) { return (a.maxX - a.minX) + (a.maxY - a.minY); }

function enlargedArea(a, b) {
    return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) *
           (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));
}

function intersectionArea(a, b) {
    var minX = Math.max(a.minX, b.minX),
        minY = Math.max(a.minY, b.minY),
        maxX = Math.min(a.maxX, b.maxX),
        maxY = Math.min(a.maxY, b.maxY);

    return Math.max(0, maxX - minX) *
           Math.max(0, maxY - minY);
}

function contains(a, b) {
    return a.minX <= b.minX &&
           a.minY <= b.minY &&
           b.maxX <= a.maxX &&
           b.maxY <= a.maxY;
}

function intersects(a, b) {
    return b.minX <= a.maxX &&
           b.minY <= a.maxY &&
           b.maxX >= a.minX &&
           b.maxY >= a.minY;
}

function createNode(children) {
    return {
        children: children,
        height: 1,
        leaf: true,
        minX: Infinity,
        minY: Infinity,
        maxX: -Infinity,
        maxY: -Infinity
    };
}

// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;
// combines selection algorithm with binary divide & conquer approach

function multiSelect(arr, left, right, n, compare) {
    var stack = [left, right],
        mid;

    while (stack.length) {
        right = stack.pop();
        left = stack.pop();

        if (right - left <= n) continue;

        mid = left + Math.ceil((right - left) / n / 2) * n;
        quickselect(arr, mid, left, right, compare);

        stack.push(left, mid, mid, right);
    }
}


/***/ }),

/***/ 153:
/***/ ((module) => {

const hexRegex = /^[-+]?0x[a-fA-F0-9]+$/;
const numRegex = /^([\-\+])?(0*)(\.[0-9]+([eE]\-?[0-9]+)?|[0-9]+(\.[0-9]+([eE]\-?[0-9]+)?)?)$/;
// const octRegex = /0x[a-z0-9]+/;
// const binRegex = /0x[a-z0-9]+/;


//polyfill
if (!Number.parseInt && window.parseInt) {
    Number.parseInt = window.parseInt;
}
if (!Number.parseFloat && window.parseFloat) {
    Number.parseFloat = window.parseFloat;
}

  
const consider = {
    hex :  true,
    leadingZeros: true,
    decimalPoint: "\.",
    eNotation: true
    //skipLike: /regex/
};

function toNumber(str, options = {}){
    // const options = Object.assign({}, consider);
    // if(opt.leadingZeros === false){
    //     options.leadingZeros = false;
    // }else if(opt.hex === false){
    //     options.hex = false;
    // }

    options = Object.assign({}, consider, options );
    if(!str || typeof str !== "string" ) return str;
    
    let trimmedStr  = str.trim();
    // if(trimmedStr === "0.0") return 0;
    // else if(trimmedStr === "+0.0") return 0;
    // else if(trimmedStr === "-0.0") return -0;

    if(options.skipLike !== undefined && options.skipLike.test(trimmedStr)) return str;
    else if (options.hex && hexRegex.test(trimmedStr)) {
        return Number.parseInt(trimmedStr, 16);
    // } else if (options.parseOct && octRegex.test(str)) {
    //     return Number.parseInt(val, 8);
    // }else if (options.parseBin && binRegex.test(str)) {
    //     return Number.parseInt(val, 2);
    }else{
        //separate negative sign, leading zeros, and rest number
        const match = numRegex.exec(trimmedStr);
        if(match){
            const sign = match[1];
            const leadingZeros = match[2];
            let numTrimmedByZeros = trimZeros(match[3]); //complete num without leading zeros
            //trim ending zeros for floating number
            
            const eNotation = match[4] || match[6];
            if(!options.leadingZeros && leadingZeros.length > 0 && sign && trimmedStr[2] !== ".") return str; //-0123
            else if(!options.leadingZeros && leadingZeros.length > 0 && !sign && trimmedStr[1] !== ".") return str; //0123
            else{//no leading zeros or leading zeros are allowed
                const num = Number(trimmedStr);
                const numStr = "" + num;
                if(numStr.search(/[eE]/) !== -1){ //given number is long and parsed to eNotation
                    if(options.eNotation) return num;
                    else return str;
                }else if(eNotation){ //given number has enotation
                    if(options.eNotation) return num;
                    else return str;
                }else if(trimmedStr.indexOf(".") !== -1){ //floating number
                    // const decimalPart = match[5].substr(1);
                    // const intPart = trimmedStr.substr(0,trimmedStr.indexOf("."));

                    
                    // const p = numStr.indexOf(".");
                    // const givenIntPart = numStr.substr(0,p);
                    // const givenDecPart = numStr.substr(p+1);
                    if(numStr === "0" && (numTrimmedByZeros === "") ) return num; //0.0
                    else if(numStr === numTrimmedByZeros) return num; //0.456. 0.79000
                    else if( sign && numStr === "-"+numTrimmedByZeros) return num;
                    else return str;
                }
                
                if(leadingZeros){
                    // if(numTrimmedByZeros === numStr){
                    //     if(options.leadingZeros) return num;
                    //     else return str;
                    // }else return str;
                    if(numTrimmedByZeros === numStr) return num;
                    else if(sign+numTrimmedByZeros === numStr) return num;
                    else return str;
                }

                if(trimmedStr === numStr) return num;
                else if(trimmedStr === sign+numStr) return num;
                // else{
                //     //number with +/- sign
                //     trimmedStr.test(/[-+][0-9]);

                // }
                return str;
            }
            // else if(!eNotation && trimmedStr && trimmedStr !== Number(trimmedStr) ) return str;
            
        }else{ //non-numeric string
            return str;
        }
    }
}

/**
 * 
 * @param {string} numStr without leading zeros
 * @returns 
 */
function trimZeros(numStr){
    if(numStr && numStr.indexOf(".") !== -1){//float
        numStr = numStr.replace(/0+$/, ""); //remove ending zeros
        if(numStr === ".")  numStr = "0";
        else if(numStr[0] === ".")  numStr = "0"+numStr;
        else if(numStr[numStr.length-1] === ".")  numStr = numStr.substr(0,numStr.length-1);
        return numStr;
    }
    return numStr;
}
module.exports = toNumber


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";

// UNUSED EXPORTS: AddressMatchService, AggregationParameter, AggregationTypes, AlongLineDirection, AnalystAreaUnit, AnalystSizeUnit, AreaSolarRadiationParameters, ArrayStatistic, AttributesPopContainer, Bounds, BoundsType, Browser, BucketAggParameter, BucketAggType, BufferAnalystParameters, BufferDistance, BufferEndType, BufferRadiusUnit, BufferSetting, BuffersAnalystJobsParameter, BurstPipelineAnalystParameters, CartoCSS, CellSizeType, ChartQueryFilterParameter, ChartQueryParameters, ChartService, ChartType, ChartView, ChartViewModel, CityTabsPage, ClientType, ClipAnalystMode, ClipParameter, ColorDictionary, ColorGradientType, ColorSpaceType, ColorsPickerUtil, CommonContainer, CommonServiceBase, CommonTheme, CommonUtil, ComponentsUtil, ComputeWeightMatrixParameters, ConnectedEdgesAnalystParameters, ConvexHullAnalystParameters, CreateDatasetParameters, Credential, DataFlowService, DataFormat, DataItemOrderBy, DataItemType, DataReturnMode, DataReturnOption, DatasetBufferAnalystParameters, DatasetInfo, DatasetMinDistanceAnalystParameters, DatasetOverlayAnalystParameters, DatasetService, DatasetSurfaceAnalystParameters, DatasetThiessenAnalystParameters, DatasourceConnectionInfo, DatasourceService, DeckglLayer, DensityKernelAnalystParameters, DirectionType, DropDownBox, EditFeaturesParameters, EditType, ElasticSearch, EngineType, EntityType, Event, Events, Exponent, FGBLayer, FacilityAnalyst3DParameters, FacilityAnalystSinks3DParameters, FacilityAnalystSources3DParameters, FacilityAnalystStreamParameters, FacilityAnalystTracedown3DParameters, FacilityAnalystTraceup3DParameters, FacilityAnalystUpstream3DParameters, Feature, FeatureService, FeatureShapeFactory, FeatureTheme, FeatureThemeGraph, FeatureThemeRankSymbol, FeatureThemeVector, FeatureVector, FetchRequest, FieldParameters, FieldService, FieldStatisticsParameters, FieldsFilter, FileReaderUtil, FillGradientMode, FilterField, FilterParameter, FindClosestFacilitiesParameters, FindLocationParameters, FindMTSPPathsParameters, FindPathParameters, FindServiceAreasParameters, FindTSPPathsParameters, Format, GenerateSpatialDataParameters, GeoCodingParameter, GeoDecodingParameter, GeoFeature, GeoFeatureThemeLayer, GeoHashGridAggParameter, GeoJSONFormat, GeoRelationAnalystParameters, Geometry, Geometry3D, GeometryBufferAnalystParameters, GeometryCollection, GeometryCurve, GeometryGeoText, GeometryLineString, GeometryLinearRing, GeometryMinDistanceAnalystParameters, GeometryMultiLineString, GeometryMultiPoint, GeometryMultiPolygon, GeometryOverlayAnalystParameters, GeometryPoint, GeometryPolygon, GeometryRectangle, GeometrySurfaceAnalystParameters, GeometryThiessenAnalystParameters, GeometryType, GeoprocessingService, GetFeatureMode, GetFeaturesByBoundsParameters, GetFeaturesByBufferParameters, GetFeaturesByGeometryParameters, GetFeaturesByIDsParameters, GetFeaturesBySQLParameters, GetFeaturesParametersBase, GetFeaturesServiceBase, GetGridCellInfosParameters, GetLayersLegendInfoParameters, GraduatedMode, Graph, GraphAxesTextDisplayMode, GraphMap, GraphThemeLayer, Graphic, GraphicLayer, GraticuleLayer, Grid, GridCellInfosService, GridType, HeatMapLayer, HillshadeParameter, IManager, IManagerCreateNodeParam, IManagerServiceBase, IPortal, IPortalAddDataParam, IPortalAddResourceParam, IPortalDataConnectionInfoParam, IPortalDataMetaInfoParam, IPortalDataStoreInfoParam, IPortalQueryParam, IPortalQueryResult, IPortalRegisterServiceParam, IPortalResource, IPortalServiceBase, IPortalShareEntity, IPortalShareParam, IPortalUser, ImageCollectionService, ImageGFAspect, ImageGFHillShade, ImageGFOrtho, ImageGFSlope, ImageRenderingRule, ImageSearchParameter, ImageService, ImageStretchOption, IndexTabsPageContainer, InterpolationAlgorithmType, InterpolationAnalystParameters, InterpolationDensityAnalystParameters, InterpolationIDWAnalystParameters, InterpolationKrigingAnalystParameters, InterpolationRBFAnalystParameters, JSONFormat, JoinItem, JoinType, KernelDensityJobParameter, KeyServiceParameter, KnowledgeGraph, KnowledgeGraphService, Label, LabelBackShape, LabelImageCell, LabelMatrixCell, LabelMixedTextStyle, LabelOverLengthMode, LabelSymbolCell, LabelThemeCell, LabelThemeLayer, Lang, LayerInfoService, LayerStatus, LayerType, LinkItem, Logo, LonLat, MapExtend, MapService, MappingParameters, MapvDataSet, MapvLayer, MathExpressionAnalysisParameters, MeasureMode, MeasureParameters, MeasureService, MessageBox, MetricsAggParameter, MetricsAggType, NDVIParameter, NavTabsPage, NetworkAnalyst3DService, NetworkAnalystService, NetworkAnalystServiceBase, Online, OnlineData, OnlineQueryDatasParameter, OnlineServiceBase, OrderBy, OrderType, OutputSetting, OutputType, OverlapDisplayedOptions, OverlayAnalystParameters, OverlayGeoJobParameter, OverlayOperationType, PaginationContainer, PermissionType, Pixel, PixelFormat, PointWithMeasure, PopContainer, ProcessingService, ProcessingServiceBase, QueryByBoundsParameters, QueryByDistanceParameters, QueryByGeometryParameters, QueryBySQLParameters, QueryOption, QueryParameters, QueryService, Range, RangeMode, RangeTheme3DLayer, RangeThemeLayer, RankSymbol, RankSymbolThemeLayer, RasterFunctionParameter, RasterFunctionType, ResourceType, Route, RouteCalculateMeasureParameters, RouteLocatorParameters, SearchMode, SearchType, SecurityManager, Select, ServerColor, ServerFeature, ServerGeometry, ServerInfo, ServerStyle, ServerTextStyle, ServerTheme, ServerType, ServiceBase, ServiceStatus, SetDatasourceParameters, SetLayerInfoParameters, SetLayerStatusParameters, SetLayersInfoParameters, ShapeParameters, ShapeParametersCircle, ShapeParametersImage, ShapeParametersLabel, ShapeParametersLine, ShapeParametersPoint, ShapeParametersPolygon, ShapeParametersRectangle, ShapeParametersSector, SideType, SingleObjectQueryJobsParameter, Size, SmoothMethod, Sortby, SpatialAnalystBase, SpatialAnalystService, SpatialQueryMode, SpatialRelationType, StatisticAnalystMode, StatisticMode, StopQueryParameters, SummaryAttributesJobsParameter, SummaryMeshJobParameter, SummaryRegionJobParameter, SummaryType, SuperMap, SupplyCenter, SupplyCenterType, SurfaceAnalystMethod, SurfaceAnalystParameters, SurfaceAnalystParametersSetting, TemplateBase, TerrainAspectCalculationParameters, TerrainCurvatureCalculationParameters, TerrainCutFillCalculationParameters, TerrainSlopeCalculationParameters, TextAlignment, Theme3DLayer, ThemeDotDensity, ThemeFeature, ThemeGraduatedSymbol, ThemeGraduatedSymbolStyle, ThemeGraph, ThemeGraphAxes, ThemeGraphItem, ThemeGraphSize, ThemeGraphText, ThemeGraphTextFormat, ThemeGraphType, ThemeGridRange, ThemeGridRangeItem, ThemeGridUnique, ThemeGridUniqueItem, ThemeLabel, ThemeLabelAlongLine, ThemeLabelBackground, ThemeLabelItem, ThemeLabelText, ThemeLabelUniqueItem, ThemeLayer, ThemeMemoryData, ThemeOffset, ThemeParameters, ThemeRange, ThemeRangeItem, ThemeService, ThemeStyle, ThemeType, ThemeUnique, ThemeUniqueItem, ThiessenAnalystParameters, ThreeLayer, TimeControlBase, TimeFlowControl, TokenServiceParameter, TopologyValidatorJobsParameter, TopologyValidatorRule, TraceAnalystParameters, TrafficTransferAnalystService, TransferLine, TransferPathParameters, TransferPreference, TransferSolutionParameters, TransferTactic, Transform, TransportationAnalystParameter, TransportationAnalystResultSetting, TurnType, UGCLayer, UGCLayerType, UGCMapLayer, UGCSubLayer, Unique, UniqueTheme3DLayer, UniqueThemeLayer, Unit, UpdateDatasetParameters, UpdateEdgeWeightParameters, UpdateTurnNodeWeightParameters, Util, VariogramMode, Vector, VectorClipJobsParameter, WKTFormat, WebExportFormatType, WebMap, WebPrintingJobContent, WebPrintingJobCustomItems, WebPrintingJobExportOptions, WebPrintingJobImage, WebPrintingJobLayers, WebPrintingJobLayoutOptions, WebPrintingJobLegendOptions, WebPrintingJobLittleMapOptions, WebPrintingJobNorthArrowOptions, WebPrintingJobParameters, WebPrintingJobScaleBarOptions, WebPrintingJobService, WebScaleOrientationType, WebScaleType, WebScaleUnit, WebSymbol, conversionDegree, getDefaultVectorTileStyle, getMeterPerMapUnit, getWrapNum, initMap, isCORS, setBackground, setCORS, setPaintProperty, terrainAnalystSetting

;// CONCATENATED MODULE: external "mapboxgl"
const external_mapboxgl_namespaceObject = mapboxgl;
var external_mapboxgl_default = /*#__PURE__*/__webpack_require__.n(external_mapboxgl_namespaceObject);
;// CONCATENATED MODULE: ./src/mapboxgl/core/MapExtend.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


/**
 * @function MapExtend
 * @description  扩展了 mapboxgl.Map 对图层相关的操作。
 * @private
 */
var MapExtend = (function () {
  (external_mapboxgl_default()).Map.prototype.overlayLayersManager = {};
  if ((external_mapboxgl_default()).Map.prototype.addLayerBak === undefined) {
    (external_mapboxgl_default()).Map.prototype.addLayerBak = (external_mapboxgl_default()).Map.prototype.addLayer;
    (external_mapboxgl_default()).Map.prototype.addLayer = function (layer, before) {
      if (layer.source || layer.type === 'custom' || layer.type === 'background') {
        this.addLayerBak(layer, before);
        if (layer.overlay && !this.overlayLayersManager[layer.id]) {
          this.overlayLayersManager[layer.id] = layer;
        }
        return this;
      }
      if (this.overlayLayersManager[layer.id] || this.style._layers[layer.id]) {
        this.fire('error', {
          error: new Error('A layer with this id already exists.')
        });
        return;
      }
      addLayer(layer, this);
      this.overlayLayersManager[layer.id] = layer;
      return this;
    };
  }

  (external_mapboxgl_default()).Map.prototype.getLayer = function (id) {
    if (this.overlayLayersManager[id]) {
      return this.overlayLayersManager[id];
    }
    return this.style.getLayer(id);
  };

  (external_mapboxgl_default()).Map.prototype.moveLayer = function (id, beforeId) {
    if (this.overlayLayersManager[id]) {
      this.overlayLayersManager[id].moveLayer
        ? this.overlayLayersManager[id].moveLayer(id, beforeId)
        : moveLayer(id, beforeId);
      return this;
    }
    if (this.style._layers[id]) {
      this.style.moveLayer(id, beforeId);
      this._update(true);
      return this;
    }
  };

  (external_mapboxgl_default()).Map.prototype.removeLayer = function (id) {
    if (this.overlayLayersManager[id]) {
      delete this.overlayLayersManager[id];
    }
    this.style.removeLayer(id);
    this._update(true);
    return this;
  };

  //目前扩展的overlayer，只支持显示或隐藏图层操作
  (external_mapboxgl_default()).Map.prototype.setLayoutProperty = function (layerID, name, value) {
    if (this.overlayLayersManager[layerID]) {
      if (name === 'visibility') {
        if (value === 'visible') {
          value = true;
        } else {
          value = false;
        }
        setVisibility(this.overlayLayersManager[layerID], value);
        this.style.fire('data', { dataType: 'style' });
      }
      return this;
    }
    this.style.setLayoutProperty(layerID, name, value);
    this._update(true);
    return this;
  };
  (external_mapboxgl_default()).Map.prototype.updateTransform = function (units, originX, originY, centerX, centerY, width, height) {
    this.transform.units = units;
    var mercatorZfromAltitude = this.mercatorZfromAltitude;
    (external_mapboxgl_default()).MercatorCoordinate.fromLngLat = function (lngLatLike, altitude) {
      altitude = altitude || 0;
      const lngLat = external_mapboxgl_default().LngLat.convert(lngLatLike);
      return new (external_mapboxgl_default()).MercatorCoordinate(
        (lngLat.lng - originX) / width,
        (originY - lngLat.lat) / height,
        mercatorZfromAltitude(altitude, lngLat.lat)
      );
    };
    (external_mapboxgl_default()).MercatorCoordinate.prototype.toLngLat = function () {
      return new (external_mapboxgl_default()).LngLat(this.x * width + originX, originY - this.y * height);
    };
    this.customConvertPoint = window.URL.createObjectURL(
      new Blob(
        [
          'customConvertPoint = {projectX:function(x){return (x - ' +
            centerX +
            ') / ' +
            width +
            ' + 0.5},projectY:function(y){y = 0.5 - ((y - ' +
            centerY +
            ') / ' +
            height +
            ');return y < 0 ? 0 : y > 1 ? 1 : y;},toY:function(y){return (0.5-y)*' +
            height +
            '+' +
            centerY +
            ';}}'
        ],
        { type: 'text/javascript' }
      )
    );
  };

  function addLayer(layer, map) {
    layer.onAdd && layer.onAdd(map);
  }

  /**
   * @function MapExtend.prototype.setVisibility
   * @description  设置图层可见性，设置图层的隐藏，显示，重绘的相应的可见标记。
   * @param {boolean} [visibility] - 是否显示图层（当前地图的 resolution 在最大最小 resolution 之间）。
   */
  function setVisibility(layer, visibility) {
    layer.setVisibility && layer.setVisibility(visibility);
  }

  /**
   * @function MapExtend.prototype.moveTo
   * @description 将图层移动到某个图层之前。
   * @param {string} layerID -待插入的图层 ID。
   * @param {boolean} [beforeLayerID] - 是否将本图层插入到图层 id 为 layerID 的图层之前(如果为 false 则将本图层插入到图层 id 为 layerID 的图层之后)。
   */
  function moveLayer(layerID, beforeLayerID) {
    var layer = document.getElementById(layerID);
    // var beforeLayer;
    if (beforeLayerID) {
      var beforeLayer = document.getElementById(beforeLayerID);
      if (!beforeLayer) {
        external_mapboxgl_default().Evented.prototype.fire('error', {
          error: new Error(`Layer with id "${beforeLayerID}" does not exist on this document.`)
        });
      }
    }
    if (layer && beforeLayer) {
      beforeLayer.parentNode.insertBefore(layer, beforeLayer);
    } else {
      //当没有传入beforeLayerID ，则默认将图层移动到最上面
      layer.parentNode.appendChild(layer);
    }
  }
})();

;// CONCATENATED MODULE: ./src/mapboxgl/core/Base.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/

;// CONCATENATED MODULE: ./src/common/control/img/Logo.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/
var LogoBase64 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAF4AAAAdCAYAAAAjHtusAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA4ZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMDY3IDc5LjE1Nzc0NywgMjAxNS8wMy8zMC0yMzo0MDo0MiAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDozYWZlOGIwMi01MWE3LTRiZjYtYWVkYS05MGQ2ZTQ4YjZiMmUiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6ODg0NkFBQUE3RjEzMTFFNzhFRjJFQkY4RjcxQjc1NjIiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6ODg0NkFBQTk3RjEzMTFFNzhFRjJFQkY4RjcxQjc1NjIiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUgKE1hY2ludG9zaCkiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo4MWI3NzdhNC1lZmEyLTQ1MzUtOGQzNi03MmRjNDkyODMzN2UiIHN0UmVmOmRvY3VtZW50SUQ9ImFkb2JlOmRvY2lkOnBob3Rvc2hvcDpjYTYzODVjMi1jNDQ1LTExN2EtYTc0ZC1lM2I5MzJlMGE4Y2QiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz5q1HM0AAAF/ElEQVR42tSabYhUVRjHZ7W01C1uaCRW4F3oi9SXCUnwQ9gsGUFvOEtQH1bLu5VS9sbYh5KicjYt29qiGQwVg2xWWKgocob91AvC+CWsoJqB3qHMSdTMpZyeU/+Df07n3pk7997Z6cBv99z7nHvOvf/z/pxJNZvNVI/jCKXmv6EquAmVkxPSlvtp2GItr0/96fFQForChJAWDiVYTkMYMu4XBFcYjLOwWS3sNwmn8NGzZ0h4Flv/zwIdchAnh/slCGmmKUNIBzYPaXOUr0vPuEjD71JAPh7l61embzinhV3V8nnCGmGT8LwlzSL8/yUh4Tfjo9T/CgnCIYNKycA2Qq21AcHU/VHE80Idoo3Qs0W6p0UtUnkZvEMDeVcCyqxEafF7hL8Qf0oYsIj+lfC9cH1CwhchWAGCtZO+AooQOkdC1Km1VtCb63StW73uFSzgKFUkNwBbmZGGmqowhvg8ZNpH9oXChcIcYRdeNomgxLkaH+S1SGubAxyIpFv+Zp+0DYjrAS00j/dem2VGEl6FJ4Qa4quEu8j2hTCJ+GJhe4JjfQMf6JCYPPbysMPxBlp0BUKOogEF9Rg9/heNvNKYfM0KsZUZaYxX4STGrzJa+zbhPeFH2DcK10KItcI+pI0rVElwXl1ULaKnIJhDw0oRQpTQc1zcbwRU8ATy4DR6yMlTzwkqMziEWHvubJ4Nk4ZtHdnqwvwY17xq3Z4FjrG+z2Kdrdf2ZSGD+xlLPh6t1R0jP9fI22ZzKI92yvQl7EbmBxI4S7Y+vIAOL87QZqsc5uNnssxZIcfYjXT9snCR7jjobidp+FkxA2v+Cq1QervMDmp4P7Xs3YZtE9kOC3P/By6JGaETl8ElwueYTNTDq4UDsKnd7YfCNbT239LF1udS72xYJt1UWxNfN4IIP4bWuTpEja01JtMFZFsm/AHbtHBlDE6yasA4moYTrUbvdBTXHqUrAH4uSadbyzF+vbBM2IsNkS3MNa5305JxqfA02T4TnkX8XOH1mPw8ruVejpxbI9hZD2Cz1U7LdrrUvjP/WfZinNZhr6V27hP+FPZh9aLvLxVO4DllX0G2OcKnlO/DCblxaz6uXBtmi+8mBaP3/SP8IuEIiTRoPPQm2TaEmEyXo0JU+F0YiPFD0hhOsiE/vqeEVwyTgF8L51OilcIZ2I4Ll5NttvAJPfukUeB2sk0ZPSbKIUUJpCII7+DasWy08uhNNazT0wGHI7mAtB7KqMKm38HhDdAUibTVKGicbB8YAqrJ9DRsp43JdB4qUof1HQrPE6XTQWu3Ce/inVzjXhXpMiTwUYugNVQ+p80jrUsV5EH0POKeuXO9QjhFq5GryNYvfEMCDhsftYVsB9ETtG0V9ZjfhCURhbcJFpfwVZ9jvhxsLHwTYtp2svlWQw3vXL8UnqHVSIG8l8ex+tHhBXgjddgqHEZ8ufAA2aaEnYgrF/KrPXrEmMUqZ9THLW06xhoBaVueQpkug+ewOUphE3Qv2Q5gGamXYa+QbVq4O+DQ5FHyZqrjxNt7UHh9uuRa0F7HjCF8o9PCTOGnscM7g2u1Hl9C9oeEnxC/1ajZg8JLiM9Hj9GHJseMShwL2DO0G5yEWn3Zh1QUods5CPkIoqlwAZxhXMsb6HrcEPBxchhdJ6wj29vCW4hfLOzo8J3rltYX50nXQAATSf/K4DEaGlTLvplsk/QCpoD60EQ7gLYZc8H9wq+I3yncEOEcNhuz6HWf3XEiwU/4Y8YEqVp2P10rt+8REvBGw026i4aDcbL9jF8r8Blmf4fCOzhViiscskygXRdehf3CO4hfigmTBXyQrl8TFtD1IzQX3CbcQrY3hPcRv4z8OmHPXwchVNln2MmE7BX6VwIFi/he6uxvb6JM3m0fdqvx/ATidxg2JeC7VDErAw5NzGfvwRJVheEIQ8Mg/pdwIM+UOmi9Q8ivCsrIy0tF+wVbEcLrd3Pb2XisEb4Tdlhsi4WP4RBbaLGrHfC3PrvMIezy9rTpGm5lz9LOMG15xvFxD/j5gjzjjDbMOzk+9zzt3v5bgAEAibzFeFHVgYkAAAAASUVORK5CYII=";
;// CONCATENATED MODULE: ./src/mapboxgl/control/Logo.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/



/**
 * @class Logo
 * @deprecatedclass mapboxgl.supermap.LogoControl
 * @category  Control
 * @classdesc Logo 控件类。默认不显示。
 * @modulecategory Control
 *
 * @example
 * (start code)
 *  map.addControl(new Logo(),'bottom-right');
 * (end)
 * @param {Object} options - logo 控件配置项。
 * @param {string} [options.imageUrl] - logo 图片地址。
 * @param {string} [options.width] - logo 图片宽度。
 * @param {string} [options.height] - logo 图片高度。
 * @param {string} [options.link] - logo图片跳转链接。
 * @param {string} [options.alt='SuperMap iClient'] - logo 图片失效时显示文本。
 * @usage
 */
class Logo {
    constructor(options) {
        //logo图片地址
        this.imageUrl = null;
        //跳转链接
        this.link = null;
        //logo图片宽
        this.width = null;
        //logo图片高
        this.height = null;
        //logo图片失效时显示文本
        this.alt = "SuperMap iClient";
        this._extend(this, options)
    }

    /**
     * @function Logo.prototype.onAdd
     * @description 添加Logo。
     * @returns {HTMLElement} 返回创建的 Logo 元素。
     */
    onAdd(map) {
        this._map = map;
        this._container = document.createElement('div');
        this._container.className = 'mapboxgl-ctrl iclient-logo';
        this._container.style.marginTop = 0;
        this._container.style.marginBottom = 0;
        this._container.style.marginLeft = 0;
        this._container.style.marginRight = 0;

        var imgSrc = LogoBase64;
        if (this.imageUrl) {
            imgSrc = this.imageUrl;
        }
        var alt = this.alt;

        var imageWidth = "94px";
        var imageHeight = "29px";
        var styleSize = "width:" + imageWidth + ";height:" + imageHeight + ";";
        if (this.imageUrl) {
            imageWidth = this.width;
            imageHeight = this.height;
            styleSize = "width:" + imageWidth + ";height:" + imageHeight + ";";
            if (!imageWidth || !imageHeight) {
                styleSize = "";
            }
        }
        var link = this.link;
        this._container.innerHTML = "<a href='" + link + "' target='_blank'>" +
            "<img src=" + imgSrc + " alt='" + alt + "' style='" + styleSize + "margin-bottom: 2px'></a>";
        this._createStyleSheet();
        return this._container;
    }

    _createStyleSheet() {
        var style = document.createElement('style');
        style.type = 'text/css';
        style.innerHTML = ".iclient-logo{" +
            "margin:0 !important;" +
            "}" +
            ".iclient-logo a{" +
            "border: none;" +
            "display: block;" +
            "height:31px;" +
            "}" +
            ".iclient-logo img{" +
            "border: none;" +
            "white-space: nowrap" +
            "}";
        document.getElementsByTagName('head')[0].appendChild(style);
    }

    _extend(dest) {
        for (var index = 0; index < Object.getOwnPropertyNames(arguments).length; index++) {
            var arg = Object.getOwnPropertyNames(arguments)[index];
            if (arg == "caller" || arg == "callee" || arg == "length" || arg == "arguments") {
                continue;
            }
            var obj = arguments[arg];
            if (obj) {
                for (var j = 0; j < Object.getOwnPropertyNames(obj).length; j++) {
                    var key = Object.getOwnPropertyNames(obj)[j];
                    if (arg == "caller" || arg == "callee" || arg == "length" || arg == "arguments") {
                        continue;
                    }
                    dest[key] = obj[key];
                }
            }
        }
        return dest;
    }
}

;// CONCATENATED MODULE: ./src/mapboxgl/control/index.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/

;// CONCATENATED MODULE: ./src/common/commontypes/Size.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/

/**
 * @class  Size
 * @deprecatedclass SuperMap.Size
 * @category BaseTypes Style
 * @classdesc 此类描绘一对高宽值的实例。
 * @param {number} [w=0.0] - 宽度。
 * @param {number} [h=0.0] - 高度。
 *
 * @example
 * var size = new Size(31,46);
 * @usage
 */
class Size {

    constructor(w, h) {
        /**
         * @member {number} [Size.prototype.w=0.0]
         * @description 宽度。
         */
        this.w = w ? parseFloat(w) : 0.0;

        /**
         * @member {number} [Size.prototype.h=0.0]
         * @description 高度。
         */
        this.h = w ? parseFloat(h) : 0.0;
        this.CLASS_NAME = "SuperMap.Size";
    }


    /**
     * @function Size.prototype.toString
     * @description 返回字符串形式。
     * @example
     * var size = new Size(10,5);
     * var str = size.toString();
     * @returns {string} 例如："w=10,h=5"。
     */
    toString() {
        return ("w=" + this.w + ",h=" + this.h);
    }


    /**
     * @function Size.prototype.clone
     * @description 克隆当前size对象。
     * @example
     * var size = new Size(31,46);
     * var size2 = size.clone();
     * @returns {Size}  新的与当前 size 对象有相同宽、高的 Size 对象。
     */
    clone() {
        return new Size(this.w, this.h);
    }


    /**
     *
     * @function Size.prototype.equals
     * @description 比较两个 size 对象是否相等。
     * @example
     * var size = new Size(31,46);
     * var size2 = new Size(31,46);
     * var isEquals = size.equals(size2);
     *
     * @param {Size} sz - 用于比较相等的 Size 对象。
     * @returns {boolean} 传入的 size 和当前 size 高宽相等，注意：如果传入的 size 为空则返回 false。
     *
     */
    equals(sz) {
        var equals = false;
        if (sz != null) {
            equals = ((this.w === sz.w && this.h === sz.h) ||
                (isNaN(this.w) && isNaN(this.h) && isNaN(sz.w) && isNaN(sz.h)));
        }
        return equals;
    }

    /**
     *
     * @function Size.prototype.destroy
     * @description 销毁此对象。销毁后此对象的所有属性为 null，而不是初始值。
     * @example
     * var size = new Size(31,46);
     * size.destroy();
     */
    destroy() {
        this.w = null;
        this.h = null;
    }
}

;// CONCATENATED MODULE: ./src/common/commontypes/Pixel.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/

/**
 * @class Pixel
 * @deprecatedclass SuperMap.Pixel
 * @category BaseTypes Geometry
 * @classdesc 用 x,y 坐标描绘屏幕坐标（像素点）。
 * @param {number} [x=0.0] - x 坐标。
 * @param {number} [y=0.0] - y 坐标。
 * @param {Pixel.Mode} [mode=Pixel.Mode.LeftTop] - 坐标模式。
 *
 * @example
 * //单独创建一个对象
 * var pixcel = new Pixel(100,50);
 *
 * //依据 size 创建
 *  var size = new Size(21,25);
 *  var offset = new Pixel(-(size.w/2), -size.h);
 * @usage
 */
class Pixel {
  constructor(x, y, mode) {
    /**
     * @member {number} [Pixel.prototype.x=0.0]
     * @description x 坐标。
     */
    this.x = x ? parseFloat(x) : 0.0;

    /**
     * @member {number} [Pixel.prototype.y=0.0]
     * @description y 坐标。
     */
    this.y = y ? parseFloat(y) : 0.0;

    /**
     * @member {Pixel.Mode} [Pixel.prototype.mode=Pixel.Mode.LeftTop]
     * @description 坐标模式，有左上、右上、右下、左下这几种模式，分别表示相对于左上角、右上角、右下角、左下角的坐标。
     */
    this.mode = mode;
    this.CLASS_NAME = 'SuperMap.Pixel';
  }

  /**
   * @function Pixel.prototype.toString
   * @description 返回此对象的字符串形式。
   * @example
   *
   * var pixcel = new Pixel(100,50);
   * var str = pixcel.toString();
   *
   * @returns {string} 例如: "x=200.4,y=242.2"
   */
  toString() {
    return 'x=' + this.x + ',y=' + this.y;
  }

  /**
   * @function Pixel.prototype.clone
   * @description 克隆当前的 pixel 对象。
   * @example
   * var pixcel = new Pixel(100,50);
   * var pixcel2 = pixcel.clone();
   * @returns {Pixel} 新的与当前 pixel 对象有相同 x、y 坐标的 pixel 对象。
   */
  clone() {
    return new Pixel(this.x, this.y, this.mode);
  }

  /**
   * @function Pixel.prototype.equals
   * @description 比较两 pixel 是否相等。
   * @example
   * var pixcel = new Pixel(100,50);
   * var pixcel2 = new Pixel(100,50);
   * var isEquals = pixcel.equals(pixcel2);
   *
   * @param {Pixel} px - 用于比较相等的 pixel 对象。
   * @returns {boolean} 如果传入的像素点和当前像素点相同返回 true，如果不同或传入参数为 NULL 则返回 false。
   */
  equals(px) {
    var equals = false;
    if (px != null) {
      equals = (this.x == px.x && this.y == px.y) || (isNaN(this.x) && isNaN(this.y) && isNaN(px.x) && isNaN(px.y));
    }
    return equals;
  }

  /**
   * @function Pixel.prototype.distanceTo
   * @description 返回两个 pixel 的距离。
   * @example
   * var pixcel = new Pixel(100,50);
   * var pixcel2 = new Pixel(110,30);
   * var distance = pixcel.distanceTo(pixcel2);
   *
   * @param {Pixel} px - 需要计算的 pixel。
   * @returns {number} 作为参数传入的像素与当前像素点的距离。
   */
  distanceTo(px) {
    return Math.sqrt(Math.pow(this.x - px.x, 2) + Math.pow(this.y - px.y, 2));
  }

  /**
   * @function Pixel.prototype.add
   * @description 在原来像素坐标基础上，x 值加上传入的 x 参数，y 值加上传入的 y 参数。
   * @example
   * var pixcel = new Pixel(100,50);
   * //pixcel2是新的对象
   * var pixcel2 = pixcel.add(20,30);
   *
   * @param {number} x - 传入的 x 值。
   * @param {number} y - 传入的 y 值。
   * @returns {Pixel} 新的 pixel 对象，该 pixel 是由当前的 pixel 与传入的 x，y 相加得到。
   */
  add(x, y) {
    if (x == null || y == null) {
      throw new TypeError('Pixel.add cannot receive null values');
    }
    return new Pixel(this.x + x, this.y + y);
  }

  /**
   * @function Pixel.prototype.offset
   * @description 通过传入的 {@link Pixel} 参数对原屏幕坐标进行偏移。
   * @example
   * var pixcel = new Pixel(100,50);
   * var pixcel2 = new Pixel(130,20);
   * //pixcel3 是新的对象
   * var pixcel3 = pixcel.offset(pixcel2);
   *
   * @param {Pixel} px - 传入的 {@link Pixel} 对象。
   * @returns {Pixel} 新的 pixel，该 pixel 是由当前的 pixel 对象的 x，y 值与传入的 Pixel 对象的 x，y 值相加得到。
   */
  offset(px) {
    var newPx = this.clone();
    if (px) {
      newPx = this.add(px.x, px.y);
    }
    return newPx;
  }

  /**
   *
   * @function Pixel.prototype.destroy
   * @description 销毁此对象。销毁后此对象的所有属性为 null，而不是初始值。
   * @example
   * var pixcel = new Pixel(100,50);
   * pixcel.destroy();
   */
  destroy() {
    this.x = null;
    this.y = null;
    this.mode = null;
  }
}
/**
 * @enum Mode
 * @memberOf Pixel
 * @readonly
 * @description 模式。
 * @type {string}
 */
Pixel.Mode = {
  /** 左上模式。*/
  LeftTop: 'lefttop',
  /** 右上模式。 */
  RightTop: 'righttop',
  /** 右下模式。 */
  RightBottom: 'rightbottom',
  /** 左下模式。 */
  LeftBottom: 'leftbottom'
};

;// CONCATENATED MODULE: ./src/common/commontypes/BaseTypes.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/
 

/**
 * @function inherit
 * @description 除了 C 和 P 两个必要参数外，可以传递任意数量的对象，这些对象都将继承C。
 * @param {Object} C - 继承的类。
 * @param {Object} P - 被继承的父类。
 * @private
 */
var inheritExt = function (C, P) {
    var F = function () {
    };
    F.prototype = P.prototype;
    C.prototype = new F;
    var i, l, o;
    for (i = 2, l = arguments.length; i < l; i++) {
        o = arguments[i];
        if (typeof o === "function") {
            o = o.prototype;
        }
        Util_Util.extend(C.prototype, o);
    }
};


/**
 * @function mixinExt
 * @description 实现多重继承。
 * @param {Class|Object} ...mixins - 继承的类。
 * @private
 */
var mixinExt = function (...mixins) {

    class Mix {
        constructor(options) {
            for (var index = 0; index < mixins.length; index++) {
                copyProperties(this, new mixins[index](options));
            }
        }
    }

    for (var index = 0; index < mixins.length; index++) {
        var mixin = mixins[index];
        copyProperties(Mix, mixin);
        copyProperties(Mix.prototype, mixin.prototype);
        copyProperties(Mix.prototype, new mixin());
    }
    return Mix;

    function copyProperties(target, source) {
        var ownKeys = Object.getOwnPropertyNames(source);
        if (Object.getOwnPropertySymbols) {
            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source));
        }
        for (var index = 0; index < ownKeys.length; index++) {
            var key = ownKeys[index];
            if (key !== "constructor"
                && key !== "prototype"
                && key !== "name" && key !== "length") {
                let desc = Object.getOwnPropertyDescriptor(source, key);
                if (window["ActiveXObject"]) {
                    Object.defineProperty(target, key, desc || {});
                } else {
                    Object.defineProperty(target, key, desc);
                }
            }
        }
    }
};

/**
 * @name String
 * @namespace
 * @category BaseTypes Util
 * @description 字符串操作的一系列常用扩展函数。
 * @private
 */
var StringExt = {

    /**
     * @function StringExt.startsWith
     * @description 判断目标字符串是否以指定的子字符串开头。
     * @param {string} str - 目标字符串。
     * @param {string} sub - 查找的子字符串。
     * @returns {boolean} 目标字符串以指定的子字符串开头，则返回 true；否则返回 false。
     */
    startsWith: function (str, sub) {
        return (str.indexOf(sub) == 0);
    },

    /**
     * @function StringExt.contains
     * @description 判断目标字符串是否包含指定的子字符串。
     * @param {string} str - 目标字符串。
     * @param {string} sub - 查找的子字符串。
     * @returns {boolean} 目标字符串中包含指定的子字符串，则返回 true；否则返回 false。
     */
    contains: function (str, sub) {
        return (str.indexOf(sub) != -1);
    },

    /**
     * @function StringExt.trim
     * @description 删除一个字符串的开头和结尾处的所有空白字符。
     * @param {string} str - （可能）存在空白字符填塞的字符串。
     * @returns {string} 删除开头和结尾处空白字符后的字符串。
     */
    trim: function (str) {
        return str.replace(/^\s\s*/, '').replace(/\s\s*$/, '');
    },

    /**
     * @function StringExt.camelize
     * @description 骆驼式("-")连字符的字符串处理。
     * 例如："chicken-head" becomes "chickenHead",
     *       "-chicken-head" becomes "ChickenHead"。
     * @param {string} str - 要处理的字符串，原始内容不应被修改。
     * @returns {string}
     */
    camelize: function (str) {
        var oStringList = str.split('-');
        var camelizedString = oStringList[0];
        for (var i = 1, len = oStringList.length; i < len; i++) {
            var s = oStringList[i];
            camelizedString += s.charAt(0).toUpperCase() + s.substring(1);
        }
        return camelizedString;
    },

    /**
     * @function StringExt.format
     * @description 提供带 ${token} 标记的字符串, 返回 context 对象属性中指定标记的属性值。
     * @example
     * 示例：
     * (code)
     * 1、template = "${value,getValue}";
     *         context = {value: {getValue:function(){return Math.max.apply(null,argument);}}};
     *         args = [2,23,12,36,21];
     *       返回值:36
     * (end)
     * 示例:
     * (code)
     * 2、template = "$${{value,getValue}}";
     *         context = {value: {getValue:function(){return Math.max.apply(null,argument);}}};
     *         args = [2,23,12,36,21];
     *       返回值:"${36}"
     * (end)
     * 示例:
     * (code)
     * 3、template = "${a,b}";
     *         context = {a: {b:"format"}};
     *         args = null;
     *       返回值:"format"
     * (end)
     * 示例:
     * (code)
     * 3、template = "${a,b}";
     *         context = null;
     *         args = null;
     *       返回值:"${a.b}"
     * (end)
     * @param {string} template - 带标记的字符串将要被替换。参数 template 格式为"${token}"，此处的 token 标记会替换为 context["token"] 属性的值。
     * @param {Object} [context=window] - 带有属性的可选对象的属性用于匹配格式化字符串中的标记。如果该参数为空，将使用 window 对象。
     * @param {Array.<number>} [args] - 可选参数传递给在 context 对象上找到的函数。
     * @returns {string} 从 context 对象属性中替换字符串标记位的字符串。
     */
    format: function (template, context, args) {
        if (!context) {
            context = window;
        }

        // Example matching:
        // str   = ${foo.bar}
        // match = foo.bar
        var replacer = function (str, match) {
            var replacement;

            // Loop through all subs. Example: ${a.b.c}
            // 0 -> replacement = context[a];
            // 1 -> replacement = context[a][b];
            // 2 -> replacement = context[a][b][c];
            var subs = match.split(/\.+/);
            for (var i = 0; i < subs.length; i++) {
                if (i == 0) {
                    replacement = context;
                }

                replacement = replacement[subs[i]];
            }

            if (typeof replacement === "function") {
                replacement = args ?
                    replacement.apply(null, args) :
                    replacement();
            }

            // If replacement is undefined, return the string 'undefined'.
            // This is a workaround for a bugs in browsers not properly
            // dealing with non-participating groups in regular expressions:
            // http://blog.stevenlevithan.com/archives/npcg-javascript
            if (typeof replacement == 'undefined') {
                return 'undefined';
            } else {
                return replacement;
            }
        };

        return template.replace(StringExt.tokenRegEx, replacer);
    },

    /**
     * @member {RegExp} [StringExt.tokenRegEx]
     * @description 寻找带 token 的字符串，默认为 tokenRegEx=/\$\{([\w.]+?)\}/g。
     * @example
     * Examples: ${a}, ${a.b.c}, ${a-b}, ${5}
     */
    tokenRegEx: /\$\{([\w.]+?)\}/g,

    /**
     * @member {RegExp} [StringExt.numberRegEx]
     * @description 判断一个字符串是否只包含一个数值，默认为 numberRegEx=/^([+-]?)(?=\d|\.\d)\d*(\.\d*)?([Ee]([+-]?\d+))?$/。
     */
    numberRegEx: /^([+-]?)(?=\d|\.\d)\d*(\.\d*)?([Ee]([+-]?\d+))?$/,

    /**
     * @function StringExt.isNumeric
     * @description 判断一个字符串是否只包含一个数值。
     * @example
     * (code)
     * StringExt.isNumeric("6.02e23") // true
     * StringExt.isNumeric("12 dozen") // false
     * StringExt.isNumeric("4") // true
     * StringExt.isNumeric(" 4 ") // false
     * (end)
     * @returns {boolean} 字符串包含唯一的数值，返回 true；否则返回 false。
     */
    isNumeric: function (value) {
        return StringExt.numberRegEx.test(value);
    },

    /**
     * @function StringExt.numericIf
     * @description 把一个看似数值型的字符串转化为一个数值。
     * @returns {(number|string)} 如果能转换为数值则返回数值，否则返回字符串本身。
     */
    numericIf: function (value) {
        return StringExt.isNumeric(value) ? parseFloat(value) : value;
    }

};

/**
 * @name Number
 * @namespace
 * @category BaseTypes Util
 * @description 数值操作的一系列常用扩展函数。
 * @private
 */
var NumberExt = {

    /**
     * @member {string} [NumberExt.decimalSeparator='.']
     * @description 格式化数字时默认的小数点分隔符。
     * @constant
     */
    decimalSeparator: ".",

    /**
     * @member {string} [NumberExt.thousandsSeparator=',']
     * @description 格式化数字时默认的千位分隔符。
     * @constant
     */
    thousandsSeparator: ",",

    /**
     * @function NumberExt.limitSigDigs
     * @description 限制浮点数的有效数字位数。
     * @param {number} num - 浮点数。
     * @param {number} sig - 有效位数。
     * @returns {number} 将数字四舍五入到指定数量的有效位数。
     */
    limitSigDigs: function (num, sig) {
        var fig = 0;
        if (sig > 0) {
            fig = parseFloat(num.toPrecision(sig));
        }
        return fig;
    },

    /**
     * @function NumberExt.format
     * @description 数字格式化输出。
     * @param {number} num - 数字。
     * @param {number} [dec=0]  - 数字的小数部分四舍五入到指定的位数。设置为 null 值时小数部分不变。
     * @param {string} [tsep=','] - 千位分隔符。
     * @param {string} [dsep='.'] - 小数点分隔符。
     * @returns {string} 数字格式化后的字符串。
     */
    format: function (num, dec, tsep, dsep) {
        dec = (typeof dec != "undefined") ? dec : 0;
        tsep = (typeof tsep != "undefined") ? tsep :
        NumberExt.thousandsSeparator;
        dsep = (typeof dsep != "undefined") ? dsep :
        NumberExt.decimalSeparator;

        if (dec != null) {
            num = parseFloat(num.toFixed(dec));
        }

        var parts = num.toString().split(".");
        if (parts.length === 1 && dec == null) {
            // integer where we do not want to touch the decimals
            dec = 0;
        }

        var integer = parts[0];
        if (tsep) {
            var thousands = /(-?[0-9]+)([0-9]{3})/;
            while (thousands.test(integer)) {
                integer = integer.replace(thousands, "$1" + tsep + "$2");
            }
        }

        var str;
        if (dec == 0) {
            str = integer;
        } else {
            var rem = parts.length > 1 ? parts[1] : "0";
            if (dec != null) {
                rem = rem + new Array(dec - rem.length + 1).join("0");
            }
            str = integer + dsep + rem;
        }
        return str;
    }
};

if (!Number.prototype.limitSigDigs) {
    /**
     * APIMethod: Number.limitSigDigs
     * 限制浮点数的有效数字位数.
     * @param {number} sig -有效位数。
     * @returns {number} 将数字四舍五入到指定数量的有效位数。
     *           如果传入值 为 null、0、或者是负数, 返回值 0。
     */
    Number.prototype.limitSigDigs = function (sig) {
        return NumberExt.limitSigDigs(this, sig);
    };
}

/**
 * @name Function
 * @namespace
 * @category BaseTypes Util
 * @description 函数操作的一系列常用扩展函数。
 * @private
 */
var FunctionExt = {
    /**
     * @function FunctionExt.bind
     * @description 绑定函数到对象。方便创建 this 的作用域。
     * @param {function} func - 输入函数。
     * @param {Object} object - 对象绑定到输入函数（作为输入函数的 this 对象）。
     * @returns {function} object 参数作为 func 函数的 this 对象。
     */
    bind: function (func, object) {
        // create a reference to all arguments past the second one
        var args = Array.prototype.slice.apply(arguments, [2]);
        return function () {
            // Push on any additional arguments from the actual function call.
            // These will come after those sent to the bind call.
            var newArgs = args.concat(
                Array.prototype.slice.apply(arguments, [0])
            );
            return func.apply(object, newArgs);
        };
    },

    /**
     * @function FunctionExt.bindAsEventListener
     * @description 绑定函数到对象，在调用该函数时配置并使用事件对象作为第一个参数。
     * @param {function} func - 用于监听事件的函数。
     * @param {Object} object - this 对象的引用。
     * @returns {function}
     */
    bindAsEventListener: function (func, object) {
        return function (event) {
            return func.call(object, event || window.event);
        };
    },

    /**
     * @function FunctionExt.False
     * @description 该函数仅仅返回 false。该函数主要是避免在 IE8 以下浏览中 DOM 事件句柄的匿名函数问题。
     * @example
     * document.onclick = FunctionExt.False;
     * @returns {boolean}
     */
    False: function () {
        return false;
    },

    /**
     * @function FunctionExt.True
     * @description 该函数仅仅返回 true。该函数主要是避免在 IE8 以下浏览中 DOM 事件句柄的匿名函数问题。
     * @example
     * document.onclick = FunctionExt.True;
     * @returns {boolean}
     */
    True: function () {
        return true;
    },

    /**
     * @function FunctionExt.Void
     * @description 可重用函数，仅仅返回 "undefined"。
     * @returns {undefined}
     */
    Void: function () {
    }

};

/**
 * @name Array
 * @namespace
 * @category BaseTypes Util
 * @description 数组操作的一系列常用扩展函数。
 * @private
 */
var ArrayExt = {

    /**
     * @function ArrayExt.filter
     * @description 过滤数组，提供了 ECMA-262 标准中 Array.prototype.filter 函数的扩展。详见：{@link http://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Global_Objects/Array/filter}
     * @param {Array} array - 要过滤的数组。
     * @param {function} callback - 数组中的每一个元素调用该函数。</br>
     *     如果函数的返回值为 true，该元素将包含在返回的数组中。该函数有三个参数: 数组中的元素，元素的索引，数组自身。</br>
     *     如果设置了可选参数 caller，在调用 callback 时，使用可选参数 caller 设置为 callback 的参数。</br>
     * @param {Object} [caller] - 在调用 callback 时，使用参数 caller 设置为 callback 的参数。
     * @returns {Array} callback 函数返回 true 时的元素将作为返回数组中的元素。
     */
    filter: function (array, callback, caller) {
        var selected = [];
        if (Array.prototype.filter) {
            selected = array.filter(callback, caller);
        } else {
            var len = array.length;
            if (typeof callback != "function") {
                throw new TypeError();
            }
            for (var i = 0; i < len; i++) {
                if (i in array) {
                    var val = array[i];
                    if (callback.call(caller, val, i, array)) {
                        selected.push(val);
                    }
                }
            }
        }
        return selected;
    }

};

;// CONCATENATED MODULE: ./src/common/commontypes/Geometry.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/
// import {WKT} from '../format/WKT';
// import {Vector} from './Vector';


/**
 * @class Geometry
 * @deprecatedclass SuperMap.Geometry
 * @category BaseTypes Geometry
 * @classdesc 几何对象类，描述地理对象的几何图形。
 * @usage
 */
class Geometry_Geometry {


    constructor() {
        this.CLASS_NAME = "SuperMap.Geometry";
        /**
         * @member {string} Geometry.prototype.id
         * @description  几何对象的唯一标识符。
         *
         */
        this.id = Util_Util.createUniqueID(this.CLASS_NAME + "_");

        /**
         * @member {Geometry} Geometry.prototype.parent
         * @description 父类几何对象。
         */
        this.parent = null;

        /**
         * @member {Bounds} Geometry.prototype.bounds
         * @description 几何对象的范围。
         *
         */
        this.bounds = null;

        /**
         * @member {number} Geometry.prototype.SRID
         * @description 投影坐标参数。通过该参数，服务器判断 Geometry 对象的坐标参考系是否与数据集相同，如果不同，则在数据入库前进行投影变换。
         * @example
         * var geometry= new Geometry();
         * geometry. SRID=4326;
         *
         */
        this.SRID = null;
    }


    /**
     * @function Geometry.prototype.destroy
     * @description 解构 Geometry 类，释放资源。
     */
    destroy() {
        this.id = null;
        this.bounds = null;
        this.SRID = null;
    }


    /**
     * @function Geometry.prototype.clone
     * @description 克隆几何图形。克隆的几何图形不设置非标准的属性。
     * @returns {Geometry} 克隆的几何图形。
     */
    clone() {
        return new Geometry_Geometry();
    }


    /**
     * @function Geometry.prototype.setBounds
     * @description 设置几何对象的 bounds。
     * @param {Bounds} bounds - 范围。
     */
    setBounds(bounds) {
        if (bounds) {
            this.bounds = bounds.clone();
        }
    }


    /**
     * @function Geometry.prototype.clearBounds
     * @description 清除几何对象的 bounds。
     * 如果该对象有父类，也会清除父类几何对象的 bounds。
     */
    clearBounds() {
        this.bounds = null;
        if (this.parent) {
            this.parent.clearBounds();
        }
    }


    /**
     * @function Geometry.prototype.extendBounds
     * @description 扩展现有边界以包含新边界。如果尚未设置几何边界，则设置新边界。
     * @param {Bounds} newBounds - 几何对象的 bounds。
     */
    extendBounds(newBounds) {
        var bounds = this.getBounds();
        if (!bounds) {
            this.setBounds(newBounds);
        } else {
            this.bounds.extend(newBounds);
        }
    }


    /**
     * @function Geometry.prototype.getBounds
     * @description 获得几何图形的边界。如果没有设置边界，可通过计算获得。
     * @returns {Bounds} 几何对象的边界。
     */
    getBounds() {
        if (this.bounds == null) {
            this.calculateBounds();
        }
        return this.bounds;
    }


    /**
     * @function Geometry.prototype.calculateBounds
     * @description 重新计算几何图形的边界（需要在子类中实现此方法）。
     */
    calculateBounds() {
        //
        // This should be overridden by subclasses.
        //
    }

    /**
     * @function Geometry.prototype.getVertices
     * @description 返回几何图形的所有顶点的列表（需要在子类中实现此方法）。
     * @param {boolean} [nodes] - 如果是 true，线则只返回线的末端点，如果 false，仅仅返回顶点，如果没有设置，则返回顶点。
     * @returns {Array} 几何图形的顶点列表。
     */
    getVertices(nodes) { // eslint-disable-line no-unused-vars
    }

    /**
     * @function Geometry.prototype.getArea
     * @description 计算几何对象的面积 ，此方法需要在子类中定义。
     * @returns {number} 计算后的对象面积。
     */
    getArea() {
        //to be overridden by geometries that actually have an area
        //
        return 0.0;
    }


    // /**
    //  * @function Geometry.prototype.toString
    //  * @description 返回geometry对象的字符串表述，需要引入{@link WKTFormat}。此方法只能在子类实现，在父类使用会报错。
    //  * @returns {string} geometry对象的字符串表述(Well-Known Text)
    //  */
    // toString() {
    // var string;
    // if (WKT) {
    //     var wkt = new WKT();
    //     string = wkt.write(new Vector(this));
    // } else {
    //     string = Object.prototype.toString.call(this);
    // }
    // return string;
    // }
}

;// CONCATENATED MODULE: ./src/common/commontypes/Util.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/



/**
 * @description 浏览器名称，依赖于 userAgent 属性，BROWSER_NAME 可以是空，或者以下浏览器：
 *     * "opera" -- Opera
 *     * "msie"  -- Internet Explorer
 *     * "safari" -- Safari
 *     * "firefox" -- Firefox
 *     * "mozilla" -- Mozilla
 * @category BaseTypes Constant
 * @constant {Object}
 * @usage
 * ```
 * // 浏览器
 * <script type="text/javascript" src="{cdn}"></script>
 * <script>
 *   const result = {namespace}.Browser.name;
 *
 * </script>
 * // ES6 Import
 * import { Browser } from '{npm}';
 *
 * const result = Browser.name;
 * ```
 */
const Browser = (function () {
  var name = '',
    version = '',
    device = 'pc',
    uaMatch;
  //以下进行测试
  var ua = navigator.userAgent.toLowerCase();
  if (ua.indexOf('msie') > -1 || (ua.indexOf('trident') > -1 && ua.indexOf('rv') > -1)) {
    name = 'msie';
    uaMatch = ua.match(/msie ([\d.]+)/) || ua.match(/rv:([\d.]+)/);
  } else if (ua.indexOf('chrome') > -1) {
    name = 'chrome';
    uaMatch = ua.match(/chrome\/([\d.]+)/);
  } else if (ua.indexOf('firefox') > -1) {
    name = 'firefox';
    uaMatch = ua.match(/firefox\/([\d.]+)/);
  } else if (ua.indexOf('opera') > -1) {
    name = 'opera';
    uaMatch = ua.match(/version\/([\d.]+)/);
  } else if (ua.indexOf('safari') > -1) {
    name = 'safari';
    uaMatch = ua.match(/version\/([\d.]+)/);
  }
  version = uaMatch ? uaMatch[1] : '';

  if (ua.indexOf('ipad') > -1 || ua.indexOf('ipod') > -1 || ua.indexOf('iphone') > -1) {
    device = 'apple';
  } else if (ua.indexOf('android') > -1) {
    uaMatch = ua.match(/version\/([\d.]+)/);
    version = uaMatch ? uaMatch[1] : '';
    device = 'android';
  }
  return { name: name, version: version, device: device };
})();

const isSupportCanvas = (function () {
  var checkRes = true,
    broz = Browser;
  if (document.createElement('canvas').getContext) {
    if (broz.name === 'firefox' && parseFloat(broz.version) < 5) {
      checkRes = false;
    }
    if (broz.name === 'safari' && parseFloat(broz.version) < 4) {
      checkRes = false;
    }
    if (broz.name === 'opera' && parseFloat(broz.version) < 10) {
      checkRes = false;
    }
    if (broz.name === 'msie' && parseFloat(broz.version) < 9) {
      checkRes = false;
    }
  } else {
    checkRes = false;
  }
  return checkRes;
})();

/**
 * @description 如果 userAgent 捕获到浏览器使用的是 Gecko 引擎则返回 true。
 * @constant {number}
 * @private
 */
const IS_GECKO = (function () {
  var ua = navigator.userAgent.toLowerCase();
  return ua.indexOf('webkit') === -1 && ua.indexOf('gecko') !== -1;
})();

/**
 * @constant {number}
 * @default
 * @description 分辨率与比例尺之间转换的常量。
 * @private
 */
const DOTS_PER_INCH = 96;

/**
 * @name CommonUtil
 * @namespace
 * @category BaseTypes Util
 * @description common 工具类。
 * @usage
 * ```
 * // 浏览器
 * <script type="text/javascript" src="{cdn}"></script>
 * <script>
 *   const result = {namespace}.CommonUtil.getElement();
 *
 *   // 弃用的写法
 *   const result = SuperMap.Util.getElement();
 *
 * </script>
 *
 * // ES6 Import
 * import { CommonUtil } from '{npm}';
 *
 * const result = CommonUtil.getElement();
 * ```
 */

const Util_Util = {

  /**
     * @memberOf CommonUtil
     * @description 对象拷贝赋值。
     * @param {Object} dest - 目标对象。
     * @param {Object} arguments - 待拷贝的对象。
     * @returns {Object} 赋值后的目标对象。
     */
  assign(dest) {
    for (var index = 0; index < Object.getOwnPropertyNames(arguments).length; index++) {
        var arg = Object.getOwnPropertyNames(arguments)[index];
        if (arg == "caller" || arg == "callee" || arg == "length" || arg == "arguments") {
            continue;
        }
        var obj = arguments[arg];
        if (obj) {
            for (var j = 0; j < Object.getOwnPropertyNames(obj).length; j++) {
                var key = Object.getOwnPropertyNames(obj)[j];
                if (arg == "caller" || arg == "callee" || arg == "length" || arg == "arguments") {
                    continue;
                }
                dest[key] = obj[key];
            }
        }
    }
    return dest;
  },
  /**
   * @memberOf CommonUtil
   * @description 复制源对象的所有属性到目标对象上，源对象上的没有定义的属性在目标对象上也不会被设置。
   * @example
   * 要复制 Size 对象的所有属性到自定义对象上，使用方法如下:
   *     var size = new Size(100, 100);
   *     var obj = {}；
   *     CommonUtil.extend(obj, size);
   * @param {Object} [destination] - 目标对象。
   * @param {Object} source - 源对象，其属性将被设置到目标对象上。
   * @returns {Object} 目标对象。
   */

  extend: function (destination, source) {
    destination = destination || {};
    if (source) {
      for (var property in source) {
        var value = source[property];
        if (value !== undefined) {
          destination[property] = value;
        }
      }

      /**
       * IE doesn't include the toString property when iterating over an object's
       * properties with the for(property in object) syntax.  Explicitly check if
       * the source has its own toString property.
       */

      /*
       * FF/Windows < 2.0.0.13 reports "Illegal operation on WrappedNative
       * prototype object" when calling hawOwnProperty if the source object
       * is an instance of window.Event.
       */

      var sourceIsEvt = typeof window.Event === 'function' && source instanceof window.Event;

      if (!sourceIsEvt && source.hasOwnProperty && source.hasOwnProperty('toString')) {
        destination.toString = source.toString;
      }
    }
    return destination;
  },
  /**
   * @memberOf CommonUtil
   * @description 对象拷贝。
   * @param {Object} [des] - 目标对象。
   * @param {Object} soc - 源对象。
   */
  copy: function (des, soc) {
    des = des || {};
    var v;
    if (soc) {
      for (var p in des) {
        v = soc[p];
        if (typeof v !== 'undefined') {
          des[p] = v;
        }
      }
    }
  },
  /**
   * @memberOf CommonUtil
   * @description 销毁对象，将其属性置空。
   * @param {Object} [obj] - 目标对象。
   */
  reset: function (obj) {
    obj = obj || {};
    for (var p in obj) {
      if (obj.hasOwnProperty(p)) {
        if (typeof obj[p] === 'object' && obj[p] instanceof Array) {
          for (var i in obj[p]) {
            if (obj[p][i].destroy) {
              obj[p][i].destroy();
            }
          }
          obj[p].length = 0;
        } else if (typeof obj[p] === 'object' && obj[p] instanceof Object) {
          if (obj[p].destroy) {
            obj[p].destroy();
          }
        }
        obj[p] = null;
      }
    }
  },

  /**
   * @memberOf CommonUtil
   * @description 获取 HTML 元素数组。
   * @returns {Array.<HTMLElement>} HTML 元素数组。
   */
  getElement: function () {
    var elements = [];

    for (var i = 0, len = arguments.length; i < len; i++) {
      var element = arguments[i];
      if (typeof element === 'string') {
        element = document.getElementById(element);
      }
      if (arguments.length === 1) {
        return element;
      }
      elements.push(element);
    }
    return elements;
  },

  /**
   * @memberOf CommonUtil
   * @description instance of 的跨浏览器实现。
   * @param {Object} o - 对象。
   * @returns {boolean} 是否是页面元素。
   */
  isElement: function (o) {
    return !!(o && o.nodeType === 1);
  },

  /**
   * @memberOf CommonUtil
   * @description 判断一个对象是否是数组。
   * @param {Object} a - 对象。
   * @returns {boolean} 是否是数组。
   */
  isArray: function (a) {
    return Object.prototype.toString.call(a) === '[object Array]';
  },

  /**
   * @memberOf CommonUtil
   * @description 从数组中删除某一项。
   * @param {Array} array - 数组。
   * @param {Object} item - 数组中要删除的一项。
   * @returns {Array} 执行删除操作后的数组。
   */
  removeItem: function (array, item) {
    for (var i = array.length - 1; i >= 0; i--) {
      if (array[i] === item) {
        array.splice(i, 1);
        //break;more than once??
      }
    }
    return array;
  },

  /**
   * @memberOf CommonUtil
   * @description 获取某对象在数组中的索引值。
   * @param {Array.<Object>} array - 数组。
   * @param {Object} obj - 对象。
   * @returns {number} 某对象在数组中的索引值。
   */
  indexOf: function (array, obj) {
    if (array == null) {
      return -1;
    } else {
      // use the build-in function if available.
      if (typeof array.indexOf === 'function') {
        return array.indexOf(obj);
      } else {
        for (var i = 0, len = array.length; i < len; i++) {
          if (array[i] === obj) {
            return i;
          }
        }
        return -1;
      }
    }
  },

  /**
   * @memberOf CommonUtil
   * @description 修改某 DOM 元素的许多属性。
   * @param {HTMLElement} element - 待修改的 DOM 元素。
   * @param {string} [id] - DOM 元素的 ID。
   * @param {Pixel} [px] - DOM 元素的 style 属性的 left 和 top 属性。
   * @param {Size} [sz] - DOM 元素的 width 和 height 属性。
   * @param {string} [position] - DOM 元素的 position 属性。
   * @param {string} [border] - DOM 元素的 style 属性的 border 属性。
   * @param {string} [overflow] - DOM 元素的 style 属性的 overflow 属性。
   * @param {number} [opacity] - 不透明度值。取值范围为(0.0 - 1.0)。
   */
  modifyDOMElement: function (element, id, px, sz, position, border, overflow, opacity) {
    if (id) {
      element.id = id;
    }
    if (px) {
      element.style.left = px.x + 'px';
      element.style.top = px.y + 'px';
    }
    if (sz) {
      element.style.width = sz.w + 'px';
      element.style.height = sz.h + 'px';
    }
    if (position) {
      element.style.position = position;
    }
    if (border) {
      element.style.border = border;
    }
    if (overflow) {
      element.style.overflow = overflow;
    }
    if (parseFloat(opacity) >= 0.0 && parseFloat(opacity) < 1.0) {
      element.style.filter = 'alpha(opacity=' + opacity * 100 + ')';
      element.style.opacity = opacity;
    } else if (parseFloat(opacity) === 1.0) {
      element.style.filter = '';
      element.style.opacity = '';
    }
  },

  /**
   * @memberOf CommonUtil
   * @description 比较两个对象并合并。
   * @param {Object} [to] - 目标对象。
   * @param {Object} from - 源对象。
   * @returns {Object} 返回合并后的对象。
   */
  applyDefaults: function (to, from) {
    to = to || {};
    /*
     * FF/Windows < 2.0.0.13 reports "Illegal operation on WrappedNative
     * prototype object" when calling hawOwnProperty if the source object is an
     * instance of window.Event.
     */
    var fromIsEvt = typeof window.Event === 'function' && from instanceof window.Event;

    for (var key in from) {
      if (
        to[key] === undefined ||
        (!fromIsEvt && from.hasOwnProperty && from.hasOwnProperty(key) && !to.hasOwnProperty(key))
      ) {
        to[key] = from[key];
      }
    }
    /**
     * IE doesn't include the toString property when iterating over an object's
     * properties with the for(property in object) syntax.  Explicitly check if
     * the source has its own toString property.
     */
    if (
      !fromIsEvt &&
      from &&
      from.hasOwnProperty &&
      from.hasOwnProperty('toString') &&
      !to.hasOwnProperty('toString')
    ) {
      to.toString = from.toString;
    }

    return to;
  },

  /**
   * @memberOf CommonUtil
   * @description 将参数对象转换为 HTTP 的 GET 请求中的参数字符串。例如："key1=value1&key2=value2&key3=value3"。
   * @param {Object} params - 参数对象。
   * @returns {string} HTTP 的 GET 请求中的参数字符串。
   */
  getParameterString: function (params) {
    var paramsArray = [];

    for (var key in params) {
      var value = params[key];
      if (value != null && typeof value !== 'function') {
        var encodedValue;
        if (Array.isArray(value) || value.toString() === '[object Object]') {
          encodedValue = encodeURIComponent(JSON.stringify(value));
        } else {
          /* value is a string; simply encode */
          encodedValue = encodeURIComponent(value);
        }
        paramsArray.push(encodeURIComponent(key) + '=' + encodedValue);
      }
    }

    return paramsArray.join('&');
  },

  /**
   * @memberOf CommonUtil
   * @description 给 URL 追加查询参数。
   * @param {string} url - 待追加参数的 URL 字符串。
   * @param {string} paramStr - 待追加的查询参数。
   * @returns {string} 新的 URL。
   */
  urlAppend: function (url, paramStr) {
    var newUrl = url;
    if (paramStr) {
      if (paramStr.indexOf('?') === 0) {
        paramStr = paramStr.substring(1);
      }
      var parts = (url + ' ').split(/[?&]/);
      newUrl += parts.pop() === ' ' ? paramStr : parts.length ? '&' + paramStr : '?' + paramStr;
    }
    return newUrl;
  },

  /**
   * @memberOf CommonUtil
   * @description 给 URL 追加 path 参数。
   * @param {string} url - 待追加参数的 URL 字符串。
   * @param {string} paramStr - 待追加的path参数。
   * @returns {string} 新的 URL。
   */
  urlPathAppend: function (url, pathStr) {
    let newUrl = url;
    if (!pathStr) {
      return newUrl;
    }
    if (pathStr.indexOf('/') === 0) {
      pathStr = pathStr.substring(1);
    }
    const parts = url.split('?');
    if (parts[0].indexOf('/', parts[0].length - 1) < 0) {
      parts[0] += '/';
    }
    newUrl = `${parts[0]}${pathStr}${parts.length > 1 ? `?${parts[1]}` : ''}`;
    return newUrl;
  },

  /**
   * @memberOf CommonUtil
   * @description 为了避免浮点精度错误而保留的有效位数。
   * @type {number}
   * @default 14
   */
  DEFAULT_PRECISION: 14,

  /**
   * @memberOf CommonUtil
   * @description 将字符串以接近的精度转换为数字。
   * @param {string} number - 字符串。
   * @param {number} [precision=14] - 精度。
   * @returns {number} 转化后的数字。
   */
  toFloat: function (number, precision) {
    if (precision == null) {
      precision = Util_Util.DEFAULT_PRECISION;
    }
    if (typeof number !== 'number') {
      number = parseFloat(number);
    }
    return precision === 0 ? number : parseFloat(number.toPrecision(precision));
  },

  /**
   * @memberOf CommonUtil
   * @description 角度转弧度。
   * @param {number} x - 角度。
   * @returns {number} 转化后的弧度。
   */
  rad: function (x) {
    return (x * Math.PI) / 180;
  },

  /**
   * @memberOf CommonUtil
   * @description 从 URL 字符串中解析出参数对象。
   * @param {string} url - URL。
   * @returns {Object} 解析出的参数对象。
   */
  getParameters: function (url) {
    // if no url specified, take it from the location bar
    url = url === null || url === undefined ? window.location.href : url;

    //parse out parameters portion of url string
    var paramsString = '';
    if (StringExt.contains(url, '?')) {
      var start = url.indexOf('?') + 1;
      var end = StringExt.contains(url, '#') ? url.indexOf('#') : url.length;
      paramsString = url.substring(start, end);
    }

    var parameters = {};
    var pairs = paramsString.split(/[&;]/);
    for (var i = 0, len = pairs.length; i < len; ++i) {
      var keyValue = pairs[i].split('=');
      if (keyValue[0]) {
        var key = keyValue[0];
        try {
          key = decodeURIComponent(key);
        } catch (err) {
          key = unescape(key);
        }

        // being liberal by replacing "+" with " "
        var value = (keyValue[1] || '').replace(/\+/g, ' ');

        try {
          value = decodeURIComponent(value);
        } catch (err) {
          value = unescape(value);
        }

        // follow OGC convention of comma delimited values
        value = value.split(',');

        //if there's only one value, do not return as array
        if (value.length == 1) {
          value = value[0];
        }

        parameters[key] = value;
      }
    }
    return parameters;
  },

  /**
   * @memberOf CommonUtil
   * @description 不断递增计数变量，用于生成唯一 ID。
   * @type {number}
   * @default 0
   */
  lastSeqID: 0,

  /**
   * @memberOf CommonUtil
   * @description 创建唯一 ID 值。
   * @param {string} [prefix] - 前缀。
   * @returns {string} 唯一的 ID 值。
   */
  createUniqueID: function (prefix) {
    if (prefix == null) {
      prefix = 'id_';
    }
    Util_Util.lastSeqID += 1;
    return prefix + Util_Util.lastSeqID;
  },

  /**
   * @memberOf CommonUtil
   * @description 判断并转化比例尺。
   * @param {number} scale - 比例尺。
   * @returns {number} 正常的 scale 值。
   */
  normalizeScale: function (scale) {
    var normScale = scale > 1.0 ? 1.0 / scale : scale;
    return normScale;
  },

  /**
   * @memberOf CommonUtil
   * @description 比例尺转分辨率。
   * @param {number} scale - 比例尺。
   * @param {string} [units='degrees'] - 比例尺单位。
   * @returns {number} 转化后的分辨率。
   */
  getResolutionFromScale: function (scale, units) {
    var resolution;
    if (scale) {
      if (units == null) {
        units = 'degrees';
      }
      var normScale = Util_Util.normalizeScale(scale);
      resolution = 1 / (normScale * INCHES_PER_UNIT[units] * DOTS_PER_INCH);
    }
    return resolution;
  },

  /**
   * @memberOf CommonUtil
   * @description 分辨率转比例尺。
   * @param {number} resolution - 分辨率。
   * @param {string} [units='degrees'] - 分辨率单位。
   * @returns {number} 转化后的比例尺。
   */
  getScaleFromResolution: function (resolution, units) {
    if (units == null) {
      units = 'degrees';
    }

    var scale = resolution * INCHES_PER_UNIT[units] * DOTS_PER_INCH;
    return scale;
  },

  /**
   * @memberOf CommonUtil
   * @description 获取浏览器相关信息。支持的浏览器包括：Opera，Internet Explorer，Safari，Firefox。
   * @returns {Object} 浏览器名称、版本、设备名称。对应的属性分别为 name, version, device。
   */
  getBrowser: function () {
    return Browser;
  },

  /**
   * @memberOf CommonUtil
   * @description 浏览器是否支持 Canvas。
   * @returns {boolean} 当前浏览器是否支持 HTML5 Canvas。
   */
  isSupportCanvas,

  /**
   * @memberOf CommonUtil
   * @description 判断浏览器是否支持 Canvas。
   * @returns {boolean} 当前浏览器是否支持 HTML5 Canvas 。
   */
  supportCanvas: function () {
    return Util_Util.isSupportCanvas;
  },

  /**
   * @memberOf CommonUtil
   * @description 判断一个 URL 请求是否在当前域中。
   * @param {string} url - URL 请求字符串。
   * @returns {boolean} URL 请求是否在当前域中。
   */
  isInTheSameDomain: function (url) {
    if (!url) {
      return true;
    }
    var index = url.indexOf('//');
    var documentUrl = document.location.toString();
    var documentIndex = documentUrl.indexOf('//');
    if (index === -1) {
      return true;
    } else {
      var protocol;
      var substring = (protocol = url.substring(0, index));
      var documentSubString = documentUrl.substring(documentIndex + 2);
      documentIndex = documentSubString.indexOf('/');
      var documentPortIndex = documentSubString.indexOf(':');
      var documentDomainWithPort = documentSubString.substring(0, documentIndex);
      //var documentPort;

      var documentprotocol = document.location.protocol;
      if (documentPortIndex !== -1) {
        // documentPort = +documentSubString.substring(documentPortIndex, documentIndex);
      } else {
        documentDomainWithPort += ':' + (documentprotocol.toLowerCase() === 'http:' ? 80 : 443);
      }
      if (documentprotocol.toLowerCase() !== substring.toLowerCase()) {
        return false;
      }
      substring = url.substring(index + 2);
      var portIndex = substring.indexOf(':');
      index = substring.indexOf('/');
      var domainWithPort = substring.substring(0, index);
      var domain;
      if (portIndex !== -1) {
        domain = substring.substring(0, portIndex);
      } else {
        domain = substring.substring(0, index);
        domainWithPort += ':' + (protocol.toLowerCase() === 'http:' ? 80 : 443);
      }
      var documentDomain = document.domain;
      if (domain === documentDomain && domainWithPort === documentDomainWithPort) {
        return true;
      }
    }
    return false;
  },

  /**
   * @memberOf CommonUtil
   * @description 计算 iServer 服务的 REST 图层的显示分辨率，需要从 iServer 的 REST 图层表述中获取 viewBounds、viewer、scale、coordUnit、datumAxis 五个参数，来进行计算。
   * @param {Bounds} viewBounds - 地图的参照可视范围，即地图初始化时默认的地图显示范围。
   * @param {Size} viewer - 地图初始化时默认的地图图片的尺寸。
   * @param {number} scale - 地图初始化时默认的显示比例尺。
   * @param {string} [coordUnit='degrees'] - 投影坐标系统的地图单位。
   * @param {number} [datumAxis=6378137] - 地理坐标系统椭球体长半轴。用户自定义地图的 Options 时，若未指定该参数的值，则系统默认为 WGS84 参考系的椭球体长半轴 6378137。
   * @returns {number} 图层显示分辨率。
   */
  calculateDpi: function (viewBounds, viewer, scale, coordUnit, datumAxis) {
    //10000 是 0.1毫米与米的转换。DPI的计算公式：Viewer / DPI *  0.0254 * 10000 = ViewBounds * scale ，公式中的10000是为了提高计算结果的精度，以下出现的ratio皆为如此。
    if (!viewBounds || !viewer || !scale) {
      return;
    }
    var ratio = 10000,
      rvbWidth = viewBounds.getWidth(),
      rvbHeight = viewBounds.getHeight(),
      rvWidth = viewer.w,
      rvHeight = viewer.h;
    //用户自定义地图的Options时，若未指定该参数的值，则系统默认为6378137米，即WGS84参考系的椭球体长半轴。
    datumAxis = datumAxis || 6378137;
    coordUnit = coordUnit || 'degrees';
    var dpi;
    if (
      coordUnit.toLowerCase() === 'degree' ||
      coordUnit.toLowerCase() === 'degrees' ||
      coordUnit.toLowerCase() === 'dd'
    ) {
      let num1 = rvbWidth / rvWidth,
        num2 = rvbHeight / rvHeight,
        resolution = num1 > num2 ? num1 : num2;
      dpi = (0.0254 * ratio) / resolution / scale / ((Math.PI * 2 * datumAxis) / 360) / ratio;
    } else {
      let resolution = rvbWidth / rvWidth;
      dpi = (0.0254 * ratio) / resolution / scale / ratio;
    }
    return dpi;
  },

  /**
   * @memberOf CommonUtil
   * @description 将对象转换成 JSON 字符串。
   * @param {Object} obj - 要转换成 JSON 的 Object 对象。
   * @returns {string} 转换后的 JSON 对象。
   */
  toJSON: function (obj) {
    var objInn = obj;
    if (objInn == null) {
      return null;
    }
    switch (objInn.constructor) {
      case String:
        //s = "'" + str.replace(/(["\\])/g, "\\$1") + "'";   string含有单引号出错
        objInn = '"' + objInn.replace(/(["\\])/g, '\\$1') + '"';
        objInn = objInn.replace(/\n/g, '\\n');
        objInn = objInn.replace(/\r/g, '\\r');
        objInn = objInn.replace('<', '&lt;');
        objInn = objInn.replace('>', '&gt;');
        objInn = objInn.replace(/%/g, '%25');
        objInn = objInn.replace(/&/g, '%26');
        return objInn;
      case Array:
        var arr = '';
        for (var i = 0, len = objInn.length; i < len; i++) {
          arr += Util_Util.toJSON(objInn[i]);
          if (i !== objInn.length - 1) {
            arr += ',';
          }
        }
        return "[" + arr + "]";
      case Number:
        return isFinite(objInn) ? String(objInn) : null;
      case Boolean:
        return String(objInn);
      case Date:
        var dateStr =
          '{' +
          '\'__type\':"System.DateTime",' +
          "'Year':" +
          objInn.getFullYear() +
          ',' +
          "'Month':" +
          (objInn.getMonth() + 1) +
          ',' +
          "'Day':" +
          objInn.getDate() +
          ',' +
          "'Hour':" +
          objInn.getHours() +
          ',' +
          "'Minute':" +
          objInn.getMinutes() +
          ',' +
          "'Second':" +
          objInn.getSeconds() +
          ',' +
          "'Millisecond':" +
          objInn.getMilliseconds() +
          ',' +
          "'TimezoneOffset':" +
          objInn.getTimezoneOffset() +
          '}';
        return dateStr;
      default:
        if (objInn['toJSON'] != null && typeof objInn['toJSON'] === 'function') {
          return objInn.toJSON();
        }
        if (typeof objInn === 'object') {
          if (objInn.length) {
            let arr = [];
            for (let i = 0, len = objInn.length; i < len; i++) {
              arr.push(Util_Util.toJSON(objInn[i]));
            }
            return '[' + arr.join(',') + ']';
          }
          let arr = [];
          for (let attr in objInn) {
            //为解决Geometry类型头json时堆栈溢出的问题，attr == "parent"时不进行json转换
            if (typeof objInn[attr] !== 'function' && attr !== 'CLASS_NAME' && attr !== 'parent') {
              arr.push("'" + attr + "':" + Util_Util.toJSON(objInn[attr]));
            }
          }

          if (arr.length > 0) {
            return '{' + arr.join(',') + '}';
          } else {
            return '{}';
          }
        }
        return objInn.toString();
    }
  },

  /**
   * @memberOf CommonUtil
   * @description 根据比例尺和 DPI 计算屏幕分辨率。
   * @category BaseTypes Util
   * @param {number} scale - 比例尺。
   * @param {number} dpi - 图像分辨率，表示每英寸内的像素个数。
   * @param {string} [coordUnit] - 投影坐标系统的地图单位。
   * @param {number} [datumAxis=6378137] - 地理坐标系统椭球体长半轴。用户自定义地图的 Options 时，若未指定该参数的值，则 DPI 默认按照 WGS84 参考系的椭球体长半轴 6378137 来计算。
   * @returns {number} 当前比例尺下的屏幕分辨率。
   */
  getResolutionFromScaleDpi: function (scale, dpi, coordUnit, datumAxis) {
    var resolution = null,
      ratio = 10000;
    //用户自定义地图的Options时，若未指定该参数的值，则系统默认为6378137米，即WGS84参考系的椭球体长半轴。
    datumAxis = datumAxis || 6378137;
    coordUnit = coordUnit || '';
    if (scale > 0 && dpi > 0) {
      scale = Util_Util.normalizeScale(scale);
      if (
        coordUnit.toLowerCase() === 'degree' ||
        coordUnit.toLowerCase() === 'degrees' ||
        coordUnit.toLowerCase() === 'dd'
      ) {
        //scale = Util.normalizeScale(scale);
        resolution = (0.0254 * ratio) / dpi / scale / ((Math.PI * 2 * datumAxis) / 360) / ratio;
        return resolution;
      } else {
        resolution = (0.0254 * ratio) / dpi / scale / ratio;
        return resolution;
      }
    }
    return -1;
  },

  /**
   * @memberOf CommonUtil
   * @description 根据 resolution、dpi、coordUnit 和 datumAxis 计算比例尺。
   * @param {number} resolution - 用于计算比例尺的地图分辨率。
   * @param {number} dpi - 图像分辨率，表示每英寸内的像素个数。
   * @param {string} [coordUnit] - 投影坐标系统的地图单位。
   * @param {number} [datumAxis=6378137] - 地理坐标系统椭球体长半轴。用户自定义地图的 Options 时，若未指定该参数的值，则 DPI 默认按照 WGS84 参考系的椭球体长半轴 6378137 来计算。
   * @returns {number} 当前屏幕分辨率下的比例尺。
   */
  getScaleFromResolutionDpi: function (resolution, dpi, coordUnit, datumAxis) {
    var scale = null,
      ratio = 10000;
    //用户自定义地图的Options时，若未指定该参数的值，则系统默认为6378137米，即WGS84参考系的椭球体长半轴。
    datumAxis = datumAxis || 6378137;
    coordUnit = coordUnit || '';
    if (resolution > 0 && dpi > 0) {
      if (
        coordUnit.toLowerCase() === 'degree' ||
        coordUnit.toLowerCase() === 'degrees' ||
        coordUnit.toLowerCase() === 'dd'
      ) {
        scale = (0.0254 * ratio) / dpi / resolution / ((Math.PI * 2 * datumAxis) / 360) / ratio;
        return scale;
      } else {
        scale = (0.0254 * ratio) / dpi / resolution / ratio;
        return scale;
      }
    }
    return -1;
  },

  /**
   * @memberOf CommonUtil
   * @description 转换查询结果。
   * @param {Object} result - 查询结果。
   * @returns {Object} 转换后的查询结果。
   */
  transformResult: function (result) {
    if (result.responseText && typeof result.responseText === 'string') {
      result = JSON.parse(result.responseText);
    }
    return result;
  },

  /**
   * @memberOf CommonUtil
   * @description 属性拷贝，不拷贝方法类名(CLASS_NAME)等。
   * @param {Object} [destination] - 拷贝目标。
   * @param {Object} source - 源对象。
   *
   */
  copyAttributes: function (destination, source) {
    destination = destination || {};
    if (source) {
      for (var property in source) {
        var value = source[property];
        if (value !== undefined && property !== 'CLASS_NAME' && typeof value !== 'function') {
          destination[property] = value;
        }
      }
    }
    return destination;
  },

  /**
   * @memberOf CommonUtil
   * @description 将源对象上的属性拷贝到目标对象上。（不拷贝 CLASS_NAME 和方法）
   * @param {Object} [destination] - 目标对象。
   * @param {Object} source - 源对象。
   * @param {Array.<string>} clip - 源对象中禁止拷贝到目标对象的属性，目的是防止目标对象上不可修改的属性被篡改。
   *
   */
  copyAttributesWithClip: function (destination, source, clip) {
    destination = destination || {};
    if (source) {
      for (var property in source) {
        //去掉禁止拷贝的属性
        var isInClip = false;
        if (clip && clip.length) {
          for (var i = 0, len = clip.length; i < len; i++) {
            if (property === clip[i]) {
              isInClip = true;
              break;
            }
          }
        }
        if (isInClip === true) {
          continue;
        }

        var value = source[property];
        if (value !== undefined && property !== 'CLASS_NAME' && typeof value !== 'function') {
          destination[property] = value;
        }
      }
    }
    return destination;
  },

  /**
   * @memberOf CommonUtil
   * @description 克隆一个 Object 对象。
   * @param {Object} obj - 需要克隆的对象。
   * @returns {Object} 对象的拷贝对象，注意是新的对象，不是指向。
   */
  cloneObject: function (obj) {
    // Handle the 3 simple types, and null or undefined
    if (null === obj || 'object' !== typeof obj) {
      return obj;
    }

    // Handle Date
    if (obj instanceof Date) {
      let copy = new Date();
      copy.setTime(obj.getTime());
      return copy;
    }

    // Handle Array
    if (obj instanceof Array) {
      let copy = obj.slice(0);
      return copy;
    }

    // Handle Object
    if (obj instanceof Object) {
      let copy = {};
      for (var attr in obj) {
        if (obj.hasOwnProperty(attr)) {
          copy[attr] = Util_Util.cloneObject(obj[attr]);
        }
      }
      return copy;
    }

    throw new Error("Unable to copy obj! Its type isn't supported.");
  },

  /**
   * @memberOf CommonUtil
   * @description 判断两条线段是不是有交点。
   * @param {GeometryPoint} a1 - 第一条线段的起始节点。
   * @param {GeometryPoint} a2 - 第一条线段的结束节点。
   * @param {GeometryPoint} b1 - 第二条线段的起始节点。
   * @param {GeometryPoint} b2 - 第二条线段的结束节点。
   * @returns {Object} 如果相交返回交点，如果不相交返回两条线段的位置关系。
   */
  lineIntersection: function (a1, a2, b1, b2) {
    var intersectValue = null;
    var k1;
    var k2;
    var b = (b2.x - b1.x) * (a1.y - b1.y) - (b2.y - b1.y) * (a1.x - b1.x);
    var a = (a2.x - a1.x) * (a1.y - b1.y) - (a2.y - a1.y) * (a1.x - b1.x);
    var ab = (b2.y - b1.y) * (a2.x - a1.x) - (b2.x - b1.x) * (a2.y - a1.y);
    //ab==0代表两条线断的斜率一样
    if (ab != 0) {
      k1 = b / ab;
      k2 = a / ab;

      if (k1 >= 0 && k2 <= 1 && k1 <= 1 && k2 >= 0) {
        intersectValue = new Geometry_Geometry.Point(a1.x + k1 * (a2.x - a1.x), a1.y + k1 * (a2.y - a1.y));
      } else {
        intersectValue = 'No Intersection';
      }
    } else {
      if (b == 0 && a == 0) {
        var maxy = Math.max(a1.y, a2.y);
        var miny = Math.min(a1.y, a2.y);
        var maxx = Math.max(a1.x, a2.x);
        var minx = Math.min(a1.x, a2.x);
        if (
          (((b1.y >= miny && b1.y <= maxy) || (b2.y >= miny && b2.y <= maxy)) && b1.x >= minx && b1.x <= maxx) ||
          (b2.x >= minx && b2.x <= maxx)
        ) {
          intersectValue = 'Coincident'; //重合
        } else {
          intersectValue = 'Parallel'; //平行
        }
      } else {
        intersectValue = 'Parallel'; //平行
      }
    }
    return intersectValue;
  },

  /**
   * @memberOf CommonUtil
   * @description 获取文本外接矩形宽度与高度。
   * @param {ThemeStyle} style - 文本样式。
   * @param {string} text - 文本内容。
   * @param {Object} element - DOM 元素。
   * @returns {Object} 裁剪后的宽度，高度信息。
   */
  getTextBounds: function (style, text, element) {
    document.body.appendChild(element);
    element.style.width = 'auto';
    element.style.height = 'auto';
    if (style.fontSize) {
      element.style.fontSize = style.fontSize;
    }
    if (style.fontFamily) {
      element.style.fontFamily = style.fontFamily;
    }
    if (style.fontWeight) {
      element.style.fontWeight = style.fontWeight;
    }
    element.style.position = 'relative';
    element.style.visibility = 'hidden';
    //fix 在某些情况下，element内的文本变成竖起排列，导致宽度计算不正确的bug
    element.style.display = 'inline-block';
    element.innerHTML = text;
    var textWidth = element.clientWidth;
    var textHeight = element.clientHeight;
    document.body.removeChild(element);
    return {
      textWidth: textWidth,
      textHeight: textHeight
    };
  },
  /**
   * @memberOf CommonUtil
   * @description 获取转换后的path路径。
   * @param {string} path - 待转换的path，包含`{param}`。
   * @param {Object} pathParams - path中待替换的参数。
   * @returns {string} 转换后的path路径。
   */
  convertPath: function (path, pathParams) {
    if (!pathParams) {
      return path;
    }
    return path.replace(/\{([\w-\.]+)\}/g, (fullMatch, key) => {
      var value;
      if (pathParams.hasOwnProperty(key)) {
        value = paramToString(pathParams[key]);
      } else {
        value = fullMatch;
      }
      return encodeURIComponent(value);
    });
  }
};

/**
 * @enum INCHES_PER_UNIT
 * @description 每单位的英尺数。
 * @type {number}
 * @private
 */
const INCHES_PER_UNIT = {
  inches: 1.0,
  ft: 12.0,
  mi: 63360.0,
  m: 39.3701,
  km: 39370.1,
  dd: 4374754,
  yd: 36
};
INCHES_PER_UNIT['in'] = INCHES_PER_UNIT.inches;
INCHES_PER_UNIT['degrees'] = INCHES_PER_UNIT.dd;
INCHES_PER_UNIT['nmi'] = 1852 * INCHES_PER_UNIT.m;

// Units from CS-Map
const METERS_PER_INCH = 0.0254000508001016002;
Util_Util.extend(INCHES_PER_UNIT, {
  Inch: INCHES_PER_UNIT.inches,
  Meter: 1.0 / METERS_PER_INCH, //EPSG:9001
  Foot: 0.30480060960121920243 / METERS_PER_INCH, //EPSG:9003
  IFoot: 0.3048 / METERS_PER_INCH, //EPSG:9002
  ClarkeFoot: 0.3047972651151 / METERS_PER_INCH, //EPSG:9005
  SearsFoot: 0.30479947153867624624 / METERS_PER_INCH, //EPSG:9041
  GoldCoastFoot: 0.30479971018150881758 / METERS_PER_INCH, //EPSG:9094
  IInch: 0.0254 / METERS_PER_INCH,
  MicroInch: 0.0000254 / METERS_PER_INCH,
  Mil: 0.0000000254 / METERS_PER_INCH,
  Centimeter: 0.01 / METERS_PER_INCH,
  Kilometer: 1000.0 / METERS_PER_INCH, //EPSG:9036
  Yard: 0.91440182880365760731 / METERS_PER_INCH,
  SearsYard: 0.914398414616029 / METERS_PER_INCH, //EPSG:9040
  IndianYard: 0.91439853074444079983 / METERS_PER_INCH, //EPSG:9084
  IndianYd37: 0.91439523 / METERS_PER_INCH, //EPSG:9085
  IndianYd62: 0.9143988 / METERS_PER_INCH, //EPSG:9086
  IndianYd75: 0.9143985 / METERS_PER_INCH, //EPSG:9087
  IndianFoot: 0.30479951 / METERS_PER_INCH, //EPSG:9080
  IndianFt37: 0.30479841 / METERS_PER_INCH, //EPSG:9081
  IndianFt62: 0.3047996 / METERS_PER_INCH, //EPSG:9082
  IndianFt75: 0.3047995 / METERS_PER_INCH, //EPSG:9083
  Mile: 1609.34721869443738887477 / METERS_PER_INCH,
  IYard: 0.9144 / METERS_PER_INCH, //EPSG:9096
  IMile: 1609.344 / METERS_PER_INCH, //EPSG:9093
  NautM: 1852.0 / METERS_PER_INCH, //EPSG:9030
  'Lat-66': 110943.316488932731 / METERS_PER_INCH,
  'Lat-83': 110946.25736872234125 / METERS_PER_INCH,
  Decimeter: 0.1 / METERS_PER_INCH,
  Millimeter: 0.001 / METERS_PER_INCH,
  Dekameter: 10.0 / METERS_PER_INCH,
  Decameter: 10.0 / METERS_PER_INCH,
  Hectometer: 100.0 / METERS_PER_INCH,
  GermanMeter: 1.0000135965 / METERS_PER_INCH, //EPSG:9031
  CaGrid: 0.999738 / METERS_PER_INCH,
  ClarkeChain: 20.1166194976 / METERS_PER_INCH, //EPSG:9038
  GunterChain: 20.11684023368047 / METERS_PER_INCH, //EPSG:9033
  BenoitChain: 20.116782494375872 / METERS_PER_INCH, //EPSG:9062
  SearsChain: 20.11676512155 / METERS_PER_INCH, //EPSG:9042
  ClarkeLink: 0.201166194976 / METERS_PER_INCH, //EPSG:9039
  GunterLink: 0.2011684023368047 / METERS_PER_INCH, //EPSG:9034
  BenoitLink: 0.20116782494375872 / METERS_PER_INCH, //EPSG:9063
  SearsLink: 0.2011676512155 / METERS_PER_INCH, //EPSG:9043
  Rod: 5.02921005842012 / METERS_PER_INCH,
  IntnlChain: 20.1168 / METERS_PER_INCH, //EPSG:9097
  IntnlLink: 0.201168 / METERS_PER_INCH, //EPSG:9098
  Perch: 5.02921005842012 / METERS_PER_INCH,
  Pole: 5.02921005842012 / METERS_PER_INCH,
  Furlong: 201.1684023368046 / METERS_PER_INCH,
  Rood: 3.778266898 / METERS_PER_INCH,
  CapeFoot: 0.3047972615 / METERS_PER_INCH,
  Brealey: 375.0 / METERS_PER_INCH,
  ModAmFt: 0.304812252984505969011938 / METERS_PER_INCH,
  Fathom: 1.8288 / METERS_PER_INCH,
  'NautM-UK': 1853.184 / METERS_PER_INCH,
  '50kilometers': 50000.0 / METERS_PER_INCH,
  '150kilometers': 150000.0 / METERS_PER_INCH
});

//unit abbreviations supported by PROJ.4
Util_Util.extend(INCHES_PER_UNIT, {
  mm: INCHES_PER_UNIT['Meter'] / 1000.0,
  cm: INCHES_PER_UNIT['Meter'] / 100.0,
  dm: INCHES_PER_UNIT['Meter'] * 100.0,
  km: INCHES_PER_UNIT['Meter'] * 1000.0,
  kmi: INCHES_PER_UNIT['nmi'], //International Nautical Mile
  fath: INCHES_PER_UNIT['Fathom'], //International Fathom
  ch: INCHES_PER_UNIT['IntnlChain'], //International Chain
  link: INCHES_PER_UNIT['IntnlLink'], //International Link
  'us-in': INCHES_PER_UNIT['inches'], //U.S. Surveyor's Inch
  'us-ft': INCHES_PER_UNIT['Foot'], //U.S. Surveyor's Foot
  'us-yd': INCHES_PER_UNIT['Yard'], //U.S. Surveyor's Yard
  'us-ch': INCHES_PER_UNIT['GunterChain'], //U.S. Surveyor's Chain
  'us-mi': INCHES_PER_UNIT['Mile'], //U.S. Surveyor's Statute Mile
  'ind-yd': INCHES_PER_UNIT['IndianYd37'], //Indian Yard
  'ind-ft': INCHES_PER_UNIT['IndianFt37'], //Indian Foot
  'ind-ch': 20.11669506 / METERS_PER_INCH //Indian Chain
});

//将服务端的地图单位转成SuperMap的地图单位
INCHES_PER_UNIT['degree'] = INCHES_PER_UNIT.dd;
INCHES_PER_UNIT['meter'] = INCHES_PER_UNIT.m;
INCHES_PER_UNIT['foot'] = INCHES_PER_UNIT.ft;
INCHES_PER_UNIT['inch'] = INCHES_PER_UNIT.inches;
INCHES_PER_UNIT['mile'] = INCHES_PER_UNIT.mi;
INCHES_PER_UNIT['kilometer'] = INCHES_PER_UNIT.km;
INCHES_PER_UNIT['yard'] = INCHES_PER_UNIT.yd;

function paramToString(param) {
  if (param == undefined || param == null) {
    return '';
  }
  if (param instanceof Date) {
    return param.toJSON();
  }
  if (canBeJsonified(param)) {
    return JSON.stringify(param);
  }

  return param.toString();
}

function canBeJsonified(str) {
  if (typeof str !== 'string' && typeof str !== 'object') {
    return false;
  }
  try {
    const type = str.toString();
    return type === '[object Object]' || type === '[object Array]';
  } catch (err) {
    return false;
  }
}



;// CONCATENATED MODULE: ./src/common/commontypes/LonLat.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


/**
 * @class LonLat
 * @category BaseTypes Geometry
 * @classdesc  这个类用来表示经度和纬度对。
 * @param {number|Array.<number>} [lon=0.0] - 地图单位上的 X 轴坐标或者横纵坐标组成的数组；如果地图是地理投影，则此值是经度，否则，此值是地图地理位置的 x 坐标。
 * @param {number} [lat=0.0] - 地图单位上的 Y 轴坐标，如果地图是地理投影，则此值是纬度，否则，此值是地图地理位置的 y 坐标。
 * @example
 * var lonLat = new LonLat(30,45);
 * @usage
 */
class LonLat {


    constructor(lon, lat) {
        if (Util_Util.isArray(lon)) {
            lat = lon[1];
            lon = lon[0];
        }
        /**
         * @member {number} [LonLat.prototype.lon=0.0]
         * @description 地图的单位的 X 轴（横轴）坐标。
         */
        this.lon = lon ? Util_Util.toFloat(lon) : 0.0;

        /**
         * @member {number} [LonLat.prototype.lat=0.0]
         * @description 地图的单位的 Y 轴（纵轴）坐标。
         */
        this.lat = lat ? Util_Util.toFloat(lat) : 0.0;
        this.CLASS_NAME = "SuperMap.LonLat";
    }

    /**
     * @function LonLat.prototype.toString
     * @description 返回此对象的字符串形式。
     * @example
     * var lonLat = new LonLat(100,50);
     * var str = lonLat.toString();
     * @returns {string} 例如: "lon=100,lat=50"。
     */
    toString() {
        return ("lon=" + this.lon + ",lat=" + this.lat);
    }

    /**
     * @function LonLat.prototype.toShortString
     * @description 将经度纬度转换成简单字符串。
     * @example
     * var lonLat = new LonLat(100,50);
     * var str = lonLat.toShortString();
     * @returns {string} 处理后的经纬度字符串。例如："100,50"。
     */
    toShortString() {
        return (this.lon + "," + this.lat);
    }

    /**
     * @function LonLat.prototype.clone
     * @description 复制坐标对象，并返回复制后的新对象。
     * @example
     * var lonLat1 = new LonLat(100,50);
     * var lonLat2 = lonLat1.clone();
     * @returns {LonLat}  相同坐标值的新的坐标对象。
     */
    clone() {
        return new LonLat(this.lon, this.lat);
    }

    /**
     * @function LonLat.prototype.add
     * @description 在已有坐标对象的经纬度基础上加上新的坐标经纬度，并返回新的坐标对象。
     * @example
     * var lonLat1 = new LonLat(100,50);
     * //lonLat2 是新的对象
     * var lonLat2 = lonLat1.add(100,50);
     * @param {number} lon - 经度参数。
     * @param {number} lat - 纬度参数。
     * @returns {LonLat} 新的 LonLat 对象，此对象的经纬度是由传入的经纬度与当前的经纬度相加所得。
     */
    add(lon, lat) {
        if ((lon == null) || (lat == null)) {
            throw new TypeError('LonLat.add cannot receive null values');
        }
        return new LonLat(this.lon + Util_Util.toFloat(lon),
            this.lat + Util_Util.toFloat(lat));
    }

    /**
     * @function LonLat.prototype.equals
     * @description 判断两个坐标对象是否相等。
     * @example
     * var lonLat1 = new LonLat(100,50);
     * var lonLat2 = new LonLat(100,50);
     * var isEquals = lonLat1.equals(lonLat2);
     * @param {LonLat} ll - 需要进行比较的坐标对象。
     * @returns {boolean} 如果LonLat对象的经纬度和传入的经纬度一致则返回true,不一
     *      致或传入的ll参数为NULL则返回false。
     */
    equals(ll) {
        var equals = false;
        if (ll != null) {
            equals = ((this.lon === ll.lon && this.lat === ll.lat) ||
                (isNaN(this.lon) && isNaN(this.lat) && isNaN(ll.lon) && isNaN(ll.lat)));
        }
        return equals;
    }

    /**
     * @function LonLat.prototype.wrapDateLine
     * @description 通过传入的范围对象对坐标对象转换到该范围内。
     * 如果经度小于给定范围最小精度，则在原经度基础上加上范围宽度，直到精度在范围内为止，如果经度大于给定范围则在原经度基础上减去范围宽度。
     * 即指将不在经度范围内的坐标转换到范围以内（只会转换 lon，不会转换 lat，主要用于转移到日界线以内）。
     * @example
     * var lonLat1 = new LonLat(420,50);
     * var lonLat2 = lonLat1.wrapDateLine(
     *      new Bounds(-180,-90,180,90)
     *  );
     * @param {Bounds} maxExtent - 最大边界的范围。
     * @returns {LonLat} 将坐标转换到范围对象以内，并返回新的坐标。
     */
    wrapDateLine(maxExtent) {

        var newLonLat = this.clone();

        if (maxExtent) {
            //shift right?
            while (newLonLat.lon < maxExtent.left) {
                newLonLat.lon += maxExtent.getWidth();
            }

            //shift left?
            while (newLonLat.lon > maxExtent.right) {
                newLonLat.lon -= maxExtent.getWidth();
            }
        }

        return newLonLat;
    }

    /**
     *
     * @function LonLat.prototype.destroy
     * @description 销毁此对象。
     * 销毁后此对象的所有属性为 null，而不是初始值。
     * @example
     * var lonLat = new LonLat(100,50);
     * lonLat.destroy();
     */
    destroy() {
        this.lon = null;
        this.lat = null;
    }

    /**
     * @function LonLat.fromString
     * @description 通过字符串生成一个 {@link LonLat} 对象。
     * @example
     * var str = "100,50";
     * var lonLat = LonLat.fromString(str);
     * @param {string} str - 字符串的格式：Lon+","+Lat。如："100,50"。
     * @returns {LonLat} {@link LonLat} 对象。
     */
    static fromString(str) {
        var pair = str.split(",");
        return new LonLat(pair[0], pair[1]);
    }

    /**
     * @function LonLat.fromArray
     * @description 通过数组生成一个 {@link LonLat} 对象。
     * @param {Array.<number>} arr - 数组的格式，长度只能为2,：[Lon,Lat]。如：[5,-42]。
     * @returns {LonLat} {@link LonLat} 对象。
     */
    static fromArray(arr) {
        var gotArr = Util_Util.isArray(arr),
            lon = gotArr && arr[0],
            lat = gotArr && arr[1];
        return new LonLat(lon, lat);
    }


}


;// CONCATENATED MODULE: ./src/common/commontypes/Bounds.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/





/**
 * @class Bounds
 * @deprecatedclass SuperMap.Bounds
 * @category BaseTypes Geometry
 * @classdesc 表示边界类实例。使用 bounds 之前需要设置 left，bottom，right，top 四个属性，这些属性的初始值为 null。
 * @param {number|Array.<number>} [left] - 如果是number，则表示左边界，注意考虑宽度，理论上小于 right 值。如果是数组，则表示 [left, bottom, right, top] 左下右上组成的数组。
 * @param {number} [bottom] - 下边界。考虑高度，理论上小于 top 值。
 * @param {number} [right] - 右边界。
 * @param {number} [top] - 上边界。
 * @example
 * var bounds = new Bounds();
 * bounds.extend(new LonLat(4,5));
 * bounds.extend(new LonLat(5,6));
 * bounds.toBBOX(); // returns 4,5,5,6
 * @usage
 */
class Bounds {


    constructor(left, bottom, right, top) {
        if (Util_Util.isArray(left)) {
            top = left[3];
            right = left[2];
            bottom = left[1];
            left = left[0];
        }
        /**
         * @member {number} Bounds.prototype.left
         * @description 最小的水平坐标系。
         */
        this.left = left != null ? Util_Util.toFloat(left) : this.left;

        /**
         * @member {number} Bounds.prototype.bottom
         * @description 最小的垂直坐标系。
         */
        this.bottom = bottom != null ? Util_Util.toFloat(bottom) : this.bottom;

        /**
         * @member {number} Bounds.prototype.right
         * @description 最大的水平坐标系。
         */
        this.right = right != null ? Util_Util.toFloat(right) : this.right;

        /**
         * @member {number} Bounds.prototype.top
         * @description 最大的垂直坐标系。
         */
        this.top = top != null ? Util_Util.toFloat(top) : this.top;

        /**
         * @member {LonLat} Bounds.prototype.centerLonLat
         * @description bounds 的地图空间的中心点。用 getCenterLonLat() 获得。
         */
        this.centerLonLat = null;
        this.CLASS_NAME = "SuperMap.Bounds";
    }

    /**
     * @function Bounds.prototype.clone
     * @description 复制当前 bounds 对象。
     * @example
     * var bounds1 = new Bounds(-180,-90,180,90);
     * var bounds2 = bounds1.clone();
     * @returns {Bounds} 克隆后的 bounds。
     */
    clone() {
        return new Bounds(this.left, this.bottom,
            this.right, this.top);
    }

    /**
     * @function Bounds.prototype.equals
     * @description 判断两个 bounds 对象是否相等。
     * @example
     * var bounds1 = new Bounds(-180,-90,180,90);
     * var bounds2 = new Bounds(-180,-90,180,90);
     * var isEquals = bounds1.equals(bounds2);
     * @param {Bounds} bounds - 需要进行计较的 bounds。
     * @returns {boolean} 如果 bounds 对象的边和传入的 bounds 一致则返回 true，不一致或传入的 bounds 参数为 NULL 则返回 false。
     */
    equals(bounds) {
        var equals = false;
        if (bounds != null) {
            equals = ((this.left === bounds.left) &&
                (this.right === bounds.right) &&
                (this.top === bounds.top) &&
                (this.bottom === bounds.bottom));
        }
        return equals;
    }

    /**
     * @function Bounds.prototype.toString
     * @description 返回此对象的字符串形式。
     * @example
     * var bounds = new Bounds(-180,-90,180,90);
     * var str = bounds.toString();
     * @returns {string} 边界对象的字符串表示形式（left,bottom,right,top），例如: "-180,-90,180,90"。
     */
    toString() {
        return [this.left, this.bottom, this.right, this.top].join(",");
    }

    /**
     * @function Bounds.prototype.toArray
     * @description 边界对象的数组表示形式。
     * @example
     * var bounds = new Bounds(-180,-90,100,80);
     * //array1 = [-180,-90,100,80];
     * var array1 = bounds.toArray();
     * //array1 = [-90,-180,80,100];
     * var array2 = bounds.toArray(true);
     * @param {boolean} [reverseAxisOrder=false] - 是否反转轴顺序。
     * 如果设为 true，则倒转顺序（bottom,left,top,right），否则按正常轴顺序（left,bottom,right,top）。
     * @returns {Array.<number>} left, bottom, right, top 数组。
     */
    toArray(reverseAxisOrder) {
        if (reverseAxisOrder === true) {
            return [this.bottom, this.left, this.top, this.right];
        } else {
            return [this.left, this.bottom, this.right, this.top];
        }
    }

    /**
     * @function Bounds.prototype.toBBOX
     * @description 取小数点后 decimal 位数字进行四舍五入再转换为 BBOX 字符串。
     * @example
     * var bounds = new Bounds(-1.1234567,-1.7654321,1.4444444,1.5555555);
     * //str1 = "-1.123457,-1.765432,1.444444,1.555556";
     * var str1 = bounds.toBBOX();
     * //str2 = "-1.1,-1.8,1.4,1.6";
     * var str2 = bounds.toBBOX(1);
     * //str2 = "-1.8,-1.1,1.6,1.4";
     * var str2 = bounds.toBBOX(1,true);
     * @param {number} [decimal=6] - 边界方位坐标的有效数字个数。
     * @param {boolean} [reverseAxisOrder=false] - 是否是反转轴顺序。
     * 如果设为true，则倒转顺序（bottom,left,top,right）,否则按正常轴顺序（left,bottom,right,top）。
     * @returns {string} 边界对象的字符串表示形式，如："5,42,10,45"。
     */
    toBBOX(decimal, reverseAxisOrder) {
        if (decimal == null) {
            decimal = 6;
        }
        var mult = Math.pow(10, decimal);
        var xmin = Math.round(this.left * mult) / mult;
        var ymin = Math.round(this.bottom * mult) / mult;
        var xmax = Math.round(this.right * mult) / mult;
        var ymax = Math.round(this.top * mult) / mult;
        if (reverseAxisOrder === true) {
            return ymin + "," + xmin + "," + ymax + "," + xmax;
        } else {
            return xmin + "," + ymin + "," + xmax + "," + ymax;
        }
    }

    ///**
    // * @function Bounds.prototype.toGeometry
    // * @description 基于当前边界范围创建一个新的多边形对象。
    // * @example
    // * var bounds = new Bounds(-180,-90,100,80);
    // * // Polygon对象
    // * var geo = bounds.toGeometry();
    // * @returns {GeometryPolygon} 基于当前 bounds 坐标创建的新的多边形。
    // */
    // toGeometry() {
    //     return new Polygon([
    //         new LinearRing([
    //             new Point(this.left, this.bottom),
    //             new Point(this.right, this.bottom),
    //             new Point(this.right, this.top),
    //             new Point(this.left, this.top)
    //         ])
    //     ]);
    // }

    /**
     * @function Bounds.prototype.getWidth
     * @description 获取 bounds 的宽度。
     * @example
     * var bounds = new Bounds(-180,-90,100,80);
     * //width = 280;
     * var width = bounds.getWidth();
     * @returns {number} 获取当前 bounds 的宽度（right 减去 left）。
     */
    getWidth() {
        return (this.right - this.left);
    }

    /**
     * @function Bounds.prototype.getHeight
     * @description 获取 bounds 的高度。
     * @example
     * var bounds = new Bounds(-180,-90,100,80);
     * //height = 170;
     * var height = bounds.getHeight();
     * @returns {number} 边界高度（top 减去 bottom）。
     */
    getHeight() {
        return (this.top - this.bottom);
    }

    /**
     * @function Bounds.prototype.getSize
     * @description 获取边框大小。
     * @example
     * var bounds = new Bounds(-180,-90,100,80);
     * var size = bounds.getSize();
     * @returns {Size} 边框大小。
     */
    getSize() {
        return new Size(this.getWidth(), this.getHeight());
    }

    /**
     * @function Bounds.prototype.getCenterPixel
     * @description 获取像素格式的范围中心点。
     * @example
     * var bounds = new Bounds(-180,-90,100,80);
     * var pixel = bounds.getCenterPixel();
     * @returns {Pixel} 像素格式的当前范围的中心点。
     */
    getCenterPixel() {
        return new Pixel((this.left + this.right) / 2,
            (this.bottom + this.top) / 2);
    }

    /**
     * @function Bounds.prototype.getCenterLonLat
     * @description 获取地理格式的范围中心点。
     * @example
     * var bounds = new Bounds(-180,-90,100,80);
     * var lonlat = bounds.getCenterLonLat();
     * @returns {LonLat} 当前地理范围的中心点。
     */
    getCenterLonLat() {
        if (!this.centerLonLat) {
            this.centerLonLat = new LonLat(
                (this.left + this.right) / 2, (this.bottom + this.top) / 2
            );
        }
        return this.centerLonLat;
    }

    /**
     * @function Bounds.prototype.scale
     * @description 按照比例扩大/缩小出一个新的 bounds。
     * @example
     * var bounds = new Bounds(-50,-50,40,40);
     * var bounds2 = bounds.scale(2);
     * @param {number} [ratio=1] - 需要扩大的比例。
     * @param {(Pixel|LonLat)} [origin] - 扩大时的基准点，默认为当前 bounds 的中心点。
     * @returns {Bounds} 通过 ratio、origin 计算得到的新的边界范围。
     */
    scale(ratio, origin) {
        ratio = ratio ? ratio : 1;
        if (origin == null) {
            origin = this.getCenterLonLat();
        }

        var origx, origy;

        // get origin coordinates
        if (origin.CLASS_NAME === "SuperMap.LonLat") {
            origx = origin.lon;
            origy = origin.lat;
        } else {
            origx = origin.x;
            origy = origin.y;
        }

        var left = (this.left - origx) * ratio + origx;
        var bottom = (this.bottom - origy) * ratio + origy;
        var right = (this.right - origx) * ratio + origx;
        var top = (this.top - origy) * ratio + origy;

        return new Bounds(left, bottom, right, top);
    }

    /**
     * @function Bounds.prototype.add
     * @description 在当前的 Bounds 上按照传入的坐标点进行平移，返回新的范围。
     * @example
     * var bounds1 = new Bounds(-50,-50,40,40);
     * //bounds2 是新的 bounds
     * var bounds2 = bounds.add(20,10);
     * @param {number} x - 坐标点的 x 坐标。
     * @param {number} y - 坐标点的 y 坐标。
     * @returns {Bounds} 新的 bounds，此 bounds 的坐标是由传入的 x，y 参数与当前 bounds 坐标计算所得。
     */
    add(x, y) {
        if ((x == null) || (y == null)) {
            throw new TypeError('Bounds.add cannot receive null values');
        }
        return new Bounds(this.left + x, this.bottom + y,
            this.right + x, this.top + y);
    }

    /**
     * @function Bounds.prototype.extend
     * @description 在当前 bounds 上扩展 bounds，支持 point，lonlat 和 bounds。扩展后的 bounds 的范围是两者的结合。
     * @example
     * var bounds1 = new Bounds(-50,-50,40,40);
     * //bounds 改变
     * bounds.extend(new LonLat(50,60));
     * @param {GeometryPoint|LonLat|Bounds} object - 可以是 point、lonlat 和 bounds。
     */
    extend(object) {
        var bounds = null;
        if (object) {
            // clear cached center location
            switch (object.CLASS_NAME) {
                case "SuperMap.LonLat":
                    bounds = new Bounds(object.lon, object.lat,
                        object.lon, object.lat);
                    break;
                case "SuperMap.Geometry.Point":
                    bounds = new Bounds(object.x, object.y,
                        object.x, object.y);
                    break;

                case "SuperMap.Bounds":
                    bounds = object;
                    break;
            }

            if (bounds) {
                this.centerLonLat = null;
                if ((this.left == null) || (bounds.left < this.left)) {
                    this.left = bounds.left;
                }
                if ((this.bottom == null) || (bounds.bottom < this.bottom)) {
                    this.bottom = bounds.bottom;
                }
                if ((this.right == null) || (bounds.right > this.right)) {
                    this.right = bounds.right;
                }
                if ((this.top == null) || (bounds.top > this.top)) {
                    this.top = bounds.top;
                }
            }
        }
    }

    /**
     * @function Bounds.prototype.containsLonLat
     * @description 判断传入的坐标是否在范围内。
     * @example
     * var bounds1 = new Bounds(-50,-50,40,40);
     * //isContains1 = true
     * //这里的第二个参数可以直接为 boolean 类型，也就是inclusive
     * var isContains1 = bounds.containsLonLat(new LonLat(40,40),true);
     *
     * //(40,40)在范围内，同样(40+360,40)也在范围内
     * var bounds2 = new Bounds(-50,-50,40,40);
     * //isContains2 = true;
     * var isContains2 = bounds2.containsLonLat(
     *      new LonLat(400,40),
     *      {
     *           inclusive:true,
     *           //全球的范围
     *           worldBounds: new Bounds(-180,-90,180,90)
     *      }
     * );
     * @param {(LonLat|Object)} ll - <LonLat> 对象或者是一个包含 'lon' 与 'lat' 属性的对象。
     * @param {Object} options - 可选参数。
     * @param {boolean} [options.inclusive=true] - 是否包含边界。
     * @param {Bounds} [options.worldBounds] - 如果提供 worldBounds 参数, 如果 ll 参数提供的坐标超出了世界边界（worldBounds），
     *        但是通过日界线的转化可以被包含, 它将被认为是包含在该范围内的。
     * @returns {boolean} 传入坐标是否包含在范围内。
     */
    containsLonLat(ll, options) {
        if (typeof options === "boolean") {
            options = {inclusive: options};
        }
        options = options || {};
        var contains = this.contains(ll.lon, ll.lat, options.inclusive),
            worldBounds = options.worldBounds;
        //日界线以外的也有可能算包含，
        if (worldBounds && !contains) {
            var worldWidth = worldBounds.getWidth();
            var worldCenterX = (worldBounds.left + worldBounds.right) / 2;
            //这一步很关键
            var worldsAway = Math.round((ll.lon - worldCenterX) / worldWidth);
            contains = this.containsLonLat({
                lon: ll.lon - worldsAway * worldWidth,
                lat: ll.lat
            }, {inclusive: options.inclusive});
        }
        return contains;
    }

    /**
     * @function Bounds.prototype.containsPixel
     * @description 判断传入的像素是否在范围内。直接匹配大小，不涉及像素和地理转换。
     * @example
     * var bounds = new Bounds(-50,-50,40,40);
     * //isContains = true
     * var isContains = bounds.containsPixel(new Pixel(40,40),true);
     * @param {Pixel} px - 提供的像素参数。
     * @param {boolean} [inclusive=true] - 是否包含边界。
     * @returns {boolean} 传入的 pixel 在当前边界范围之内。
     */
    containsPixel(px, inclusive) {
        return this.contains(px.x, px.y, inclusive);
    }

    /**
     * @function Bounds.prototype.contains
     * @description 判断传入的 x，y 坐标值是否在范围内。
     * @example
     * var bounds = new Bounds(-50,-50,40,40);
     * //isContains = true
     * var isContains = bounds.contains(40,40,true);
     * @param {number} x - x 坐标值。
     * @param {number} y - y 坐标值。
     * @param {boolean} [inclusive=true] - 是否包含边界。
     * @returns {boolean} 传入的 x，y 坐标是否在当前范围内。
     */
    contains(x, y, inclusive) {
        //set default
        if (inclusive == null) {
            inclusive = true;
        }

        if (x == null || y == null) {
            return false;
        }

        //x = Util.toFloat(x);
        //y = Util.toFloat(y);

        var contains = false;
        if (inclusive) {
            contains = ((x >= this.left) && (x <= this.right) &&
                (y >= this.bottom) && (y <= this.top));
        } else {
            contains = ((x > this.left) && (x < this.right) &&
                (y > this.bottom) && (y < this.top));
        }
        return contains;
    }

    /**
     * @function Bounds.prototype.intersectsBounds
     * @description 判断目标边界范围是否与当前边界范围相交。如果两个边界范围中的任意边缘相交或者一个边界包含了另外一个就认为这两个边界相交。
     * @example
     * var bounds = new Bounds(-180,-90,100,80);
     * var isIntersects = bounds.intersectsBounds(
     *      new Bounds(-170,-90,120,80)
     *  );
     * @param {Bounds} bounds - 目标边界。
     * @param {Object} options - 参数。
     * @param {boolean} [options.inclusive=true] - 边缘重合也看成相交。如果是false，两个边界范围没有重叠部分仅仅是在边缘相接（重合），这种情况被认为没有相交。
     * @param {Bounds} [options.worldBounds] - 提供了 worldBounds 参数，如果他们相交时是在全球范围内，两个边界将被视为相交。这仅适用于交叉或完全不在世界范围的边界。
     * @returns {boolean} 传入的 bounds 对象与当前 bounds 相交。
     */
    intersectsBounds(bounds, options) {
        if (typeof options === "boolean") {
            options = {inclusive: options};
        }
        options = options || {};
        if (options.worldBounds) {
            var self = this.wrapDateLine(options.worldBounds);
            bounds = bounds.wrapDateLine(options.worldBounds);
        } else {
            self = this;
        }
        if (options.inclusive == null) {
            options.inclusive = true;
        }
        var intersects = false;
        var mightTouch = (
            self.left === bounds.right ||
            self.right === bounds.left ||
            self.top === bounds.bottom ||
            self.bottom === bounds.top
        );

        // if the two bounds only touch at an edge, and inclusive is false,
        // then the bounds don't *really* intersect.
        if (options.inclusive || !mightTouch) {
            // otherwise, if one of the boundaries even partially contains another,
            // inclusive of the edges, then they do intersect.
            var inBottom = (
                ((bounds.bottom >= self.bottom) && (bounds.bottom <= self.top)) ||
                ((self.bottom >= bounds.bottom) && (self.bottom <= bounds.top))
            );
            var inTop = (
                ((bounds.top >= self.bottom) && (bounds.top <= self.top)) ||
                ((self.top > bounds.bottom) && (self.top < bounds.top))
            );
            var inLeft = (
                ((bounds.left >= self.left) && (bounds.left <= self.right)) ||
                ((self.left >= bounds.left) && (self.left <= bounds.right))
            );
            var inRight = (
                ((bounds.right >= self.left) && (bounds.right <= self.right)) ||
                ((self.right >= bounds.left) && (self.right <= bounds.right))
            );
            intersects = ((inBottom || inTop) && (inLeft || inRight));
        }
        // document me
        if (options.worldBounds && !intersects) {
            var world = options.worldBounds;
            var width = world.getWidth();
            var selfCrosses = !world.containsBounds(self);
            var boundsCrosses = !world.containsBounds(bounds);
            if (selfCrosses && !boundsCrosses) {
                bounds = bounds.add(-width, 0);
                intersects = self.intersectsBounds(bounds, {inclusive: options.inclusive});
            } else if (boundsCrosses && !selfCrosses) {
                self = self.add(-width, 0);
                intersects = bounds.intersectsBounds(self, {inclusive: options.inclusive});
            }
        }
        return intersects;
    }

    /**
     * @function Bounds.prototype.containsBounds
     * @description 判断目标边界是否被当前边界包含在内。
     * @example
     * var bounds = new Bounds(-180,-90,100,80);
     * var isContains = bounds.containsBounds(
     *      new Bounds(-170,-90,100,80),true,true
     *  );
     * @param {Bounds} bounds - 目标边界。
     * @param {boolean} [partial=false] - 目标边界的任意部分都包含在当前边界中则被认为是包含关系。
     * 如果设为 false，整个目标边界全部被包含在当前边界范围内。
     * @param {boolean} [inclusive=true] - 边缘共享是否被视为包含。
     * @returns {boolean} 传入的边界是否被当前边界包含。
     */
    containsBounds(bounds, partial, inclusive) {
        if (partial == null) {
            partial = false;
        }
        if (inclusive == null) {
            inclusive = true;
        }
        var bottomLeft = this.contains(bounds.left, bounds.bottom, inclusive);
        var bottomRight = this.contains(bounds.right, bounds.bottom, inclusive);
        var topLeft = this.contains(bounds.left, bounds.top, inclusive);
        var topRight = this.contains(bounds.right, bounds.top, inclusive);

        return (partial) ? (bottomLeft || bottomRight || topLeft || topRight)
            : (bottomLeft && bottomRight && topLeft && topRight);
    }

    /**
     * @function Bounds.prototype.determineQuadrant
     * @description 判断传入坐标是否在 bounds 范围内的象限。以 bounds 中心点为坐标原点。
     * @example
     * var bounds = new Bounds(-180,-90,100,80);
     * //str = "tr";
     * var str = bounds.determineQuadrant(
     *      new LonLat(20,20)
     *  );
     * @param {LonLat} lonlat - 传入的坐标对象。
     * @returns {string} 传入坐标所在的象限（"br" "tr" "tl" "bl" 分别对应"右下"，"右上"，"左上" "左下"）。
     */
    determineQuadrant(lonlat) {

        var quadrant = "";
        var center = this.getCenterLonLat();

        quadrant += (lonlat.lat < center.lat) ? "b" : "t";
        quadrant += (lonlat.lon < center.lon) ? "l" : "r";

        return quadrant;
    }

    /**
     * @function Bounds.prototype.wrapDateLine
     * @description 将当前 bounds 移动到最大边界范围内部（所谓的内部是相交或者内部）。
     * @example
     * var bounds = new Bounds(380,-40,400,-20);
     * var maxExtent = new Bounds(-180,-90,100,80);
     * //新的bounds
     * var newBounds = bounds.wrapDateLine(maxExtent);
     * @param {Bounds} maxExtent - 最大的边界范围（一般是全球范围）。
     * @param {Object} options - 可选选项参数。
     * @param {number} [options.leftTolerance=0] - left 允许的误差。
     * @param {number} [options.rightTolerance=0] - right 允许的误差。
     * @returns {Bounds} 克隆当前边界。如果当前边界完全在最大范围之外此函数则返回一个不同值的边界，
     *                            若落在最大边界的左边，则给当前的bounds值加上最大范围的宽度，即向右移动，
     *                            若落在右边，则向左移动，即给当前的bounds值加上负的最大范围的宽度。
     */
    wrapDateLine(maxExtent, options) {
        options = options || {};

        var leftTolerance = options.leftTolerance || 0;
        var rightTolerance = options.rightTolerance || 0;

        var newBounds = this.clone();

        if (maxExtent) {
            var width = maxExtent.getWidth();
            //如果 newBounds 在 maxExtent 的左边，那么一直向右移动，直到相交或者包含为止，每次移动width
            //shift right?
            while (newBounds.left < maxExtent.left &&
            newBounds.right - rightTolerance <= maxExtent.left) {
                newBounds = newBounds.add(width, 0);
            }
            //如果 newBounds 在 maxExtent 的右边，那么一直向左移动，直到相交或者包含为止，每次移动width
            //shift left?
            while (newBounds.left + leftTolerance >= maxExtent.right &&
            newBounds.right > maxExtent.right) {
                newBounds = newBounds.add(-width, 0);
            }
            //如果和右边相交，左边又在内部，那么再次向左边移动一次
            // crosses right only? force left
            var newLeft = newBounds.left + leftTolerance;
            if (newLeft < maxExtent.right && newLeft > maxExtent.left &&
                newBounds.right - rightTolerance > maxExtent.right) {
                newBounds = newBounds.add(-width, 0);
            }
        }

        return newBounds;
    }

    /**
     * @function Bounds.prototype.toServerJSONObject
     * @description 转换成对应的 JSON 格式对象。
     * @example
     * var bounds = new Bounds(-180,-90,100,80);
     * var obj = bounds.toServerJSONObject();
     * @returns {Object} JSON 格式的 Object 对象。
     */
    toServerJSONObject() {
        var jsonObject = {
            rightTop: {x: this.right, y: this.top},
            leftBottom: {x: this.left, y: this.bottom},
            left: this.left,
            right: this.right,
            top: this.top,
            bottom: this.bottom
        }
        return jsonObject;
    }

    /**
     *
     * @function Bounds.prototype.destroy
     * @description 销毁此对象。
     * 销毁后此对象的所有属性为 null，而不是初始值。
     * @example
     * var bounds = new Bounds(-180,-90,100,80);
     * bounds.destroy();
     */
    destroy() {
        this.left = null;
        this.right = null;
        this.top = null;
        this.bottom = null;
        this.centerLonLat = null;
    }

    /**
     * @function Bounds.fromString
     * @description 通过字符串参数创建新的 bounds 的构造函数。
     * @example
     * var bounds = Bounds.fromString("-180,-90,100,80");
     * @param {string} str - 边界字符串，用逗号隔开（e.g. <i>"5,42,10,45"</i>）。
     * @param {boolean} [reverseAxisOrder=false] - 是否反转轴顺序。
     * 如果设为true，则倒转顺序（bottom,left,top,right），否则按正常轴顺序（left,bottom,right,top）。
     * @returns {Bounds} 给定的字符串创建的新的边界对象。
     */
    static fromString(str, reverseAxisOrder) {
        var bounds = str.split(",");
        return Bounds.fromArray(bounds, reverseAxisOrder);
    }

    /**
     * @function Bounds.fromArray
     * @description 通过边界框数组创建 Bounds。
     * @example
     * var bounds = Bounds.fromArray([-180,-90,100,80]);
     * @param {Array.<number>} bbox - 边界值数组。（e.g. <i>[5,42,10,45]</i>）。
     * @param {boolean} [reverseAxisOrder=false] - 是否是反转轴顺序。如果设为true，则倒转顺序（bottom,left,top,right），否则按正常轴顺序（left,bottom,right,top）。
     * @returns {Bounds} 根据传入的数组创建的新的边界对象。
     */
    static fromArray(bbox, reverseAxisOrder) {
        return reverseAxisOrder === true ?
            new Bounds(bbox[1], bbox[0], bbox[3], bbox[2]) :
            new Bounds(bbox[0], bbox[1], bbox[2], bbox[3]);
    }

    /**
     * @function Bounds.fromSize
     * @description 通过传入的边界大小来创建新的边界。
     * @example
     * var bounds = Bounds.fromSize(new Size(20,10));
     * @param {Size} size - 边界大小。
     * @returns {Bounds} 根据传入的边界大小的创建新的边界。
     */
    static fromSize(size) {
        return new Bounds(0,
            size.h,
            size.w,
            0);
    }

    /**
     * @function Bounds.oppositeQuadrant
     * @description 反转象限。"t"和"b" 交换，"r"和"l"交换, 如："tl"变为"br"。
     * @param {string} quadrant - 代表象限的字符串，如："tl"。
     * @returns {string} 反转后的象限。
     */
    static oppositeQuadrant(quadrant) {
        var opp = "";

        opp += (quadrant.charAt(0) === 't') ? 'b' : 't';
        opp += (quadrant.charAt(1) === 'l') ? 'r' : 'l';

        return opp;
    }

}

;// CONCATENATED MODULE: ./src/common/commontypes/geometry/Point.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/




/**
 * @class GeometryPoint
 * @aliasclass Geometry.Point
 * @deprecatedclass SuperMap.Geometry.Point
 * @classdesc 点几何对象类。
 * @category BaseTypes Geometry
 * @extends {Geometry}
 * @param {number} x - x 坐标。
 * @param {number} y - y 坐标。
 * @param {string} [type = 'Point'] - 点的类型。
 * @param {number} [tag] - 额外的属性，比如插值分析中的 Z 值。
 * @example
 * var point = new GeometryPoint(-111.04, 45.68);
 * @usage
 */
class Point extends Geometry_Geometry {


    constructor(x, y, type, tag) {
        super(x, y, type, tag);
        /**
         * @member {number} GeometryPoint.prototype.x
         * @description 横坐标。
         */
        this.x = parseFloat(x);

        /**
         * @member {number} GeometryPoint.prototype.y
         * @description 纵坐标。
         */
        this.y = parseFloat(y);

        /**
         * @member {string} GeometryPoint.prototype.tag
         * @description  用来存储额外的属性，比如插值分析中的 Z 值。
         */
        this.tag = (tag || tag == 0) ? parseFloat(tag) : null;

        /**
         * @member {string} GeometryPoint.prototype.type
         * @description  用来存储点的类型。
         */
        this.type = type || "Point";
        this.CLASS_NAME = "SuperMap.Geometry.Point";
        this.geometryType = "Point";
    }

    /**
     * @function GeometryPoint.prototype.clone
     * @description 克隆点对象。
     * @returns {GeometryPoint} 克隆后的点对象。
     */
    clone(obj) {
        if (obj == null) {
            obj = new Point(this.x, this.y);
        }

        // catch any randomly tagged-on properties
        Util_Util.applyDefaults(obj, this);

        return obj;
    }

    /**
     * @function GeometryPoint.prototype.calculateBounds
     * @description 计算点对象的范围。
     */
    calculateBounds() {
        this.bounds = new Bounds(this.x, this.y,
            this.x, this.y);
    }

    /**
     * @function GeometryPoint.prototype.equals
     * @description 判断两个点对象是否相等。如果两个点对象具有相同的坐标，则认为是相等的。
     * @example
     * var point= new GeometryPoint(0,0);
     * var point1={x:0,y:0};
     * var result= point.equals(point1);
     * @param {GeometryPoint} geom - 需要判断的点对象。
     * @returns {boolean} 两个点对象是否相等（true 为相等，false 为不等）。
     */
    equals(geom) {
        var equals = false;
        if (geom != null) {
            equals = ((this.x === geom.x && this.y === geom.y) ||
                (isNaN(this.x) && isNaN(this.y) && isNaN(geom.x) && isNaN(geom.y)));
        }
        return equals;
    }


    /**
     * @function GeometryPoint.prototype.move
     * @description 沿着 x、y 轴的正方向上按照给定的位移移动点对象，move 不仅改变了几何对象的位置并且清理了边界缓存。
     * @param {number} x - x 轴正方向上的偏移量。
     * @param {number} y - y 轴正方向上偏移量。
     */
    move(x, y) {
        this.x = this.x + x;
        this.y = this.y + y;
        this.clearBounds();
    }

    /**
     * @function GeometryPoint.prototype.toShortString
     * @description 将 x/y 坐标转换成简单字符串。
     * @returns {string} 字符串代表点对象。(ex. <i>"5, 42"</i>)
     */
    toShortString() {
        return (this.x + ", " + this.y);
    }

    /**
     * @function GeometryPoint.prototype.destroy
     * @description 释放点对象的资源。
     */
    destroy() {
        this.x = null;
        this.y = null;
        this.tag = null;
        super.destroy();
    }

    /**
     * @function GeometryPoint.prototype.getVertices
     * @description 获取几何图形所有顶点的列表。
     * @returns {Array} 几何图形的顶点列表。
     */
    getVertices() {
        return [this];
    }


}

;// CONCATENATED MODULE: ./src/common/commontypes/geometry/Collection.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/




/**
 * @class GeometryCollection
 * @aliasclass Geometry.Collection
 * @deprecatedclass SuperMap.Geometry.Collection
 * @classdesc 几何对象集合类，存储在本地的 components 属性中（可作为参数传递给构造函数）。<br>
 *            随着新的几何图形添加到集合中，将不能被克隆，当移动几何图形时，需要指定参照物。<br>
 *            getArea 和 getLength 函数只能通过遍历存储几何对象的 components 数组，总计所有几何图形的面积和长度。
 * @category BaseTypes Geometry
 * @extends {Geometry}
 * @param {Array.<Geometry>} components - 几何对象数组。
 * @example
 * var point1 = new GeometryPoint(10,20);
 * var point2 = new GeometryPoint(30,40);
 * var col = new GeometryCollection([point1,point2]);
 * @usage
 */
class Collection extends Geometry_Geometry {


    constructor(components) {
        super();

        /**
         * @description 存储几何对象的数组。
         * @member {Array.<Geometry>} GeometryCollection.prototype.components
         */
        this.components = [];

        /**
         * @member {Array.<string>} GeometryCollection.prototype.componentTypes
         * @description components 存储的几何对象所支持的几何类型数组，为空表示类型不受限制。
         */
        this.componentTypes = null;
        if (components != null) {
            this.addComponents(components);
        }
        this.CLASS_NAME = "SuperMap.Geometry.Collection";
        this.geometryType = "Collection";
    }

    /**
     * @function GeometryCollection.prototype.destroy
     * @description 销毁几何图形。
     */
    destroy() {
        this.components.length = 0;
        this.components = null;
        super.destroy();
    }

    /**
     * @function GeometryCollection.prototype.clone
     * @description 克隆当前几何对象。
     * @returns {GeometryCollection} 克隆的几何对象集合。
     */
    clone() {
        var geometry = new Collection();
        for (var i = 0, len = this.components.length; i < len; i++) {
            geometry.addComponent(this.components[i].clone());
        }

        // catch any randomly tagged-on properties
        Util_Util.applyDefaults(geometry, this);

        return geometry;
    }

    /**
     * @function GeometryCollection.prototype.getComponentsString
     * @description 获取 components 字符串。
     * @returns {string} components 字符串。
     */
    getComponentsString() {
        var strings = [];
        for (var i = 0, len = this.components.length; i < len; i++) {
            strings.push(this.components[i].toShortString());
        }
        return strings.join(",");
    }

    /**
     * @function GeometryCollection.prototype.calculateBounds
     * @description 通过遍历数组重新计算边界，在遍历每一子项中时调用 extend 方法。
     */
    calculateBounds() {
        this.bounds = null;
        var bounds = new Bounds();
        var components = this.components;
        if (components) {
            for (var i = 0, len = components.length; i < len; i++) {
                bounds.extend(components[i].getBounds());
            }
        }
        // to preserve old behavior, we only set bounds if non-null
        // in the future, we could add bounds.isEmpty()
        if (bounds.left != null && bounds.bottom != null &&
            bounds.right != null && bounds.top != null) {
            this.setBounds(bounds);
        }
    }

    /**
     * @function GeometryCollection.prototype.addComponents
     * @description 给几何图形对象添加元素。
     * @param {Array.<Geometry>} components - 几何对象组件。
     * @example
     * var geometryCollection = new GeometryCollection();
     * geometryCollection.addComponents(new SuerpMap.Geometry.Point(10,10));
     */
    addComponents(components) {
        if (!(Util_Util.isArray(components))) {
            components = [components];
        }
        for (var i = 0, len = components.length; i < len; i++) {
            this.addComponent(components[i]);
        }
    }

    /**
     * @function GeometryCollection.prototype.addComponent
     * @description 添加几何对象到集合中。如果设置了 componentTypes 类型，则添加的几何对象必须是 componentTypes 中的类型。
     * @param {Geometry} component - 待添加的几何对象。
     * @param {number} [index] - 几何对象插入的位置。
     * @returns {boolean} 是否添加成功。
     */
    addComponent(component, index) {
        var added = false;
        if (component) {
            if (this.componentTypes == null ||
                (Util_Util.indexOf(this.componentTypes,
                    component.CLASS_NAME) > -1)) {

                if (index != null && (index < this.components.length)) {
                    var components1 = this.components.slice(0, index);
                    var components2 = this.components.slice(index,
                        this.components.length);
                    components1.push(component);
                    this.components = components1.concat(components2);
                } else {
                    this.components.push(component);
                }
                component.parent = this;
                this.clearBounds();
                added = true;
            }
        }
        return added;
    }

    /**
     * @function GeometryCollection.prototype.removeComponents
     * @description 清除几何对象。
     * @param {Array.<Geometry>} components - 需要清除的几何对象。
     * @returns {boolean} 元素是否被删除。
     */
    removeComponents(components) {
        var removed = false;

        if (!(Util_Util.isArray(components))) {
            components = [components];
        }
        for (var i = components.length - 1; i >= 0; --i) {
            removed = this.removeComponent(components[i]) || removed;
        }
        return removed;
    }

    /**
     * @function GeometryCollection.prototype.removeComponent
     * @description 从集合中移除几何对象。
     * @param {Geometry} component - 要移除的几何对象。
     * @returns {boolean} 几何对象是否移除成功。
     */
    removeComponent(component) {
        Util_Util.removeItem(this.components, component);

        // clearBounds() so that it gets recalculated on the next call
        // to this.getBounds();
        this.clearBounds();
        return true;
    }

    /**
     * @function GeometryCollection.prototype.getArea
     * @description 计算几何对象的面积。注意，这个方法在 {@link GeometryPolygon} 类中需要重写。
     * @returns {number} 几何图形的面积，是几何对象中所有组成部分的面积之和。
     */
    getArea() {
        var area = 0.0;
        for (var i = 0, len = this.components.length; i < len; i++) {
            area += this.components[i].getArea();
        }
        return area;
    }

    /**
     * @function GeometryCollection.prototype.equals
     * @description 判断两个几何图形是否相等。如果所有的 components 具有相同的坐标，则认为是相等的。
     * @param {Geometry} geometry - 需要判断的几何图形。
     * @returns {boolean} 输入的几何图形与当前几何图形是否相等。
     */
    equals(geometry) {
        var equivalent = true;
        if (!geometry || !geometry.CLASS_NAME ||
            (this.CLASS_NAME !== geometry.CLASS_NAME)) {
            equivalent = false;
        } else if (!(Util_Util.isArray(geometry.components)) ||
            (geometry.components.length !== this.components.length)) {
            equivalent = false;
        } else {
            for (var i = 0, len = this.components.length; i < len; ++i) {
                if (!this.components[i].equals(geometry.components[i])) {
                    equivalent = false;
                    break;
                }
            }
        }
        return equivalent;
    }


    /**
     * @function GeometryCollection.prototype.getVertices
     * @description 返回几何对象的所有结点的列表。
     * @param {boolean} [nodes] - 对于线来说，仅仅返回作为端点的顶点，如果设为 false，则返回非端点的顶点，如果没有设置此参数，则返回所有顶点。
     * @returns {Array} 几何对象的顶点列表。
     */
    getVertices(nodes) {
        var vertices = [];
        for (var i = 0, len = this.components.length; i < len; ++i) {
            Array.prototype.push.apply(
                vertices, this.components[i].getVertices(nodes)
            );
        }
        return vertices;
    }

}

;// CONCATENATED MODULE: ./src/common/commontypes/geometry/MultiPoint.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


/**
 * @class GeometryMultiPoint
 * @aliasclass Geometry.MultiPoint
 * @deprecatedclass SuperMap.Geometry.MultiPoint
 * @classdesc 几何对象多点类。
 * @category BaseTypes Geometry
 * @extends GeometryCollection
 * @param {Array.<GeometryPoint>} components - 点对象数组。
 * @example
 * var point1 = new GeometryPoint(5,6);
 * var poine2 = new GeometryMultiPoint(7,8);
 * var multiPoint = new MultiPoint([point1,point2]);
 * @usage
 */
class MultiPoint extends Collection {


    constructor(components) {
        super(components);
        /**
         * @member {Array.<string>} [GeometryMultiPoint.prototype.componentTypes=["SuperMap.Geometry.Point"]]
         * @description components 存储的几何对象所支持的几何类型数组。
         * @readonly
         */
        this.componentTypes = ["SuperMap.Geometry.Point"];
        this.CLASS_NAME = "SuperMap.Geometry.MultiPoint";
        this.geometryType = "MultiPoint";
    }

    /**
     * @function GeometryMultiPoint.prototype.addPoint
     * @description 添加点，封装了 {@link GeometryCollection|GeometryCollection.addComponent} 方法。
     * @param {GeometryPoint} point - 添加的点。
     * @param {number} [index] - 下标。
     */
    addPoint(point, index) {
        this.addComponent(point, index);
    }


    /**
     * @function GeometryMultiPoint.prototype.removePoint
     * @description 移除点，封装了 {@link GeometryCollection|GeometryCollection.removeComponent} 方法。
     * @param {GeometryPoint} point - 移除的点对象。
     */
    removePoint(point) {
        this.removeComponent(point);
    }


}

;// CONCATENATED MODULE: ./src/common/commontypes/geometry/Curve.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


/**
 * @class GeometryCurve
 * @aliasclass Geometry.Curve
 * @deprecatedclass SuperMap.Geometry.Curve
 * @classdesc 几何对象曲线类。
 * @category BaseTypes Geometry
 * @extends GeometryMultiPoint
 * @param {Array.<GeometryPoint>} components - 几何对象数组。
 * @example
 * var point1 = new GeometryPoint(10,20);
 * var point2 = new GeometryPoint(30,40);
 * var curve = new Curve([point1,point2]);
 * @usage
 */
class Curve extends MultiPoint {

    constructor(components) {
        super(components);
        /**
         * @member {Array.<string>} [GeometryCurve.prototype.componentTypes=["SuperMap.Geometry.Point", "SuperMap.PointWithMeasure"]]
         * @description components 存储的几何对象所支持的几何类型数组。
         * @readonly
         */
        this.componentTypes = ["SuperMap.Geometry.Point", "SuperMap.PointWithMeasure"];
        this.CLASS_NAME = "SuperMap.Geometry.Curve";
        this.geometryType = "Curve";

    }


}

;// CONCATENATED MODULE: ./src/common/commontypes/geometry/LineString.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/



/**
 * @class GeometryLineString
 * @aliasclass Geometry.LineString
 * @deprecatedclass SuperMap.Geometry.LineString
 * @classdesc 几何对象线串类。
 * @category BaseTypes Geometry
 * @param {Array.<GeometryPoint>} points - 用来生成线串的点数组。
 * @extends GeometryCurve
 * @example
 * var points = [new GeometryPoint(4933.319287022352, -3337.3849141502124),
 *     new GeometryPoint(4960.9674060199022, -3349.3316322355736),
 *     new GeometryPoint(5006.0235999418364, -3358.8890067038628),
 *     new GeometryPoint(5075.3145648369318, -3378.0037556404409),
 *     new GeometryPoint(5305.19551436013, -3376.9669111768926)],
 * var roadLine = new GeometryLineString(points)；
 * @usage
 */
class LineString extends Curve {

    constructor(points) {
        super(points);
        this.CLASS_NAME = "SuperMap.Geometry.LineString";
        this.geometryType = "LineString";
    }

    /**
     * @function GeometryLineString.prototype.removeComponent
     * @description 只有在线串上有三个或更多的点的时候，才会允许移除点（否则结果将会是单一的点）。
     * @param {GeometryPoint} point - 将被删除的点。
     * @returns {boolean} 删除的点。
     */
    removeComponent(point) { // eslint-disable-line no-unused-vars
        var removed = this.components && (this.components.length > 2);
        if (removed) {
            super.removeComponent.apply(this, arguments);
        }
        return removed;
    }

    /**
     * @function GeometryLineString.prototype.getSortedSegments
     * @description 获取升序排列的点坐标对象数组。
     * @returns {Array} 升序排列的点坐标对象数组。
     */
    getSortedSegments() {
        var numSeg = this.components.length - 1;
        var segments = new Array(numSeg), point1, point2;
        for (var i = 0; i < numSeg; ++i) {
            point1 = this.components[i];
            point2 = this.components[i + 1];
            if (point1.x < point2.x) {
                segments[i] = {
                    x1: point1.x,
                    y1: point1.y,
                    x2: point2.x,
                    y2: point2.y
                };
            } else {
                segments[i] = {
                    x1: point2.x,
                    y1: point2.y,
                    x2: point1.x,
                    y2: point1.y
                };
            }
        }

        // more efficient to define this somewhere static
        function byX1(seg1, seg2) {
            return seg1.x1 - seg2.x1;
        }

        return segments.sort(byX1);
    }

    /**
     * @function GeometryLineString.prototype.getVertices
     * @description 返回几何图形的所有顶点的列表。
     * @param {boolean} [nodes] - 对于线来说，仅仅返回作为端点的顶点，如果设为 false，则返回非端点的顶点，如果没有设置此参数，则返回所有顶点。
     * @returns {Array} 几何图形的顶点列表。
     */
    getVertices(nodes) {
        var vertices;
        if (nodes === true) {
            vertices = [
                this.components[0],
                this.components[this.components.length - 1]
            ];
        } else if (nodes === false) {
            vertices = this.components.slice(1, this.components.length - 1);
        } else {
            vertices = this.components.slice();
        }
        return vertices;
    }

    /**
     * @function GeometryLineString.calculateCircle
     * @description 三点画圆弧。
     * @param {Array.<GeometryPoint>} points - 传入的待计算的初始点串。
     * @returns {Array.<GeometryPoint>} 计算出相应的圆弧控制点。
     * @example
     * var points = [];
     * points.push(new GeometryPoint(-50,30));
     * points.push(new GeometryPoint(-30,50));
     * points.push(new GeometryPoint(2,60));
     * var circle = GeometryLineString.calculateCircle(points);
     */
    static calculateCircle(points) {
        if (points.length < 3) {
            return points
        }
        var centerPoint = {},
            p1 = points[0],
            p2 = points[1],
            p3 = points[2];
        var R = 0,
            dStep = 0,
            direc = true,
            dRotation = 0,
            dRotationBegin = 0,
            dRotationAngle = 0,
            nSegmentCount = 72,
            circlePoints = [];

        var KTan13 = (p3.y - p1.y) / (p3.x - p1.x);
        var B13 = p3.y - KTan13 * p3.x;
        if ((((p3.x != p1.x) && (p3.y != p1.y)) && (p2.y == KTan13 * p2.x + B13)) ||
            ((p3.x == p1.x) && (p2.x == p1.x)) || ((p3.y == p1.y) && (p2.y == p1.y)) ||
            ((p3.x == p1.x) && (p3.y == p1.y)) || ((p3.x == p2.x) && (p3.y == p2.y)) || ((p1.x == p2.x) && (p1.y == p2.y))) {
            circlePoints.push(p1);
            circlePoints.push(p2);
            circlePoints.push(p3);
        } else {
            var D = ((p2.x * p2.x + p2.y * p2.y) - (p1.x * p1.x + p1.y * p1.y)) * (2 * (p3.y - p1.y)) - ((p3.x * p3.x + p3.y * p3.y) -
                (p1.x * p1.x + p1.y * p1.y)) * (2 * (p2.y - p1.y));
            var E = (2 * (p2.x - p1.x)) * ((p3.x * p3.x + p3.y * p3.y) - (p1.x * p1.x + p1.y * p1.y)) -
                (2 * (p3.x - p1.x)) * ((p2.x * p2.x + p2.y * p2.y) - (p1.x * p1.x + p1.y * p1.y));
            var F = 4 * ((p2.x - p1.x) * (p3.y - p1.y) - (p3.x - p1.x) * (p2.y - p1.y));
            centerPoint.x = D / F;
            centerPoint.y = E / F;
            R = Math.sqrt((p1.x - centerPoint.x) * (p1.x - centerPoint.x) + (p1.y - centerPoint.y) * (p1.y - centerPoint.y));

            var dis = (p1.x - p3.x) * (p1.x - p3.x) + (p1.y - p3.y) * (p1.y - p3.y);
            var cons = (2 * R * R - dis) / (2 * R * R);
            cons = cons >= 1 ? 1 : cons;
            cons = cons <= -1 ? -1 : cons;
            dRotationAngle = Math.acos(cons) * 180 / Math.PI;

            if (p3.x == p1.x) {
                dRotationAngle = ((centerPoint.x > p1.x && p2.x > p1.x) || (centerPoint.x < p1.x && p2.x < p1.x)) ? (360 - dRotationAngle) : dRotationAngle;
            } else {
                dRotationAngle = ((centerPoint.y > (KTan13 * centerPoint.x + B13) && p2.y > (KTan13 * p2.x + B13)) ||
                    (centerPoint.y < (KTan13 * centerPoint.x + B13) && p2.y < (KTan13 * p2.x + B13))) ? (360 - dRotationAngle) : dRotationAngle;
            }
            dStep = dRotationAngle / 72;

            if (p3.y != p1.y) {
                if (p3.x == p1.x) {
                    if (p3.y > p1.y) {
                        if (p2.x < p1.x) {
                            direc = false;
                        }
                    } else {
                        if (p2.x > p1.x) {
                            direc = false;
                        }
                    }
                } else if (p3.x < p1.x) {
                    if (p2.y < KTan13 * p2.x + B13) {
                        direc = false;
                    }
                } else {
                    if (p2.y > KTan13 * p2.x + B13) {
                        direc = false;
                    }
                }
            } else {
                if (p3.x > p1.x) {
                    if (p2.y > p1.y) {
                        direc = false;
                    }
                } else {
                    if (p2.y < p1.y) {
                        direc = false;
                    }
                }
            }

            var K10 = (p1.y - centerPoint.y) / (p1.x - centerPoint.x);
            var atan10 = K10 >= 0 ? Math.atan(K10) * 180 / Math.PI : Math.abs(Math.atan(K10) * 180 / Math.PI) + 90;

            var CY = Math.abs(centerPoint.y);
            if ((p1.y == CY) && (CY == p3.y)) {
                if (p1.x < p3.x) {
                    atan10 = atan10 + 180;
                }
            }

            var newPY = p1.y - centerPoint.y;
            circlePoints.push(p1);
            for (var i = 1; i < nSegmentCount; i++) {
                dRotation = dStep * i;
                dRotationBegin = atan10;

                if (direc) {
                    if (newPY >= 0) {
                        if (K10 >= 0) {
                            dRotationBegin = dRotationBegin + dRotation;
                        } else {
                            dRotationBegin = (180 - (dRotationBegin - 90)) + dRotation;
                        }
                    } else {
                        if (K10 > 0) {
                            dRotationBegin = (dRotationBegin - 180) + dRotation;
                        } else {
                            dRotationBegin = (90 - dRotationBegin) + dRotation;
                        }
                    }
                } else {
                    if (newPY >= 0) {
                        if (K10 >= 0) {
                            dRotationBegin = dRotationBegin - dRotation;
                        } else {
                            dRotationBegin = (180 - (dRotationBegin - 90)) - dRotation;
                        }
                    } else {
                        if (K10 >= 0) {
                            dRotationBegin = (dRotationBegin - 180) - dRotation;
                        } else {
                            dRotationBegin = (90 - dRotationBegin) - dRotation;
                        }
                    }
                }

                dRotationBegin = dRotationBegin * Math.PI / 180;
                var x = centerPoint.x + R * Math.cos(dRotationBegin);
                var y = centerPoint.y + R * Math.sin(dRotationBegin);
                circlePoints.push(new Point(x, y));
            }
            circlePoints.push(p3);
        }
        return circlePoints;
    }

    /**
     * @function GeometryLineString.createLineEPS
     * @description 根据点的类型画出不同类型的曲线。
     * 点的类型有三种：LTypeArc，LTypeCurve，NONE。
     * @param {Array.<GeometryPoint>} points - 传入的待计算的初始点串。
     * @returns {Array.<GeometryPoint>} 计算出相应的 lineEPS 控制点。
     * @example
     * var points = [];
     * points.push(new GeometryPoint(-50,30));
     * points.push(new GeometryPoint(-30,50,"LTypeArc"));
     * points.push(new GeometryPoint(2,60));
     * points.push(new GeometryPoint(8,20));
     * var lineEPS = GeometryLineString.createLineEPS(points);
     */
    static createLineEPS(points) {
        var list = [],
            len = points.length;
        if (len < 2) {
            return points;
        }
        for (var i = 0; i < len;) {
            var type = points[i].type;
            if (type == 'LTypeArc') {
                var listObj = LineString.createLineArc(list, i, len, points);
                list = listObj[0];
                i = listObj[1];
            } else {
                list.push(points[i]);
                i++;
            }
        }
        return list;
    }

    static createLineArc(list, i, len, points) {
        if (i == 0) {
            let bezierPtsObj = LineString.addPointEPS(points, i, len, 'LTypeArc');
            Array.prototype.push.apply(list, bezierPtsObj[0]);
            i = bezierPtsObj[1] + 1;
        } else if (i == len - 1) {
            var bezierP = [points[i - 1], points[i]],
                bezierPts = LineString.calculateCircle(bezierP);
            Array.prototype.push.apply(list, bezierPts);
            i++;
        } else {
            let bezierPtsObj = LineString.addPointEPS(points, i, len, 'LTypeArc');
            list.pop();
            Array.prototype.push.apply(list, bezierPtsObj[0]);
            i = bezierPtsObj[1] + 1;
        }
        return [list, i];
    }

    static addPointEPS(points, i, len, type) {
        var bezierP = [], j = i + 1;
        if (i == 0) {
            Array.prototype.push.apply(bezierP, [points[i], points[i + 1]]);
        } else if (i == len - 1) {
            Array.prototype.push.apply(bezierP, [points[i - 1], points[i]]);
        } else {
            Array.prototype.push.apply(bezierP, [points[i - 1], points[i], points[i + 1]]);
        }
        var bezierPts;
        if (type == 'LTypeCurve') {
            bezierPts = LineString.calculatePointsFBZN(bezierP);
        } else if (type == 'LTypeArc') {
            bezierPts = LineString.calculateCircle(bezierP);
        }
        return [bezierPts, j];
    }
}



;// CONCATENATED MODULE: ./src/common/commontypes/geometry/LinearRing.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


/**
 * @class  GeometryLinearRing
 * @aliasclass Geometry.LinearRing
 * @deprecatedclass SuperMap.Geometry.LinearRing
 * @classdesc 几何对象线环类，是一个特殊的封闭的线串，在每次 addPoint/removePoint 之后会通过添加一个点（此点是复制的第一个点得到的）
 * 作为最后的一个点来自动关闭线环。
 * @category BaseTypes Geometry
 * @extends GeometryLineString
 * @param {Array.<GeometryPoint>} points - 组成线性环的点。
 * @example
 * var points = [new GeometryPoint(4933.319287022352, -3337.3849141502124),
 *      new GeometryPoint(4960.9674060199022, -3349.3316322355736),
 *      new GeometryPoint(5006.0235999418364, -3358.8890067038628),
 *      new GeometryPoint(5075.3145648369318, -3378.0037556404409),
 *      new GeometryPoint(5305.19551436013, -3376.9669111768926)],
 * var linearRing = new GeometryLinearRing(points);
 * @usage
 */
class LinearRing_LinearRing extends LineString {


    constructor(points) {
        super(points);
        /**
         * @member {Array.<string>} [GeometryLinearRing.prototype.componentTypes=["SuperMap.Geometry.Point"]]
         * @description components 存储的几何对象所支持的几何类型数组，为空表示类型不受限制。
         * @readonly
         */
        this.componentTypes = ["SuperMap.Geometry.Point"];
        this.CLASS_NAME = "SuperMap.Geometry.LinearRing";
        this.geometryType = "LinearRing";
    }

    /**
     * @function GeometryLinearRing.prototype.addComponent
     * @description 添加一个点到几何图形数组中，如果这个点将要被添加到组件数组的末端，并且与数组中已经存在的最后一个点相同，
     * 重复的点是不能被添加的。这将影响未关闭环的关闭。
     * 这个方法可以通过将非空索引（组件数组的下标）作为第二个参数重写。
     * @param {GeometryPoint} point - 点对象。
     * @param {number} [index] - 插入组件数组的下标。
     * @returns {boolean} 点对象是否添加成功。
     */
    addComponent(point, index) {
        var added = false;

        //remove last point
        var lastPoint = this.components.pop();

        // given an index, add the point
        // without an index only add non-duplicate points
        if (index != null || !point.equals(lastPoint)) {
            added = super.addComponent.apply(this, arguments);
        }

        //append copy of first point
        var firstPoint = this.components[0];
        super.addComponent.apply(this, [firstPoint]);

        return added;
    }

    /**
     * @function GeometryLinearRing.prototype.removeComponent
     * @description 从几何组件中删除一个点。
     * @param {GeometryPoint} point - 点对象。
     * @returns {boolean} 点对象是否删除。
     */
    removeComponent(point) { // eslint-disable-line no-unused-vars
        var removed = this.components && (this.components.length > 3);
        if (removed) {
            //remove last point
            this.components.pop();

            //remove our point
            super.removeComponent.apply(this, arguments);
            //append copy of first point
            var firstPoint = this.components[0];
            super.addComponent.apply(this, [firstPoint]);
        }
        return removed;
    }

    /**
     * @function GeometryLinearRing.prototype.getArea
     * @description 获得当前几何对象区域大小，如果是沿顺时针方向的环则是正值，否则为负值。
     * @returns {number} 环的面积。
     */
    getArea() {
        var area = 0.0;
        if (this.components && (this.components.length > 2)) {
            var sum = 0.0;
            for (var i = 0, len = this.components.length; i < len - 1; i++) {
                var b = this.components[i];
                var c = this.components[i + 1];
                sum += (b.x + c.x) * (c.y - b.y);
            }
            area = -sum / 2.0;
        }
        return area;
    }

    /**
     * @function GeometryLinearRing.prototype.getVertices
     * @description 返回几何图形的所有点的列表。
     * @param {boolean} [nodes] - 对于线来说，仅仅返回作为端点的顶点，如果设为 false ，则返回非端点的顶点，如果没有设置此参数，则返回所有顶点。
     * @returns {Array} 几何对象所有点的列表。
     */
    getVertices(nodes) {
        return (nodes === true) ? [] : this.components.slice(0, this.components.length - 1);
    }


}

;// CONCATENATED MODULE: ./src/common/commontypes/geometry/Polygon.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/





/**
 * @class GeometryPolygon
 * @aliasclass Geometry.Polygon
 * @deprecatedclass SuperMap.Geometry.Polygon
 * @classdesc  多边形几何对象类。
 * @category BaseTypes Geometry
 * @extends GeometryCollection
 * @param {Array.<GeometryLinearRing>} components - 多边形的线环数组。
 * @example
 * var points =[new GeometryPoint(0,4010338),
 *      new GeometryPoint(1063524,4010338),
 *      new GeometryPoint(1063524,3150322),
 *      new GeometryPoint(0,3150322)
 *  ],
 *  var linearRings = new GeometryLinearRing(points),
 *  var  region = new GeometryPolygon([linearRings]);
 * @usage
 */
class Polygon_Polygon extends Collection {


    constructor(components) {
        super(components);
        /**
         * @member {Array.<string>} [GeometryPolygon.prototype.componentTypes=["SuperMap.Geometry.LinearRing"]]
         * @description components 存储的几何对象所支持的几何类型数组。
         * @readonly
         */
        this.componentTypes = ["SuperMap.Geometry.LinearRing"];
        this.CLASS_NAME = "SuperMap.Geometry.Polygon";
        this.geometryType = "Polygon";
    }

    /**
     * @function GeometryPolygon.prototype.getArea
     * @description 获得区域面积，从区域的外部口径减去计此区域内部口径算所得的面积。
     * @returns {number} 几何对象的面积。
     */
    getArea() {
        var area = 0.0;
        if (this.components && (this.components.length > 0)) {
            area += Math.abs(this.components[0].getArea());
            for (var i = 1, len = this.components.length; i < len; i++) {
                area -= Math.abs(this.components[i].getArea());
            }
        }
        return area;
    }


}

;// CONCATENATED MODULE: ./src/common/commontypes/Feature.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


/**
 * @class Feature
 * @deprecatedclass SuperMap.Feature
 * @category BaseTypes Geometry
 * @classdesc 要素类组合了地理和属性，Feature 类同时具有 marker 和 lonlat 属性。
 * @param {SuperMap.Layer} layer - 图层。
 * @param {LonLat} lonlat - 经纬度。
 * @param {Object} data - 数据对象。
 * @usage
 */
class Feature_Feature {


    constructor(layer, lonlat, data) {
        this.CLASS_NAME = "SuperMap.Feature";
        /**
         * @deprecated
         * @member {SuperMap.Layer} Feature.prototype.layer
         * @description 图层。
         */
        this.layer = layer;

        /**
         * @member {string} Feature.prototype.id
         * @description 要素 ID。
         */
        this.id = Util_Util.createUniqueID(this.CLASS_NAME + "_");

        /**
         * @member {LonLat} Feature.prototype.lonlat
         * @description 经纬度。
         *
         */
        this.lonlat = lonlat;

        /**
         * @member {Object} Feature.prototype.data
         * @description 数据对象。
         */
        this.data = (data != null) ? data : {};

    }

    /**
     * @function Feature.prototype.destroy
     * @description 释放相关资源。
     */
    destroy() {
        this.id = null;
        this.lonlat = null;
        this.data = null;
    }
}

;// CONCATENATED MODULE: ./src/common/commontypes/Vector.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/



/**
 * @class FeatureVector
 * @aliasclass Feature.Vector
 * @deprecatedclass SuperMap.Feature.Vector
 * @category BaseTypes Geometry
 * @classdesc 矢量要素类。该类具有 Geometry 属性存放几何信息，
 * attributes 属性存放非几何信息，另外还包含了 style 属性，用来定义矢量要素的样式，
 * 其中，默认的样式在 {@link FeatureVector.style} 类中定义，如果没有特别的指定将使用默认的样式。
 * @extends {Feature}
 * @param {Geometry} geometry - 要素的几何信息。
 * @param {Object} [attributes] - 描述要素的任意的可序列化属性，将要映射到 attributes 属性中的对象。
 * @param {Object} [style] - 样式对象。
 * @example
 * var geometry = new GeometryPoint(-115,10);
 *  var style = {
     *      strokeColor:"#339933",
     *      strokeOpacity:1,
     *      strokeWidth:3,
     *      pointRadius:6
     *  }
 *  var pointFeature = new FeatureVector(geometry,null,style);
 *  vectorLayer.addFeatures(pointFeature);
 * @usage
 */
// TRASH THIS
const State = {
  /** states */
  UNKNOWN: 'Unknown',
  INSERT: 'Insert',
  UPDATE: 'Update',
  DELETE: 'Delete'
};
class Vector extends Feature_Feature {


    constructor(geometry, attributes, style) {
        super(null, null, attributes);
        /**
         * @member {string} FeatureVector.prototype.fid
         * @description fid。
         */
        this.fid = null;

        /**
         * @member {Geometry} FeatureVector.prototype.geometry
         * @description 存放几何信息。
         */
        this.geometry = geometry ? geometry : null;

        /**
         * @member {Object} FeatureVector.prototype.attributes
         * @description 描述要素的任意的可序列化属性。
         */
        this.attributes = {};

        if (attributes) {
            this.attributes = Util_Util.extend(this.attributes, attributes);
        }

        /**
         * @member {Bounds} FeatureVector.prototype.bounds
         * @description 限制要素几何的边界。
         */
        this.bounds = null;

        /**
         * @member {string} FeatureVector.prototype.state
         * @description state。
         */
        this.state = null;

        /**
         * @member {Object} FeatureVector.prototype.style
         * @description 要素的样式属性，地图查询返回的 feature 的 style，8C 变为null。
         */
        this.style = style ? style : null;

        /**
         * @member {string} FeatureVector.prototype.url
         * @description 如果设置了这个属性，在更新或者删除要素时需要考虑 {@link HTTP} 。
         */
        this.url = null;

        this.lonlat = null;

        this.CLASS_NAME = "SuperMap.Feature.Vector";

        Vector.style = {
            'default': {
                fillColor: "#ee9900",
                fillOpacity: 0.4,
                hoverFillColor: "white",
                hoverFillOpacity: 0.8,
                strokeColor: "#ee9900",
                strokeOpacity: 1,
                strokeWidth: 1,
                strokeLinecap: "round",
                strokeDashstyle: "solid",
                hoverStrokeColor: "red",
                hoverStrokeOpacity: 1,
                hoverStrokeWidth: 0.2,
                pointRadius: 6,
                hoverPointRadius: 1,
                hoverPointUnit: "%",
                pointerEvents: "visiblePainted",
                cursor: "inherit",
                fontColor: "#000000",
                labelAlign: "cm",
                labelOutlineColor: "white",
                labelOutlineWidth: 3
            },
            'select': {
                fillColor: "blue",
                fillOpacity: 0.4,
                hoverFillColor: "white",
                hoverFillOpacity: 0.8,
                strokeColor: "blue",
                strokeOpacity: 1,
                strokeWidth: 2,
                strokeLinecap: "round",
                strokeDashstyle: "solid",
                hoverStrokeColor: "red",
                hoverStrokeOpacity: 1,
                hoverStrokeWidth: 0.2,
                pointRadius: 6,
                hoverPointRadius: 1,
                hoverPointUnit: "%",
                pointerEvents: "visiblePainted",
                cursor: "pointer",
                fontColor: "#000000",
                labelAlign: "cm",
                labelOutlineColor: "white",
                labelOutlineWidth: 3

            },
            'temporary': {
                fillColor: "#66cccc",
                fillOpacity: 0.2,
                hoverFillColor: "white",
                hoverFillOpacity: 0.8,
                strokeColor: "#66cccc",
                strokeOpacity: 1,
                strokeLinecap: "round",
                strokeWidth: 2,
                strokeDashstyle: "solid",
                hoverStrokeColor: "red",
                hoverStrokeOpacity: 1,
                hoverStrokeWidth: 0.2,
                pointRadius: 6,
                hoverPointRadius: 1,
                hoverPointUnit: "%",
                pointerEvents: "visiblePainted",
                //cursor:"inherit",
                cursor: "default",
                fontColor: "#000000",
                labelAlign: "cm",
                labelOutlineColor: "white",
                labelOutlineWidth: 3

            },
            'delete': {
                display: "none"
            }
        };
    }

    /**
     * @function FeatureVector.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        if (this.layer) {
            this.layer.removeFeatures(this);
            this.layer = null;
        }

        this.geometry = null;
        super.destroy();
    }

    /**
     * @function FeatureVector.prototype.clone
     * @description 复制矢量要素，并返回复制后的新对象。
     * @returns {FeatureVector} 相同要素的新的矢量要素。
     */
    clone() {
        return new Vector(
            this.geometry ? this.geometry.clone() : null,
            this.attributes,
            this.style);
    }

    /**
     * @function FeatureVector.prototype.toState
     * @description 设置新状态。
     * @param {string} state - 状态。
     */
    toState(state) {
        if (state === State.UPDATE) {
            switch (this.state) {
                case State.UNKNOWN:
                case State.DELETE:
                    this.state = state;
                    break;
                case State.UPDATE:
                case State.INSERT:
                    break;
            }
        } else if (state === State.INSERT) {
            switch (this.state) {
                case State.UNKNOWN:
                    break;
                default:
                    this.state = state;
                    break;
            }
        } else if (state === State.DELETE) {
            switch (this.state) {
                case State.INSERT:
                    // the feature should be destroyed
                    break;
                case State.DELETE:
                    break;
                case State.UNKNOWN:
                case State.UPDATE:
                    this.state = state;
                    break;
            }
        } else if (state === State.UNKNOWN) {
            this.state = state;
        }
    }
}
/**
 *
 * @typedef {Object} FeatureVector.style
 * @description Feature 有大量的样式属性，如果没有特别的指定将使用默认的样式，
 * 大部分样式通过 SVG 标准定义属性。
 * - fill properties 资料介绍：{@link http://www.w3.org/TR/SVG/painting.html#FillProperties}
 * - stroke properties 资料介绍：{@link http://www.w3.org/TR/SVG/painting.html#StrokeProperties}
 * @property {boolean} [fill] - 不需要填充则设置为 false。
 * @property {string} [fillColor='#ee9900'] - 十六进制填充颜色。
 * @property {number} [fillOpacity=0.4] - 填充不透明度。
 * @property {boolean} [stroke] - 不需要描边则设为 false。
 * @property {string} [strokeColor='#ee9900'] - 十六进制描边颜色。
 * @property {number} [strokeOpacity=0.4] - 描边的不透明度(0-1)。
 * @property {number} [strokeWidth=1] - 像素描边宽度。
 * @property {string} [strokeLinecap='round'] - strokeLinecap 有三种类型 butt，round，square。
 * @property {string} [strokeDashstyle='solid'] - 有 dot，dash，dashdot，longdash，longdashdot，solid 几种样式。
 * @property {boolean} [graphic] - 不需要则设置为 false。
 * @property {number} [pointRadius=6] - 像素点半径。
 * @property {string} [pointerEvents='visiblePainted'] - pointerEvents。
 * @property {string} [cursor] - cursor。
 * @property {boolean} [allowRotate='false'] - 是否允许图标随着运行方向旋转。用于时空数据图层。
 * @property {string} [externalGraphic] - 连接到用来渲染点的外部的图形。
 * @property {number} [graphicWidth] - 外部图表的像素宽度。
 * @property {number} [graphicHeight] - 外部图表的像素高度。
 * @property {number} [graphicOpacity] - 外部图表的不透明度(0-1)。
 * @property {number} [graphicXOffset] - 外部图表沿着x方向的偏移量。
 * @property {number} [graphicYOffset] - 外部图表沿着y方向的偏移量。
 * @property {number} [rotation] - 一个图表沿着其中心点（或者偏移中心指定点）在顺时针方向旋转。
 * @property {number} [graphicZIndex] - 渲染时使用的索引值。
 * @property {string} [graphicName='circle'] - 渲染点时图标使用的名字。支持"circle" , "square", "star", "x", "cross", "triangle"。
 * @property {string} [graphicTitle] - 外部图表的提示框。
 * @property {string} [backgroundGraphic] - 外部图表的背景。
 * @property {number} [backgroundGraphicZIndex] - 背景图渲染时使用的索引值。
 * @property {number} [backgroundXOffset] - 背景图在 x 轴的偏移量。
 * @property {number} [backgroundYOffset] - 背景图在 y 轴的偏移量。
 * @property {number} [backgroundHeight] - 背景图的高度。如果没有设置，将用 graphicHeight。
 * @property {number} [backgroundWidth] - 背景图的宽度。如果没有设置，将用 graphicWidth。
 * @property {boolean} [isUnicode=false] - 这个属性要配合 label 属性来用，当为 true时，label 就可以使用 unicode 编码，
 * 比如 "a" 的 unicode 十六进制编码为 61，则 label 属性可以为 "&#x61;",其中 "&#" 为前缀，标志这个为 unicode 编码，
 * "x" 是指 16 进制,这时页面显示的是 "a"；当此值为 false 的时候，label 的内容会被直接输出，
 * 比如，label 为 "&#x61;"，这时页面显示的也是 "&#x61;"。
 * @property {string} [label] - 可选的标签文本。
 * @property {string} [labelAlign='cm'] - 标签对齐，是由两个字符组成的字符串，如："lt", "cm", "rb"，
 * 其中第一个字符代表水平方向上的对齐，"l"=left, "c"=center, "r"=right；
 * 第二个字符代表垂直方向上的对齐，"t"=top, "m"=middle, "b"=bottom。
 * @property {number} [labelXOffset] - 标签在 x 轴方向的偏移量。
 * @property {number} [labelYOffset] - 标签在 y 轴方向的偏移量。
 * @property {boolean} [labelSelect=false] - 如果设为 true，标签可以选用 SelectFeature 或者 similar 控件。
 * @property {string} [fontColor='#000000'] - 标签字体颜色。
 * @property {number} [fontOpacity] - 标签透明度 (0-1)。
 * @property {string} [fontFamily] - 标签的字体类型。
 * @property {string} [fontSize] - 标签的字体大小。
 * @property {string} [fontStyle] - 标签的字体样式。
 * @property {string} [fontWeight] - 标签的字体粗细。
 * @property {string} [display] - 如果 display 属性设置为 “none”，符号将没有任何效果。
 * @example
 *  // label的用法如下：
 *  function addGeoTest(){
 *  var geometry = new GeometryPoint(105, 35);
 *  var pointFeature = new FeatureVector(geometry);
 *  var styleTest = {
 *        label:"supermap",
 *        fontColor:"#0000ff",
 *        fontOpacity:"0.5",
 *        fontFamily:"隶书",
 *        fontSize:"8em",
 *        fontWeight:"bold",
 *        fontStyle:"italic",
 *        labelSelect:"true",
 *     }
 *           pointFeature.style = styleTest;
 *          vectorLayer.addFeatures([pointFeature]);
 * }
     */



;// CONCATENATED MODULE: ./src/common/format/Format.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


/**
 * @class Format
 * @deprecatedclass SuperMap.Format
 * @classdesc 读写各种格式的格式类基类。其子类应该包含并实现 read 和 write 方法。
 * @category BaseTypes Format
 * @param {Object} options - 可选参数。
 * @param {boolean} [options.keepData=false] - 如果设置为 true， data 属性会指向被解析的对象（例如 JSON 或 xml 数据对象）。
 * @param {Object} [options.data] - 当 keepData 属性设置为 true，这是传递给 read 操作的要被解析的字符串。
 * @usage
 */
class Format {


    constructor(options) {
        /**
         * @member {Object} Format.prototype.data
         * @description 当 keepData 属性设置为 true，这是传递给 read 操作的要被解析的字符串。
         */
        this.data = null;

        /**
         * @member {Object} [Format.prototype.keepData=false]
         * @description 保持最近读到的数据的引用（通过 data 属性）。
         */
        this.keepData = false;

        Util_Util.extend(this, options);
        this.options = options;

        this.CLASS_NAME = "SuperMap.Format";
    }

    /**
     * @function Format.prototype.destroy
     * @description 销毁该格式类，释放相关资源。
     */
    destroy() {
        //用来销毁该格式类，释放相关资源
    }

    /**
     * @function Format.prototype.read
     * @description 来从字符串中读取数据。
     * @param {string} data - 读取的数据。
     */
    read(data) { // eslint-disable-line no-unused-vars
        //用来从字符串中读取数据
    }

    /**
     * @function Format.prototype.write
     * @description 将对象写成字符串。
     * @param {Object} object - 可序列化的对象。
     * @returns {string} 对象转化后的字符串。
     */
    write(object) { // eslint-disable-line no-unused-vars
        //用来写字符串
    }
}

;// CONCATENATED MODULE: ./src/common/format/JSON.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


/**
 * @class JSONFormat
 * @aliasclass Format.JSON
 * @deprecatedclass SuperMap.Format.JSON
 * @classdesc 安全的读写 JSON 的解析类。使用 {@link JSONFormat} 构造函数创建新实例。
 * @category BaseTypes Format
 * @param {Object} [options] - 可选参数。
 * @param {string} [options.indent="    "] - 用于格式化输出，indent 字符串会在每次缩进的时候使用一次。
 * @param {string} [options.space=" "] - 用于格式化输出，space 字符串会在名值对的 ":" 后边添加。
 * @param {string} [options.newline="\n"] - 用于格式化输出, newline 字符串会用在每一个名值对或数组项末尾。
 * @param {number} [options.level=0] - 用于格式化输出, 表示的是缩进级别。
 * @param {boolean} [options.pretty=false] - 是否在序列化的时候使用额外的空格控制结构。在 write 方法中使用。
 * @param {boolean} [options.nativeJSON] - 需要被注册的监听器对象。
 * @extends {Format}
 * @usage
 */
class JSONFormat extends Format {

    constructor(options) {
        super(options);
        /**
         * @member {string} [JSONFormat.prototype.indent="    "]
         * @description 用于格式化输出，indent 字符串会在每次缩进的时候使用一次。
         */
        this.indent = "    ";

        /**
         * @member {string} [JSONFormat.prototype.space=" "]
         * @description 用于格式化输出，space 字符串会在名值对的 ":" 后边添加。
         */
        this.space = " ";

        /**
         * @member {string} [JSONFormat.prototype.newline="\n"]
         * @description 用于格式化输出, newline 字符串会用在每一个名值对或数组项末尾。
         */
        this.newline = "\n";

        /**
         * @member {number} [JSONFormat.prototype.level=0]
         * @description 用于格式化输出, 表示的是缩进级别。
         */
        this.level = 0;

        /**
         * @member {boolean} [JSONFormat.prototype.pretty=false]
         * @description 是否在序列化的时候使用额外的空格控制结构。在 write 方法中使用。
         */
        this.pretty = false;

        /**
         * @member {boolean} JSONFormat.prototype.nativeJSON
         * @description 判断浏览器是否原生支持 JSON 格式数据。
         */
        this.nativeJSON = (function () {
            return !!(window.JSON && typeof JSON.parse === "function" && typeof JSON.stringify === "function");
        })();

        this.CLASS_NAME = "SuperMap.Format.JSON";
        /**
         * @member JSONFormat.prototype.serialize
         * @description 提供一些类型对象转 JSON 字符串的方法。
         */
        this.serialize = {
            /**
             * @function JSONFormat.serialize.object
             * @description 把对象转换为 JSON 字符串。
             * @param {Object} object - 可序列化的对象。
             * @returns {string} JSON 字符串。
             */
            'object': function (object) {
                // three special objects that we want to treat differently
                if (object == null) {
                    return "null";
                }
                if (object.constructor === Date) {
                    return this.serialize.date.apply(this, [object]);
                }
                if (object.constructor === Array) {
                    return this.serialize.array.apply(this, [object]);
                }
                var pieces = ['{'];
                this.level += 1;
                var key, keyJSON, valueJSON;

                var addComma = false;
                for (key in object) {
                    if (object.hasOwnProperty(key)) {
                        // recursive calls need to allow for sub-classing
                        keyJSON = this.write.apply(this,
                            [key, this.pretty]);
                        valueJSON = this.write.apply(this,
                            [object[key], this.pretty]);
                        if (keyJSON != null && valueJSON != null) {
                            if (addComma) {
                                pieces.push(',');
                            }
                            pieces.push(this.writeNewline(), this.writeIndent(),
                                keyJSON, ':', this.writeSpace(), valueJSON);
                            addComma = true;
                        }
                    }
                }

                this.level -= 1;
                pieces.push(this.writeNewline(), this.writeIndent(), '}');
                return pieces.join('');
            },

            /**
             * @function JSONFormat.serialize.array
             * @description 把数组转换成 JSON 字符串。
             * @param {Array} array - 可序列化的数组。
             * @returns {string} JSON 字符串。
             */
            'array': function (array) {
                var json;
                var pieces = ['['];
                this.level += 1;

                for (var i = 0, len = array.length; i < len; ++i) {
                    // recursive calls need to allow for sub-classing
                    json = this.write.apply(this,
                        [array[i], this.pretty]);
                    if (json != null) {
                        if (i > 0) {
                            pieces.push(',');
                        }
                        pieces.push(this.writeNewline(), this.writeIndent(), json);
                    }
                }

                this.level -= 1;
                pieces.push(this.writeNewline(), this.writeIndent(), ']');
                return pieces.join('');
            },

            /**
             * @function JSONFormat.serialize.string
             * @description 把字符串转换成 JSON 字符串。
             * @param {string} string - 可序列化的字符串。
             * @returns {string} JSON 字符串。
             */
            'string': function (string) {
                // If the string contains no control characters, no quote characters, and no
                // backslash characters, then we can simply slap some quotes around it.
                // Otherwise we must also replace the offending characters with safe
                // sequences.
                var m = {
                    '\b': '\\b',
                    '\t': '\\t',
                    '\n': '\\n',
                    '\f': '\\f',
                    '\r': '\\r',
                    '"': '\\"',
                    '\\': '\\\\'
                };
                /*eslint-disable no-control-regex*/
                if (/["\\\x00-\x1f]/.test(string)) {
                    return '"' + string.replace(/([\x00-\x1f\\"])/g, function (a, b) {
                        var c = m[b];
                        if (c) {
                            return c;
                        }
                        c = b.charCodeAt();
                        return '\\u00' +
                            Math.floor(c / 16).toString(16) +
                            (c % 16).toString(16);
                    }) + '"';
                }
                return '"' + string + '"';
            },

            /**
             * @function JSONFormat.serialize.number
             * @description 把数字转换成 JSON 字符串。
             * @param {number} number - 可序列化的数字。
             * @returns {string} JSON 字符串。
             */
            'number': function (number) {
                return isFinite(number) ? String(number) : "null";
            },

            /**
             * @function JSONFormat.serialize.boolean
             * @description Transform a boolean into a JSON string.
             * @param {boolean} bool - The boolean to be serialized.
             * @returns {string} A JSON string representing the boolean.
             */
            'boolean': function (bool) {
                return String(bool);
            },

            /**
             * @function JSONFormat.serialize.object
             * @description 将日期对象转换成 JSON 字符串。
             * @param {Date} date - 可序列化的日期对象。
             * @returns {string} JSON 字符串。
             */
            'date': function (date) {
                function format(number) {
                    // Format integers to have at least two digits.
                    return (number < 10) ? '0' + number : number;
                }

                return '"' + date.getFullYear() + '-' +
                    format(date.getMonth() + 1) + '-' +
                    format(date.getDate()) + 'T' +
                    format(date.getHours()) + ':' +
                    format(date.getMinutes()) + ':' +
                    format(date.getSeconds()) + '"';
            }
        };
    }

    /**
     * @function JSONFormat.prototype.read
     * @description 将一个符合 JSON 结构的字符串进行解析。
     * @param {string} json - 符合 JSON 结构的字符串。
     * @param {function} filter - 过滤方法，最终结果的每一个键值对都会调用该过滤方法，并在对应的值的位置替换成该方法返回的值。
     * @returns {(Object|string|Array|number|boolean)} 对象，数组，字符串或数字。
     */
    read(json, filter) {
        var object;
        if (this.nativeJSON) {
            try {
                object = JSON.parse(json, filter);
            } catch (e) {
                // Fall through if the regexp test fails.
                return { data: json}
            }
        }

        if (this.keepData) {
            this.data = object;
        }

        return object;
    }

    /**
     * @function JSONFormat.prototype.write
     * @description 序列化一个对象到一个符合 JSON 格式的字符串。
     * @param {Object|string|Array|number|boolean} value - 需要被序列化的对象，数组，字符串，数字，布尔值。
     * @param {boolean} [pretty=false] - 是否在序列化的时候使用额外的空格控制结构。在 write 方法中使用。
     * @returns {string} 符合 JSON 格式的字符串。
     *
     */
    write(value, pretty) {
        this.pretty = !!pretty;
        var json = null;
        var type = typeof value;
        if (this.serialize[type]) {
            try {
                json = (!this.pretty && this.nativeJSON) ?
                    JSON.stringify(value) :
                    this.serialize[type].apply(this, [value]);
            } catch (err) {
                //console.error("Trouble serializing: " + err);
            }
        }
        return json;
    }

    /**
     * @function JSONFormat.prototype.writeIndent
     * @description 根据缩进级别输出一个缩进字符串。
     * @private
     * @returns {string} 一个适当的缩进字符串。
     */
    writeIndent() {
        var pieces = [];
        if (this.pretty) {
            for (var i = 0; i < this.level; ++i) {
                pieces.push(this.indent);
            }
        }
        return pieces.join('');
    }

    /**
     * @function JSONFormat.prototype.writeNewline
     * @description 在格式化输出模式情况下输出代表新一行的字符串。
     * @private
     * @returns {string} 代表新的一行的字符串。
     */
    writeNewline() {
        return (this.pretty) ? this.newline : '';
    }

    /**
     * @function JSONFormat.prototype.writeSpace
     * @private
     * @description 在格式化输出模式情况下输出一个代表空格的字符串。
     * @returns {string} 空格字符串。
     */
    writeSpace() {
        return (this.pretty) ? this.space : '';
    }

}

;// CONCATENATED MODULE: ./src/common/commontypes/geometry/MultiLineString.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/




/**
 * @class GeometryMultiLineString
 * @aliasclass Geometry.MultiLineString
 * @deprecatedclass SuperMap.Geometry.MultiLineString
 * @classdesc 几何对象多线类。
 * @category BaseTypes Geometry
 * @extends GeometryCollection
 * @param {Array.<GeometryLineString>} components - GeometryLineString 数组。
 * @example
 * var multi = new GeometryMultiLineString([
 *      new GeometryLineString([
 *          new GeometryPoint(1, 0),
 *          new GeometryPoint(0, 1)
 *      ])
 *  ]);
 * @usage
 */
class MultiLineString extends Collection {


    constructor(components) {
        super(components);
        /**
         * @member {Array.<string>} [GeometryMultiLineString.prototype.componentTypes=["SuperMap.Geometry.LineString"]]
         * @description components 存储的几何对象所支持的几何类型数组。
         * @readonly
         */
        this.componentTypes = ["SuperMap.Geometry.LineString"];
        this.CLASS_NAME = "SuperMap.Geometry.MultiLineString";
        this.geometryType = "MultiLineString";
    }


}

;// CONCATENATED MODULE: ./src/common/commontypes/geometry/MultiPolygon.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


/**
 * @class GeometryMultiPolygon
 * @aliasclass Geometry.MultiPolygon
 * @deprecatedclass SuperMap.Geometry.MultiPolygon
 * @classdesc 几何对象多多边形类。
 * @category BaseTypes Geometry
 * @extends GeometryCollection
 * @param  {Array.<GeometryPolygon>} components - 形成 GeometryMultiPolygon 的多边形数组。
 * @example
 * var points1 = [new GeometryPoint(10,10),new GeometryPoint(0,0)];
 * var points2 = [new GeometryPoint(10,10),new GeometryPoint(0,0),new GeometryPoint(3,3),new GeometryPoint(10,10)];
 *
 * var linearRing1 = new GeometryLinearRing(points1);
 * var linearRing2 = new GeometryLinearRing(points2);
 *
 * var polygon1 = new GeometryPolygon([linearRing1]);
 * var polygon2 = new GeometryPolygon([linearRing2]);
 *
 * var multiPolygon1 = new GeometryMultiPolygon([polygon1,polygon2]);
 * @usage
 */
class MultiPolygon extends Collection {


    constructor(components) {
        super(components);
        /**
         * @member {Array.<string>} [GeometryMultiPolygon.prototype.componentTypes=["SuperMap.Geometry.Polygon"]]
         * @description components 存储的几何对象所支持的几何类型数组。
         * @readonly
         */
        this.componentTypes = ["SuperMap.Geometry.Polygon"];
        this.CLASS_NAME = "SuperMap.Geometry.MultiPolygon";
        this.geometryType = "MultiPolygon";
    }


}

;// CONCATENATED MODULE: ./src/common/iServer/ServerColor.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/

/**
 * @class ServerColor
 * @deprecatedclass SuperMap.ServerColor
 * @category iServer Map Theme
 * @classdesc 颜色类。该类使用三原色（ RGB ）来表达颜色。
 * @param {Object} options - 可选参数。
 * @param {number} [options.red=255] - 获取或设置红色值。
 * @param {number} [options.green=0] - 获取或设置绿色值。
 * @param {number} [options.blue=0] - 获取或设置蓝色值。
 * @usage
 */
class ServerColor {

    constructor(red, green, blue) {

        /**
         * @member {number} [ServerColor.prototype.red=255]
         * @description 获取或设置红色值。
         */
        this.red = (!red && red != 0)?255:red;

        /**
         * @member {number} [ServerColor.prototype.green=0]
         * @description 获取或设置绿色值。
         */
        this.green = green||0;

        /**
         * @member {number} [ServerColor.prototype.blue=0]
         * @description 获取或设置蓝色值。
         */
        this.blue = blue||0;

        this.CLASS_NAME = "SuperMap.ServerColor";
    }

    /**
     * @function ServerColor.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        var me = this;
        me.red = null;
        me.green = null;
        me.blue = null;
    }


    /**
     * @function ServerColor.formJson
     * @description 将 JSON 对象转化为 ServerColor 对象。
     * @param {Object} jsonObject - 要转换的 JSON 对象。
     * @returns {ServerColor} 转化后的 ServerColor 对象。
     */
    static fromJson(jsonObject) {
        if (!jsonObject) {
            return;
        }
        var color = new ServerColor();
        var red = 255;
        if (jsonObject.red !== null) {
            red = Number(jsonObject.red);
        }
        color.red = red;

        var green = 0;
        if (jsonObject.green !== null) {
            green = Number(jsonObject.green);
        }
        color.green = green;

        var blue = 0;
        if (jsonObject.blue !== null) {
            blue = Number(jsonObject.blue);
        }
        color.blue = blue;
        return color;
    }

}



;// CONCATENATED MODULE: ./src/common/iServer/ServerStyle.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/



/**
 * @class ServerStyle
 * @deprecatedclass SuperMap.ServerStyle
 * @category  iServer Map Theme
 * @classdesc 服务端矢量要素风格类。该类用于定义点状符号、线状符号、填充符号风格及其相关属性。
 * @param {Object} options - 参数。
 * @param {FillGradientMode} options.fillGradientMode - 渐变填充风格的渐变类型。
 * @param {ServerColor} [options.fillBackColor=[255,255,255]] - 填充背景颜色。
 * @param {boolean} [options.fillBackOpaque=false] - 背景是否不透明。
 * @param {ServerColor} [options.fillForeColor=[255,0,0]] - 填充颜色。
 * @param {number} [options.fillGradientAngle=0] - 渐变填充的旋转角度。
 * @param {number} [options.fillGradientOffsetRatioX=0] - 渐变填充中心点相对于填充区域范围中心点的水平偏移百分比。
 * @param {number} [options.fillGradientOffsetRatioY=0] - 填充中心点相对于填充区域范围中心点的垂直偏移百分比。
 * @param {number} [options.fillOpaqueRate=100] - 填充不透明度。
 * @param {number} [options.fillSymbolID=0] - 填充符号的编码。
 * @param {ServerColor} [options.lineColor] - 矢量要素的边线颜色。默认 lineColor = new ServerColor(0, 0, 0)。
 * @param {number} [options.lineSymbolID=0] - 线状符号的编码。
 * @param {number} [options.lineWidth=1] - 边线的宽度。
 * @param {number} [options.markerAngle=0] - 点状符号的旋转角度。
 * @param {number} [options.markerSize=1] - 点状符号的大小。
 * @param {number} [options.markerSymbolID=-1] - 点状符号的编码。
 * @usage
 */
class ServerStyle {

    constructor(options) {
        /**
         * @member {ServerColor} ServerStyle.prototype.fillBackColor
         * @description 填充背景颜色。当填充模式为渐变填充时，该颜色为填充终止色。
         */
        this.fillBackColor = new ServerColor(255, 255, 255);

        /**
         * @member {boolean} [ServerStyle.prototype.fillBackOpaque=false]
         * @description 背景是否不透明。false 表示透明。
         */
        this.fillBackOpaque = false;

        /**
         * @member {ServerColor} ServerStyle.prototype.fillForeColor
         * @description 填充颜色。当填充模式为渐变填充时，该颜色为填充起始颜色。
         */
        this.fillForeColor = new ServerColor(255, 0, 0);

        /**
         * @member {FillGradientMode} ServerStyle.prototype.fillGradientMode
         * @description 渐变填充风格的渐变类型。
         */
        this.fillGradientMode = null;

        /**
         * @member {number} ServerStyle.prototype.fillGradientAngle -
         * @description 渐变填充的旋转角度。单位为度，精确到 0.1 度，逆时针方向为正方向。
         */
        this.fillGradientAngle = 0;

        /**
         * @member {number} ServerStyle.prototype.fillGradientOffsetRatioX
         * @description 渐变填充中心点相对于填充区域范围中心点的水平偏移百分比。它们的关系如下：设填充区域范围中心点的坐标为（x0, y0），
         *              填充中心点的坐标为（x, y），填充区域范围的宽度为 a，水平偏移百分比为 dx，则 x=x0 + a*dx/100。
         */
        this.fillGradientOffsetRatioX = 0;

        /**
         * @member {number} ServerStyle.prototype.fillGradientOffsetRatioY
         * @description 填充中心点相对于填充区域范围中心点的垂直偏移百分比。它们的关系如下：<br>
         *              设填充区域范围中心点的坐标为（x0, y0），填充中心点的坐标为（x, y），填充区域范围的高度为 b，垂直偏移百分比为 dy，则 y=y0 + b*dx/100。
         */
        this.fillGradientOffsetRatioY = 0;

        /**
         * @member {number} [ServerStyle.prototype.fillOpaqueRate=100]
         * @description 填充不透明度。合法值为 0 - 100 的数值。其中为 0 表示完全透明；
         *              100 表示完全不透明。赋值小于 0 时按照 0 处理，大于 100 时按照 100 处理。
         */
        this.fillOpaqueRate = 100;

        /**
         * @member {number} ServerStyle.prototype.fillSymbolID
         * @description 填充符号的编码。此编码用于唯一标识各普通填充风格的填充符号。
         *              关于填充符号的样式与对应的 ID 号请在 SuperMap 桌面软件中查找。
         */
        this.fillSymbolID = 0;

        /**
         * @member {ServerColor} ServerStyle.prototype.lineColor
         * @description 矢量要素的边线颜色。如果等级符号是点符号，点符号的颜色由 lineColor 控制。
         */
        this.lineColor = new ServerColor(0, 0, 0);

        /**
         * @member {number} [ServerStyle.prototype.lineSymbolID=0]
         * @description 线状符号的编码。此编码用于唯一标识各普通填充风格的填充符号。
         *              关于线状符号的样式与对应的 ID 号请在 SuperMap 桌面软件中查找。
         */
        this.lineSymbolID = 0;

        /**
         * @member {number} [ServerStyle.prototype.lineWidth=1.0]
         * @description 边线的宽度。单位为毫米，精度到 0.1。
         */
        this.lineWidth = 1;

        /**
         * @member {number} [ServerStyle.prototype.markerAngle=0]
         * @description 点状符号的旋转角度。以度为单位，精确到 0.1 度，逆时针方向为正方向。
         */
        this.markerAngle = 0;

        /**
         * @member {number} [ServerStyle.prototype.markerSize=1.0]
         * @description 点状符号的大小。单位为毫米，精度为 0.1。当该属性设置为0时，采用符号默认大小 1.0 显示。
         *              当该属性设置为非法值时，交由服务器默认处理。
         */
        this.markerSize = 1;

        /**
         * @member {number} [ServerStyle.prototype.markerSymbolID=-1]
         * @description 点状符号的编码。此编码用于唯一标识各点状符号。
         *              关于线状符号的样式与对应的 ID 号请在 SuperMap 桌面软件中查找。
         */
        this.markerSymbolID = -1;
        if (options) {
            Util_Util.extend(this, options);
        }

        this.CLASS_NAME = "SuperMap.ServerStyle";
    }

    /**
     * @function ServerStyle.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        var me = this;
        if (me.fillBackColor) {
            me.fillBackColor.destroy();
            me.fillBackColor = null;
        }
        me.fillBackOpaque = null;

        if (me.fillForeColor) {
            me.fillForeColor.destroy();
            me.fillForeColor = null;
        }
        me.fillGradientMode = null;
        me.fillGradientAngle = null;
        me.fillGradientOffsetRatioX = null;
        me.fillGradientOffsetRatioY = null;
        me.fillOpaqueRate = null;
        me.fillSymbolID = null;
        if (me.lineColor) {
            me.lineColor.destroy();
            me.lineColor = null;
        }
        me.lineSymbolID = null;
        me.lineWidth = null;
        me.markerAngle = null;
        me.markerSize = null;
        me.markerSymbolID = null;
    }

    /**
     * @function ServerStyle.prototype.toServerJSONObject
     * @description 转换成对应的 JSON 格式对象。
     * @returns {Object} 对应的 JSON 格式对象.
     */
    toServerJSONObject() {
        var styleObj = {};
        styleObj = Util_Util.copyAttributes(styleObj, this);
        //暂时先忽略serverColor往Json的转换
        return styleObj;
    }

    /**
     * @function ServerStyle.fromJson
     * @description 将JSON对象转换为 ServerStyle 对象。
     * @param {Object} jsonObject - 要转换的 JSON 对象。
     * @returns {ServerStyle} 转化后的 ServerStyle 对象。
     */
    static fromJson(jsonObject) {
        if (!jsonObject) {
            return;
        }
        return new ServerStyle({
            fillBackColor: ServerColor.fromJson(jsonObject.fillBackColor),
            fillBackOpaque: jsonObject.fillBackOpaque,
            fillForeColor: ServerColor.fromJson(jsonObject.fillForeColor),
            fillGradientMode: jsonObject.fillGradientMode,
            fillGradientAngle: jsonObject.fillGradientAngle,
            fillGradientOffsetRatioX: jsonObject.fillGradientOffsetRatioX,
            fillGradientOffsetRatioY: jsonObject.fillGradientOffsetRatioY,
            fillOpaqueRate: jsonObject.fillOpaqueRate,
            fillSymbolID: jsonObject.fillSymbolID,
            lineColor: ServerColor.fromJson(jsonObject.lineColor),
            lineSymbolID: jsonObject.lineSymbolID,
            lineWidth: jsonObject.lineWidth,
            markerAngle: jsonObject.markerAngle,
            markerSize: jsonObject.markerSize,
            markerSymbolID: jsonObject.markerSymbolID
        });
    }

}



;// CONCATENATED MODULE: ./src/common/iServer/PointWithMeasure.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/



/**
 * @class PointWithMeasure
 * @deprecatedclass SuperMap.PointWithMeasure
 * @category iServer SpatialAnalyst RouteLocator
 * @classdesc 路由点类。路由点是指具有线性度量值 (Measure) 的二维地理坐标点。
 * @param {Object} options - 参数。
 * @param {number} options.measure - 度量值，即路由对象属性值 M。
 * @param {number} options.x - 地理坐标系下的 X 坐标值。
 * @param {number} options.y - 地理坐标系下的 Y 坐标值。
 * @extends {GeometryPoint}
 * @usage
 */
class PointWithMeasure extends Point {

    constructor(options) {
        super(options);

        /**
         * @member {number} PointWithMeasure.prototype.measure
         * @description 度量值，即路由对象属性值 M。
         */
        this.measure = null;

        if (options) {
            Util_Util.extend(this, options);
        }

        this.CLASS_NAME = "SuperMap.PointWithMeasure";
    }

    /**
     * @function PointWithMeasure.prototype.equals
     * @description 判断两个路由点对象是否相等。如果两个路由点对象具有相同的坐标以及度量值，则认为是相等的。
     * @param {PointWithMeasure} geom - 需要判断的路由点对象。
     * @returns {boolean} 两个路由点对象是否相等（true 为相等，false 为不等）。
     */
    equals(geom) {
        var equals = false;
        if (geom != null) {
            var isValueEquals = this.x === geom.x && this.y === geom.y && this.measure === geom.measure;
            var isNaNValue = isNaN(this.x) && isNaN(this.y) && isNaN(this.measure);
            var isNaNGeometry = isNaN(geom.x) && isNaN(geom.y) && isNaN(geom.measure);
            equals = ( isValueEquals || ( isNaNValue && isNaNGeometry ));
        }
        return equals;
    }


    /**
     * @function PointWithMeasure.prototype.toJson
     * @description 转换为 JSON 对象。
     * */
     toJson() {
        var result = "{";
        if (this.measure != null && this.measure != undefined) {
            result += "\"measure\":" + this.measure + ",";
        }
        result += "\"x\":" + this.x + ",";
        result += "\"y\":" + this.y;
        result += "}";
        return result;
    }


     /**
     * @function PointWithMeasure.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        var me = this;
        me.measure = null;
        me.x = null;
        me.y = null;
    }

    /**
     * @function PointWithMeasure.fromJson
     * @description 将 JSON 对象转换为{@link PointWithMeasure} 对象。
     * @param {Object} jsonObject - JSON 对象表示的路由点。
     * @returns {PointWithMeasure} 转化后的 PointWithMeasure 对象。
     */
    static fromJson(jsonObject) {
        if (!jsonObject) {
            return;
        }
        return new PointWithMeasure({
            x: jsonObject.x,
            y: jsonObject.y,
            measure: jsonObject.measure
        });
    }

}


;// CONCATENATED MODULE: ./src/common/iServer/Route.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/






/**
 * @class Route
 * @deprecatedclass SuperMap.Route
 * @category iServer SpatialAnalyst RouteCalculateMeasure
 * @classdesc 路由对象类。路由对象为一系列有序的带有属性值 M 的 x，y 坐标对，其中 M 值为该结点的距离属性（到已知点的距离）。
 * @param {Array.<Geometry>} points - 形成路由对象的线数组。
 * @param {Object} options - 参数。
 * @param {number} options.id - 路由对象在数据库中的 ID。
 * @param {number} options.length - 路由对象的长度。单位与数据集的单位相同。
 * @param {number} [options.maxM] - 最大线性度量值，即所有结点到起始点的量算距离中最大值。
 * @param {number} [options.minM] - 最小线性度量值，即所有结点到起始点的量算距离中最小值。
 * @param {string} [options.type] - 数据类型，如："LINEM"。
 * @extends GeometryCollection
 * @usage
 */
class Route extends Collection {

    constructor(points, options) {
        super(points, options);

        /**
         * @member {number} Route.prototype.id
         * @description 路由对象在数据库中的 ID。
         */
        this.id = null;

        /**
         * @member {number} Route.prototype.center
         * @description 路由对象的中心点。
         */
        this.center = null;

        /**
         * @member {string} Route.prototype.style
         * @description 路由对象的样式。
         */
        this.style = null;

        /**
         * @member {number} Route.prototype.length
         * @description 路由对象的长度。单位与数据集的单位相同。
         */
        this.length = null;

        /**
         *  @member {number} Route.prototype.maxM
         *  @description 最大线性度量值，即所有结点到起始点的量算距离中最大值。
         */
        this.maxM = null;

        /**
         * @member {number} Route.prototype.minM
         * @description 最小线性度量值，即所有结点到起始点的量算距离中最小值。
         */
        this.minM = null;

        /**
         * @member {Array.<number>} Route.prototype.parts
         * @description 服务端几何对象中各个子对象所包含的节点个数。
         */
        this.parts = null;

        /**
         * @member {Array.<Object>} Route.prototype.points
         * @description 路由对象的所有路由点。
         * @example
         * (start code)
         * [
         *  {
         *      "measure": 0,
         *      "y": -4377.027184298267,
         *      "x": 4020.0045221720466
         *  },
         *  {
         *      "measure": 37.33288381391519,
         *      "y": -4381.569363260499,
         *      "x": 4057.0600591960642
         *  }
         * ]
         * (end)
         */
        this.points = null;

        /**
         * @member {string} Route.prototype.type
         * @description 服务端几何对象类型。
         */
        this.type = null;

        /**
         * @member {Array.<string>} [Route.prototype.componentTypes=LineString]
         * @description components 存储的几何对象所支持的几何类型数组。
         */
        this.componentTypes = ["SuperMap.Geometry.LinearRing", "SuperMap.Geometry.LineString"];

        if (options) {
            Util_Util.extend(this, options);
        }

        this.CLASS_NAME = "SuperMap.Route";
        this.geometryType = "LINEM";
    }

    /**
     *
     * @function Route.prototype.toJson
     * @description 转换为 JSON 对象。
     * @returns {Object} JSON 对象。
     */
    toJson() {
        var result = "{";
        if (this.id != null && this.id != undefined) {
            result += "\"id\":" + this.id + ",";
        }
        if (this.center != null && this.center != undefined) {
            result += "\"center\":" + this.center + ",";
        }
        if (this.style != null && this.style != undefined) {
            result += "\"style\":" + this.style + ",";
        }
        if (this.length != null && this.length != undefined) {
            result += "\"length\":" + this.length + ",";
        }
        if (this.maxM != null && this.maxM != undefined) {
            result += "\"maxM\":" + this.maxM + ",";
        }
        if (this.minM != null && this.minM != undefined) {
            result += "\"minM\":" + this.minM + ",";
        }
        if (this.type != null && this.type != undefined) {
            result += "\"type\":\"" + this.type + "\",";
        }
        if (this.parts != null && this.parts != undefined) {
            result += "\"parts\":[" + this.parts[0];

            for (var i = 1; i < this.parts.length; i++) {
                result += "," + this.parts[i];
            }
            result += "],";
        }
        if (this.components != null && this.components.length > 0) {
            result += "\"points\":[";
            for (var j = 0, len = this.components.length; j < len; j++) {
                for (var k = 0, len2 = this.components[j].components.length; k < len2; k++) {
                    result += this.components[j].components[k].toJson() + ",";
                }
            }
            result = result.replace(/,$/g, '');
            result += "]";
        }
        result = result.replace(/,$/g, '');
        result += "}";
        return result;
    }


    /**
     * @function Route.prototype.destroy
     * @override
     */
    destroy() {
        var me = this;
        me.id = null;
        me.center = null;
        me.style = null;
        me.length = null;
        me.maxM = null;
        me.minM = null;
        me.type = null;
        me.parts = null;
        me.components.length = 0;
        me.components = null;
        me.componentTypes = null;
    }


    /**
     * @function Route.fromJson
     * @description 将 JSON 对象转换为 Route 对象。
     * @param {Object} [jsonObject] - JSON 对象表示的路由对象。
     * @returns {Route} 转化后的 Route 对象。
     */
    static fromJson(jsonObject) {
        if (!jsonObject) {
            return;
        }

        var geoParts = jsonObject.parts || [],
            geoPoints = jsonObject.points || [],
            len = geoParts.length,
            lineList = [];
        if (len > 0) {
            for (var i = 0, pointIndex = 0, pointList = []; i < len; i++) {
                for (var j = 0; j < geoParts[i]; j++) {
                    pointList.push(PointWithMeasure.fromJson(geoPoints[pointIndex + j]));
                }
                pointIndex += geoParts[i];
                //判断线是否闭合，如果闭合，则返回LinearRing，否则返回LineString
                if (pointList[0].equals(pointList[geoParts[i] - 1])) {
                    lineList.push(new LinearRing_LinearRing(pointList));
                } else {
                    lineList.push(new LineString(pointList));
                }
                pointList = [];
            }

        } else {
            return null;
        }

        return new Route(lineList, {
            id: jsonObject.id,
            center: jsonObject.center,
            style: jsonObject.style,
            length: jsonObject.length,
            maxM: jsonObject.maxM,
            minM: jsonObject.minM,
            type: jsonObject.type,
            parts: jsonObject.parts
        });
    }

}

;// CONCATENATED MODULE: ./src/common/REST.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/

 /**
 * @enum DataFormat
 * @description 服务请求返回结果数据类型
 * @category BaseTypes Constant
 * @type {string}
 * @usage
 * ```
 * // 浏览器
 * <script type="text/javascript" src="{cdn}"></script>
 * <script>
 *   const result = {namespace}.DataFormat.GEOJSON;
 *
 * </script>
 * // ES6 Import
 * import { DataFormat } from '{npm}';
 *
 * const result = DataFormat.GEOJSON;
 * ```
 */
var DataFormat = {
    /** GEOJSON */
    GEOJSON: "GEOJSON",
    /** ISERVER */
    ISERVER: "ISERVER",
    /** FGB */
    FGB: "FGB"
};

/**
 * @enum ServerType
 * @description 服务器类型
 * @category BaseTypes Constant
 * @type {string}
 * @usage
 * ```
 * // 浏览器
 * <script type="text/javascript" src="{cdn}"></script>
 * <script>
 *   const result = {namespace}.ServerType.ISERVER;
 *
 * </script>
 * // ES6 Import
 * import { ServerType } from '{npm}';
 *
 * const result = ServerType.ISERVER;
 * ```
 */
var ServerType = {
    /** ISERVER */
    ISERVER: "ISERVER",
    /** IPORTAL */
    IPORTAL: "IPORTAL",
    /** ONLINE */
    ONLINE: "ONLINE"
};

/**
 * @enum GeometryType
 * @description 几何对象枚举,定义了一系列几何对象类型。
 * @category BaseTypes Constant
 * @type {string}
 * @usage
 * ```
 * // 浏览器
 * <script type="text/javascript" src="{cdn}"></script>
 * <script>
 *   const result = {namespace}.GeometryType.LINE;
 *
 * </script>
 * // ES6 Import
 * import { GeometryType } from '{npm}';
 *
 * const result = GeometryType.LINE;
 * ```
 */
var REST_GeometryType = {
    /** 线几何对象类型。 */
    LINE: "LINE",
    /** 路由对象。 */
    LINEM: "LINEM",
    /** 点几何对象类型。 */
    POINT: "POINT",
    /** 面几何对象类型。 */
    REGION: "REGION",
    /** EPS点几何对象。 */
    POINTEPS: "POINTEPS",
    /** EPS线几何对象。 */
    LINEEPS: "LINEEPS",
    /** EPS面几何对象。 */
    REGIONEPS: "REGIONEPS",
    /** 椭圆。 */
    ELLIPSE: "ELLIPSE",
    /** 圆。 */
    CIRCLE: "CIRCLE",
    /** 文本几何对象类型。 */
    TEXT: "TEXT",
    /** 矩形。 */
    RECTANGLE: "RECTANGLE",
    /** 未定义。 */
    UNKNOWN: "UNKNOWN",
    /** 复合几何对象类型。 */
    GEOCOMPOUND:"GEOCOMPOUND"
};

/**
 * @enum QueryOption
 * @description 查询结果类型枚举，描述查询结果返回类型，包括只返回属性、只返回几何实体以及返回属性和几何实体。
 * @category BaseTypes Constant
 * @type {string}
 * @usage
 * ```
 * // 浏览器
 * <script type="text/javascript" src="{cdn}"></script>
 * <script>
 *   const result = {namespace}.QueryOption.ATTRIBUTE;
 *
 * </script>
 * // ES6 Import
 * import { QueryOption } from '{npm}';
 *
 * const result = QueryOption.ATTRIBUTE;
 * ```
 */
var QueryOption = {
    /** 属性。 */
    ATTRIBUTE: "ATTRIBUTE",
    /** 属性和几何对象。 */
    ATTRIBUTEANDGEOMETRY: "ATTRIBUTEANDGEOMETRY",
    /** 几何对象。 */
    GEOMETRY: "GEOMETRY"
};

/**
 * @enum JoinType
 * @description 关联查询时的关联类型常量。
 * 该类定义了两个表之间的连接类型常量，决定了对两个表之间进行连接查询时，查询结果中得到的记录的情况。
 * @category BaseTypes Constant
 * @type {string}
 * @usage
 * ```
 * // 浏览器
 * <script type="text/javascript" src="{cdn}"></script>
 * <script>
 *   const result = {namespace}.JoinType.INNERJOIN;
 *
 * </script>
 * // ES6 Import
 * import { JoinType } from '{npm}';
 *
 * const result = JoinType.INNERJOIN;
 * ```
 */
var JoinType = {
    /** 内连接。 */
    INNERJOIN: "INNERJOIN",
    /** 左连接。 */
    LEFTJOIN: "LEFTJOIN"
};

/**
 * @enum SpatialQueryMode
 * @description  空间查询模式枚举。该类定义了空间查询操作模式常量。
 * @category BaseTypes Constant
 * @type {string}
 * @usage
 * ```
 * // 浏览器
 * <script type="text/javascript" src="{cdn}"></script>
 * <script>
 *   const result = {namespace}.SpatialQueryMode.CONTAIN;
 *
 * </script>
 * // ES6 Import
 * import { SpatialQueryMode } from '{npm}';
 *
 * const result = SpatialQueryMode.CONTAIN;
 * ```
 */
var SpatialQueryMode = {
    /** 包含空间查询模式。 */
    CONTAIN: "CONTAIN",
    /** 交叉空间查询模式。 */
    CROSS: "CROSS",
    /** 分离空间查询模式。 */
    DISJOINT: "DISJOINT",
    /** 重合空间查询模式。 */
    IDENTITY: "IDENTITY",
    /** 相交空间查询模式。 */
    INTERSECT: "INTERSECT",
    /** 无空间查询。 */
    NONE: "NONE",
    /** 叠加空间查询模式。 */
    OVERLAP: "OVERLAP",
    /** 邻接空间查询模式。 */
    TOUCH: "TOUCH",
    /** 被包含空间查询模式。 */
    WITHIN: "WITHIN"
};

/**
 * @enum SpatialRelationType
 * @description  数据集对象间的空间关系枚举。
 * 该类定义了数据集对象间的空间关系类型常量。
 * @category BaseTypes Constant
 * @type {string}
 * @usage
 * ```
 * // 浏览器
 * <script type="text/javascript" src="{cdn}"></script>
 * <script>
 *   const result = {namespace}.SpatialRelationType.CONTAIN;
 *
 * </script>
 * // ES6 Import
 * import { SpatialRelationType } from '{npm}';
 *
 * const result = {namespace}.SpatialRelationType.CONTAIN;
 * ```
 */
var SpatialRelationType = {
    /** 包含关系。 */
    CONTAIN: "CONTAIN",
    /** 相交关系。 */
    INTERSECT: "INTERSECT",
    /** 被包含关系。 */
    WITHIN: "WITHIN"
};

/**
 * @enum MeasureMode
 * @type {string}
 * @description  量算模式枚举。
 * @category BaseTypes Constant
 * 该类定义了两种测量模式：距离测量和面积测量。
 * @usage
 * ```
 * // 浏览器
 * <script type="text/javascript" src="{cdn}"></script>
 * <script>
 *   const result = {namespace}.MeasureMode.DISTANCE;
 *
 * </script>
 * // ES6 Import
 * import { MeasureMode } from '{npm}';
 *
 * const result = MeasureMode.DISTANCE;
 * ```
 */
var MeasureMode = {
    /** 距离测量。 */
    DISTANCE: "DISTANCE",
    /** 面积测量。 */
    AREA: "AREA"
};

/**
 * @enum Unit
 * @description  距离单位枚举。
 * 该类定义了一系列距离单位类型。
 * @category BaseTypes Constant
 * @type {string}
 * @usage
 * ```
 * // 浏览器
 * <script type="text/javascript" src="{cdn}"></script>
 * <script>
 *   const result = {namespace}.Unit.METER;
 *
 * </script>
 * // ES6 Import
 * import { Unit } from '{npm}';
 *
 * const result = Unit.METER;
 * ```
 */
var Unit = {
    /**  米。 */
    METER: "METER",
    /**  千米。 */
    KILOMETER: "KILOMETER",
    /**  英里。 */
    MILE: "MILE",
    /**  码。 */
    YARD: "YARD",
    /**  度。 */
    DEGREE: "DEGREE",
    /**  毫米。 */
    MILLIMETER: "MILLIMETER",
    /**  厘米。 */
    CENTIMETER: "CENTIMETER",
    /**  英寸。 */
    INCH: "INCH",
    /**  分米。 */
    DECIMETER: "DECIMETER",
    /**  英尺。 */
    FOOT: "FOOT",
    /**  秒。 */
    SECOND: "SECOND",
    /**  分。 */
    MINUTE: "MINUTE",
    /**  弧度。 */
    RADIAN: "RADIAN"
};

/**
 * @enum BufferRadiusUnit
 * @description  缓冲区距离单位枚举。该类定义了一系列缓冲距离单位类型。
 * @category BaseTypes Constant
 * @type {string}
 * @usage
 * ```
 * // 浏览器
 * <script type="text/javascript" src="{cdn}"></script>
 * <script>
 *   const result = {namespace}.BufferRadiusUnit.CENTIMETER;
 *
 * </script>
 * // ES6 Import
 * import { BufferRadiusUnit } from '{npm}';
 *
 * const result = BufferRadiusUnit.CENTIMETER;
 * ```
 */
var BufferRadiusUnit = {
    /**  厘米。 */
    CENTIMETER: "CENTIMETER",
    /**  分米。 */
    DECIMETER: "DECIMETER",
    /**  英尺。 */
    FOOT: "FOOT",
    /**  英寸。 */
    INCH: "INCH",
    /**  千米。 */
    KILOMETER: "KILOMETER",
    /**  米。 */
    METER: "METER",
    /**  英里。 */
    MILE: "MILE",
    /**  毫米。 */
    MILLIMETER: "MILLIMETER",
    /**  码。 */
    YARD: "YARD"
}

/**
 * @enum EngineType
 * @description  数据源引擎类型枚举。
 * @category BaseTypes Constant
 * @type {string}
 * @usage
 * ```
 * // 浏览器
 * <script type="text/javascript" src="{cdn}"></script>
 * <script>
 *   const result = {namespace}.EngineType.IMAGEPLUGINS;
 *
 * </script>
 * // ES6 Import
 * import { EngineType } from '{npm}';
 *
 * const result = EngineType.IMAGEPLUGINS;
 * ```
 */
var EngineType = {
    /** 影像只读引擎类型，文件引擎，针对通用影像格式如 BMP，JPG，TIFF 以及超图自定义影像格式 SIT 等。 */
    IMAGEPLUGINS: "IMAGEPLUGINS",
    /**  OGC 引擎类型，针对于 Web 数据源，Web 引擎，目前支持的类型有 WMS，WFS，WCS。 */
    OGC: "OGC",
    /**  Oracle 引擎类型，针对 Oracle 数据源，数据库引擎。 */
    ORACLEPLUS: "ORACLEPLUS",
    /**  SDB 引擎类型，文件引擎，即 SDB 数据源。 */
    SDBPLUS: "SDBPLUS",
    /**  SQL Server 引擎类型，针对 SQL Server 数据源，数据库引擎。 */
    SQLPLUS: "SQLPLUS",
    /**  UDB 引擎类型，文件引擎。 */
    UDB: "UDB"
};

/**
 * @enum ThemeGraphTextFormat
 * @description  统计专题图文本显示格式枚举。
 * @category BaseTypes Constant
 * @type {string}
 * @usage
 * ```
 * // 浏览器
 * <script type="text/javascript" src="{cdn}"></script>
 * <script>
 *   const result = {namespace}.ThemeGraphTextFormat.CAPTION;
 *
 * </script>
 * // ES6 Import
 * import { ThemeGraphTextFormat } from '{npm}';
 *
 * const result = ThemeGraphTextFormat.CAPTION;
 * ```
 */
var ThemeGraphTextFormat = {
    /**  标题。以各子项的标题来进行标注。 */
    CAPTION: "CAPTION",
    /**  标题 + 百分数。以各子项的标题和所占的百分比来进行标注。 */
    CAPTION_PERCENT: "CAPTION_PERCENT",
    /**  标题 + 实际数值。以各子项的标题和真实数值来进行标注。 */
    CAPTION_VALUE: "CAPTION_VALUE",
    /**  百分数。以各子项所占的百分比来进行标注。 */
    PERCENT: "PERCENT",
    /**  实际数值。以各子项的真实数值来进行标注。 */
    VALUE: "VALUE"

};

/**
 * @enum ThemeGraphType
 * @description  统计专题图类型枚举。
 * @category BaseTypes Constant
 * @type {string}
 * @usage
 * ```
 * // 浏览器
 * <script type="text/javascript" src="{cdn}"></script>
 * <script>
 *   const result = {namespace}.ThemeGraphType.AREA;
 *
 * </script>
 * // ES6 Import
 * import { ThemeGraphType } from '{npm}';
 *
 * const result = ThemeGraphType.AREA;
 * ```
 */
var ThemeGraphType = {
    /**  面积图。 */
    AREA: "AREA",
    /**  柱状图。 */
    BAR: "BAR",
    /**  三维柱状图。 */
    BAR3D: "BAR3D",
    /**  折线图。 */
    LINE: "LINE",
    /**  饼图。 */
    PIE: "PIE",
    /**  三维饼图。 */
    PIE3D: "PIE3D",
    /**  点状图。 */
    POINT: "POINT",
    /**  环状图。 */
    RING: "RING",
    /**  玫瑰图。 */
    ROSE: "ROSE",
    /**  三维玫瑰图。 */
    ROSE3D: "ROSE3D",
    /**  堆叠柱状图。 */
    STACK_BAR: "STACK_BAR",
    /**  三维堆叠柱状图。 */
    STACK_BAR3D: "STACK_BAR3D",
    /**  阶梯图。 */
    STEP: "STEP"
};

/**
 * @enum GraphAxesTextDisplayMode
 * @description  统计专题图坐标轴文本显示模式。
 * @category BaseTypes Constant
 * @type {string}
 * @usage
 * ```
 * // 浏览器
 * <script type="text/javascript" src="{cdn}"></script>
 * <script>
 *   const result = {namespace}.GraphAxesTextDisplayMode.ALL;
 *
 * </script>
 * // ES6 Import
 * import { GraphAxesTextDisplayMode } from '{npm}';
 *
 * const result = GraphAxesTextDisplayMode.ALL;
 * ```
 */
var GraphAxesTextDisplayMode = {
    /**  显示全部文本。 */
    ALL: "ALL",
    /**  不显示。 */
    NONE: "NONE",
    /**  显示Y轴的文本。 */
    YAXES: "YAXES"
};

/**
 * @enum GraduatedMode
 * @description  专题图分级模式枚举。
 * @category BaseTypes Constant
 * @type {string}
 * @usage
 * ```
 * // 浏览器
 * <script type="text/javascript" src="{cdn}"></script>
 * <script>
 *   const result = {namespace}.GraduatedMode.CONSTANT;
 *
 * </script>
 * // ES6 Import
 * import { GraduatedMode } from '{npm}';
 *
 * const result = GraduatedMode.CONSTANT;
 * ```
 */
var GraduatedMode = {
    /**  常量分级模式。 */
    CONSTANT: "CONSTANT",
    /** 对数分级模式。 */
    LOGARITHM: "LOGARITHM",
    /**  平方根分级模式。 */
    SQUAREROOT: "SQUAREROOT"
};

/**
 * @enum RangeMode
 * @description  范围分段专题图分段方式枚举。
 * @category BaseTypes Constant
 * @type {string}
 * @usage
 * ```
 * // 浏览器
 * <script type="text/javascript" src="{cdn}"></script>
 * <script>
 *   const result = {namespace}.RangeMode.CUSTOMINTERVAL;
 *
 * </script>
 * // ES6 Import
 * import { RangeMode } from '{npm}';
 *
 * const result = RangeMode.CUSTOMINTERVAL;
 * ```
 */
var RangeMode = {
    /**  自定义分段法。 */
    CUSTOMINTERVAL: "CUSTOMINTERVAL",
    /**  等距离分段法。 */
    EQUALINTERVAL: "EQUALINTERVAL",
    /**  对数分段法。 */
    LOGARITHM: "LOGARITHM",
    /**  等计数分段法。 */
    QUANTILE: "QUANTILE",
    /**  平方根分段法。 */
    SQUAREROOT: "SQUAREROOT",
    /**  标准差分段法。 */
    STDDEVIATION: "STDDEVIATION"
};

/**
 * @enum ThemeType
 * @description  专题图类型枚举。
 * @category BaseTypes Constant
 * @type {string}
 * @usage
 * ```
 * // 浏览器
 * <script type="text/javascript" src="{cdn}"></script>
 * <script>
 *   const result = {namespace}.ThemeType.DOTDENSITY;
 *
 * </script>
 * // ES6 Import
 * import { ThemeType } from '{npm}';
 *
 * const result = ThemeType.DOTDENSITY;
 * ```
 */
var ThemeType = {
    /** 点密度专题图。 */
    DOTDENSITY: "DOTDENSITY",
    /** 等级符号专题图。 */
    GRADUATEDSYMBOL: "GRADUATEDSYMBOL",
    /** 统计专题图。 */
    GRAPH: "GRAPH",
    /** 标签专题图。 */
    LABEL: "LABEL",
    /** 分段专题图。 */
    RANGE: "RANGE",
    /** 単值专题图。 */
    UNIQUE: "UNIQUE"
};

/**
 * @enum ColorGradientType
 * @description  渐变颜色枚举。
 * @category BaseTypes Constant
 * @type {string}
 * @usage
 * ```
 * // 浏览器
 * <script type="text/javascript" src="{cdn}"></script>
 * <script>
 *   const result = {namespace}.ColorGradientType.BLACK_WHITE;
 *
 * </script>
 * // ES6 Import
 * import { ColorGradientType } from '{npm}';
 *
 * const result = ColorGradientType.BLACK_WHITE;
 * ```
 */
var ColorGradientType = {
    /** 黑白渐变色。 */
    BLACK_WHITE: "BLACKWHITE",
    /** 蓝黑渐变色。 */
    BLUE_BLACK: "BLUEBLACK",
    /** 蓝红渐变色。 */
    BLUE_RED: "BLUERED",
    /** 蓝白渐变色。 */
    BLUE_WHITE: "BLUEWHITE",
    /** 青黑渐变色。 */
    CYAN_BLACK: "CYANBLACK",
    /** 青蓝渐变色。 */
    CYAN_BLUE: "CYANBLUE",
    /** 青绿渐变色。 */
    CYAN_GREEN: "CYANGREEN",
    /** 青白渐变色。 */
    CYAN_WHITE: "CYANWHITE",
    /** 绿黑渐变色。 */
    GREEN_BLACK: "GREENBLACK",
    /** 绿蓝渐变色。 */
    GREEN_BLUE: "GREENBLUE",
    /** 绿橙紫渐变色。 */
    GREEN_ORANGE_VIOLET: "GREENORANGEVIOLET",
    /** 绿红渐变色。 */
    GREEN_RED: "GREENRED",
    /** 蓝红渐变色。 */
    GREEN_WHITE: "GREENWHITE",
    /** 粉黑渐变色。 */
    PINK_BLACK: "PINKBLACK",
    /** 粉蓝渐变色。 */
    PINK_BLUE: "PINKBLUE",
    /** 粉红渐变色。 */
    PINK_RED: "PINKRED",
    /** 粉白渐变色。 */
    PINK_WHITE: "PINKWHITE",
    /** 彩虹色。 */
    RAIN_BOW: "RAINBOW",
    /** 红黑渐变色。 */
    RED_BLACK: "REDBLACK",
    /** 红白渐变色。 */
    RED_WHITE: "REDWHITE",
    /** 光谱渐变。 */
    SPECTRUM: "SPECTRUM",
    /** 地形渐变，用于三维显示效果较好。 */
    TERRAIN: "TERRAIN",
    /** 黄黑渐变色。 */
    YELLOW_BLACK: "YELLOWBLACK",
    /** 黄蓝渐变色。 */
    YELLOW_BLUE: "YELLOWBLUE",
    /** 黄绿渐变色。 */
    YELLOW_GREEN: "YELLOWGREEN",
    /** 黄红渐变色。 */
    YELLOW_RED: "YELLOWRED",
    /** 黄白渐变色。 */
    YELLOW_WHITE: "YELLOWWHITE"
};

/**
 * @enum TextAlignment
 * @description  文本对齐枚举。
 * @category BaseTypes Constant
 * @type {string}
 * @usage
 * ```
 * // 浏览器
 * <script type="text/javascript" src="{cdn}"></script>
 * <script>
 *   const result = {namespace}.TextAlignment.TOPLEFT;
 *
 * </script>
 * // ES6 Import
 * import { TextAlignment } from '{npm}';
 *
 * const result = TextAlignment.TOPLEFT;
 * ```
 */
var TextAlignment = {
    /** 左上角对齐。 */
    TOPLEFT: "TOPLEFT",
    /** 顶部居中对齐。 */
    TOPCENTER: "TOPCENTER",
    /** 右上角对齐。 */
    TOPRIGHT: "TOPRIGHT",
    /** 基准线左对齐。 */
    BASELINELEFT: "BASELINELEFT",
    /** 基准线居中对齐。 */
    BASELINECENTER: "BASELINECENTER",
    /** 基准线右对齐。 */
    BASELINERIGHT: "BASELINERIGHT",
    /** 左下角对齐。 */
    BOTTOMLEFT: "BOTTOMLEFT",
    /** 底部居中对齐。 */
    BOTTOMCENTER: "BOTTOMCENTER",
    /** 右下角对齐。 */
    BOTTOMRIGHT: "BOTTOMRIGHT",
    /** 左中对齐。 */
    MIDDLELEFT: "MIDDLELEFT",
    /** 中心对齐。 */
    MIDDLECENTER: "MIDDLECENTER",
    /** 右中对齐。 */
    MIDDLERIGHT: "MIDDLERIGHT"
};

/**
 * @enum FillGradientMode
 * @description  渐变填充风格的渐变类型枚举。
 * @category BaseTypes Constant
 * @type {string}
 * @usage
 * ```
 * // 浏览器
 * <script type="text/javascript" src="{cdn}"></script>
 * <script>
 *   const result = {namespace}.FillGradientMode.NONE;
 *
 * </script>
 * // ES6 Import
 * import { FillGradientMode } from '{npm}';
 *
 * const result = FillGradientMode.NONE;
 * ```
 */
var FillGradientMode = {
    /** 无渐变。 */
    NONE: "NONE",
    /** 线性渐变填充。 */
    LINEAR: "LINEAR",
    /** 辐射渐变填充。 */
    RADIAL: "RADIAL",
    /** 圆锥渐变填充。 */
    CONICAL: "CONICAL",
    /** 四角渐变填充。 */
    SQUARE: "SQUARE"
};

/**
 * @enum AlongLineDirection
 * @description  标签沿线标注方向枚举。
 * @category BaseTypes Constant
 * @type {string}
 * @usage
 * ```
 * // 浏览器
 * <script type="text/javascript" src="{cdn}"></script>
 * <script>
 *   const result = {namespace}.AlongLineDirection.NORMAL;
 *
 * </script>
 * // ES6 Import
 * import { AlongLineDirection } from '{npm}';
 *
 * const result = AlongLineDirection.NORMAL;
 * ```
 */
var AlongLineDirection = {
    /** 沿线的法线方向放置标签。 */
    NORMAL: "ALONG_LINE_NORMAL",
    /** 从下到上，从左到右放置。 */
    LB_TO_RT: "LEFT_BOTTOM_TO_RIGHT_TOP",
    /** 从上到下，从左到右放置。 */
    LT_TO_RB: "LEFT_TOP_TO_RIGHT_BOTTOM",
    /** 从下到上，从右到左放置。 */
    RB_TO_LT: "RIGHT_BOTTOM_TO_LEFT_TOP",
    /** 从上到下，从右到左放置。 */
    RT_TO_LB: "RIGHT_TOP_TO_LEFT_BOTTOM"
};

/**
 * @enum LabelBackShape
 * @description  标签专题图中标签背景的形状枚举。
 * @category BaseTypes Constant
 * @type {string}
 * @usage
 * ```
 * // 浏览器
 * <script type="text/javascript" src="{cdn}"></script>
 * <script>
 *   const result = {namespace}.LabelBackShape.DIAMOND;
 *
 * </script>
 * // ES6 Import
 * import { LabelBackShape } from '{npm}';
 *
 * const result = LabelBackShape.DIAMOND;
 * ```
 */
var LabelBackShape = {
    /** 菱形背景，即标签背景的形状为菱形。 */
    DIAMOND: "DIAMOND",
    /** 椭圆形背景，即标签背景的行状为椭圆形。 */
    ELLIPSE: "ELLIPSE",
    /** 符号背景，即标签背景的形状为设定的符号。 */
    MARKER: "MARKER",
    /** 空背景，即不使用任何形状作为标签的背景。 */
    NONE: "NONE",
    /** 矩形背景，即标签背景的形状为矩形。 */
    RECT: "RECT",
    /** 圆角矩形背景，即标签背景的形状为圆角矩形。 */
    ROUNDRECT: "ROUNDRECT",
    /** 三角形背景，即标签背景的形状为三角形。 */
    TRIANGLE: "TRIANGLE"
};

/**
 * @enum LabelOverLengthMode
 * @description  标签专题图中超长标签的处理模式枚举。
 * @category BaseTypes Constant
 * @type {string}
 * @usage
 * ```
 * // 浏览器
 * <script type="text/javascript" src="{cdn}"></script>
 * <script>
 *   const result = {namespace}.LabelOverLengthMode.NEWLINE;
 *
 * </script>
 * // ES6 Import
 * import { LabelOverLengthMode } from '{npm}';
 *
 * const result = LabelOverLengthMode.NEWLINE;
 * ```
 */
var LabelOverLengthMode = {
    /** 换行显示。 */
    NEWLINE: "NEWLINE",
    /** 对超长标签不进行处理。 */
    NONE: "NONE",
    /** 省略超出部分。 */
    OMIT: "OMIT"
};

/**
 * @enum DirectionType
 * @description  网络分析中方向枚举。
 * 在行驶引导子项中使用。
 * @category BaseTypes Constant
 * @type {string}
 * @usage
 * ```
 * // 浏览器
 * <script type="text/javascript" src="{cdn}"></script>
 * <script>
 *   const result = {namespace}.DirectionType.EAST;
 *
 * </script>
 * // ES6 Import
 * import { DirectionType } from '{npm}';
 *
 * const result = DirectionType.EAST;
 * ```
 */
var DirectionType = {
    /** 东。 */
    EAST: "EAST",
    /** 无方向。 */
    NONE: "NONE",
    /** 北。 */
    NORTH: "NORTH",
    /** 南。 */
    SOURTH: "SOURTH",
    /** 西。 */
    WEST: "WEST"
};

/**
 * @enum SideType
 * @description  行驶位置枚举。
 * 表示在行驶在路的左边、右边或者路上的枚举，该类用在行驶导引子项类中。
 * @category BaseTypes Constant
 * @type {string}
 * @usage
 * ```
 * // 浏览器
 * <script type="text/javascript" src="{cdn}"></script>
 * <script>
 *   const result = {namespace}.SideType.LEFT;
 *
 * </script>
 * // ES6 Import
 * import { SideType } from '{npm}';
 *
 * const result = SideType.LEFT;
 * ```
 */
var SideType = {
    /** 路的左侧。 */
    LEFT: "LEFT",
    /** 在路上（即路的中间）。 */
    MIDDLE: "MIDDLE",
    /** 无效值。 */
    NONE: "NONE",
    /** 路的右侧。 */
    RIGHT: "RIGHT"
};

/**
 * @enum SupplyCenterType
 * @description  资源供给中心类型枚举。
 * 该枚举定义了网络分析中资源中心点的类型，主要用于资源分配和选址分区。
 * 资源供给中心点的类型包括非中心，固定中心和可选中心。固定中心用于资源分配分析；固定中心和可选中心用于选址分析；非中心在两种网络分析时都不予考虑。
 * @category BaseTypes Constant
 * @type {string}
 * @usage
 * ```
 * // 浏览器
 * <script type="text/javascript" src="{cdn}"></script>
 * <script>
 *   const result = {namespace}.SupplyCenterType.FIXEDCENTER;
 *
 * </script>
 * // ES6 Import
 * import { SupplyCenterType } from '{npm}';
 *
 * const result = SupplyCenterType.FIXEDCENTER;
 * ```
 */
var SupplyCenterType = {
    /** 固定中心点。 */
    FIXEDCENTER: "FIXEDCENTER",
    /** 非中心点。 */
    NULL: "NULL",
    /** 可选中心点。 */
    OPTIONALCENTER: "OPTIONALCENTER"
};

/**
 * @enum TurnType
 * @description  转弯方向枚举。
 * 用在行驶引导子项类中，表示转弯的方向。
 * @category BaseTypes Constant
 * @type {string}
 * @usage
 * ```
 * // 浏览器
 * <script type="text/javascript" src="{cdn}"></script>
 * <script>
 *   const result = {namespace}.TurnType.AHEAD;
 *
 * </script>
 * // ES6 Import
 * import { TurnType } from '{npm}';
 *
 * const result = TurnType.AHEAD;
 * ```
 */
var TurnType = {
    /** 向前直行。 */
    AHEAD: "AHEAD",
    /** 掉头。 */
    BACK: "BACK",
    /** 终点，不拐弯。 */
    END: "END",
    /** 左转弯。 */
    LEFT: "LEFT",
    /** 无效值。 */
    NONE: "NONE",
    /** 右转弯。 */
    RIGHT: "RIGHT"
};

/**
 * @enum BufferEndType
 * @description  缓冲区分析BufferEnd类型。
 * @category BaseTypes Constant
 * @type {string}
 * @usage
 * ```
 * // 浏览器
 * <script type="text/javascript" src="{cdn}"></script>
 * <script>
 *   const result = {namespace}.BufferEndType.FLAT;
 *
 * </script>
 * // ES6 Import
 * import { BufferEndType } from '{npm}';
 *
 * const result = BufferEndType.FLAT;
 * ```
 */
var BufferEndType = {
    /** 平头缓冲。 */
    FLAT: "FLAT",
    /** 圆头缓冲。 */
    ROUND: "ROUND"
};
/**
 * @enum OverlayOperationType
 * @description  叠加分析类型枚举。
 * @category BaseTypes Constant
 * @type {string}
 * @usage
 * ```
 * // 浏览器
 * <script type="text/javascript" src="{cdn}"></script>
 * <script>
 *   const result = {namespace}.OverlayOperationType.CLIP;
 *
 * </script>
 * // ES6 Import
 * import { OverlayOperationType } from '{npm}';
 *
 * const result = OverlayOperationType.CLIP;
 * ```
 */
 var OverlayOperationType = {
    /** 操作数据集（几何对象）裁剪被操作数据集（几何对象）。 */
    CLIP: "CLIP",
    /** 在被操作数据集（几何对象）上擦除掉与操作数据集（几何对象）相重合的部分。 */
    ERASE: "ERASE",
    /**对被操作数据集（几何对象）进行同一操作，即操作执行后，被操作数据集（几何对象）包含来自操作数据集（几何对象）的几何形状。 */
    IDENTITY: "IDENTITY",
    /** 对两个数据集（几何对象）求交，返回两个数据集（几何对象）的交集。 */
    INTERSECT: "INTERSECT",
    /** 对两个面数据集（几何对象）进行合并操作。 */
    UNION: "UNION",
    /** 对两个面数据集（几何对象）进行更新操作。 */
    UPDATE: "UPDATE",
    /** 对两个面数据集（几何对象）进行对称差操作。 */
    XOR: "XOR"
};

/**
 * @enum OutputType
 * @description  分布式分析输出类型枚举。
 * @category BaseTypes Constant
 * @type {string}
 * @usage
 * ```
 * // 浏览器
 * <script type="text/javascript" src="{cdn}"></script>
 * <script>
 *   const result = {namespace}.OutputType.INDEXEDHDFS;
 *
 * </script>
 * // ES6 Import
 * import { OutputType } from '{npm}';
 *
 * const result = OutputType.INDEXEDHDFS;
 * ```
 */
var OutputType =  {
    /** INDEXEDHDFS */
    INDEXEDHDFS: "INDEXEDHDFS",
    /** UDB */
    UDB: "UDB",
    /** MONGODB */
    MONGODB: "MONGODB",
    /** PG */
    PG: "PG"
};

/**
 * @enum SmoothMethod
 * @description  光滑方法枚举。
 * 用于从Grid 或DEM数据生成等值线或等值面时对等值线或者等值面的边界线进行平滑处理的方法。
 * @category BaseTypes Constant
 * @type {string}
 * @usage
 * ```
 * // 浏览器
 * <script type="text/javascript" src="{cdn}"></script>
 * <script>
 *   const result = {namespace}.SmoothMethod.BSPLINE;
 *
 * </script>
 * // ES6 Import
 * import { SmoothMethod } from '{npm}';
 *
 * const result = SmoothMethod.BSPLINE;
 * ```
 */
 var SmoothMethod = {
    /** B 样条法。 */
    BSPLINE: "BSPLINE",
    /** 磨角法。 */
    POLISH: "POLISH"
};

/**
 * @enum SurfaceAnalystMethod
 * @description  表面分析方法枚举。
 * 通过对数据进行表面分析，能够挖掘原始数据所包含的信息，使某些细节明显化，易于分析。
 * @category BaseTypes Constant
 * @type {string}
 * @usage
 * ```
 * // 浏览器
 * <script type="text/javascript" src="{cdn}"></script>
 * <script>
 *   const result = {namespace}.SurfaceAnalystMethod.ISOLINE;
 *
 * </script>
 * // ES6 Import
 * import { SurfaceAnalystMethod } from '{npm}';
 *
 * const result = SurfaceAnalystMethod.ISOLINE;
 * ```
 */
var SurfaceAnalystMethod = {
    /** 等值线提取。 */
    ISOLINE: "ISOLINE",
    /** 等值面提取。 */
    ISOREGION: "ISOREGION"
};

/**
 * @enum DataReturnMode
 * @description  数据返回模式枚举。
 * 该枚举用于指定空间分析返回结果模式，包含返回数据集标识和记录集、只返回数据集标识(数据集名称@数据源名称)及只返回记录集三种模式。
 * @category BaseTypes Constant
 * @type {string}
 * @usage
 * ```
 * // 浏览器
 * <script type="text/javascript" src="{cdn}"></script>
 * <script>
 *   const result = {namespace}.DataReturnMode.DATASET_AND_RECORDSET;
 *
 * </script>
 * // ES6 Import
 * import { DataReturnMode } from '{npm}';
 *
 * const result = DataReturnMode.DATASET_AND_RECORDSET;
 * ```
 */
var DataReturnMode = {
    /** 返回结果数据集标识(数据集名称@数据源名称)和记录集（RecordSet）。 */
    DATASET_AND_RECORDSET: "DATASET_AND_RECORDSET",
    /** 只返回数据集标识（数据集名称@数据源名称）。 */
    DATASET_ONLY: "DATASET_ONLY",
    /** 只返回记录集（RecordSet）。 */
    RECORDSET_ONLY: "RECORDSET_ONLY"
};

/**
 * @enum EditType
 * @description  要素集更新模式枚举。
 * 该枚举用于指定数据服务中要素集更新模式，包含添加要素集、更新要素集和删除要素集。
 * @category BaseTypes Constant
 * @type {string}
 * @usage
 * ```
 * // 浏览器
 * <script type="text/javascript" src="{cdn}"></script>
 * <script>
 *   const result = {namespace}.EditType.ADD;
 *
 * </script>
 * // ES6 Import
 * import { EditType } from '{npm}';
 *
 * const result = {namespace}.EditType.ADD;
 * ```
 */
var EditType = {
    /** 增加操作。 */
    ADD: "add",
    /** 修改操作。 */
    UPDATE: "update",
    /** 删除操作。 */
    DELETE: "delete"
};

/**
 * @enum TransferTactic
 * @description  公交换乘策略枚举。
 * 该枚举用于指定公交服务中要素集更新模式,包含添加要素集、更新要素集和删除要素集。
 * @category BaseTypes Constant
 * @type {string}
 * @usage
 * ```
 * // 浏览器
 * <script type="text/javascript" src="{cdn}"></script>
 * <script>
 *   const result = {namespace}.TransferTactic.LESS_TIME;
 *
 * </script>
 * // ES6 Import
 * import { TransferTactic } from '{npm}';
 *
 * const result = TransferTactic.LESS_TIME;
 * ```
 */
var TransferTactic = {
    /** 时间短。 */
    LESS_TIME: "LESS_TIME",
    /** 少换乘。 */
    LESS_TRANSFER: "LESS_TRANSFER",
    /** 少步行。 */
    LESS_WALK: "LESS_WALK",
    /** 距离最短。 */
    MIN_DISTANCE: "MIN_DISTANCE"
};

/**
 * @enum TransferPreference
 * @description  公交换乘策略枚举。
 * 该枚举用于指定交通换乘服务中设置地铁优先、公交优先、不乘地铁、无偏好等偏好设置。
 * @category BaseTypes Constant
 * @type {string}
 * @usage
 * ```
 * // 浏览器
 * <script type="text/javascript" src="{cdn}"></script>
 * <script>
 *   const result = {namespace}.TransferPreference.BUS;
 *
 * </script>
 * // ES6 Import
 * import { TransferPreference } from '{npm}';
 *
 * const result = TransferPreference.BUS;
 * ```
 */
var TransferPreference = {
    /** 公交汽车优先。 */
    BUS: "BUS",
    /** 地铁优先。 */
    SUBWAY: "SUBWAY",
    /** 不乘坐地铁。 */
    NO_SUBWAY: "NO_SUBWAY",
    /** 无乘车偏好。 */
    NONE: "NONE"
};

/**
 * @enum GridType
 * @description  地图背景格网类型枚举。
 * @category BaseTypes Constant
 * @type {string}
 * @usage
 * ```
 * // 浏览器
 * <script type="text/javascript" src="{cdn}"></script>
 * <script>
 *   const result = {namespace}.GridType.CROSS;
 *
 * </script>
 * // ES6 Import
 * import { GridType } from '{npm}';
 *
 * const result = GridType.CROSS;
 * ```
 */
var GridType =  {
    /** 十字叉丝。 */
    CROSS: "CROSS",
    /** 网格线。 */
    GRID: "GRID",
    /** 点。 */
    POINT: "POINT"
};

/**
 * @enum ColorSpaceType
 * @description  色彩空间枚举。
 * 由于成色原理的不同，决定了显示器、投影仪这类靠色光直接合成颜色的颜色设备和打印机、
 * 印刷机这类靠使用颜料的印刷设备在生成颜色方式上的区别。
 * 针对上述不同成色方式，SuperMap 提供两种色彩空间，
 * 分别为 RGB 和 CMYK。RGB 主要用于显示系统中，CMYK 主要用于印刷系统中。
 * @category BaseTypes Constant
 * @type {string}
 * @usage
 * ```
 * // 浏览器
 * <script type="text/javascript" src="{cdn}"></script>
 * <script>
 *   const result = {namespace}.ColorSpaceType.CMYK;
 *
 * </script>
 * // ES6 Import
 * import { ColorSpaceType } from '{npm}';
 *
 * const result = ColorSpaceType.CMYK;
 * ```
 */
var ColorSpaceType = {
    /** 该类型主要在印刷系统使用。 */
    CMYK: "CMYK",
    /** 该类型主要在显示系统中使用。 */
    RGB: "RGB"
};

/**
 * @enum LayerType
 * @description  图层类型。
 * @category BaseTypes Constant
 * @type {string}
 * @usage
 * ```
 * // 浏览器
 * <script type="text/javascript" src="{cdn}"></script>
 * <script>
 *   const result = {namespace}.LayerType.UGC;
 *
 * </script>
 * // ES6 Import
 * import { LayerType } from '{npm}';
 *
 * const result = LayerType.UGC;
 * ```
 */
var LayerType = {
    /** SuperMap UGC 类型图层。如矢量图层、栅格(Grid)图层、影像图层。 */
    UGC: "UGC",
    /** WMS 图层。 */
    WMS: "WMS",
    /** WFS 图层。 */
    WFS: "WFS",
    /** 自定义图层。 */
    CUSTOM: "CUSTOM"
};

/**
 * @enum UGCLayerType
 * @description  SuperMap 图层类型。
 * @category BaseTypes Constant
 * @type {string}
 * @usage
 * ```
 * // 浏览器
 * <script type="text/javascript" src="{cdn}"></script>
 * <script>
 *   const result = {namespace}.UGCLayerType.THEME;
 *
 * </script>
 * // ES6 Import
 * import { UGCLayerType } from '{npm}';
 *
 * const result = UGCLayerType.THEME;
 * ```
 */
var UGCLayerType = {
    /** 专题图层。 */
    THEME: "THEME",
    /** 矢量图层。 */
    VECTOR: "VECTOR",
    /** 栅格图层。 */
    GRID: "GRID",
    /** 影像图层。 */
    IMAGE: "IMAGE"
};

/**
 * @enum StatisticMode
 * @description  字段统计方法类型。
 * @category BaseTypes Constant
 * @type {string}
 * @usage
 * ```
 * // 浏览器
 * <script type="text/javascript" src="{cdn}"></script>
 * <script>
 *   const result = {namespace}.StatisticMode.AVERAGE;
 *
 * </script>
 * // ES6 Import
 * import { StatisticMode } from '{npm}';
 *
 * const result = StatisticMode.AVERAGE;
 * ```
 */
var StatisticMode = {
    /** 统计所选字段的平均值。 */
    AVERAGE: "AVERAGE",
    /** 统计所选字段的最大值。 */
    MAX: "MAX",
    /** 统计所选字段的最小值。 */
    MIN: "MIN",
    /** 统计所选字段的标准差 */
    STDDEVIATION: "STDDEVIATION",
    /** 统计所选字段的总和。 */
    SUM: "SUM",
    /** 统计所选字段的方差。 */
    VARIANCE: "VARIANCE"
};

/**
 * @enum PixelFormat
 * @description  栅格与影像数据存储的像素格式枚举。
 * @category BaseTypes Constant
 * @type {string}
 * @usage
 * ```
 * // 浏览器
 * <script type="text/javascript" src="{cdn}"></script>
 * <script>
 *   const result = {namespace}.PixelFormat.BIT16;
 *
 * </script>
 * // ES6 Import
 * import { PixelFormat } from '{npm}';
 *
 * const result = PixelFormat.BIT16;
 * ```
 */
var PixelFormat = {
    /** 每个像元用16个比特(即2个字节)表示。 */
    BIT16: "BIT16",
    /** 每个像元用32个比特(即4个字节)表示。 */
    BIT32: "BIT32",
    /** 每个像元用64个比特(即8个字节)表示，只提供给栅格数据集使用。 */
    BIT64: "BIT64",
    /** 每个像元用4个字节来表示，只提供给栅格数据集使用。 */
    SINGLE: "SINGLE",
    /** 每个像元用8个字节来表示，只提供给栅格数据集使用。 */
    DOUBLE: "DOUBLE",
    /** 每个像元用1个比特表示。 */
    UBIT1: "UBIT1",
    /** 每个像元用4个比特来表示。 */
    UBIT4: "UBIT4",
    /** 每个像元用8个比特(即1个字节)来表示。 */
    UBIT8: "UBIT8",
    /** 每个像元用24个比特(即3个字节)来表示。 */
    UBIT24: "UBIT24",
    /** 每个像元用32个比特(即4个字节)来表示。 */
    UBIT32: "UBIT32"
};

/**
 * @enum SearchMode
 * @description  内插时使用的样本点的查找方式枚举。
 * @category BaseTypes Constant
 * @type {string}
 * @usage
 * ```
 * // 浏览器
 * <script type="text/javascript" src="{cdn}"></script>
 * <script>
 *   const result = {namespace}.SearchMode.KDTREE_FIXED_COUNT;
 *
 * </script>
 * // ES6 Import
 * import { SearchMode } from '{npm}';
 *
 * const result = SearchMode.KDTREE_FIXED_COUNT;
 * ```
 */
var SearchMode = {
    /** 使用 KDTREE 的固定点数方式查找参与内插分析的点。 */
    KDTREE_FIXED_COUNT: "KDTREE_FIXED_COUNT",
    /** 使用 KDTREE 的定长方式查找参与内插分析的点。 */
    KDTREE_FIXED_RADIUS: "KDTREE_FIXED_RADIUS",
    /** 不进行查找，使用所有的输入点进行内插分析。 */
    NONE: "NONE",
    /** 使用 QUADTREE 方式查找参与内插分析的点，仅对样条（RBF）插值和普通克吕金（Kriging）有用。 */
    QUADTREE: "QUADTREE"
};

/**
 * @enum InterpolationAlgorithmType
 * @description  插值分析的算法的类型。
 * @category BaseTypes Constant
 * @type {string}
 * @usage
 * ```
 * // 浏览器
 * <script type="text/javascript" src="{cdn}"></script>
 * <script>
 *   const result = {namespace}.InterpolationAlgorithmType.KRIGING;
 *
 * </script>
 * // ES6 Import
 * import { InterpolationAlgorithmType } from '{npm}';
 *
 * const result = InterpolationAlgorithmType.KRIGING;
 * ```
 */
var InterpolationAlgorithmType = {
    /** 普通克吕金插值法。 */
    KRIGING: "KRIGING",
    /** 简单克吕金插值法。 */
    SimpleKriging: "SimpleKriging",
    /** 泛克吕金插值法。 */
    UniversalKriging: "UniversalKriging"
};

/**
 * @enum VariogramMode
 * @description  克吕金（Kriging）插值时的半变函数类型枚举。
 * @category BaseTypes Constant
 * @type {string}
 * @usage
 * ```
 * // 浏览器
 * <script type="text/javascript" src="{cdn}"></script>
 * <script>
 *   const result = {namespace}.VariogramMode.EXPONENTIAL;
 *
 * </script>
 * // ES6 Import
 * import { VariogramMode } from '{npm}';
 *
 * const result = VariogramMode.EXPONENTIAL;
 * ```
 */
var VariogramMode = {
    /** 指数函数。 */
    EXPONENTIAL: "EXPONENTIAL",
    /** 高斯函数。 */
    GAUSSIAN: "GAUSSIAN",
    /** 球型函数。 */
    SPHERICAL: "SPHERICAL"
};

/**
 * @enum Exponent
 * @description  定义了泛克吕金（UniversalKriging）插值时样点数据中趋势面方程的阶数。
 * @category BaseTypes Constant
 * @type {string}
 * @usage
 * ```
 * // 浏览器
 * <script type="text/javascript" src="{cdn}"></script>
 * <script>
 *   const result = {namespace}.Exponent.EXP1;
 *
 * </script>
 * // ES6 Import
 * import { Exponent } from '{npm}';
 *
 * const result = Exponent.EXP1;
 * ```
 */
var Exponent = {
    /** 阶数为1。 */
    EXP1: "EXP1",
    /** 阶数为2。 */
    EXP2: "EXP2"
};

/**
 * @enum ClientType
 * @description token申请的客户端标识类型。
 * @category BaseTypes Constant
 * @type {string}
 * @usage
 * ```
 * // 浏览器
 * <script type="text/javascript" src="{cdn}"></script>
 * <script>
 *   const result = {namespace}.ClientType.IP;
 *
 * </script>
 * // ES6 Import
 * import { ClientType } from '{npm}';
 *
 * const result = ClientType.IP;
 * ```
 */
var ClientType = {
    /** 指定的 IP 地址。 */
    IP: "IP",
    /** 指定的 URL。 */
    REFERER: "Referer",
    /** 发送申请令牌请求的客户端 IP。 */
    REQUESTIP: "RequestIP",
    /** 不做任何验证。 */
    NONE: "NONE",
    /** SERVER。 */
    SERVER: "SERVER",
    /** WEB。 */
    WEB: "WEB"
};

/**
 * @enum ChartType
 * @description 客户端专题图图表类型。
 * @category BaseTypes Constant
 * @type {string}
 * @usage
 * ```
 * // 浏览器
 * <script type="text/javascript" src="{cdn}"></script>
 * <script>
 *   const result = {namespace}.ChartType.BAR;
 *
 * </script>
 * // ES6 Import
 * import { ChartType } from '{npm}';
 *
 * const result = ChartType.BAR;
 * ```
 */
var ChartType = {
    /** 柱状图。 */
    BAR: "Bar",
    /** 三维柱状图。 */
    BAR3D: "Bar3D",
    /** 圆形图。 */
    CIRCLE: "Circle",
    /** 饼图。 */
    PIE: "Pie",
    /** 散点图。 */
    POINT: "Point",
    /** 折线图。 */
    LINE: "Line",
    /** 环状图。 */
    RING: "Ring"
};

/**
 * @enum ClipAnalystMode
 * @description  裁剪分析模式
 * @category BaseTypes Constant
 * @type {string}
 * @usage
 * ```
 * // 浏览器
 * <script type="text/javascript" src="{cdn}"></script>
 * <script>
 *   const result = {namespace}.ClipAnalystMode.CLIP;
 *
 * </script>
 * // ES6 Import
 * import { ClipAnalystMode } from '{npm}';
 *
 * const result = ClipAnalystMode.CLIP;
 * ```
 */
var ClipAnalystMode = {
    /** CLIP。 */
    CLIP: "clip",
    /** INTERSECT。 */
    INTERSECT: "intersect"
};

/**
 * @enum AnalystAreaUnit
 * @description 分布式分析面积单位。
 * @category BaseTypes Constant
 * @type {string}
 * @usage
 * ```
 * // 浏览器
 * <script type="text/javascript" src="{cdn}"></script>
 * <script>
 *   const result = {namespace}.AnalystAreaUnit.SQUAREMETER;
 *
 * </script>
 * // ES6 Import
 * import { AnalystAreaUnit } from '{npm}';
 *
 * const result = AnalystAreaUnit.SQUAREMETER;
 * ```
 */
var AnalystAreaUnit = {
    /** 平方米。 */
    "SQUAREMETER": "SquareMeter",
    /** 平方千米。 */
    "SQUAREKILOMETER": "SquareKiloMeter",
    /** 公顷。 */
    "HECTARE": "Hectare",
    /** 公亩。 */
    "ARE": "Are",
    /** 英亩。 */
    "ACRE": "Acre",
    /** 平方英尺。 */
    "SQUAREFOOT": "SquareFoot",
    /** 平方码。 */
    "SQUAREYARD": "SquareYard",
    /** 平方英里。 */
    "SQUAREMILE": "SquareMile"
};

/**
 * @enum AnalystSizeUnit
 * @description 分布式分析单位。
 * @category BaseTypes Constant
 * @type {string}
 * @usage
 * ```
 * // 浏览器
 * <script type="text/javascript" src="{cdn}"></script>
 * <script>
 *   const result = {namespace}.AnalystSizeUnit.METER;
 *
 * </script>
 * // ES6 Import
 * import { AnalystSizeUnit } from '{npm}';
 *
 * const result = AnalystSizeUnit.METER;
 * ```
 */
var AnalystSizeUnit = {
    /** 米。 */
    "METER": "Meter",
    /** 千米。 */
    "KILOMETER": "Kilometer",
    /** 码。 */
    "YARD": "Yard",
    /** 英尺。 */
    "FOOT": "Foot",
    /** 英里。 */
    "MILE": "Mile"
};

/**
 * @enum StatisticAnalystMode
 * @description 分布式分析统计模式。
 * @category BaseTypes Constant
 * @type {string}
 * @usage
 * ```
 * // 浏览器
 * <script type="text/javascript" src="{cdn}"></script>
 * <script>
 *   const result = {namespace}.StatisticAnalystMode.MAX;
 *
 * </script>
 * // ES6 Import
 * import { StatisticAnalystMode } from '{npm}';
 *
 * const result = StatisticAnalystMode.MAX;
 * ```
 */
var StatisticAnalystMode = {
    /** 统计所选字段的最大值。 */
    "MAX": "max",
    /** 统计所选字段的最小值。 */
    "MIN": "min",
    /** 统计所选字段的平均值。 */
    "AVERAGE": "average",
    /** 统计所选字段的总和。 */
    "SUM": "sum",
    /** 统计所选字段的方差。 */
    "VARIANCE": "variance",
    /** 统计所选字段的标准差。 */
    "STDDEVIATION": "stdDeviation"
};

/**
 * @enum SummaryType
 * @description 分布式分析聚合类型。
 * @category BaseTypes Constant
 * @type {string}
 * @usage
 * ```
 * // 浏览器
 * <script type="text/javascript" src="{cdn}"></script>
 * <script>
 *   const result = {namespace}.SummaryType.SUMMARYMESH;
 *
 * </script>
 * // ES6 Import
 * import { SummaryType } from '{npm}';
 *
 * const result = SummaryType.SUMMARYMESH;
 * ```
 */
var SummaryType = {
    /** 格网聚合。 */
    "SUMMARYMESH": "SUMMARYMESH",
    /** 多边形聚合。 */
    "SUMMARYREGION": "SUMMARYREGION"
};

/**
 * @enum TopologyValidatorRule
 * @description  拓扑检查模式枚举。该类定义了拓扑检查操作模式常量。
 * @category BaseTypes Constant
 * @type {string}
 * @usage
 * ```
 * // 浏览器
 * <script type="text/javascript" src="{cdn}"></script>
 * <script>
 *   const result = {namespace}.TopologyValidatorRule.REGIONNOOVERLAP;
 *
 * </script>
 * // ES6 Import
 * import { TopologyValidatorRule } from '{npm}';
 *
 * const result = TopologyValidatorRule.REGIONNOOVERLAP;
 * ```
 */
var TopologyValidatorRule = {
    /** 面内无重叠，用于对面数据进行拓扑检查。 */
    REGIONNOOVERLAP: "REGIONNOOVERLAP",
    /** 面与面无重叠，用于对面数据进行拓扑检查。 */
    REGIONNOOVERLAPWITH: "REGIONNOOVERLAPWITH",
    /** 面被面包含，用于对面数据进行拓扑检查。 */
    REGIONCONTAINEDBYREGION: "REGIONCONTAINEDBYREGION",
    /** 面被面覆盖，用于对面数据进行拓扑检查。 */
    REGIONCOVEREDBYREGION: "REGIONCOVEREDBYREGION",
    /** 线与线无重叠，用于对线数据进行拓扑检查。 */
    LINENOOVERLAP: "LINENOOVERLAP",
    /** 线内无重叠，用于对线数据进行拓扑检查。 */
    LINENOOVERLAPWITH: "LINENOOVERLAPWITH",
    /** 点不相同，用于对点数据进行拓扑检查。 */
    POINTNOIDENTICAL: "POINTNOIDENTICAL"
};

/**
 * @enum BucketAggType
 * @description  格网聚合查询枚举类，该类定义了Elasticsearch数据服务中聚合查询模式常量
 * @category BaseTypes Constant
 * @type {string}
 * @usage
 * ```
 * // 浏览器
 * <script type="text/javascript" src="{cdn}"></script>
 * <script>
 *   const result = {namespace}.BucketAggType.GEOHASH_GRID;
 *
 * </script>
 * // ES6 Import
 * import { BucketAggType } from '{npm}';
 *
 * const result = BucketAggType.GEOHASH_GRID;
 * ```
 */
var BucketAggType = {
    /** 格网聚合类型。 */
    GEOHASH_GRID: "geohash_grid"
};

/**
 * @enum MetricsAggType
 * @description  指标聚合类型枚举类，该类定义了Elasticsearch数据服务中聚合查询模式常量。
 * @category BaseTypes Constant
 * @type {string}
 * @usage
 * ```
 * // 浏览器
 * <script type="text/javascript" src="{cdn}"></script>
 * <script>
 *   const result = {namespace}.MetricsAggType.AVG;
 *
 * </script>
 * // ES6 Import
 * import { MetricsAggType } from '{npm}';
 *
 * const result = MetricsAggType.AVG;
 * ```
 */
var MetricsAggType = {
  /** 平均值聚合类型。 */
  AVG:'avg',
  /** 最大值聚合类型。 */
  MAX:'max',
  /** 最小值聚合类型。 */
  MIN:'min',
  /** 求和聚合类型。 */
  SUM:'sum'
};

/**
 * @enum GetFeatureMode
 * @description feature 查询方式。
 * @category BaseTypes Constant
 * @type {string}
 * @usage
 * ```
 * // 浏览器
 * <script type="text/javascript" src="{cdn}"></script>
 * <script>
 *   const result = {namespace}.GetFeatureMode.BOUNDS;
 *
 * </script>
 * // ES6 Import
 * import { GetFeatureMode } from '{npm}';
 *
 * const result = GetFeatureMode.BOUNDS;
 * ```
 */
var GetFeatureMode = {
    /** 通过范围查询来获取要素。 */
    BOUNDS: "BOUNDS",
    /** 通过几何对象的缓冲区来获取要素。 */
    BUFFER: "BUFFER",
    /** 通过 ID 来获取要素。 */
    ID: "ID",
    /** 通过空间查询模式来获取要素。 */
    SPATIAL: "SPATIAL",
    /** 通过 SQL 查询来获取要素。 */
    SQL: 'SQL'
}

/**
 * @enum RasterFunctionType
 * @description 栅格分析方法。
 * @category BaseTypes Constant
 * @type {string}
 * @usage
 * ```
 * // 浏览器
 * <script type="text/javascript" src="{cdn}"></script>
 * <script>
 *   const result = {namespace}.GetFeatureMode.NDVI;
 *
 * </script>
 * // ES6 Import
 * import { GetFeatureMode } from '{npm}';
 *
 * const result = GetFeatureMode.NDVI;
 * ```
 */
var RasterFunctionType = {
    /** 归一化植被指数。 */
    NDVI: "NDVI",
    /** 阴影面分析。 */
    HILLSHADE: "HILLSHADE"
}

/**
 * @enum ResourceType
 * @description iportal资源类型。
 * @category BaseTypes Constant
 * @version 10.0.1
 * @type {string}
 * @usage
 * ```
 * // 浏览器
 * <script type="text/javascript" src="{cdn}"></script>
 * <script>
 *   const result = {namespace}.GetFeatureMode.MAP;
 *
 * </script>
 * // ES6 Import
 * import { GetFeatureMode } from '{npm}';
 *
 * const result = GetFeatureMode.MAP;
 * ```
 */
var ResourceType = {
    /** 地图。 */
    MAP: "MAP",
    /** 服务。 */
    SERVICE: "SERVICE",
    /** 场景。 */
    SCENE: "SCENE",
    /** 数据。 */
    DATA: "DATA",
    /** 洞察。 */
    INSIGHTS_WORKSPACE: "INSIGHTS_WORKSPACE",
    /** 大屏。 */
    MAP_DASHBOARD: "MAP_DASHBOARD"
}

/**
 * @enum OrderBy
 * @description iportal资源排序字段。
 * @category BaseTypes Constant
 * @version 10.0.1
 * @type {string}
 * @usage
 * ```
 * // 浏览器
 * <script type="text/javascript" src="{cdn}"></script>
 * <script>
 *   const result = {namespace}.OrderBy.UPDATETIME;
 *
 * </script>
 * // ES6 Import
 * import { OrderBy } from '{npm}';
 *
 * const result = OrderBy.UPDATETIME;
 * ```
 */
var OrderBy = {
    /** 按更新时间排序。 */
    UPDATETIME: "UPDATETIME",
    /** 按热度(可能是访问量、下载量)排序。 */
    HEATLEVEL: "HEATLEVEL",
    /** 按相关性排序。 */
    RELEVANCE: "RELEVANCE"
}

/**
 * @enum OrderType
 * @description iportal资源升序还是降序过滤。
 * @category BaseTypes Constant
 * @version 10.0.1
 * @type {string}
 * @usage
 * ```
 * // 浏览器
 * <script type="text/javascript" src="{cdn}"></script>
 * <script>
 *   const result = {namespace}.OrderType.ASC;
 *
 * </script>
 * // ES6 Import
 * import { OrderType } from '{npm}';
 *
 * const result = OrderType.ASC;
 * ```
 */
var OrderType = {
    /** 升序。 */
    ASC: "ASC",
    /** 降序。 */
    DESC: "DESC"
}

/**
 * @enum SearchType
 * @description iportal资源查询的范围进行过滤。
 * @category BaseTypes Constant
 * @version 10.0.1
 * @type {string}
 * @usage
 * ```
 * // 浏览器
 * <script type="text/javascript" src="{cdn}"></script>
 * <script>
 *   const result = {namespace}.SearchType.PUBLIC;
 *
 * </script>
 * // ES6 Import
 * import { SearchType } from '{npm}';
 *
 * const result = SearchType.PUBLIC;
 * ```
 */
var SearchType = {
    /** 公开资源。 */
    PUBLIC: "PUBLIC",
    /** 我的资源。 */
    MY_RES: "MY_RES",
    /** 我的群组资源。 */
    MYGROUP_RES: "MYGROUP_RES",
    /** 我的部门资源。 */
    MYDEPARTMENT_RES: "MYDEPARTMENT_RES",
    /** 分享给我的资源。 */
    SHARETOME_RES: "SHARETOME_RES"
}

/**
 * @enum AggregationTypes
 * @description iportal资源聚合查询的类型。
 * @category BaseTypes Constant
 * @version 10.0.1
 * @type {string}
 * @usage
 * ```
 * // 浏览器
 * <script type="text/javascript" src="{cdn}"></script>
 * <script>
 *   const result = {namespace}.AggregationTypes.TAG;
 *
 * </script>
 * // ES6 Import
 * import { AggregationTypes } from '{npm}';
 *
 * const result = AggregationTypes.TAG;
 * ```
 */
var AggregationTypes = {
    /** 标签。 */
    TAG: "TAG",
    /** 资源类型。 */
    TYPE: "TYPE"
}

/**
 * @enum PermissionType
 * @description iportal资源权限类型。
 * @category BaseTypes Constant
 * @version 10.0.1
 * @type {string}
 * @usage
 * ```
 * // 浏览器
 * <script type="text/javascript" src="{cdn}"></script>
 * <script>
 *   const result = {namespace}.PermissionType.SEARCH;
 *
 * </script>
 * // ES6 Import
 * import { PermissionType } from '{npm}';
 *
 * const result = PermissionType.SEARCH;
 * ```
 */
var PermissionType = {
    /** 可检索。 */
    SEARCH:"SEARCH",
    /** 可查看。 */
    READ: "READ",
    /** 可编辑。 */
    READWRITE: "READWRITE",
    /** 可删除。 */
    DELETE: "DELETE",
    /** 可下载，包括可读、可检索。 */
    DOWNLOAD:"DOWNLOAD"
}

/**
 * @enum EntityType
 * @description iportal资源实体类型。
 * @category BaseTypes Constant
 * @version 10.0.1
 * @type {string}
 * @usage
 * ```
 * // 浏览器
 * <script type="text/javascript" src="{cdn}"></script>
 * <script>
 *   const result = {namespace}.EntityType.DEPARTMENT;
 *
 * </script>
 * // ES6 Import
 * import { EntityType } from '{npm}';
 *
 * const result = EntityType.DEPARTMENT;
 * ```
 */
var EntityType = {
    /** 部门。 */
    DEPARTMENT: "DEPARTMENT",
    /** 用户组。 */
    GROUP: "GROUP",
    /** 群组。 */
    IPORTALGROUP: "IPORTALGROUP",
    /** 角色。 */
    ROLE: "ROLE",
    /** 用户。 */
    USER: "USER"
}

/**
 * @enum DataItemType
 * @description iportal数据类型。
 * @category BaseTypes Constant
 * @version 10.0.1
 * @type {string}
 * @usage
 * ```
 * // 浏览器
 * <script type="text/javascript" src="{cdn}"></script>
 * <script>
 *   const result = {namespace}.DataItemType.GEOJSON;
 *
 * </script>
 * // ES6 Import
 * import { DataItemType } from '{npm}';
 *
 * const result = DataItemType.GEOJSON;
 * ```
 */
var DataItemType = {
    /** geojson 数据。 */
    GEOJSON: "GEOJSON",
    /** UGCV5_MVT。  */
    UGCV5_MVT: "UGCV5_MVT",
    /** json数据。  */
    JSON: "JSON",
    /** 音频文件。 */
    AUDIO: "AUDIO",
    /** Color 颜色。 */
    COLOR: "COLOR",
    /** ColorScheme 颜色方案。 */
    COLORSCHEME: "COLORSCHEME",
    /** CSV 数据。 */
    CSV: "CSV",
    /** EXCEL 数据。 */
    EXCEL: "EXCEL",
    /** FillSymbol 填充符号库。 */
    FILLSYMBOL: "FILLSYMBOL",
    /** 图片类型。 */
    IMAGE: "IMAGE",
    /** LayerTemplate 图层模板。 */
    LAYERTEMPLATE: "LAYERTEMPLATE",
    /** LayoutTemplate 布局模板。 */
    LAYOUTTEMPLATE: "LAYOUTTEMPLATE",
    /** LineSymbol 线符号库。 */
    LINESYMBOL: "LINESYMBOL",
    /** MapTemplate 地图模板。 */
    MAPTEMPLATE: "MAPTEMPLATE",
    /** MarkerSymbol 点符号库。 */
    MARKERSYMBOL: "MARKERSYMBOL",
    /** MBTILES。 */
    MBTILES: "MBTILES",
    /** 照片。 */
    PHOTOS: "PHOTOS",
    /** SHP 空间数据。 */
    SHP: "SHP",
    /** SMTILES。 */
    SMTILES: "SMTILES",
    /** SVTILES。 */
    SVTILES: "SVTILES",
    /** ThemeTemplate 专题图模板。 */
    THEMETEMPLATE: "THEMETEMPLATE",
    /** TPK。 */
    TPK: "TPK",
    /** UDB 数据源。 */
    UDB: "UDB",
    /** UGCV5。 */
    UGCV5: "UGCV5",
    /** 其他类型（普通文件）。 */
    UNKNOWN: "UNKNOWN",
    /** 视频文件。 */
    VIDEO: "VIDEO",
    /** WorkEnviroment 工作环境。 */
    WORKENVIRONMENT: "WORKENVIRONMENT",
    /** 工作空间。 */
    WORKSPACE: "WORKSPACE"
}

/**
 * @enum WebExportFormatType
 * @description Web 打印输出的格式。
 * @category BaseTypes Constant
 * @version 10.0.1
 * @type {string}
 * @usage
 * ```
 * // 浏览器
 * <script type="text/javascript" src="{cdn}"></script>
 * <script>
 *   const result = {namespace}.WebExportFormatType.PNG;
 *
 * </script>
 * // ES6 Import
 * import { WebExportFormatType } from '{npm}';
 *
 * const result = WebExportFormatType.PNG;
 * ```
 */
var WebExportFormatType = {
    /** PNG */
    PNG: "PNG",
    /** PDF */
    PDF: "PDF"
}

/**
 * @enum WebScaleOrientationType
 * @description Web 比例尺的方位样式。
 * @category BaseTypes Constant
 * @version 10.0.1
 * @type {string}
 * @usage
 * ```
 * // 浏览器
 * <script type="text/javascript" src="{cdn}"></script>
 * <script>
 *   const result = {namespace}.WebScaleOrientationType.HORIZONTALLABELSBELOW;
 *
 * </script>
 * // ES6 Import
 * import { WebScaleOrientationType } from '{npm}';
 *
 * const result = WebScaleOrientationType.HORIZONTALLABELSBELOW;
 * ```
 */
var WebScaleOrientationType = {
    /** horizontal labels below. */
    HORIZONTALLABELSBELOW: "HORIZONTALLABELSBELOW",
    /** horizontal labels above. */
    HORIZONTALLABELSABOVE: "HORIZONTALLABELSABOVE",
    /** vertical labels left. */
    VERTICALLABELSLEFT: "VERTICALLABELSLEFT",
    /** vertical labels right. */
    VERTICALLABELSRIGHT: "VERTICALLABELSRIGHT"
}

/**
 * @enum WebScaleType
 * @description Web 比例尺的样式。
 * @category BaseTypes Constant
 * @version 10.0.1
 * @type {string}
 * @usage
 * ```
 * // 浏览器
 * <script type="text/javascript" src="{cdn}"></script>
 * <script>
 *   const result = {namespace}.WebScaleType.LINE;
 *
 * </script>
 * // ES6 Import
 * import { WebScaleType } from '{npm}';
 *
 * const result = WebScaleType.LINE;
 * ```
 */
var WebScaleType = {
    /** line. */
    LINE: "LINE",
    /** bar. */
    BAR: "BAR",
    /** bar sub. */
    BAR_SUB: "BAR_SUB"
}

/**
 * @enum WebScaleUnit
 * @description Web 比例尺的单位制。
 * @category BaseTypes Constant
 * @version 10.0.1
 * @type {string}
 * @usage
 * ```
 * // 浏览器
 * <script type="text/javascript" src="{cdn}"></script>
 * <script>
 *   const result = {namespace}.WebScaleUnit.METER;
 *
 * </script>
 * // ES6 Import
 * import { WebScaleUnit } from '{npm}';
 *
 * const result = WebScaleUnit.METER;
 * ```
 */
var WebScaleUnit = {
    /** 米。 */
    METER: "METER",
    /** 英尺。 */
    FOOT: "FOOT",
    /** 度。 */
    DEGREES: "DEGREES"
}

/**
 * @enum BoundsType
 * @description 范围类型。
 * @category BaseTypes Constant
 * @version 11.1.1
 * @type {string}
 * @usage
 * ```
 * // 浏览器
 * <script type="text/javascript" src="{cdn}"></script>
 * <script>
 *   const result = {namespace}.BoundsType.UNION;
 *
 * </script>
 * // ES6 Import
 * import { BoundsType } from '{npm}';
 *
 * const result = BoundsType.UNION;
 * ```
 */
var BoundsType = {
  /** 自定义范围。 */
  CUSTOM: "CUSTOM",
  /** 输入栅格数据集范围的交集。 */
  INTERSECTION: "INTERSECTION",
  /** 输入栅格数据集范围的并集。 */
  UNION: "UNION"
}

/**
 * @enum CellSizeType
 * @description 单元格类型。
 * @category BaseTypes Constant
 * @version 11.1.1
 * @type {string}
 * @usage
 * ```
 * // 浏览器
 * <script type="text/javascript" src="{cdn}"></script>
 * <script>
 *   const result = {namespace}.CellSizeType.MAX;
 *
 * </script>
 * // ES6 Import
 * import { CellSizeType } from '{npm}';
 *
 * const result = CellSizeType.MAX;
 * ```
 */
var CellSizeType = {
  /** 用户自己输入的单元格值大小作为单元格大小类型。 */
  CUSTOM: "CUSTOM",
  /** 输入栅格数据集中单元格最大值作为单元格大小类型。*/
  MAX : "MAX",
  /** 输入栅格数据集中单元格最小值作为单元格大小类型。 */
  MIN : "MIN"
}


;// CONCATENATED MODULE: ./src/common/iServer/ServerGeometry.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/













/**
 * @class ServerGeometry
 * @deprecatedclass SuperMap.ServerGeometry
 * @category  iServer Data Feature
 * @classdesc 服务端几何对象类。该类描述几何对象（矢量）的特征数据（坐标点对、几何对象的类型等）。基于服务端的空间分析、空间关系运算、查询等 GIS 服务功能使用服务端几何对象。
 * @param {Object} options - 参数。
 * @param {string} options.id - 服务端几何对象唯一标识符。
 * @param {Array.<number>} options.parts - 服务端几何对象中各个子对象所包含的节点个数。
 * @param {Array.<GeometryPoint>} options.points - 组成几何对象的节点的坐标对数组。
 * @param {GeometryType} options.type - 几何对象的类型。
 * @param {ServerStyle} [options.style] - 服务端几何对象的风格。
 * @usage
 */
class ServerGeometry {
    constructor(options) {
        /**
         * @member {string} ServerGeometry.prototype.id
         * @description 服务端几何对象唯一标识符。
         */
        this.id = 0;

        /**
         * @member {ServerStyle} [ServerGeometry.prototype.style]
         * @description 服务端几何对象的风格（ServerStyle）。
         */
        this.style = null;

        /**
         * @member {Array.<number>} ServerGeometry.prototype.parts
         * @description 服务端几何对象中各个子对象所包含的节点个数。<br>
         * 1.几何对象从结构上可以分为简单几何对象和复杂几何对象。
         * 简单几何对象与复杂几何对象的区别：简单的几何对象一般为单一对象，
         * 而复杂的几何对象由多个简单对象组成或经过一定的空间运算之后产生，
         * 如：矩形为简单的区域对象，而中空的矩形为复杂的区域对象。<br>
         * 2.通常情况，一个简单几何对象的子对象就是它本身，
         * 因此对于简单对象来说的该字段为长度为1的整型数组，
         * 该字段的值就是这个简单对象节点的个数。
         * 如果一个几何对象是由几个简单对象组合而成的，
         * 例如，一个岛状几何对象由 3 个简单的多边形组成而成，
         * 那么这个岛状的几何对象的 Parts 字段值就是一个长度为 3 的整型数组，
         * 数组中每个成员的值分别代表这三个多边形所包含的节点个数。
         */
        this.parts = null;

        /**
         * @member {Array.<GeometryPoint>} ServerGeometry.prototype.points
         * @description 组成几何对象的节点的坐标对数组。<br>
         * 1.所有几何对象（点、线、面）都是由一些简单的点坐标组成的，
         * 该字段存放了组成几何对象的点坐标的数组。
         * 对于简单的面对象，他的起点和终点的坐标点相同。<br>
         * 2.对于复杂的几何对象，根据 Parts 属性来确定每一个组成复杂几何对象的简单对象所对应的节点的个数，
         * 从而确定 Points 字段中坐标对的分配归属问题。
         */
        this.points = null;

        /**
         * @member {GeometryType} ServerGeometry.prototype.type
         * @description 几何对象的类型（GeometryType）。
         */
        this.type = null;

        /**
         * @member {Object} ServerGeometry.prototype.prjCoordSys
         * @description 投影坐标参数，现仅在缓冲区分析中有效。
         */
        this.prjCoordSys = null;
        if (options) {
            Util_Util.extend(this, options);
        }

        this.CLASS_NAME = 'SuperMap.ServerGeometry';
    }

    /**
     * @function ServerGeometry.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        var me = this;
        me.id = null;
        me.style = null;
        me.parts = null;
        me.partTopo = null;
        me.points = null;
        me.type = null;
        me.prjCoordSys = null;
    }

    /**
     * @function ServerGeometry.prototype.toGeometry
     * @description 将服务端几何对象 ServerGeometry 转换为客户端几何对象 Geometry。
     * @returns {Geometry} 转换后的客户端几何对象。
     */
    toGeometry() {
        var me = this,
            geoType = me.type;
        switch (geoType.toUpperCase()) {
            case REST_GeometryType.POINT:
                return me.toGeoPoint();
            case REST_GeometryType.LINE:
                return me.toGeoLine();
            case REST_GeometryType.LINEM:
                return me.toGeoLinem();
            case REST_GeometryType.REGION:
                return me.toGeoRegion();
            case REST_GeometryType.POINTEPS:
                return me.toGeoPoint();
            case REST_GeometryType.LINEEPS:
                return me.toGeoLineEPS();
            case REST_GeometryType.REGIONEPS:
                return me.toGeoRegionEPS();
            case REST_GeometryType.GEOCOMPOUND:
                return me.transformGeoCompound();
        }
    }

    /**
     * @function ServerGeometry.prototype.toGeoPoint
     * @description 将服务端的点几何对象转换为客户端几何对象。包括 Point、MultiPoint。
     * @returns {Geometry} 转换后的客户端几何对象。
     */
    toGeoPoint() {
        var me = this,
            geoParts = me.parts || [],
            geoPoints = me.points || [],
            len = geoParts.length;
        if (len > 0) {
            if (len === 1) {
                return new Point(geoPoints[0].x, geoPoints[0].y);
            } else {
                var pointList = [];
                for (let i = 0; i < len; i++) {
                    pointList.push(new Point(geoPoints[i].x, geoPoints[i].y));
                }
                return new MultiPoint(pointList);
            }
        } else {
            return null;
        }
    }

    /**
     * @function ServerGeometry.prototype.toGeoLine
     * @description 将服务端的线几何对象转换为客户端几何对象。包括 GeometryLinearRing、GeometryLineString、GeometryMultiLineString。
     * @returns {Geometry} 转换后的客户端几何对象。
     */
    toGeoLine() {
        var me = this,
            geoParts = me.parts || [],
            geoPoints = me.points || [],
            len = geoParts.length;
        if (len > 0) {
            if (len === 1) {
                let pointList = [];
                for (let i = 0; i < geoParts[0]; i++) {
                    pointList.push(new Point(geoPoints[i].x, geoPoints[i].y));
                }
                //判断线是否闭合，如果闭合，则返回LinearRing，否则返回LineString
                if (pointList[0].equals(pointList[geoParts[0] - 1])) {
                    return new LinearRing_LinearRing(pointList);
                } else {
                    return new LineString(pointList);
                }
            } else {
                let lineList = [];
                for (let i = 0; i < len; i++) {
                    let pointList = [];
                    for (let j = 0; j < geoParts[i]; j++) {
                        pointList.push(new Point(geoPoints[j].x, geoPoints[j].y));
                    }
                    lineList.push(new LineString(pointList));
                    geoPoints.splice(0, geoParts[i]);
                }
                return new MultiLineString(lineList);
            }
        } else {
            return null;
        }
    }

    /**
     * @function ServerGeometry.prototype.toGeoLineEPS
     * @description 将服务端的线几何对象转换为客户端几何对象。包括 GeometryLinearRing、GeometryLineString、GeometryMultiLineString。
     * @returns {Geometry} 转换后的客户端几何对象。
     */
    toGeoLineEPS() {
        var me = this,
            geoParts = me.parts || [],
            geoPoints = me.points || [],
            i,
            j,
            pointList,
            lineList,
            lineEPS,
            len = geoParts.length;
        if (len > 0) {
            if (len === 1) {
                for (i = 0, pointList = []; i < geoParts[0]; i++) {
                    pointList.push(new Point(geoPoints[i].x, geoPoints[i].y, geoPoints[i].type));
                }
                //判断线是否闭合，如果闭合，则返回LinearRing，否则返回LineString
                if (pointList[0].equals(pointList[geoParts[0] - 1])) {
                    lineEPS = LineString.createLineEPS(pointList);
                    return new LinearRing_LinearRing(lineEPS);
                } else {
                    lineEPS = LineString.createLineEPS(pointList);
                    return new LineString(lineEPS);
                }
            } else {
                for (i = 0, lineList = []; i < len; i++) {
                    for (j = 0, pointList = []; j < geoParts[i]; j++) {
                        pointList.push(new Point(geoPoints[j].x, geoPoints[j].y));
                    }
                    lineEPS = LineString.createLineEPS(pointList);
                    lineList.push(new LineString(lineEPS));
                    geoPoints.splice(0, geoParts[i]);
                }
                return new MultiLineString(lineList);
            }
        } else {
            return null;
        }
    }

    /**
     * @function ServerGeometry.prototype.toGeoLinem
     * @description 将服务端的路由线几何对象转换为客户端几何对象。包括 LinearRing、LineString、MultiLineString。
     * @returns {Geometry} 转换后的客户端几何对象。
     */
    toGeoLinem() {
        var me = this;
        return Route.fromJson(me);
    }

    /**
     * @function ServerGeometry.prototype.toGeoRegion
     * @description 将服务端的面几何对象转换为客户端几何对象。类型为 GeometryPolygon。
     * @returns {Geometry} 转换后的客户端几何对象。
     */
    toGeoRegion() {
        var me = this,
            geoParts = me.parts || [],
            geoTopo = me.partTopo || [],
            geoPoints = me.points || [],
            len = geoParts.length;
        if (len <= 0) {
            return null;
        }
        var polygonArray = [];
        var pointList = [];
        if (len == 1) {
            for (let i = 0; i < geoPoints.length; i++) {
                pointList.push(new Point(geoPoints[i].x, geoPoints[i].y));
            }
            polygonArray.push(new Polygon_Polygon([new LinearRing_LinearRing(pointList)]));
            return new MultiPolygon(polygonArray);
        }
        //处理复杂面
        var CCWArray = [];
        var areaArray = [];
        var polygonArrayTemp = [];
        var polygonBounds = [];
        //polyon岛洞标识数组，初始都是岛。
        var CCWIdent = [];
        for (let i = 0, pointIndex = 0; i < len; i++) {
            for (let j = 0; j < geoParts[i]; j++) {
                pointList.push(new Point(geoPoints[pointIndex + j].x, geoPoints[pointIndex + j].y));
            }
            pointIndex += geoParts[i];
            var polygon = new Polygon_Polygon([new LinearRing_LinearRing(pointList)]);
            pointList = [];
            polygonArrayTemp.push(polygon);
            if (geoTopo.length === 0) {
                polygonBounds.push(polygon.getBounds());
            }
            CCWIdent.push(1);
            areaArray.push(polygon.getArea());
        }
        //iServer 9D新增字段
        if (geoTopo.length === 0) {
            //根据面积排序
            ServerGeometry.bubbleSort(areaArray, polygonArrayTemp, geoTopo, polygonBounds);
            //岛洞底层判断原则：将所有的子对象按照面积排序，面积最大的直接判定为岛（1），从面积次大的开始处理，
            // 如果发现该对象在某个面积大于它的对象之中（即被包含），则根据包含它的对象的标识（1 or -1），指定其标识（-1 or 1），
            // 依次处理完所有对象，就得到了一个标识数组，1表示岛，-1表示洞
            //目标polygon索引列表 -1标示没有被任何polygon包含，
            var targetArray = [];
            for (let i = 1; i < polygonArrayTemp.length; i++) {
                for (let j = i - 1; j >= 0; j--) {
                    targetArray[i] = -1;
                    if (polygonBounds[j].containsBounds(polygonBounds[i])) {
                        CCWIdent[i] = CCWIdent[j] * -1;
                        if (CCWIdent[i] < 0) {
                            targetArray[i] = j;
                        }
                        break;
                    }
                }
            }
            for (let i = 0; i < polygonArrayTemp.length; i++) {
                if (CCWIdent[i] > 0) {
                    polygonArray.push(polygonArrayTemp[i]);
                } else {
                    polygonArray[targetArray[i]].components = polygonArray[targetArray[i]].components.concat(
                        polygonArrayTemp[i].components
                    );
                    //占位
                    polygonArray.push('');
                }
            }
        } else {
            polygonArray = new Array();
            for (let i = 0; i < polygonArrayTemp.length; i++) {
                if (geoTopo[i] && geoTopo[i] == -1) {
                    CCWArray = CCWArray.concat(polygonArrayTemp[i].components);
                } else {
                    if (CCWArray.length > 0 && polygonArray.length > 0) {
                        polygonArray[polygonArray.length - 1].components =
                            polygonArray[polygonArray.length - 1].components.concat(CCWArray);
                        CCWArray = [];
                    }
                    polygonArray.push(polygonArrayTemp[i]);
                }
                if (i == len - 1) {
                    var polyLength = polygonArray.length;
                    if (polyLength) {
                        polygonArray[polyLength - 1].components =
                            polygonArray[polyLength - 1].components.concat(CCWArray);
                    } else {
                        for (let k = 0, length = CCWArray.length; k < length; k++) {
                            polygonArray.push(new Polygon_Polygon(CCWArray));
                        }
                    }
                }
            }
        }
        return new MultiPolygon(polygonArray);
    }

    /**
     * @function ServerGeometry.prototype.toGeoRegionEPS
     * @description 将服务端的面几何对象转换为客户端几何对象。类型为 Polygon。
     * @returns {Geometry} 转换后的客户端几何对象。
     */
    toGeoRegionEPS() {
        var me = this,
            geoParts = me.parts || [],
            geoTopo = me.partTopo || [],
            geoPoints = me.points || [],
            len = geoParts.length;

        if (len <= 0) {
            return null;
        }
        var polygonArray = [];
        var pointList = [];
        var lineEPS;
        if (len == 1) {
            for (var i = 0; i < geoPoints.length; i++) {
                pointList.push(new Point(geoPoints[i].x, geoPoints[i].y));
            }

            lineEPS = LineString.createLineEPS(pointList);
            polygonArray.push(new Polygon_Polygon([new LinearRing_LinearRing(lineEPS)]));
            return new MultiPolygon(polygonArray);
        }
        //处理复杂面
        var CCWArray = [];
        var areaArray = [];
        var polygonArrayTemp = [];
        var polygonBounds = [];
        //polyon岛洞标识数组，初始都是岛。
        var CCWIdent = [];
        for (let i = 0, pointIndex = 0; i < len; i++) {
            for (let j = 0; j < geoParts[i]; j++) {
                pointList.push(new Point(geoPoints[pointIndex + j].x, geoPoints[pointIndex + j].y));
            }
            pointIndex += geoParts[i];

            lineEPS = LineString.createLineEPS(pointList);
            var polygon = new Polygon_Polygon([new LinearRing_LinearRing(lineEPS)]);
            pointList = [];
            polygonArrayTemp.push(polygon);
            if (geoTopo.length === 0) {
                polygonBounds.push(polygon.getBounds());
            }
            CCWIdent.push(1);
            areaArray.push(polygon.getArea());
        }
        //iServer 9D新增字段
        if (geoTopo.length === 0) {
            //根据面积排序
            ServerGeometry.bubbleSort(areaArray, polygonArrayTemp, geoTopo, polygonBounds);
            //岛洞底层判断原则：将所有的子对象按照面积排序，面积最大的直接判定为岛（1），从面积次大的开始处理，
            // 如果发现该对象在某个面积大于它的对象之中（即被包含），则根据包含它的对象的标识（1 or -1），指定其标识（-1 or 1），
            // 依次处理完所有对象，就得到了一个标识数组，1表示岛，-1表示洞
            //目标polygon索引列表 -1标示没有被任何polygon包含，
            var targetArray = [];
            for (let i = 1; i < polygonArrayTemp.length; i++) {
                for (let j = i - 1; j >= 0; j--) {
                    targetArray[i] = -1;
                    if (polygonBounds[j].containsBounds(polygonBounds[i])) {
                        CCWIdent[i] = CCWIdent[j] * -1;
                        if (CCWIdent[i] < 0) {
                            targetArray[i] = j;
                        }
                        break;
                    }
                }
            }
            for (let i = 0; i < polygonArrayTemp.length; i++) {
                if (CCWIdent[i] > 0) {
                    polygonArray.push(polygonArrayTemp[i]);
                } else {
                    polygonArray[targetArray[i]].components = polygonArray[targetArray[i]].components.concat(
                        polygonArrayTemp[i].components
                    );
                    //占位
                    polygonArray.push('');
                }
            }
        } else {
            polygonArray = new Array();
            for (let i = 0; i < polygonArrayTemp.length; i++) {
                if (geoTopo[i] && geoTopo[i] == -1) {
                    CCWArray = CCWArray.concat(polygonArrayTemp[i].components);
                } else {
                    if (CCWArray.length > 0 && polygonArray.length > 0) {
                        polygonArray[polygonArray.length - 1].components =
                            polygonArray[polygonArray.length - 1].components.concat(CCWArray);
                        CCWArray = [];
                    }
                    polygonArray.push(polygonArrayTemp[i]);
                }
                if (i == len - 1) {
                    var polyLength = polygonArray.length;
                    if (polyLength) {
                        polygonArray[polyLength - 1].components =
                            polygonArray[polyLength - 1].components.concat(CCWArray);
                    } else {
                        for (let k = 0, length = CCWArray.length; k < length; k++) {
                            polygonArray.push(new Polygon_Polygon(CCWArray));
                        }
                    }
                }
            }
        }
        return new MultiPolygon(polygonArray);
    }
    transformGeoCompound() {
        const me = this,
            geoParts = me.geoParts || [],
            len = geoParts.length;
        if (len <= 0) {
            return null;
        }
        const geometryList = [];
        for (let index = 0; index < len; index++) {
            const geometry = geoParts[index];
            geometryList.push(new ServerGeometry(geometry).toGeometry());
        }
        return new Collection(geometryList);
    }

    /**
     * @function ServerGeometry.prototype.fromJson
     * @description 将 JSON 对象表示服务端几何对象转换为 ServerGeometry。
     * @param {Object} jsonObject - 要转换的 JSON 对象。
     * @returns {ServerGeometry} 转换后的 ServerGeometry 对象。
     */
    static fromJson(jsonObject) {
        if (!jsonObject) {
            return;
        }
        return new ServerGeometry({
            id: jsonObject.id,
            style: ServerStyle.fromJson(jsonObject.style),
            parts: jsonObject.parts,
            partTopo: jsonObject.partTopo,
            points: jsonObject.points,
            center: jsonObject.center,
            length: jsonObject.length,
            maxM: jsonObject.maxM,
            minM: jsonObject.minM,
            type: jsonObject.type
        });
    }

    /**
     * @function ServerGeometry.prototype.fromGeometry
     * @description 将客户端 Geometry 转换成服务端 ServerGeometry。
     * @param {Geometry} geometry - 要转换的客户端 Geometry 对象。
     * @returns {ServerGeometry} 转换后的 ServerGeometry 对象。
     */
    static fromGeometry(geometry) {
        if (!geometry) {
            return;
        }
        var id = 0,
            parts = [],
            points = [],
            type = null,
            icomponents = geometry.components,
            className = geometry.CLASS_NAME,
            prjCoordSys = { epsgCode: geometry.SRID };

        if (!isNaN(geometry.id)) {
            id = geometry.id;
        }
        //坑爹的改法，没法，为了支持态势标绘，有时间就得全改
        if (
            className != 'SuperMap.Geometry.LinearRing' &&
            className != 'SuperMap.Geometry.LineString' &&
            (geometry instanceof MultiPoint || geometry instanceof MultiLineString)
        ) {
            let ilen = icomponents.length;
            for (let i = 0; i < ilen; i++) {
                const vertices = icomponents[i].getVertices();
                let partPointsCount = vertices.length;
                parts.push(partPointsCount);
                for (let j = 0; j < partPointsCount; j++) {
                    points.push(new Point(vertices[j].x, vertices[j].y));
                }
            }
            //这里className不是多点就全部是算线
            type = className == 'SuperMap.Geometry.MultiPoint' ? REST_GeometryType.POINT : REST_GeometryType.LINE;
        } else if (geometry instanceof MultiPolygon) {
            let ilen = icomponents.length;
            for (let i = 0; i < ilen; i++) {
                let polygon = icomponents[i],
                    linearRingOfPolygon = polygon.components,
                    linearRingOfPolygonLen = linearRingOfPolygon.length;
                for (let j = 0; j < linearRingOfPolygonLen; j++) {
                    const vertices = linearRingOfPolygon[j].getVertices();
                    const partPointsCount = vertices.length + 1;
                    parts.push(partPointsCount);
                    for (let k = 0; k < partPointsCount - 1; k++) {
                        points.push(new Point(vertices[k].x, vertices[k].y));
                    }
                    points.push(
                        new Point(vertices[0].x, vertices[0].y)
                    );
                }
            }
            type = REST_GeometryType.REGION;
        } else if (geometry instanceof Polygon_Polygon) {
            let ilen = icomponents.length;
            for (let i = 0; i < ilen; i++) {
                const vertices = icomponents[i].getVertices();
                let partPointsCount = vertices.length + 1;
                parts.push(partPointsCount);
                for (let j = 0; j < partPointsCount - 1; j++) {
                  points.push(new Point(vertices[j].x, vertices[j].y));
                }
                points.push(new Point(vertices[0].x, vertices[0].y));
            }
            type = REST_GeometryType.REGION;
        } else {
            const vertices = geometry.getVertices();
            let geometryVerticesCount = vertices.length;
            for (let j = 0; j < geometryVerticesCount; j++) {
                points.push(new Point(vertices[j].x, vertices[j].y));
            }
            if (geometry instanceof LinearRing_LinearRing) {
                points.push(new Point(vertices[0].x, vertices[0].y));
                geometryVerticesCount++;
            }
            parts.push(geometryVerticesCount);
            type = geometry instanceof Point ? REST_GeometryType.POINT : REST_GeometryType.LINE;
        }

        return new ServerGeometry({
            id: id,
            style: null,
            parts: parts,
            points: points,
            type: type,
            prjCoordSys: prjCoordSys
        });
    }

    /**
     * @function ServerGeometry.prototype.IsClockWise
     * @description 判断 linearRing 中的点的顺序。返回值大于 0，逆时针；小于 0，顺时针。
     * @param {Geometry} geometry - 要转换的客户端 Geometry 对象。
     * @returns {number} 返回值大于 0，逆时针；小于 0，顺时针。
     */
    static IsClockWise(points) {
        var length = points.length;
        if (length < 3) {
            return 0.0;
        }
        var s = points[0].y * (points[length - 1].x - points[1].x);
        points.push(points[0]);
        for (var i = 1; i < length; i++) {
            s += points[i].y * (points[i - 1].x - points[i + 1].x);
        }
        return s * 0.5;
    }

    static bubbleSort(areaArray, pointList, geoTopo, polygonBounds) {
        for (var i = 0; i < areaArray.length; i++) {
            for (var j = 0; j < areaArray.length; j++) {
                if (areaArray[i] > areaArray[j]) {
                    var d = areaArray[j];
                    areaArray[j] = areaArray[i];
                    areaArray[i] = d;
                    var b = pointList[j];
                    pointList[j] = pointList[i];
                    pointList[i] = b;
                    if (geoTopo && geoTopo.length > 0) {
                        var c = geoTopo[j];
                        geoTopo[j] = geoTopo[i];
                        geoTopo[i] = c;
                    }
                    if (polygonBounds && polygonBounds.length > 0) {
                        var f = polygonBounds[j];
                        polygonBounds[j] = polygonBounds[i];
                        polygonBounds[i] = f;
                    }
                }
            }
        }
    }
}


;// CONCATENATED MODULE: ./src/common/format/GeoJSON.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/














/**
 * @class GeoJSONFormat
 * @aliasclass Format.GeoJSON
 * @deprecatedclass SuperMap.Format.GeoJSON
 * @classdesc  GeoJSON 的读和写。使用 {@link GeoJSONObject} 构造器创建一个 GeoJSON 解析器。
 * @category BaseTypes Format
 * @param {Object} [options] - 可选参数。
 * @param {string} [options.indent="    "] - 用于格式化输出，indent 字符串会在每次缩进的时候使用一次。
 * @param {string} [options.space=" "] - 用于格式化输出，space 字符串会在名值对的 ":" 后边添加。
 * @param {string} [options.newline="\n"] - 用于格式化输出, newline 字符串会用在每一个名值对或数组项末尾。
 * @param {number} [options.level=0] - 用于格式化输出, 表示的是缩进级别。
 * @param {boolean} [options.pretty=false] - 是否在序列化的时候使用额外的空格控制结构。在 write 方法中使用。
 * @param {boolean} [options.nativeJSON] - 需要被注册的监听器对象。
 * @param {boolean} [options.ignoreExtraDims=true] - 忽略维度超过 2 的几何要素。
 * @extends {JSONFormat}
 * @usage
 */
class GeoJSON extends JSONFormat {


    constructor(options) {
        super(options);
        /**
         * @member {boolean} [GeoJSONFormat.prototype.ignoreExtraDims=true]
         * @description 忽略维度超过 2 的几何要素。
         */
        this.ignoreExtraDims = true;

        this.CLASS_NAME = "SuperMap.Format.GeoJSON";
        /**
         * @member {Object} GeoJSONFormat.prototype.parseCoords
         * @private
         * @description 一个属性名对应着 GeoJSON 对象的几何类型的对象。每个属性其实都是一个实际上做解析用的方法。
         */
        this.parseCoords = {
            /**
             * @function GeoJSONFormat.parseCoords.point
             * @description 将一组坐标转成一个 {@link Geometry} 对象。
             * @param {Object} array - GeoJSON 片段中的一组坐标。
             * @returns {Geometry} 一个几何对象。
             */
            "point": function (array) {
                if (this.ignoreExtraDims === false &&
                    array.length != 2) {
                    throw "Only 2D points are supported: " + array;
                }
                return new Point(array[0], array[1]);
            },

            /**
             * @function GeoJSONFormat.parseCoords.multipoint
             * @description 将坐标组数组转化成为一个 {@link Geometry} 对象。
             * @param {Object} array - GeoJSON 片段中的坐标组数组。
             * @returns {Geometry} 一个几何对象。
             */
            "multipoint": function (array) {
                var points = [];
                var p = null;
                for (var i = 0, len = array.length; i < len; ++i) {
                    try {
                        p = this.parseCoords["point"].apply(this, [array[i]]);
                    } catch (err) {
                        throw err;
                    }
                    points.push(p);
                }
                return new MultiPoint(points);
            },

            /**
             * @function GeoJSONFormat.parseCoords.linestring
             * @description 将坐标组数组转化成为一个 {@link Geometry} 对象。
             * @param {Object} array - GeoJSON 片段中的坐标组数组。
             * @returns {Geometry} 一个几何对象。
             */
            "linestring": function (array) {
                var points = [];
                var p = null;
                for (var i = 0, len = array.length; i < len; ++i) {
                    try {
                        p = this.parseCoords["point"].apply(this, [array[i]]);
                    } catch (err) {
                        throw err;
                    }
                    points.push(p);
                }
                return new LineString(points);
            },

            /**
             * @function GeoJSONFormat.parseCoords.multilinestring
             * @description 将坐标组数组转化成为一个 {@link Geometry} 对象。
             * @param {Object} array - GeoJSON 片段中的坐标组数组。
             * @returns {Geometry} 一个几何对象。
             */
            "multilinestring": function (array) {
                var lines = [];
                var l = null;
                for (var i = 0, len = array.length; i < len; ++i) {
                    try {
                        l = this.parseCoords["linestring"].apply(this, [array[i]]);
                    } catch (err) {
                        throw err;
                    }
                    lines.push(l);
                }
                return new MultiLineString(lines);
            },

            /**
             * @function GeoJSONFormat.parseCoords.polygon
             * @description 将坐标组数组转化成为一个 {@link Geometry} 对象。
             * @returns {Geometry} 一个几何对象。
             */
            "polygon": function (array) {
                var rings = [];
                var r, l;
                for (var i = 0, len = array.length; i < len; ++i) {
                    try {
                        l = this.parseCoords["linestring"].apply(this, [array[i]]);
                    } catch (err) {
                        throw err;
                    }
                    r = new LinearRing_LinearRing(l.components);
                    rings.push(r);
                }
                return new Polygon_Polygon(rings);
            },

            /**
             * @function GeoJSONFormat.parseCoords.multipolygon
             * @description 将坐标组数组转化成为一个 {@link Geometry} 对象。
             * @param {Object} array - GeoJSON 片段中的坐标组数组。
             * @returns {Geometry} 一个几何对象。
             */
            "multipolygon": function (array) {
                var polys = [];
                var p = null;
                for (var i = 0, len = array.length; i < len; ++i) {
                    try {
                        p = this.parseCoords["polygon"].apply(this, [array[i]]);
                    } catch (err) {
                        throw err;
                    }
                    polys.push(p);
                }
                return new MultiPolygon(polys);
            },

            /**
             * @function GeoJSONFormat.parseCoords.box
             * @description 将坐标组数组转化成为一个 {@link Geometry} 对象。
             * @param {Array} array - GeoJSON 片段中的坐标组数组。
             * @returns {Geometry} 一个几何对象。
             */
            "box": function (array) {
                if (array.length != 2) {
                    throw "GeoJSON box coordinates must have 2 elements";
                }
                return new Polygon_Polygon([
                    new LinearRing_LinearRing([
                        new Point(array[0][0], array[0][1]),
                        new Point(array[1][0], array[0][1]),
                        new Point(array[1][0], array[1][1]),
                        new Point(array[0][0], array[1][1]),
                        new Point(array[0][0], array[0][1])
                    ])
                ]);
            }

        };
        /**
         * @member {Object} GeoJSONFormat.prototype.extract
         * @private
         * @description 一个属性名对应着GeoJSON类型的对象。其值为相应的实际的解析方法。
         */
        this.extract = {
            /**
             * @function GeoJSONFormat.extract.feature
             * @description 返回一个表示单个要素对象的 GeoJSON 的一部分。
             * @param {SuperMap.ServerFeature} feature - iServer 要素对象。
             * @returns {Object} 一个表示点的对象。
             */
            'feature': function (feature) {
                var geom = this.extract.geometry.apply(this, [feature.geometry]);
                var json = {
                    "type": "Feature",
                    "properties": this.createAttributes(feature),
                    "geometry": geom
                };

                if (feature.geometry && feature.geometry.type === 'TEXT') {
                    json.properties.texts = feature.geometry.texts;
                    json.properties.textStyle = feature.geometry.textStyle;
                }
                if (feature.fid) {
                    json.id = feature.fid;
                }
                if (feature.ID) {
                    json.id = feature.ID;
                }
                return json;
            },


            /**
             * @function GeoJSONFormat.extract.geometry
             * @description 返回一个表示单个几何对象的 GeoJSON 的一部分。
             * @param {Object} geometry - iServer 几何对象。
             * @returns {Object} 一个表示几何体的对象。
             */
            'geometry': function (geometry) {
                if (geometry == null) {
                    return null;
                }
                if (!geometry.parts && geometry.points) {
                    geometry.parts = [geometry.points.length];
                }
                var geo = geometry.hasOwnProperty('geometryType')
                    ? geometry
                    : new ServerGeometry(geometry).toGeometry() || geometry;
                var geometryType = geo.geometryType || geo.type;
                var data;
                if (geometryType === "LinearRing") {
                    geometryType = "LineString";
                }
                if (geometryType === "LINEM") {
                    geometryType = "MultiLineString";
                }
                data = this.extract[geometryType.toLowerCase()].apply(this, [geo]);
                geometryType = geometryType === 'TEXT' ? 'Point' : geometryType;
                var json;
                if (geometryType === "Collection") {
                    json = {
                        "type": "GeometryCollection",
                        "geometries": data
                    };
                } else {
                    json = {
                        "type": geometryType,
                        "coordinates": data
                    };
                }
                return json;
            },


            /**
             * @function GeoJSONFormat.extract.point
             * @description 从一个点对象中返回一个坐标组。
             * @param {GeometryPoint} point - 一个点对象。
             * @returns {Array} 一个表示一个点的坐标组。
             */
            'point': function (point) {
                var p = [point.x, point.y];
                for (var name in point) {
                    if (name !== "x" && name !== "y" && point[name] !== null && !isNaN(point[name])) {
                        p.push(point[name]);
                    }
                }
                return p;
            },

            /**
             * @function GeoJSONFormat.extract.point
             * @description 从一个文本对象中返回一个坐标组。
             * @param {Object} geo - 一个文本对象。
             * @returns {Array} 一个表示一个点的坐标组。
             */
            'text': function (geo) {
                return [geo.points[0].x, geo.points[0].y];
            },

            /**
             * @function GeoJSONFormat.extract.multipoint
             * @description 从一个多点对象中返一个坐标组数组。
             * @param {GeometryMultiPoint} multipoint - 多点对象。
             * @returns {Array} 一个表示多点的坐标组数组。
             */
            'multipoint': function (multipoint) {
                var array = [];
                for (var i = 0, len = multipoint.components.length; i < len; ++i) {
                    array.push(this.extract.point.apply(this, [multipoint.components[i]]));
                }
                return array;
            },

            /**
             * @function GeoJSONFormat.extract.linestring
             * @description 从一个线对象中返回一个坐标组数组。
             * @param {Linestring} linestring - 线对象。
             * @returns {Array} 一个表示线对象的坐标组数组。
             */
            'linestring': function (linestring) {
                var array = [];
                for (var i = 0, len = linestring.components.length; i < len; ++i) {
                    array.push(this.extract.point.apply(this, [linestring.components[i]]));
                }
                return array;
            },

            /**
             * @function GeoJSONFormat.extract.multilinestring
             * @description 从一个多线对象中返回一个线数组。
             * @param {GeometryMultiLineString} multilinestring - 多线对象。
             *
             * @returns {Array} 一个表示多线的线数组。
             */
            'multilinestring': function (multilinestring) {
                var array = [];
                for (var i = 0, len = multilinestring.components.length; i < len; ++i) {
                    array.push(this.extract.linestring.apply(this, [multilinestring.components[i]]));
                }
                return array;
            },

            /**
             * @function GeoJSONFormat.extract.polygon
             * @description 从一个面对象中返回一组线环。
             * @param {GeometryPolygon} polygon - 面对象。
             * @returns {Array} 一组表示面的线环。
             */
            'polygon': function (polygon) {
                var array = [];
                for (var i = 0, len = polygon.components.length; i < len; ++i) {
                    array.push(this.extract.linestring.apply(this, [polygon.components[i]]));
                }
                return array;
            },

            /**
             * @function GeoJSONFormat.extract.multipolygon
             * @description 从一个多面对象中返回一组面。
             * @param {GeometryMultiPolygon} multipolygon - 多面对象。
             * @returns {Array} 一组表示多面的面。
             */
            'multipolygon': function (multipolygon) {
                var array = [];
                for (var i = 0, len = multipolygon.components.length; i < len; ++i) {
                    array.push(this.extract.polygon.apply(this, [multipolygon.components[i]]));
                }
                return array;
            },

            /**
             * @function GeoJSONFormat.extract.collection
             * @description 从一个几何要素集合中一组几何要素数组。
             * @param {GeometryCollection} collection - 几何要素集合。
             * @returns {Array} 一组表示几何要素集合的几何要素数组。
             */
            'collection': function (collection) {
                var len = collection.components.length;
                var array = new Array(len);
                for (var i = 0; i < len; ++i) {
                    array[i] = this.extract.geometry.apply(this, [collection.components[i]]);
                }
                return array;
            }
        };
    }

    /**
     * @function GeoJSONFormat.prototype.read
     * @description 将 GeoJSON 对象或者GeoJSON 对象字符串转换为 SuperMap Feature 对象。
     * @param {GeoJSONObject} json - GeoJSON 对象。
     * @param {string} [type='FeaureCollection'] - 可选的字符串，它决定了输出的格式。支持的值有："Geometry","Feature"，和 "FeatureCollection"，如果此值为null。
     * @param {function} filter - 对象中每个层次每个键值对都会调用此函数得出一个结果。每个值都会被 filter 函数的结果所替换掉。这个函数可被用来将某些对象转化成某个类相应的对象，或者将日期字符串转化成Date对象。
     * @returns {Object}  返回值依赖于 type 参数的值。
     *     -如果 type 等于 "FeatureCollection"，返回值将会是 {@link FeatureVector} 数组。
     *     -如果 type 为 "Geometry",输入的 JSON 对象必须表示一个唯一的几何体，然后返回值就会是 {@link Geometry}。
     *     -如果 type 为 "Feature"，输入的 JSON 对象也必须表示的一个要素，这样返回值才会是 {@link FeatureVector}。
     */

    read(json, type, filter) {
        type = (type) ? type : "FeatureCollection";
        var results = null;
        var obj = null;
        if (typeof json == "string") {
            obj = super.read(json, filter);
        } else {
            obj = json;
        }
        if (!obj) {
            //console.error("Bad JSON: " + json);
        } else if (typeof (obj.type) != "string") {
            //console.error("Bad GeoJSON - no type: " + json);
        } else if (this.isValidType(obj, type)) {
            switch (type) {
                case "Geometry":
                    try {
                        results = this.parseGeometry(obj);
                    } catch (err) {
                        //console.error(err);
                    }
                    break;
                case "Feature":
                    try {
                        results = this.parseFeature(obj);
                        results.type = "Feature";
                    } catch (err) {
                        //console.error(err);
                    }
                    break;
                case "FeatureCollection":
                    // for type FeatureCollection, we allow input to be any type
                    results = [];
                    switch (obj.type) {
                        case "Feature":
                            try {
                                results.push(this.parseFeature(obj));
                            } catch (err) {
                                results = null;
                                //console.error(err);
                            }
                            break;
                        case "FeatureCollection":
                            for (var i = 0, len = obj.features.length; i < len; ++i) {
                                try {
                                    results.push(this.parseFeature(obj.features[i]));
                                } catch (err) {
                                    results = null;
                                    // console.error(err);
                                }
                            }
                            break;
                        default:
                            try {
                                var geom = this.parseGeometry(obj);
                                results.push(new Vector(geom));
                            } catch (err) {
                                results = null;
                                //console.error(err);
                            }
                    }
                    break;
                default:
                    break;
            }
        }
        return results;
    }

    /**
     * @function GeoJSONFormat.prototype.write
     * @description iServer Geometry JSON 对象 转 GeoJSON对象字符串。
     * @param {Object} obj - iServer Geometry JSON 对象。
     * @param {boolean} [pretty=false] - 是否使用换行和缩进来控制输出。
     * @returns {GeoJSONObject} 一个 GeoJSON 字符串，它表示了输入的几何对象，要素对象，或者要素对象数组。
     */
    write(obj, pretty) {
        return super.write(this.toGeoJSON(obj), pretty);
    }
    /**
     * @function GeoJSONFormat.prototype.fromGeoJSON
     * @version 9.1.1
     * @description 将 GeoJSON 对象或者GeoJSON 对象字符串转换为iServer Feature JSON。
     * @param {GeoJSONObject} json - GeoJSON 对象。
     * @param {string} [type='FeaureCollection'] - 可选的字符串，它决定了输出的格式。支持的值有："Geometry","Feature"，和 "FeatureCollection"，如果此值为null。
     * @param {function} filter - 对象中每个层次每个键值对都会调用此函数得出一个结果。每个值都会被 filter 函数的结果所替换掉。这个函数可被用来将某些对象转化成某个类相应的对象，或者将日期字符串转化成Date对象。
     * @returns {Object}  iServer Feature JSON。
     */
    fromGeoJSON(json, type, filter) {
        let feature = this.read(json, type, filter);
        if (!Util_Util.isArray(feature)) {
            return this._toiSevrerFeature(feature);
        }
        return feature.map((element) => {
            return this._toiSevrerFeature(element);
        })
    }

    /**
     * @function GeoJSONFormat.prototype.toGeoJSON
     * @version 9.1.1
     * @description 将 iServer Feature JSON 对象转换为 GeoJSON 对象。
     * @param {Object} obj - iServer Feature JSON。
     * @returns {GeoJSONObject}  GeoJSON 对象。
     */
    toGeoJSON(obj) {
        var geojson = {
            "type": null
        };
        if (Util_Util.isArray(obj)) {
            geojson.type = "FeatureCollection";
            var numFeatures = obj.length;
            geojson.features = new Array(numFeatures);
            for (var i = 0; i < numFeatures; ++i) {
                var element = obj[i];
                if (isGeometry(element)) {
                    let feature = {};
                    feature.geometry = element;
                    geojson.features[i] = this.extract.feature.apply(this, [feature]);
                } else {
                    geojson.features[i] = this.extract.feature.apply(this, [element]);
                }
            }
        } else if (isGeometry(obj)) {
            let feature = {};
            feature.geometry = obj;
            geojson = this.extract.feature.apply(this, [feature]);
        } else {
            geojson = this.extract.feature.apply(this, [obj]);
        }

        function isGeometry(input) {
            return (input.hasOwnProperty("parts") && input.hasOwnProperty("points")) || input.hasOwnProperty("geoParts");
        }

        return geojson;

    }
    /**
     *  @function GeoJSONFormat.prototype.isValidType
     *  @description 检查一个 GeoJSON 对象是否和给定的类型相符的合法的对象。
     *  @returns {boolean} GeoJSON 是否是给定类型的合法对象。
     *  @private
     */
    isValidType(obj, type) {
        var valid = false;
        switch (type) {
            case "Geometry":
                if (Util_Util.indexOf(
                    ["Point", "MultiPoint", "LineString", "MultiLineString",
                        "Polygon", "MultiPolygon", "Box", "GeometryCollection"
                    ],
                    obj.type) == -1) {
                    // unsupported geometry type
                    //console.error("Unsupported geometry type: " +
                    // obj.type);
                } else {
                    valid = true;
                }
                break;
            case "FeatureCollection":
                // allow for any type to be converted to a feature collection
                valid = true;
                break;
            default:
                // for Feature types must match
                if (obj.type == type) {
                    valid = true;
                } else {
                    //console.error("Cannot convert types from " +
                    //obj.type + " to " + type);
                }
        }
        return valid;
    }

    /**
     * @function GeoJSONFormat.prototype.parseFeature
     * @description 将一个 GeoJSON 中的 feature 转化成 {@link FeatureVector}> 对象。
     * @private
     * @param {GeoJSONObject} obj - 从 GeoJSON 对象中创建一个对象。
     * @returns {FeatureVector} 一个要素。
     */
    parseFeature(obj) {
        var feature, geometry, attributes, bbox;
        attributes = (obj.properties) ? obj.properties : {};
        bbox = (obj.geometry && obj.geometry.bbox) || obj.bbox;
        try {
            geometry = this.parseGeometry(obj.geometry);
        } catch (err) {
            // deal with bad geometries
            throw err;
        }
        feature = new Vector(geometry, attributes);
        if (bbox) {
            feature.bounds = Bounds.fromArray(bbox);
        }
        if (obj.id) {
            feature.geometry.id = obj.id;
            feature.fid = obj.id;
        }
        return feature;
    }


    /**
     * @function GeoJSONFormat.prototype.parseGeometry
     * @description 将一个 GeoJSON 中的几何要素转化成 {@link Geometry} 对象。
     * @param {GeoJSONObject} obj - 从 GeoJSON 对象中创建一个对象。
     * @returns {Geometry} 一个几何要素。
     * @private
     */
    parseGeometry(obj) {
        if (obj == null) {
            return null;
        }
        var geometry;
        if (obj.type == "GeometryCollection") {
            if (!(Util_Util.isArray(obj.geometries))) {
                throw "GeometryCollection must have geometries array: " + obj;
            }
            var numGeom = obj.geometries.length;
            var components = new Array(numGeom);
            for (var i = 0; i < numGeom; ++i) {
                components[i] = this.parseGeometry.apply(
                    this, [obj.geometries[i]]
                );
            }
            geometry = new Collection(components);
        } else {
            if (!(Util_Util.isArray(obj.coordinates))) {
                throw "Geometry must have coordinates array: " + obj;
            }
            if (!this.parseCoords[obj.type.toLowerCase()]) {
                throw "Unsupported geometry type: " + obj.type;
            }
            try {
                geometry = this.parseCoords[obj.type.toLowerCase()].apply(
                    this, [obj.coordinates]
                );
            } catch (err) {
                // deal with bad coordinates
                throw err;
            }
        }
        return geometry;
    }


    /**
     * @function GeoJSONFormat.prototype.createCRSObject
     * @description 从一个要素对象中创建一个坐标参考系对象。
     * @param {FeatureVector} object - 要素对象。
     * @private
     * @returns {GeoJSONObject} 一个可作为 GeoJSON 对象的 CRS 属性使用的对象。
     */
    createCRSObject(object) {
        var proj = object.layer.projection.toString();
        var crs = {};
        if (proj.match(/epsg:/i)) {
            var code = parseInt(proj.substring(proj.indexOf(":") + 1));
            if (code == 4326) {
                crs = {
                    "type": "name",
                    "properties": {
                        "name": "urn:ogc:def:crs:OGC:1.3:CRS84"
                    }
                };
            } else {
                crs = {
                    "type": "name",
                    "properties": {
                        "name": "EPSG:" + code
                    }
                };
            }
        }
        return crs;
    }
    _toiSevrerFeature(feature) {
        const attributes = feature.attributes;
        const attrNames = [];
        const attrValues = [];
        for (var attr in attributes) {
            attrNames.push(attr);
            attrValues.push(attributes[attr]);
        }
        const newFeature = {
            fieldNames: attrNames,
            fieldValues: attrValues,
            geometry: ServerGeometry.fromGeometry(feature.geometry)
        };
        newFeature.geometry.id = feature.fid;
        return newFeature;
    }
    createAttributes(feature) {
        if (!feature) {
            return null;
        }
        var attr = {};
        processFieldsAttributes(feature, attr);
        var exceptKeys = ["fieldNames", "fieldValues", "geometry", "stringID", "ID"];
        for (var key in feature) {
            if (exceptKeys.indexOf(key) > -1) {
                continue;
            }
            attr[key] = feature[key];
        }

        function processFieldsAttributes(feature, attributes) {
            if (!(feature.hasOwnProperty("fieldNames") && feature.hasOwnProperty("fieldValues"))) {
                return;
            }
            var names = feature.fieldNames,
                values = feature.fieldValues;
            for (var i in names) {
                attributes[names[i]] = values[i];
            }
        }

        return attr;
    }
}

;// CONCATENATED MODULE: ./src/mapboxgl/core/Util.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/







const isArray = function (obj){
  return Object.prototype.toString.call(obj) == "[object Array]";
}
const isString = function (str) {
  return (typeof str === 'string') && str.constructor === String;
}
/**
 * @name Util
 * @namespace
 * @category BaseTypes Util
 * @description 工具类。
 * @usage
 * ```
 * // 浏览器
 * <script type="text/javascript" src="{cdn}"></script>
 * <script>
 *   const result = {namespace}.Util.toSuperMapGeometry(geoJSON);
 *
 * </script>
 * // ES6 Import
 * import { Util } from '{npm}';
 *
 * const result = Util.toSuperMapGeometry(geoJSON);
 * ```
 */

const core_Util_Util = {
    /**
     * @function Util.toSuperMapGeometry
     * @description 将 GeoJSON 对象转为 SuperMap 几何图形。
     * @param {GeoJSONObject} geoJSON - GeoJSON 对象。
     * @returns {Geometry}
     */
    toSuperMapGeometry(geoJSON) {
        if (geoJSON && geoJSON.type) {
            var format = new GeoJSON();
            var result = format.read(geoJSON, "FeatureCollection");
            return result[0].geometry;
        }
    },

    toSuperMapBounds(bounds) {
        if (isArray(bounds)) {
            //左下右上
            return new Bounds(bounds[0], bounds[1], bounds[2], bounds[3]);
        }
        return new Bounds(bounds.getWest(), bounds.getSouth(), bounds.getEast(), bounds.getNorth());
    },

    toSuperMapPoint(lnglat) {
        //客户端可传入 geojson 对象 或者 mapboxgl lnglat 点对象,或者是点数组
        if (isArray(lnglat)) {
            return new Point(lnglat[0], lnglat[1]);
        } else if (lnglat.lng && lnglat.lat) {
            return new Point(lnglat.lng, lnglat.lat);
        }
        return new Point(lnglat.geometry.coordinates[0], lnglat.geometry.coordinates[1]);
    },
    /**
     * @function Util.toSuperMapPolygon
     * @description 将 Mapbox GL LngLatbounds 对象转为 SuperMap 几何图形。
     * @param {mapboxgl.LngLatBounds} lnglatBounds - Mapbox GL LngLatbounds对象。
     * @returns {GeometryPolygon}
     */
    toSuperMapPolygon(lnglatBounds) {
        const west = lnglatBounds.getWest();
        const east = lnglatBounds.getEast();
        const sourth = lnglatBounds.getSouth();
        const north = lnglatBounds.getNorth();
        return new Polygon_Polygon([
            new LinearRing_LinearRing([
                new Point(west, sourth),
                new Point(east, sourth),
                new Point(east, north),
                new Point(west, north)
            ])
        ]);
    },
    /**
     * @function Util.isArray
     * @description 判断是否为数组格式。
     * @param {Object} obj - 待判断对象。
     * @returns {boolean} 是否是数组。
     */
    isArray,

    /**
     * @function Util.toGeoJSON
     * @description 将传入对象转为 GeoJSON 格式。
     * @param {Object} smObj - 待转对象。
     */
    toGeoJSON(smObj) {
        if (smObj) {
            var format = new GeoJSON();
            return format.toGeoJSON(smObj);
        }
    },

    /**
     * @function Util.toProcessingParam
     * @description 将 Region 节点数组转为 Processing 服务需要的分析参数。
     * @param {Array} points - Region 各个节点数组。
     * @returns {Object} processing 服务裁剪、查询分析的分析参数。
     */
    toProcessingParam(points) {
        var geometryParam = {};
        if (points.length < 1) {
            geometryParam = "";
        } else {
            var results = [];
            for (var i = 0; i < points.length; i++) {
                var point = {};
                point.x = points[i][0];
                point.y = points[i][1];
                results.push(point);
            }
            geometryParam.type = "REGION";
            geometryParam.points = results;
        }
        return geometryParam;
    },

    /**
     * @function Util.extend
     * @description 对象拷贝赋值。
     * @param {Object} dest - 目标对象。
     * @param {Object} arguments - 待拷贝的对象。
     * @returns {Object} 赋值后的目标对象。
     */
    extend(dest) {
        for (var index = 0; index < Object.getOwnPropertyNames(arguments).length; index++) {
            var arg = Object.getOwnPropertyNames(arguments)[index];
            if (arg == "caller" || arg == "callee" || arg == "length" || arg == "arguments") {
                continue;
            }
            var obj = arguments[arg];
            if (obj) {
                for (var j = 0; j < Object.getOwnPropertyNames(obj).length; j++) {
                    var key = Object.getOwnPropertyNames(obj)[j];
                    if (arg == "caller" || arg == "callee" || arg == "length" || arg == "arguments") {
                        continue;
                    }
                    dest[key] = obj[key];
                }
            }
        }
        return dest;
    },

    /**
     * 检测数据是否为number
     * @param value 值，未知数据类型
     * @returns {boolean}
     */
    isNumber(value) {
        if (value === "") {
            return false;
        }
        let mdata = Number(value);
        if (mdata === 0) {
            return true;
        }
        return !isNaN(mdata);
    },

    isString: isString,
    /**
     * 随机生成id
     * @param attr
     * @returns {string}
     */
    newGuid(attr) {
        let len = attr || 32;
        let guid = "";
        for (let i = 1; i < len; i++) {
            let n = Math.floor(Math.random() * 16.0).toString(16);
            guid += n;
        }
        return guid;
    },
    /**
     * @description 十六进制转 RGBA 格式。
     * @param {Object} hex - 十六进制格式。
     * @param {number} opacity - 不透明度Alpha。
     * @returns {string} 生成的 RGBA 格式。
     */
    hexToRgba(hex, opacity) {
        var color = [],
            rgba = [];
        hex = hex.replace(/#/, "");
        if (hex.length == 3) {
            var tmp = [];
            for (let i = 0; i < 3; i++) {
                tmp.push(hex.charAt(i) + hex.charAt(i));
            }
            hex = tmp.join("");
        }
        for (let i = 0; i < 6; i += 2) {
            color[i] = "0x" + hex.substr(i, 2);
            rgba.push(parseInt(Number(color[i])));
        }
        rgba.push(opacity);
        return "rgba(" + rgba.join(",") + ")";
    },

    /**
     * @param {string} featureName 原始数据中的地名
     * @param {string} fieldName 待匹配的地名
     * @returns {boolean} 是否匹配
     */
    isMatchAdministrativeName(featureName, fieldName) {
      if (isString(fieldName)) {
          let shortName = featureName.substr(0, 2);
          // 张家口市和张家界市 特殊处理
          if (shortName === '张家') {
              shortName = featureName.substr(0, 3);
          }
          return !!fieldName.match(new RegExp(shortName));
      }
      return false;
  }
}

;// CONCATENATED MODULE: ./src/mapboxgl/core/index.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


;// CONCATENATED MODULE: ./src/common/commontypes/geometry/GeoText.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/








/**
 * @class GeometryGeoText
 * @aliasclass Geometry.GeoText
 * @deprecatedclass SuperMap.Geometry.GeoText
 * @classdesc 文本标签类。
 * @category BaseTypes Geometry
 * @extends {Geometry}
 * @param {number} x - x 坐标。
 * @param {number} y - y 坐标。
 * @param {string} text - 标签中的文本内容。
 * @usage
 */
class GeoText extends Geometry_Geometry {

    constructor(x, y, text) {
        super(x, y, text);
        /**
         * @member {number} GeometryGeoText.prototype.x
         * @description 横坐标。
         */
        this.x = parseFloat(x);

        /**
         * @member {number} GeometryGeoText.prototype.y
         * @description 纵坐标。
         */
        this.y = parseFloat(y);

        /**
         * @member {string} GeometryGeoText.prototype.text
         * @description 标签中的文本内容。
         */
        this.text = text.toString();

        /**
         * @member {Object} GeometryGeoText.prototype.bsInfo
         * @description 标签范围的基础信息。
         * @property {number} w - bounds 的宽度。
         * @property {number} h - bounds 的高度。
         */
        this.bsInfo = {
            "h": null,
            "w": null
        };
        this.element = document.createElement('span');
        this.CLASS_NAME = "SuperMap.Geometry.GeoText";
        this.geometryType = "GeoText";
    }

    /**
     * @function GeometryGeoText.prototype.destroy
     * @description 销毁文本标签类。
     */
    destroy() {
        super.destroy();
        this.x = null;
        this.y = null;
        this.text = null;
    }

    /**
     * @function GeometryGeoText.prototype.getCentroid
     * @description 获取标签对象的质心。
     * @returns {GeometryPoint} 标签对象的质心。
     */
    getCentroid() {
        return new Point(this.x, this.y);
    }

    /**
     * @function GeometryGeoText.prototype.clone
     * @description 克隆标签对象。
     * @returns {GeometryGeoText} 克隆后的标签对象。
     */
    clone(obj) {
        if (obj == null) {
            obj = new GeoText(this.x, this.y, this.text);
        }
        Util_Util.applyDefaults(obj, this);
        return obj;
    }

    /**
     * @function GeometryGeoText.prototype.calculateBounds
     * @description 计算标签对象的范围。
     */
    calculateBounds() {
        this.bounds = new Bounds(this.x, this.y,
            this.x, this.y);
    }

    /**
     * @function GeometryGeoText.prototype.getLabelPxBoundsByLabel
     * @description 根据绘制好的标签获取文字标签的像素范围，参数的单位是像素；此方法相对于 getLabelPxBoundsByText 效率较低，但支持所有格式的文本。
     * @param {Object} locationPixel - 标签的位置点，该对象含有属性 x（横坐标），属性 y（纵坐标）。
     * @param {string} labelWidth - 标签的宽度，如：“90px”。
     * @param {string} labelHeight - 标签的高度。
     * @param {Object} style - 标签的 style。
     * @returns {Bounds} 标签的像素范围。
     */
    getLabelPxBoundsByLabel(locationPixel, labelWidth, labelHeight, style) {
        var labelPxBounds, left, bottom, top, right;
        var locationPx = Util_Util.cloneObject(locationPixel);

        //计算文本行数
        var theText = style.label || this.text;
        var textRows = theText.split('\n');
        var laberRows = textRows.length;

        //处理文字对齐
        labelWidth = parseFloat(labelWidth);
        labelHeight = parseFloat(labelHeight);
        if (laberRows > 1) {
            labelHeight = parseFloat(labelHeight) * laberRows;
        }
        if (style.labelAlign && style.labelAlign !== "cm") {
            switch (style.labelAlign) {
                case "lt":
                    locationPx.x += labelWidth / 2;
                    locationPx.y += labelHeight / 2;
                    break;
                case "lm":
                    locationPx.x += labelWidth / 2;
                    break;
                case "lb":
                    locationPx.x += labelWidth / 2;
                    locationPx.y -= labelHeight / 2;
                    break;
                case "ct":
                    locationPx.y += labelHeight / 2;
                    break;
                case "cb":
                    locationPx.y -= labelHeight / 2;
                    break;
                case "rt":
                    locationPx.x -= labelWidth / 2;
                    locationPx.y += labelHeight / 2;
                    break;
                case "rm":
                    locationPx.x -= labelWidth / 2;
                    break;
                case "rb":
                    locationPx.x -= labelWidth / 2;
                    locationPx.y -= labelHeight / 2;
                    break;
                default:
                    break;
            }
        }

        this.bsInfo.h = labelHeight;
        this.bsInfo.w = labelWidth;

        //bounds的四边
        left = locationPx.x - parseFloat(labelWidth) / 2;
        bottom = locationPx.y + parseFloat(labelHeight) / 2;
        right = locationPx.x + parseFloat(labelWidth) / 2;
        top = locationPx.y - parseFloat(labelHeight) / 2;

        labelPxBounds = new Bounds(left, bottom, right, top);

        return labelPxBounds;
    }

    /**
     * @function GeometryGeoText.prototype.getLabelPxBoundsByText
     * @description 根据文本内容获取文字标签的像素范围。
     * @param {Object} locationPixel - 标签的位置点，该对象含有属性 x（横坐标），属性 y（纵坐标）。
     * @param {Object} style - 标签的样式。
     * @returns {Bounds} 标签的像素范围。
     */
    getLabelPxBoundsByText(locationPixel, style) {
        var labelPxBounds, left, bottom, top, right;
        var labelSize = this.getLabelPxSize(style);
        var locationPx = Util_Util.cloneObject(locationPixel);

        //处理文字对齐
        if (style.labelAlign && style.labelAlign !== "cm") {
            switch (style.labelAlign) {
                case "lt":
                    locationPx.x += labelSize.w / 2;
                    locationPx.y += labelSize.h / 2;
                    break;
                case "lm":
                    locationPx.x += labelSize.w / 2;
                    break;
                case "lb":
                    locationPx.x += labelSize.w / 2;
                    locationPx.y -= labelSize.h / 2;
                    break;
                case "ct":
                    locationPx.y += labelSize.h / 2;
                    break;
                case "cb":
                    locationPx.y -= labelSize.h / 2;
                    break;
                case "rt":
                    locationPx.x -= labelSize.w / 2;
                    locationPx.y += labelSize.h / 2;
                    break;
                case "rm":
                    locationPx.x -= labelSize.w / 2;
                    break;
                case "rb":
                    locationPx.x -= labelSize.w / 2;
                    locationPx.y -= labelSize.h / 2;
                    break;
                default:
                    break;
            }
        }

        this.bsInfo.h = labelSize.h;
        this.bsInfo.w = labelSize.w;


        left = locationPx.x - labelSize.w / 2;
        bottom = locationPx.y + labelSize.h / 2;
        //处理斜体字
        if (style.fontStyle && style.fontStyle === "italic") {
            right = locationPx.x + labelSize.w / 2 + parseInt(parseFloat(style.fontSize) / 2);
        } else {
            right = locationPx.x + labelSize.w / 2;
        }
        top = locationPx.y - labelSize.h / 2;

        labelPxBounds = new Bounds(left, bottom, right, top);

        return labelPxBounds;
    }

    /**
     * @function GeometryGeoText.prototype.getLabelPxSize
     * @description 获取 label 的像素大小。
     * @param {Object} style - 标签样式。
     * @returns {Object} 标签大小对象，属性 w 表示标签的宽度，属性 h 表示标签的高度。
     */
    getLabelPxSize(style) {
        var text,//文本内容
            fontSize,//字体大小
            spacing = 1,//两个字符间的间距（单位：px）
            lineSpacing = 0.2,
            bgstrokeWidth = parseFloat(style.strokeWidth);//标签背景框边框的宽度

        text = style.label || this.text;
        if (style.fontSize) {
            fontSize = parseFloat(style.fontSize);
        } else {
            fontSize = parseFloat("12px");
        }

        //标签宽高
        var labelW, labelH;

        var textRows = text.split('\n');
        var numRows = textRows.length;

        if (numRows > 1) {
            labelH = fontSize * numRows + numRows + bgstrokeWidth + lineSpacing * fontSize;
        } else {
            labelH = fontSize + bgstrokeWidth + lineSpacing * fontSize + 1;
        }

        //取最大宽度
        labelW = 0;
        if (this.labelWTmp && labelW < this.labelWTmp) {
            labelW = this.labelWTmp;
        }
        for (var i = 0; i < numRows; i++) {
            var textCharC = this.getTextCount(textRows[i]);
            var labelWTmp = this.labelWTmp = Util_Util.getTextBounds(style, textRows[i], this.element).textWidth + textCharC.textC * spacing + bgstrokeWidth;
            if (labelW < labelWTmp) {
                labelW = labelWTmp;
            }
        }

        var labelSize = new Object(); //标签大小
        labelSize.h = labelH;
        labelSize.w = labelW;

        return labelSize;
    }

    /**
     * @function GeometryGeoText.prototype.getTextCount
     * @description 获取 text 中的字符个数。
     * @param {string} text - 字符串。
     * @returns {Object} 字符个数统计结果，属性 cnC 表示中文字符个数，属性 enC 表示英文字符个数，属性 textC 表示字符总个数。
     */
    getTextCount(text) {
        var textCharCount = {};

        var cnCount = 0;
        var enCount = 0;

        for (var i = 0; i < text.length; i++) {
            if (text.charCodeAt(i) > 255) { //遍历判断字符串中每个字符的Unicode码,大于255则为中文
                cnCount++;
            } else {
                enCount++;
            }
        }
        //中午字符个数
        textCharCount.cnC = cnCount;
        //英文字符个数
        textCharCount.enC = enCount;
        //字符总个数
        textCharCount.textC = text.length;

        return textCharCount;
    }


}

;// CONCATENATED MODULE: ./src/common/overlay/feature/Theme.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/





/**
 * @class  FeatureTheme
 * @aliasclass Feature.Theme
 * @deprecatedclass SuperMap.Feature.Theme
 * @category Visualization Theme
 * @classdesc 专题要素基类。
 * @param {Object} data - 用户数据，用于生成可视化 shape。
 * @param {SuperMap.Layer.Theme} layer - 此专题要素所在图层。
 * @usage
 */
class Theme {
    constructor(data, layer) {

        if (!data) {
            return;
        }
        // layer 必须已经添加到地图, 且已初始化渲染器
        if (!layer || !layer.map || !layer.renderer) {
            return;
        }

        /**
         * @member {string} FeatureTheme.prototype.id
         * @description 专题要素唯一标识。
         */
        this.id = Util_Util.createUniqueID(this.CLASS_NAME + "_");

        /**
         * @member {LonLat} FeatureTheme.prototype.lonlat
         * @description 专题要素地理参考位置。子类中必须根据用户数据（或地理位置参数）对其赋值。
         */
        this.lonlat = null;

        /**
         * @member {Array.<number>} FeatureTheme.prototype.location
         * @description 专题要素像素参考位置。通常由地理参考位置决定。长度为 2 的数组，第一个元素表示 x 坐标，第二个元素表示 y 坐标。
         */
        this.location = [];

        /**
         * @readonly
         * @member {Object} FeatureTheme.prototype.data
         * @description 用户数据，用于生成可视化 shape，可在子类中规定数据格式或类型，如：<{@link FeatureVector}>。
         */
        this.data = data;

        /**
         * @readonly
         * @member {Array.<Object>} FeatureTheme.prototype.shapes
         * @description 构成此专题要素的可视化图形对象数组，数组顺序控制渲染。
         */
        this.shapes = [];

        /**
         * @readonly
         * @member {SuperMap.Layer.Theme} FeatureTheme.prototype.layer
         * @description 此专题要素所在专题图层。
         */
        this.layer = layer;

        this.CLASS_NAME = "SuperMap.Feature.Theme";

    }


    /**
     * @function FeatureTheme.prototype.destroy
     * @description 销毁专题要素。
     */
    destroy() {
        this.data = null;
        this.id = null;
        this.lonlat = null;
        this.location = null;
        this.shapes = null;
        this.layer = null;
    }


    /**
     * @function FeatureTheme.prototype.getLocalXY
     * @description 地理坐标转为像素坐标。
     * @param {GeometryPoint|GeometryGeoText|LonLat} coordinate - 地理坐标点。
     * @returns {Array.<number>} 长度为 2 的数组，第一个元素表示 x 坐标，第二个元素表示 y 坐标。
     */
    getLocalXY(coordinate) {
        var resolution = this.layer.map.getResolution();
        var extent = this.layer.map.getExtent();

        if (coordinate instanceof Point || coordinate instanceof GeoText) {
            let x = (coordinate.x / resolution + (-extent.left / resolution));
            let y = ((extent.top / resolution) - coordinate.y / resolution);
            return [x, y];
        } else if (coordinate instanceof LonLat) {
            let x = (coordinate.lon / resolution + (-extent.left / resolution));
            let y = ((extent.top / resolution) - coordinate.lat / resolution);
            return [x, y];
        } else {
            return null;
        }
    }

}

;// CONCATENATED MODULE: ./src/mapboxgl/overlay/theme/ThemeFeature.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/







/**
 * @class ThemeFeature
 * @category  Visualization Theme
 * @classdesc 专题图要素类。
 * @param {GeoJSONObject} geometry - 专题图要素几何对象。
 * @param {Object} [attributes] - 几何对象属性。
 * @usage
 */
class ThemeFeature {

    constructor(geometry, attributes) {
        this.geometry = geometry;
        this.attributes = attributes;
    }

    /**
     * @function ThemeFeature.prototype.toFeature
     * @description 转为矢量要素。
     */
    toFeature() {
        var geometry = core_Util_Util.toSuperMapGeometry(this.geometry);
        var points = [];
        if (this.geometry instanceof (external_mapboxgl_default()).LngLat) {
            points = [this.geometry.lng, this.geometry.lat];
        } else if (this.geometry instanceof (external_mapboxgl_default()).Point) {
            points = [this.geometry.x, this.geometry.y];
        } else if (this.geometry.length === 3) {
            geometry = new GeoText(this.geometry[0], this.geometry[1], this.geometry[2]);
        }
        if (points.length > 1) {
            geometry = new Point(points[0], points[1]);
        }
        return new Vector(geometry, this.attributes);
    }
}

;// CONCATENATED MODULE: ./src/common/overlay/levelRenderer/Util.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/
/**
 * @private
 * @class  LevelRenderer.Tool.Util
 * @category Visualization Theme
 * LevelRenderer 基础工具类
 *
 */
class levelRenderer_Util_Util {
    constructor() {
        /**
         * @member {Object} LevelRenderer.Tool.Util.prototype.BUILTIN_OBJECT
         * @description 用于处理merge时无法遍历Date等对象的问题
         */
        this.BUILTIN_OBJECT = {
            '[object Function]': 1,
            '[object RegExp]': 1,
            '[object Date]': 1,
            '[object Error]': 1,
            '[object CanvasGradient]': 1
        };

        /**
         * @member {Object} LevelRenderer.Tool.Util.prototype._ctx
         */
        this._ctx = null;

        /**
         * Property: _canvas
         * {Object}
         */
        this._canvas = null;

        /**
         * Property: _pixelCtx
         * {Object}
         */
        this._pixelCtx = null;

        /**
         * Property: _width
         * {Object}
         */
        this._width = null;

        /**
         * Property: _height
         * {Object}
         */
        this._height = null;

        /**
         * Property: _offsetX
         * {Object}
         */
        this._offsetX = 0;

        /**
         * Property: _offsetY
         * {Object}
         */
        this._offsetY = 0;

        this.CLASS_NAME = "SuperMap.LevelRenderer.Tool.Util";

    }


    /**
     * @function LevelRenderer.Tool.Util.prototype.clone
     * @description 对一个object进行深度拷贝。
     *
     * @param {Object} source - 需要进行拷贝的对象。
     * @return {Object} 拷贝后的新对象。
     */
    clone(source) {
        var BUILTIN_OBJECT = this.BUILTIN_OBJECT;
        if (typeof source == 'object' && source !== null) {
            var result = source;
            if (source instanceof Array) {
                result = [];
                for (var i = 0, len = source.length; i < len; i++) {
                    result[i] = this.clone(source[i]);
                }
            } else if (!BUILTIN_OBJECT[Object.prototype.toString.call(source)]) {
                result = {};
                for (var key in source) {
                    if (source.hasOwnProperty(key)) {
                        result[key] = this.clone(source[key]);
                    }
                }
            }

            return result;
        }

        return source;
    }


    /**
     * @function LevelRenderer.Tool.Util.prototype.mergeItem
     * @description 合并源对象的单个属性到目标对象。
     *
     * @param {Object} target - 目标对象。
     * @param {Object} source - 源对象。
     * @param {string} key - 键。
     * @param {boolean} overwrite - 是否覆盖。
     * @return {Object} 目标对象
     */
    mergeItem(target, source, key, overwrite) {
        var BUILTIN_OBJECT = this.BUILTIN_OBJECT;
        if (source.hasOwnProperty(key)) {
            if (typeof target[key] == 'object'
                && !BUILTIN_OBJECT[Object.prototype.toString.call(target[key])]
            ) {
                // 如果需要递归覆盖，就递归调用merge
                this.merge(
                    target[key],
                    source[key],
                    overwrite
                );
            } else if (overwrite || !(key in target)) {
                // 否则只处理overwrite为true，或者在目标对象中没有此属性的情况
                target[key] = source[key];
            }
        }
    }


    /**
     * @function LevelRenderer.Tool.Util.prototype.merge
     * @description 合并源对象的属性到目标对象。
     *
     * @param {Object} target - 目标对象。
     * @param {Object} source - 源对象。
     * @param {boolean} overwrite - 是否覆盖。
     * @return {Object} 目标对象。
     */
    merge(target, source, overwrite) {
        for (var i in source) {
            this.mergeItem(target, source, i, overwrite);
        }

        return target;
    }


    /**
     * @function LevelRenderer.Tool.Util.prototype.getContext
     * @description 获取 Canvas 上下文。
     * @return {Object} 上下文。
     */
    getContext() {
        if (!this._ctx) {
            this._ctx = document.createElement('canvas').getContext('2d');
        }
        return this._ctx;
    }


    /**
     * @function LevelRenderer.Tool.Util.prototype.getPixelContext
     * @description 获取像素拾取专用的上下文。
     * @return {Object} 像素拾取专用的上下文。
     */
    getPixelContext() {
        if (!this._pixelCtx) {
            this._canvas = document.createElement('canvas');
            this._width = this._canvas.width;
            this._height = this._canvas.height;
            this._pixelCtx = this._canvas.getContext('2d');
        }
        return this._pixelCtx;
    }


    /**
     * @function LevelRenderer.Tool.Util.prototype.adjustCanvasSize
     * @description 如果坐标处在_canvas外部，改变_canvas的大小，修改canvas的大小 需要重新设置translate
     *
     * @param {number} x - 横坐标。
     * @param {number} y - 纵坐标。
     *
     */
    adjustCanvasSize(x, y) {
        var _canvas = this._canvas;
        var _pixelCtx = this._pixelCtx;
        var _width = this._width;
        var _height = this._height;
        var _offsetX = this._offsetX;
        var _offsetY = this._offsetY;

        // 每次加的长度
        var _v = 100;
        var _flag;

        if (x + _offsetX > _width) {
            _width = x + _offsetX + _v;
            _canvas.width = _width;
            _flag = true;
        }

        if (y + _offsetY > _height) {
            _height = y + _offsetY + _v;
            _canvas.height = _height;
            _flag = true;
        }

        if (x < -_offsetX) {
            _offsetX = Math.ceil(-x / _v) * _v;
            _width += _offsetX;
            _canvas.width = _width;
            _flag = true;
        }

        if (y < -_offsetY) {
            _offsetY = Math.ceil(-y / _v) * _v;
            _height += _offsetY;
            _canvas.height = _height;
            _flag = true;
        }

        if (_flag) {
            _pixelCtx.translate(_offsetX, _offsetY);
        }
    }


    /**
     * @function LevelRenderer.Tool.Util.prototype.getPixelOffset
     * @description 获取像素canvas的偏移量。
     * @return {Object} 偏移量。
     */
    getPixelOffset() {
        return {
            x: this._offsetX,
            y: this._offsetY
        };
    }


    /**
     * @function LevelRenderer.Tool.Util.prototype.indexOf
     * @description 查询数组中元素的index
     * @return {Object} 偏移量。
     */
    indexOf(array, value) {
        if (array.indexOf) {
            return array.indexOf(value);
        }
        for (var i = 0, len = array.length; i < len; i++) {
            if (array[i] === value) {
                return i;
            }
        }
        return -1;
    }


    /**
     * @function LevelRenderer.Tool.Util.prototype.inherits
     * @description 构造类继承关系
     *
     * @param {function} clazz - 源类。
     * @param {function} baseClazz - 基类。
     * @return {Object} 偏移量。
     */
    inherits(clazz, baseClazz) {
        var clazzPrototype = clazz.prototype;

        function F() {
        }

        F.prototype = baseClazz.prototype;
        clazz.prototype = new F();

        for (var prop in clazzPrototype) {
            clazz.prototype[prop] = clazzPrototype[prop];
        }
        clazz.constructor = clazz;
    }
}

;// CONCATENATED MODULE: ./src/common/overlay/levelRenderer/Eventful.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/
/**
 * @class  LevelRenderer.Eventful
 * @category Visualization Theme
 * @classdesc 事件分发器超类，所有支持事件处理的类均是此类的子类。
 * 此类不可实例化。
 * 支持的事件：
 * Symbolizer properties:
 * onclick - {function} 默认值：null。
 * onmouseover - {function} 默认值：null。
 * onmouseout - {function} 默认值：null。
 * onmousemove - {function} 默认值：null。
 * onmousewheel - {function} 默认值：null。
 * onmousedown - {function} 默认值：null。
 * onmouseup - {function} 默认值：null。
 * ondragstart - {function} 默认值：null。
 * ondragend - {function} 默认值：null。
 * ondragenter - {function} 默认值：null。
 * ondragleave - {function} 默认值：null。
 * ondragover - {function} 默认值：null。
 * ondrop - {function} 默认值：null。
 * @private
 */
class Eventful {
    constructor() {
        /**
         * @member {Object} LevelRenderer.Eventful.prototype._handlers
         * @description 事件处理对象（事件分发器）。
         */
        this._handlers = {};

        this.CLASS_NAME = "SuperMap.LevelRenderer.Eventful";
    }


    /**
     * @function {Object} LevelRenderer.Eventful.prototype.destroy
     * @description 销毁对象，释放资源。调用此函数后所有属性将被置为 null。
     */
    destroy() {
        this._handlers = null;
    }


    /**
     * @function LevelRenderer.Eventful.prototype.one
     * @description 单次触发绑定，dispatch后销毁。
     * @param {string} event - 事件名。
     * @param {boolean} handler - 响应函数。
     * @param {Object} context - context。
     * @returns {LevelRenderer.Eventful} this
     */
    one(event, handler, context) {
        var _h = this._handlers;

        if (!handler || !event) {
            return this;
        }

        if (!_h[event]) {
            _h[event] = [];
        }

        _h[event].push({
            h: handler,
            one: true,
            ctx: context || this
        });

        return this;
    }


    /**
     * @function LevelRenderer.Eventful.prototype.bind
     * @description 绑定事件。
     * @param {string} event - 事件名。
     * @param {boolean} handler - 响应函数。
     * @param {Object} context - context。
     * @returns {LevelRenderer.Eventful} this
     */
    bind(event, handler, context) {
        var _h = this._handlers;

        if (!handler || !event) {
            return this;
        }

        if (!_h[event]) {
            _h[event] = [];
        }

        _h[event].push({
            h: handler,
            one: false,
            ctx: context || this
        });

        return this;
    }


    /**
     * @function LevelRenderer.Eventful.prototype.unbind
     * @description 解绑事件。
     * @param {string} event - 事件名。
     * @param {boolean} handler - 响应函数。
     * @returns {LevelRenderer.Eventful} this
     */
    unbind(event, handler) {
        var _h = this._handlers;

        if (!event) {
            this._handlers = {};
            return this;
        }

        if (handler) {
            if (_h[event]) {
                var newList = [];
                for (var i = 0, l = _h[event].length; i < l; i++) {
                    if (_h[event][i]['h'] != handler) {
                        newList.push(_h[event][i]);
                    }
                }
                _h[event] = newList;
            }

            if (_h[event] && _h[event].length === 0) {
                delete _h[event];
            }
        } else {
            delete _h[event];
        }

        return this;
    }


    /**
     * @function LevelRenderer.Eventful.prototype.dispatch
     * @description 事件分发。
     * @param {string} type - 事件类型。
     * @returns {LevelRenderer.Eventful} this
     */
    dispatch(type) {
        if (this._handlers[type]) {
            var args = arguments;
            var argLen = args.length;

            if (argLen > 3) {
                args = Array.prototype.slice.call(args, 1);
            }

            var _h = this._handlers[type];
            var len = _h.length;
            for (var i = 0; i < len;) {
                // Optimize advise from backbone
                switch (argLen) {
                    case 1:
                        _h[i]['h'].call(_h[i]['ctx']);
                        break;
                    case 2:
                        _h[i]['h'].call(_h[i]['ctx'], args[1]);
                        break;
                    case 3:
                        _h[i]['h'].call(_h[i]['ctx'], args[1], args[2]);
                        break;
                    default:
                        // have more than 2 given arguments
                        _h[i]['h'].apply(_h[i]['ctx'], args);
                        break;
                }

                if (_h[i]['one']) {
                    _h.splice(i, 1);
                    len--;
                } else {
                    i++;
                }
            }
        }

        return this;
    }


    /**
     * @function LevelRenderer.Eventful.prototype.dispatchWithContext
     * @description 带有context的事件分发，最后一个参数是事件回调的 context。
     * @param {string} type - 事件类型。
     * @returns {LevelRenderer.Eventful} this
     */
    dispatchWithContext(type) {
        if (this._handlers[type]) {
            var args = arguments;
            var argLen = args.length;

            if (argLen > 4) {
                args = Array.prototype.slice.call(args, 1, args.length - 1);
            }
            var ctx = args[args.length - 1];

            var _h = this._handlers[type];
            var len = _h.length;
            for (var i = 0; i < len;) {
                // Optimize advise from backbone
                switch (argLen) {
                    case 1:
                        _h[i]['h'].call(ctx);
                        break;
                    case 2:
                        _h[i]['h'].call(ctx, args[1]);
                        break;
                    case 3:
                        _h[i]['h'].call(ctx, args[1], args[2]);
                        break;
                    default:
                        // have more than 2 given arguments
                        _h[i]['h'].apply(ctx, args);
                        break;
                }

                if (_h[i]['one']) {
                    _h.splice(i, 1);
                    len--;
                } else {
                    i++;
                }
            }
        }

        return this;
    }

}

;// CONCATENATED MODULE: ./src/common/overlay/levelRenderer/Vector.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/
/**
 * @private
 * @class  LevelRenderer.Tool.Vector
 * @category Visualization Theme
 * @classdesc LevelRenderer 二维向量类
 *
 */
class Vector_Vector {
    constructor() {
        this.ArrayCtor = typeof Float32Array === 'undefined'
            ? Array
            : Float32Array;

        this.CLASS_NAME = "SuperMap.LevelRenderer.Tool.Vector";
    }

    /**
     * @function LevelRenderer.Tool.Vector.prototype.create
     * @description 创建一个向量。
     *
     * @param {number} x - x坐标
     * @param {number} y - Y坐标
     * @return {Vector2} 向量。
     */
    create(x, y) {
        var ArrayCtor = this.ArrayCtor;

        var out = new ArrayCtor(2);
        out[0] = x || 0;
        out[1] = y || 0;

        return out;
    }

    /**
     * @function LevelRenderer.Tool.Vector.prototype.copy
     * @description 复制一个向量。
     *
     * @param {Vector2} out - 基础向量。
     * @param {Vector2} v - 向量。
     * @return {Vector2} 克隆向量。
     */
    copy(out, v) {
        out[0] = v[0];
        out[1] = v[1];
        return out;
    }

    /**
     * @function LevelRenderer.Tool.Vector.prototype.set
     * @description 设置向量的两个项。
     *
     * @param {Vector2} out - 基础向量。
     * @param {number} a - 项 a。
     * @param {number} b - 项 b。
     * @return {Vector2} 结果。
     */
    set(out, a, b) {
        out[0] = a;
        out[1] = b;
        return out;
    }

    /**
     * @function LevelRenderer.Tool.Vector.prototype.add
     * @description 向量相加。
     *
     * @param {Vector2} out - 基础向量。
     * @param {Vector2} v1 - 向量 v1。
     * @param {Vector2} v2 - 向量 v2。
     * @return {Vector2} 结果。
     */
    add(out, v1, v2) {
        out[0] = v1[0] + v2[0];
        out[1] = v1[1] + v2[1];
        return out;
    }

    /**
     * @function LevelRenderer.Tool.Vector.prototype.scaleAndAdd
     * @description 向量缩放后相加。
     * @param {Vector2} out - 基础向量。
     * @param {Vector2} v1 - 向量 v1。
     * @param {Vector2} v2 - 向量 v2（缩放向量）。
     * @param {number} a - 缩放参数。
     * @return {Vector2} 结果。
     */
    scaleAndAdd(out, v1, v2, a) {
        out[0] = v1[0] + v2[0] * a;
        out[1] = v1[1] + v2[1] * a;
        return out;
    }

    /**
     * @function LevelRenderer.Tool.Vector.prototype.sub
     * @description 向量相减。
     * @param {Vector2} out - 基础向量。
     * @param {Vector2} v1 - 向量 v1。
     * @param {Vector2} v2 - 向量 v2。
     * @return {Vector2} 结果。
     */
    sub(out, v1, v2) {
        out[0] = v1[0] - v2[0];
        out[1] = v1[1] - v2[1];
        return out;
    }

    /**
     * @function LevelRenderer.Tool.Vector.prototype.len
     * @description 向量长度。
     * @param {Vector2} v - 向量。
     * @return {number} 向量长度。
     */
    len(v) {
        return Math.sqrt(this.lenSquare(v));
    }

    /**
     * @function LevelRenderer.Tool.Vector.prototype.lenSquare
     * @description 向量长度平方。
     * @param {Vector2} v - 向量。
     * @return {number} 向量长度平方。
     */
    lenSquare(v) {
        return v[0] * v[0] + v[1] * v[1];
    }

    /**
     * @function LevelRenderer.Tool.Vector.prototype.mul
     * @description 向量乘法。
     * @param {Vector2} out - 基础向量。
     * @param {Vector2} v1 - 向量 v1。
     * @param {Vector2} v2 - 向量 v2。
     * @return {Vector2} 结果。
     */
    mul(out, v1, v2) {
        out[0] = v1[0] * v2[0];
        out[1] = v1[1] * v2[1];
        return out;
    }

    /**
     * @function LevelRenderer.Tool.Vector.prototype.div
     * @description 向量除法。
     *
     * @param {Vector2} out - 基础向量。
     * @param {Vector2} v1 - 向量 v1。
     * @param {Vector2} v2 - 向量 v2。
     * @return {Vector2} 结果。
     */
    div(out, v1, v2) {
        out[0] = v1[0] / v2[0];
        out[1] = v1[1] / v2[1];
        return out;
    }

    /**
     * @function LevelRenderer.Tool.Vector.prototype.dot
     * @description 向量点乘。
     *
     * @param  {Vector2} v1 - 向量 v1。
     * @param  {Vector2} v2 - 向量 v2。
     * @return {number} 向量点乘。
     */
    dot(v1, v2) {
        return v1[0] * v2[0] + v1[1] * v2[1];
    }

    /**
     * @function LevelRenderer.Tool.Vector.prototype.scale
     * @description 向量缩放。
     *
     * @param {Vector2} out - 基础向量。
     * @param {Vector2} v - 向量v。
     * @param {number} s -缩放参数。
     * @return {Vector2} 结果。
     */
    scale(out, v, s) {
        out[0] = v[0] * s;
        out[1] = v[1] * s;
        return out;
    }

    /**
     * @function LevelRenderer.Tool.Vector.prototype.normalize
     * @description 向量归一化。
     *
     * @param {Vector2} out - 基础向量。
     * @param {Vector2} v - 向量 v。
     * @return {Vector2} 结果。
     */
    normalize(out, v) {
        var d = this.len(v);
        if (d === 0) {
            out[0] = 0;
            out[1] = 0;
        } else {
            out[0] = v[0] / d;
            out[1] = v[1] / d;
        }
        return out;
    }

    /**
     * @function LevelRenderer.Tool.Vector.prototype.distance
     * @description 计算向量间距离。
     *
     * @param {Vector2} v1 - 向量 v1。
     * @param {Vector2} v2 - 向量 v2。
     * @return {number} 向量间距离。
     */
    distance(v1, v2) {
        return Math.sqrt(
            (v1[0] - v2[0]) * (v1[0] - v2[0])
            + (v1[1] - v2[1]) * (v1[1] - v2[1])
        );
    }

    /**
     * @function LevelRenderer.Tool.Vector.prototype.distanceSquare
     * @description 向量距离平方。
     *
     * @param {Vector2} v1 - 向量 v1。
     * @param {Vector2} v2 - 向量 v2。
     * @return {number} 向量距离平方。
     */
    distanceSquare(v1, v2) {
        return (v1[0] - v2[0]) * (v1[0] - v2[0])
            + (v1[1] - v2[1]) * (v1[1] - v2[1]);
    }

    /**
     * @function LevelRenderer.Tool.Vector.prototype.negate
     * @description 求负向量。
     *
     * @param {Vector2} out - 基础向量。
     * @param {Vector2} v - 向量 v。
     * @return {Vector2} 负向量。
     */
    negate(out, v) {
        out[0] = -v[0];
        out[1] = -v[1];
        return out;
    }

    /**
     * @function LevelRenderer.Tool.Vector.prototype.lerp
     * @description 两点之间线性插值。
     *
     * @param {Vector2} out - 基础向量。
     * @param {Vector2} v1 - 向量 v1。
     * @param {Vector2} v2 - 向量 v2。
     * @param {number} t
     * @return {Vector2} 结果。
     */
    lerp(out, v1, v2, t) {
        out[0] = v1[0] + t * (v2[0] - v1[0]);
        out[1] = v1[1] + t * (v2[1] - v1[1]);
        return out;
    }

    /**
     * @function LevelRenderer.Tool.Vector.prototype.applyTransform
     * @description 矩阵左乘向量。
     *
     * @param {Vector2} out - 基础向量。
     * @param {Vector2} v1 - 向量 v1。
     * @param {Vector2} v2 - 向量 v2。
     * @return {Vector2} 结果。
     */
    applyTransform(out, v, m) {
        var x = v[0];
        var y = v[1];
        out[0] = m[0] * x + m[2] * y + m[4];
        out[1] = m[1] * x + m[3] * y + m[5];
        return out;
    }

    /**
     * @function LevelRenderer.Tool.Vector.prototype.min
     * @description 求两个向量最小值。
     * @param {Vector2} out - 基础向量。
     * @param {Vector2} v1 - 向量 v1。
     * @param {Vector2} v2 - 向量 v2。
     * @return {Vector2} 结果。
     */
    min(out, v1, v2) {
        out[0] = Math.min(v1[0], v2[0]);
        out[1] = Math.min(v1[1], v2[1]);
        return out;
    }

    /**
     * @function LevelRenderer.Tool.Vector.prototype.max
     * @description 求两个向量最大值。
     *
     * @param {Vector2} out - 基础向量。
     * @param {Vector2} v1 - 向量 v1。
     * @param {Vector2} v2 - 向量 v2。
     * @return {Vector2} 结果。
     */
    max(out, v1, v2) {
        out[0] = Math.max(v1[0], v2[0]);
        out[1] = Math.max(v1[1], v2[1]);
        return out;
    }


    /**
     * @function LevelRenderer.Tool.Vector.prototype.length
     * @description 向量长度。
     *
     * @param {Vector2} v - 向量。
     * @return {number} 向量长度。
     */
    length(v) {
        return this.len(v);
    }

    /**
     * @function LevelRenderer.Tool.Vector.prototype.lengthSquare
     * @description 向量长度平方。
     *
     * @param {Vector2} v - 向量。
     * @return {number} 向量长度平方。
     */
    lengthSquare(v) {
        return this.lenSquare(v);
    }

    /**
     * @function LevelRenderer.Tool.Vector.prototype.dist
     * @description 计算向量间距离。
     *
     * @param {Vector2} v1 - 向量 v1。
     * @param {Vector2} v2 - 向量 v2。
     * @return {number} 向量间距离。
     */
    dist(v1, v2) {
        return this.distance(v1, v2);
    }

    /**
     * @function LevelRenderer.Tool.Vector.prototype.distSquare
     * @description 向量距离平方。
     *
     * @param {Vector2} v1 - 向量 v1。
     * @param {Vector2} v2 - 向量 v2。
     * @return {number} 向量距离平方
     */
    distSquare(v1, v2) {
        return this.distanceSquare(v1, v2);
    }

}

;// CONCATENATED MODULE: ./src/common/overlay/levelRenderer/Curve.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


/**
 * @class  LevelRenderer.Tool.Curve
 * @category Visualization Theme
 * @classdesc LevelRenderer 工具-曲线
 * @private
 */
class Curve_Curve {
    constructor() {
        /**
         * @member {LevelRenderer.Tool.Vector} LevelRenderer.Tool.Curve.prototype.vector
         * @description 矢量工具。
         */
        this.vector = new Vector_Vector();

        /**
         * @member {number} LevelRenderer.Tool.Curve.prototype.EPSILON
         * @description e。
         */
        this.EPSILON = 1e-4;

        /**
         * @member {number} LevelRenderer.Tool.Curve.prototype.THREE_SQRT
         * @description 3 的平方根。
         */
        this.THREE_SQRT = Math.sqrt(3);

        /**
         * @member {number} LevelRenderer.Tool.Curve.prototype.ONE_THIRD
         * @description 1/3。
         */
        this.ONE_THIRD = 1 / 3;

        this.CLASS_NAME = "SuperMap.LevelRenderer.Tool.Curve";
    }


    /*
     * Method: evalCubicCoeff
     *
     * Parameters:
     * a - {number} 值。
     * b - {number} 值。
     * c - {number} 值。
     * d - {number} 值。
     * t - {number} 值。
     *
     * Returns:
     * {number}
     */

    /*
     evalCubicCoeff: function(a, b, c, d, t){
     return ((a * t + b) * t + c) * t + d;
     },
     */

    /**
     * @function LevelRenderer.Tool.Curve.prototype.isAroundZero
     * @description 判断一个值是否趋于0，判断参考值：1e-4。
     * @param {number} val - 值。
     * @returns {boolean} 值是否趋于0。
     */
    isAroundZero(val) {
        return val > -this.EPSILON && val < this.EPSILON;
    }


    /**
     * @function LevelRenderer.Tool.Curve.prototype.isNotAroundZero
     * @description 判断一个值是否不趋于0，判断参考值：1e-4。
     * @param {number} val - 值。
     * @returns {boolean} 值是否不趋于0。
     */
    isNotAroundZero(val) {
        return val > this.EPSILON || val < -this.EPSILON;
    }


    /**
     * @function LevelRenderer.Tool.Curve.prototype.cubicAt
     * @description 计算三次贝塞尔值
     * @param {number} p0 - 点p0。
     * @param {number} p1 - 点p1。
     * @param {number} p2 - 点p2。
     * @param {number} p3 - 点p3。
     * @param {number} t - t值。
     * @returns {number} 三次贝塞尔值。
     */
    cubicAt(p0, p1, p2, p3, t) {
        var onet = 1 - t;
        return onet * onet * (onet * p0 + 3 * t * p1)
            + t * t * (t * p3 + 3 * onet * p2);
    }


    /**
     * @function LevelRenderer.Tool.Curve.prototype.cubicDerivativeAt
     * @description 计算三次贝塞尔导数值
     * @param {number} p0 - 点p0。
     * @param {number} p1 - 点p1。
     * @param {number} p2 - 点p2。
     * @param {number} p3 - 点p3。
     * @param {number} t - t值。
     * @returns {number} 三次贝塞尔导数值。
     */
    cubicDerivativeAt(p0, p1, p2, p3, t) {
        var onet = 1 - t;
        return 3 * (
            ((p1 - p0) * onet + 2 * (p2 - p1) * t) * onet
            + (p3 - p2) * t * t
        );
    }


    /**
     * @function LevelRenderer.Tool.Curve.prototype.cubicRootAt
     * @description 计算三次贝塞尔方程根，使用盛金公式
     * @param {number} p0 - 点p0。
     * @param {number} p1 - 点p1。
     * @param {number} p2 - 点p2。
     * @param {number} p3 - 点p3。
     * @param {number} val - 值。
     * @param {Array.<number>} roots - 有效根数目。
     * @returns {number} 有效根。
     */
    cubicRootAt(p0, p1, p2, p3, val, roots) {
        // Evaluate roots of cubic functions
        var a = p3 + 3 * (p1 - p2) - p0;
        var b = 3 * (p2 - p1 * 2 + p0);
        var c = 3 * (p1 - p0);
        var d = p0 - val;

        var A = b * b - 3 * a * c;
        var B = b * c - 9 * a * d;
        var C = c * c - 3 * b * d;

        var n = 0;

        if (this.isAroundZero(A) && this.isAroundZero(B)) {
            if (this.isAroundZero(b)) {
                roots[0] = 0;
            } else {
                let t1 = -c / b;  //t1, t2, t3, b is not zero
                if (t1 >= 0 && t1 <= 1) {
                    roots[n++] = t1;
                }
            }
        } else {
            var disc = B * B - 4 * A * C;

            if (this.isAroundZero(disc)) {
                var K = B / A;
                let t1 = -b / a + K;  // t1, a is not zero
                let t2 = -K / 2;  // t2, t3
                if (t1 >= 0 && t1 <= 1) {
                    roots[n++] = t1;
                }
                if (t2 >= 0 && t2 <= 1) {
                    roots[n++] = t2;
                }
            } else if (disc > 0) {
                let discSqrt = Math.sqrt(disc);
                let Y1 = A * b + 1.5 * a * (-B + discSqrt);
                let Y2 = A * b + 1.5 * a * (-B - discSqrt);
                if (Y1 < 0) {
                    Y1 = -Math.pow(-Y1, this.ONE_THIRD);
                } else {
                    Y1 = Math.pow(Y1, this.ONE_THIRD);
                }
                if (Y2 < 0) {
                    Y2 = -Math.pow(-Y2, this.ONE_THIRD);
                } else {
                    Y2 = Math.pow(Y2, this.ONE_THIRD);
                }
                let t1 = (-b - (Y1 + Y2)) / (3 * a);
                if (t1 >= 0 && t1 <= 1) {
                    roots[n++] = t1;
                }
            } else {
                var T = (2 * A * b - 3 * a * B) / (2 * Math.sqrt(A * A * A));
                var theta = Math.acos(T) / 3;
                var ASqrt = Math.sqrt(A);
                var tmp = Math.cos(theta);

                let t1 = (-b - 2 * ASqrt * tmp) / (3 * a);
                let t2 = (-b + ASqrt * (tmp + this.THREE_SQRT * Math.sin(theta))) / (3 * a);
                let t3 = (-b + ASqrt * (tmp - this.THREE_SQRT * Math.sin(theta))) / (3 * a);
                if (t1 >= 0 && t1 <= 1) {
                    roots[n++] = t1;
                }
                if (t2 >= 0 && t2 <= 1) {
                    roots[n++] = t2;
                }
                if (t3 >= 0 && t3 <= 1) {
                    roots[n++] = t3;
                }
            }
        }
        return n;
    }


    /**
     * @function LevelRenderer.Tool.Curve.prototype.cubicRootAt
     * @description 计算三次贝塞尔方程极限值的位置
     * @param {number} p0 - 点p0。
     * @param {number} p1 - 点p1。
     * @param {number} p2 - 点p2。
     * @param {number} p3 - 点p3。
     * @param {Array.<number>} extrema - 值。
     * @returns {number} 有效数目。
     */
    cubicExtrema(p0, p1, p2, p3, extrema) {
        var b = 6 * p2 - 12 * p1 + 6 * p0;
        var a = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2;
        var c = 3 * p1 - 3 * p0;

        var n = 0;
        if (this.isAroundZero(a)) {
            if (this.isNotAroundZero(b)) {
                let t1 = -c / b;
                if (t1 >= 0 && t1 <= 1) {
                    extrema[n++] = t1;
                }
            }
        } else {
            var disc = b * b - 4 * a * c;
            if (this.isAroundZero(disc)) {
                extrema[0] = -b / (2 * a);
            } else if (disc > 0) {
                let discSqrt = Math.sqrt(disc);
                let t1 = (-b + discSqrt) / (2 * a);
                let t2 = (-b - discSqrt) / (2 * a);
                if (t1 >= 0 && t1 <= 1) {
                    extrema[n++] = t1;
                }
                if (t2 >= 0 && t2 <= 1) {
                    extrema[n++] = t2;
                }
            }
        }
        return n;
    }


    /**
     * @function LevelRenderer.Tool.Curve.prototype.cubicSubdivide
     * @description 细分三次贝塞尔曲线
     * @param {number} p0 - 点p0。
     * @param {number} p1 - 点p1。
     * @param {number} p2 - 点p2。
     * @param {number} p3 - 点p3。
     * @param {number} t - t值。
     * @param {Array.<number>} out - 投射点。
     * @returns {number} 投射点。
     */
    cubicSubdivide(p0, p1, p2, p3, t, out) {
        var p01 = (p1 - p0) * t + p0;
        var p12 = (p2 - p1) * t + p1;
        var p23 = (p3 - p2) * t + p2;

        var p012 = (p12 - p01) * t + p01;
        var p123 = (p23 - p12) * t + p12;

        var p0123 = (p123 - p012) * t + p012;
        // Seg0
        out[0] = p0;
        out[1] = p01;
        out[2] = p012;
        out[3] = p0123;
        // Seg1
        out[4] = p0123;
        out[5] = p123;
        out[6] = p23;
        out[7] = p3;
    }


    /**
     * @function LevelRenderer.Tool.Curve.prototype.cubicProjectPoint
     * @description 投射点到三次贝塞尔曲线上，返回投射距离。投射点有可能会有一个或者多个，这里只返回其中距离最短的一个。
     * @param {number} x0 - 点p0横坐标。
     * @param {number} y0 - 点p0纵坐标。
     * @param {number} x1 - 点p1横坐标。
     * @param {number} y1 - 点p1纵坐标。
     * @param {number} x2 - 点p2横坐标。
     * @param {number} y2 - 点p2纵坐标。
     * @param {number} x3 - 点p3横坐标。
     * @param {number} y3 - 点p3纵坐标。
     * @param {number} x - 点p横坐标。
     * @param {number} y - 点p纵坐标。
     * @param {Array.<number>} out - 投射点。
     * @returns {number} 投射点。
     */
    cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, out) {
        // 临时变量
        var _v0 = this.vector.create();
        var _v1 = this.vector.create();
        var _v2 = this.vector.create();
        // var _v3 = vector.create();

        // http://pomax.github.io/bezierinfo/#projections
        var t;
        var interval = 0.005;
        var d = Infinity;

        _v0[0] = x;
        _v0[1] = y;

        // 先粗略估计一下可能的最小距离的 t 值
        // PENDING
        for (let _t = 0; _t < 1; _t += 0.05) {
            _v1[0] = this.cubicAt(x0, x1, x2, x3, _t);
            _v1[1] = this.cubicAt(y0, y1, y2, y3, _t);
            let d1 = this.vector.distSquare(_v0, _v1);
            if (d1 < d) {
                t = _t;
                d = d1;
            }
        }
        d = Infinity;

        // At most 32 iteration
        for (let i = 0; i < 32; i++) {
            if (interval < this.EPSILON) {
                break;
            }
            let prev = t - interval;
            let next = t + interval;
            // t - interval
            _v1[0] = this.cubicAt(x0, x1, x2, x3, prev);
            _v1[1] = this.cubicAt(y0, y1, y2, y3, prev);

            let d1 = this.vector.distSquare(_v1, _v0);

            if (prev >= 0 && d1 < d) {
                t = prev;
                d = d1;
            } else {
                // t + interval
                _v2[0] = this.cubicAt(x0, x1, x2, x3, next);
                _v2[1] = this.cubicAt(y0, y1, y2, y3, next);
                let d2 = this.vector.distSquare(_v2, _v0);

                if (next <= 1 && d2 < d) {
                    t = next;
                    d = d2;
                } else {
                    interval *= 0.5;
                }
            }
        }
        // t
        if (out) {
            out[0] = this.cubicAt(x0, x1, x2, x3, t);
            out[1] = this.cubicAt(y0, y1, y2, y3, t);
        }
        // console.log(interval, i);
        return Math.sqrt(d);
    }


    /**
     * @function LevelRenderer.Tool.Curve.prototype.quadraticAt
     * @description 计算二次方贝塞尔值。
     * @param {number} p0 - 点p0。
     * @param {number} p1 - 点p1。
     * @param {number} p2 - 点p2。
     * @param {number} t - t值。
     * @returns {number} 二次方贝塞尔值。
     */
    quadraticAt(p0, p1, p2, t) {
        var onet = 1 - t;
        return onet * (onet * p0 + 2 * t * p1) + t * t * p2;
    }


    /**
     * @function LevelRenderer.Tool.Curve.prototype.quadraticAt
     * @description 计算二次方贝塞尔导数值。
     * @param {number} p0 - 点p0。
     * @param {number} p1 - 点p1。
     * @param {number} p2 - 点p2。
     * @param {number} t - t值。
     * @returns {number} 二次方贝塞尔导数值。
     */
    quadraticDerivativeAt(p0, p1, p2, t) {
        return 2 * ((1 - t) * (p1 - p0) + t * (p2 - p1));
    }


    /**
     * @function LevelRenderer.Tool.Curve.prototype.quadraticRootAt
     * @description 计算二次方贝塞尔方程根
     * @param {number} p0 - 点p0。
     * @param {number} p1 - 点p1。
     * @param {number} p2 - 点p2。
     * @param {number} val - 值。
     * @param {Array.<number>} roots - 有效根数目。
     * @returns {number} 有效根数目。
     */
    quadraticRootAt(p0, p1, p2, val, roots) {
        var a = p0 - 2 * p1 + p2;
        var b = 2 * (p1 - p0);
        var c = p0 - val;

        var n = 0;
        if (this.isAroundZero(a)) {
            if (this.isNotAroundZero(b)) {
                var t1 = -c / b;
                if (t1 >= 0 && t1 <= 1) {
                    roots[n++] = t1;
                }
            }
        } else {
            var disc = b * b - 4 * a * c;
            if (this.isAroundZero(disc)) {
                let t1 = -b / (2 * a);
                if (t1 >= 0 && t1 <= 1) {
                    roots[n++] = t1;
                }
            } else if (disc > 0) {
                let discSqrt = Math.sqrt(disc);
                let t1 = (-b + discSqrt) / (2 * a);
                let t2 = (-b - discSqrt) / (2 * a);
                if (t1 >= 0 && t1 <= 1) {
                    roots[n++] = t1;
                }
                if (t2 >= 0 && t2 <= 1) {
                    roots[n++] = t2;
                }
            }
        }
        return n;
    }


    /**
     * @function LevelRenderer.Tool.Curve.prototype.quadraticExtremum
     * @description 计算二次贝塞尔方程极限值
     * @param {number} p0 - 点p0。
     * @param {number} p1 - 点p1。
     * @param {number} p2 - 点p2。
     * @returns {number} 二次贝塞尔方程极限值。
     */
    quadraticExtremum(p0, p1, p2) {
        var divider = p0 + p2 - 2 * p1;
        if (divider === 0) {
            // p1 is center of p0 and p2
            return 0.5;
        } else {
            return (p0 - p1) / divider;
        }
    }


    /**
     * @function LevelRenderer.Tool.Curve.prototype.quadraticProjectPoint
     * @description 投射点到二次贝塞尔曲线上，返回投射距离。投射点有可能会有一个或者多个，这里只返回其中距离最短的一个。
     * @param {number} x0 - 点p0横坐标。
     * @param {number} y0 - 点p0纵坐标。
     * @param {number} x1 - 点p1横坐标。
     * @param {number} y1 - 点p1纵坐标。
     * @param {number} x2 - 点p2横坐标。
     * @param {number} y2 - 点p2纵坐标。
     * @param {number} x - 点p横坐标。
     * @param {number} y - 点p纵坐标。
     * @param {Array.<number>} out - 投射点。
     * @returns {number} 投射距离。
     */
    quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, out) {
        // 临时变量
        var _v0 = this.vector.create();
        var _v1 = this.vector.create();
        var _v2 = this.vector.create();

        // http://pomax.github.io/bezierinfo/#projections
        var t;
        var interval = 0.005;
        var d = Infinity;

        _v0[0] = x;
        _v0[1] = y;

        // 先粗略估计一下可能的最小距离的 t 值
        // PENDING
        for (let _t = 0; _t < 1; _t += 0.05) {
            _v1[0] = this.quadraticAt(x0, x1, x2, _t);
            _v1[1] = this.quadraticAt(y0, y1, y2, _t);
            let d1 = this.vector.distSquare(_v0, _v1);
            if (d1 < d) {
                t = _t;
                d = d1;
            }
        }
        d = Infinity;

        // At most 32 iteration
        for (let i = 0; i < 32; i++) {
            if (interval < this.EPSILON) {
                break;
            }
            let prev = t - interval;
            let next = t + interval;
            // t - interval
            _v1[0] = this.quadraticAt(x0, x1, x2, prev);
            _v1[1] = this.quadraticAt(y0, y1, y2, prev);

            let d1 = this.vector.distSquare(_v1, _v0);

            if (prev >= 0 && d1 < d) {
                t = prev;
                d = d1;
            } else {
                // t + interval
                _v2[0] = this.quadraticAt(x0, x1, x2, next);
                _v2[1] = this.quadraticAt(y0, y1, y2, next);
                let d2 = this.vector.distSquare(_v2, _v0);
                if (next <= 1 && d2 < d) {
                    t = next;
                    d = d2;
                } else {
                    interval *= 0.5;
                }
            }
        }
        // t
        if (out) {
            out[0] = this.quadraticAt(x0, x1, x2, t);
            out[1] = this.quadraticAt(y0, y1, y2, t);
        }
        // console.log(interval, i);
        return Math.sqrt(d);
    }

}

;// CONCATENATED MODULE: ./src/common/overlay/levelRenderer/Area.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/



/**
 * @class  LevelRenderer.Tool.Area
 * @category Visualization Theme
 * @classdesc LevelRenderer 工具-图形范围判断
 * @private
 */
class Area {
    constructor() {
        /**
         * @member {LevelRenderer.Tool.Util}  LevelRenderer.Tool.Areal.prototype.util
         * @description 基础工具对象。
         */
        this.util = new levelRenderer_Util_Util();

        /**
         * @member {LevelRenderer.Tool.Curve}  LevelRenderer.Tool.Areal.prototype.curve
         * @description 曲线工具对象
         */
        this.curve = new Curve_Curve();

        /**
         * @member {Object} LevelRenderer.Tool.Areal.prototype._ctx
         * @description Cavans2D 渲染上下文
         */
        this._ctx = null;

        /**
         * @member {Object} LevelRenderer.Tool.Areal.prototype._textWidthCache
         * @description 文本宽度缓存
         */
        this._textWidthCache = {};

        /**
         * @member {Object} LevelRenderer.Tool.Areal.prototype._textHeightCache
         * @description 文本高度缓存
         */
        this._textHeightCache = {};

        /**
         * @member {number} LevelRenderer.Tool.Areal.prototype._textWidthCacheCounter
         * @description 文本宽度缓存数量
         */
        this._textWidthCacheCounter = 0;

        /**
         * @member {number} LevelRenderer.Tool.Areal.prototype._textHeightCacheCounter
         * @description 文本高度缓存数量
         */
        this._textHeightCacheCounter = 0;

        /**
         * @member {number} LevelRenderer.Tool.Areal.prototype.TEXT_CACHE_MAX
         * @description 文本最大缓存数量
         */
        this.TEXT_CACHE_MAX = 5000;

        /**
         * @member {number} LevelRenderer.Tool.Areal.prototype.PI2
         * @description 2*PI 的值
         */
        this.PI2 = Math.PI * 2;

        /**
         * @member {Array.<number>} LevelRenderer.Tool.Areal.prototype.roots
         * @description 临时数组
         */
        this.roots = [-1, -1, -1];

        /**
         * @member {Array.<number>} LevelRenderer.Tool.Areal.prototype.extrema
         * @description 临时数组
         */
        this.extrema = [-1, -1];

        this.CLASS_NAME = "SuperMap.LevelRenderer.Tool.Area";
    }

    /**
     * @function LevelRenderer.Tool.Areal.prototype.normalizeRadian
     * @description 弧度标准化函数。
     * @param {number} angle - 弧度值。
     * @returns {number} 标准化后的弧度值。
     */
    normalizeRadian(angle) {
        angle %= this.PI2;
        if (angle < 0) {
            angle += this.PI2;
        }
        return angle;
    }

    /**
     * @function LevelRenderer.Tool.Areal.prototype.isInside
     * @description 包含判断。
     * @param {Object} shape - 图形。
     * @param {number} area - 目标区域。
     * @param {number} x - 横坐标。
     * @param {number} y - 纵坐标。
     * @returns {boolean} 图形是否包含鼠标位置。
     */
    isInside(shape, area, x, y) {
        if (!area || !shape) {
            // 无参数或不支持类型
            return false;
        }
        var zoneType = shape.type;

        this._ctx = this._ctx || this.util.getContext();

        // 未实现或不可用时则数学运算，主要是line，brokenLine，ring
        var _mathReturn = this._mathMethod(shape, area, x, y);
        if (typeof _mathReturn != 'undefined') {
            return _mathReturn;
        }

        if (shape.buildPath && this._ctx.isPointInPath) {
            return this._buildPathMethod(shape, this._ctx, area, x, y);
        }

        // 上面的方法都行不通时
        switch (zoneType) {
            case 'ellipse': // Todo，不精确
            case 'smicellipse': // Todo，不精确
                return true;
            // 旋轮曲线  不准确
            case 'trochoid':
                var _r = area.location == 'out'
                    ? area.r1 + area.r2 + area.d
                    : area.r1 - area.r2 + area.d;
                return this.isInsideCircle(area, x, y, _r);
            // 玫瑰线 不准确
            case 'rose' :
                return this.isInsideCircle(area, x, y, area.maxr);
            // 路径，椭圆，曲线等-----------------13
            default:
                return false;   // Todo，暂不支持
        }
    }

    /**
     * @function LevelRenderer.Tool.Areal.prototype._mathMethod
     * @description 包含判断。用数学方法判断，三个方法中最快，但是支持的shape少。
     * @param {Object} shape - 图形。
     * @param {number} area - 目标区域。
     * @param {number} x - 横坐标。
     * @param {number} y - 纵坐标。
     * @returns {boolean} 图形是否包含鼠标位置，true表示坐标处在图形中。
     */
    _mathMethod(shape, area, x, y) {
        var zoneType = shape.type;
        // 在矩形内则部分图形需要进一步判断
        switch (zoneType) {
            // 贝塞尔曲线
            case 'bezier-curve':
                if (typeof(area.cpX2) === 'undefined') {
                    return this.isInsideQuadraticStroke(
                        area.xStart, area.yStart,
                        area.cpX1, area.cpY1,
                        area.xEnd, area.yEnd,
                        area.lineWidth, x, y
                    );
                }
                return this.isInsideCubicStroke(
                    area.xStart, area.yStart,
                    area.cpX1, area.cpY1,
                    area.cpX2, area.cpY2,
                    area.xEnd, area.yEnd,
                    area.lineWidth, x, y
                );
            // 线
            case 'line':
                return this.isInsideLine(
                    area.xStart, area.yStart,
                    area.xEnd, area.yEnd,
                    area.lineWidth, x, y
                );
            // 折线
            case 'broken-line':
                return this.isInsideBrokenLine(
                    area.pointList, area.lineWidth, x, y
                );
            // 扩展折线
            case 'smicbroken-line': {
                // SMIC-修改 - start
                let icX = x;
                let icY = y;
                if (shape.refOriginalPosition) {
                    icX = x - shape.refOriginalPosition[0];
                    icY = y - shape.refOriginalPosition[1];
                }
                return this.isInsideBrokenLine(
                    area.pointList, area.lineWidth, icX, icY
                );
            }
            //初始代码：
            //      return isInsideBrokenLine(
            //          area.pointList, area.lineWidth, x, y
            //      );
            // SMIC-修改 - end
            // 圆环
            case 'ring':
                return this.isInsideRing(
                    area.x, area.y, area.r0, area.r, x, y
                );
            case 'smicring': {
                let areaX = area.x;
                let areaY = area.y;
                if (shape.refOriginalPosition) {
                    areaX = area.x + shape.refOriginalPosition[0];
                    areaY = area.y + shape.refOriginalPosition[1];
                }
                return this.isInsideRing(
                    areaX, areaY, area.r0, area.r, x, y
                );
            }
            // 圆形
            case 'circle':
                return this.isInsideCircle(
                    area.x, area.y, area.r, x, y
                );
            // 扩展-点
            case 'smicpoint': {
                // SMIC-修改 - start
                let icX = x;
                let icY = y;
                if (shape.refOriginalPosition) {
                    icX = x - shape.refOriginalPosition[0];
                    icY = y - shape.refOriginalPosition[1];
                }
                return this.isInsideCircle(
                    area.x, area.y, area.r, icX, icY
                );
            }
            //初始代码：
            //  无
            // SMIC-修改 - end
            // 扇形
            case 'sector': {
                let startAngle = area.startAngle * Math.PI / 180;
                let endAngle = area.endAngle * Math.PI / 180;
                if (!area.clockWise) {
                    startAngle = -startAngle;
                    endAngle = -endAngle;
                }
                return this.isInsideSector(
                    area.x, area.y, area.r0, area.r,
                    startAngle, endAngle,
                    !area.clockWise,
                    x, y
                );
            }
            //初始代码：
            //  无
            // SMIC-增加 - end
            // 扇形
            case 'smicsector': {
                let startAngle = area.startAngle * Math.PI / 180;
                let endAngle = area.endAngle * Math.PI / 180;
                if (!area.clockWise) {
                    startAngle = -startAngle;
                    endAngle = -endAngle;
                }

                let areaX = area.x;
                let areaY = area.y;
                if (shape.refOriginalPosition) {
                    areaX = area.x + shape.refOriginalPosition[0];
                    areaY = area.y + shape.refOriginalPosition[1];
                }

                return this.isInsideSector(
                    areaX, areaY, area.r0, area.r,
                    startAngle, endAngle,
                    !area.clockWise,
                    x, y
                );
            }
            // 多边形
            case 'path':
                return this.isInsidePath(
                    area.pathArray, Math.max(area.lineWidth, 5),
                    area.brushType, x, y
                );
            case 'polygon':
            case 'star':
            case 'smicstar':
            case 'isogon':
            case 'smicisogon':
                return this.isInsidePolygon(area.pointList, x, y);
            // 扩展多边形
            case 'smicpolygon': {
                // SMIC-修改 - start
                let icX = x;
                let icY = y;
                if (shape.refOriginalPosition) {
                    icX = x - shape.refOriginalPosition[0];
                    icY = y - shape.refOriginalPosition[1];
                }

                //岛洞面
                if (shape.holePolygonPointLists && shape.holePolygonPointLists.length > 0) {
                    var isOnBase = this.isInsidePolygon(area.pointList, icX, icY);

                    // 遍历岛洞子面
                    var holePLS = shape.holePolygonPointLists;
                    var isOnHole = false;
                    for (var i = 0, holePLSen = holePLS.length; i < holePLSen; i++) {
                        var holePL = holePLS[i];
                        var isOnSubHole = this.isInsidePolygon(holePL, icX, icY);
                        if (isOnSubHole === true) {
                            isOnHole = true;
                        }
                    }

                    // 捕获判断
                   return isOnBase === true && isOnHole === false;
                } else {
                    return this.isInsidePolygon(area.pointList, icX, icY);
                }
            }
            // 初始代码：
            //  无
            // SMIC-修改 - end
            // 文本
            case 'text':
                var rect = area.__rect || shape.getRect(area);
                return this.isInsideRect(
                    rect.x, rect.y, rect.width, rect.height, x, y
                );
            // 扩展文本
            case 'smictext':
                //用文本背景矩形判断
                var textBg = shape.getTextBackground(area);
                return this.isInsidePolygon(textBg, x, y);
            //初始代码：
            //  无
            // SMIC-修改 - end
            // 矩形
            case 'rectangle':
            case 'image':
                // 图片
                return this.isInsideRect(
                    area.x, area.y, area.width, area.height, x, y
                );
            case 'smicimage': {
                let areaX = area.x;
                let areaY = area.y;
                if (shape.refOriginalPosition) {
                    areaX = area.x + shape.refOriginalPosition[0];
                    areaY = area.y + shape.refOriginalPosition[1];
                }
                return this.isInsideRect(
                    areaX, areaY, area.width, area.height, x, y
                );
            }
            //// 扩展矩形
            //case 'smicpolygon':
            //    // SMIC-修改 - start
            //    var icX = x;
            //    var icY = y;
            //    if(shape.refOriginalPosition) {
            //        icX = x - shape.refOriginalPosition[0];
            //        icY = y - shape.refOriginalPosition[1];
            //    }
            //    return this.isInsideRect(
            //        area.x, area.y, area.width, area.height, icX, icY
            //    );
            //初始代码：
            //  无
            // SMIC-修改 - end
        }
    }

    /**
     * @function LevelRenderer.Tool.Areal.prototype._buildPathMethod
     * @description 包含判断。通过buildPath方法来判断，三个方法中较快，但是不支持线条类型的 shape。
     * @param {Object} shape - 图形。
     * @param {Object} context - 上下文。
     * @param {number} area - 目标区域。
     * @param {number} x - 横坐标。
     * @param {number} y - 纵坐标。
     * @returns {boolean} 图形是否包含鼠标位置，true表示坐标处在图形中。
     */
    _buildPathMethod(shape, context, area, x, y) {
        // 图形类实现路径创建了则用类的path
        context.beginPath();
        shape.buildPath(context, area);
        context.closePath();
        return context.isPointInPath(x, y);
    }

    /**
     * @function LevelRenderer.Tool.Areal.prototype.isOutside
     * @description 图形是否不包含鼠标位置。
     * @param {Object} shape - 图形。
     * @param {number} area - 目标区域。
     * @param {number} x - 横坐标。
     * @param {number} y - 纵坐标。
     * @returns {boolean} 图形是否不包含鼠标位置, true表示坐标处在图形外。
     */
    isOutside(shape, area, x, y) {
        return !this.isInside(shape, area, x, y);
    }

    /**
     * @function LevelRenderer.Tool.Areal.prototype.isInsideLine
     * @description 线段包含判断。
     * @param {number} x0 - 线起始点横坐标。
     * @param {number} y0 - 线起始点纵坐标。
     * @param {number} x1 - 线终点横坐标。
     * @param {number} y1 - 线终点纵坐标。
     * @param {number} lineWidth - 线宽。
     * @param {number} x - 鼠标位置横坐标。
     * @param {number} y - 鼠标位置纵坐标。
     * @returns {boolean} 图形是否包含鼠标位置，true表示坐标处在图形内。
     */
    isInsideLine(x0, y0, x1, y1, lineWidth, x, y) {
        if (lineWidth === 0) {
            return false;
        }
        var _l = Math.max(lineWidth, 5);
        var _a = 0;
        var _b = 0;
        // Quick reject
        if (
            (y > y0 + _l && y > y1 + _l)
            || (y < y0 - _l && y < y1 - _l)
            || (x > x0 + _l && x > x1 + _l)
            || (x < x0 - _l && x < x1 - _l)
        ) {
            return false;
        }

        if (x0 !== x1) {
            _a = (y0 - y1) / (x0 - x1);
            _b = (x0 * y1 - x1 * y0) / (x0 - x1);
        } else {
            return Math.abs(x - x0) <= _l / 2;
        }
        var tmp = _a * x - y + _b;
        var _s = tmp * tmp / (_a * _a + 1);
        return _s <= _l / 2 * _l / 2;
    }

    /**
     * @function LevelRenderer.Tool.Areal.prototype.isInsideCubicStroke
     * @description 三次贝塞尔曲线描边包含判断。
     * @param {number} x0 - 点1横坐标。
     * @param {number} y0 - 点1纵坐标。
     * @param {number} x1 - 点2横坐标。
     * @param {number} y1 - 点2纵坐标。
     * @param {number} x2 - 点3纵坐标。
     * @param {number} y2 - 点3纵坐标。
     * @param {number} lineWidth - 线宽。
     * @param {number} x - 鼠标位置横坐标。
     * @param {number} y - 鼠标位置纵坐标。
     * @returns {boolean} 图形是否包含鼠标位置, true表示坐标处在图形内。
     */
    isInsideCubicStroke(x0, y0, x1, y1, x2, y2, x3, y3, lineWidth, x, y) {
        if (lineWidth === 0) {
            return false;
        }
        var _l = Math.max(lineWidth, 5);
        // Quick reject
        if (
            (y > y0 + _l && y > y1 + _l && y > y2 + _l && y > y3 + _l)
            || (y < y0 - _l && y < y1 - _l && y < y2 - _l && y < y3 - _l)
            || (x > x0 + _l && x > x1 + _l && x > x2 + _l && x > x3 + _l)
            || (x < x0 - _l && x < x1 - _l && x < x2 - _l && x < x3 - _l)
        ) {
            return false;
        }
        var d = this.curve.cubicProjectPoint(
            x0, y0, x1, y1, x2, y2, x3, y3,
            x, y, null
        );
        return d <= _l / 2;
    }

    /**
     * @function LevelRenderer.Tool.Areal.prototype.isInsideQuadraticStroke
     * @description 二次贝塞尔曲线描边包含判断。
     * @param {number} x0 - 点1横坐标。
     * @param {number} y0 - 点1纵坐标。
     * @param {number} x1 - 点2横坐标。
     * @param {number} y1 - 点2纵坐标。
     * @param {number} x2 - 点3纵坐标。
     * @param {number} y2 - 点3纵坐标。
     * @param {number} lineWidth - 线宽。
     * @param {number} x - 鼠标位置横坐标。
     * @param {number} y - 鼠标位置纵坐标。
     * @returns {boolean} 图形是否包含鼠标位置, true表示坐标处在图形内。
     */
    isInsideQuadraticStroke(x0, y0, x1, y1, x2, y2, lineWidth, x, y) {
        if (lineWidth === 0) {
            return false;
        }
        var _l = Math.max(lineWidth, 5);
        // Quick reject
        if (
            (y > y0 + _l && y > y1 + _l && y > y2 + _l)
            || (y < y0 - _l && y < y1 - _l && y < y2 - _l)
            || (x > x0 + _l && x > x1 + _l && x > x2 + _l)
            || (x < x0 - _l && x < x1 - _l && x < x2 - _l)
        ) {
            return false;
        }
        var d = this.curve.quadraticProjectPoint(
            x0, y0, x1, y1, x2, y2,
            x, y, null
        );
        return d <= _l / 2;
    }

    /**
     * @function LevelRenderer.Tool.Areal.prototype.isInsideArcStroke
     * @description 圆弧描边包含判断。
     * @param {number} cx - 圆心横坐标。
     * @param {number} cy - 圆心纵坐标。
     * @param {number} r - 圆半径。
     * @param {number} startAngle - 起始角度。
     * @param {number} endAngle - 终止角度。
     * @param {number} anticlockwise - 顺时针还是逆时针。
     * @param {number} lineWidth - 线宽。
     * @param {number} x - 鼠标位置横坐标。
     * @param {number} y - 鼠标位置纵坐标。
     * @returns {boolean} 图形是否包含鼠标位置, true表示坐标处在图形内。
     */
    isInsideArcStroke(cx, cy, r, startAngle, endAngle, anticlockwise, lineWidth, x, y) {
        var PI2 = this.PI2;

        if (lineWidth === 0) {
            return false;
        }
        var _l = Math.max(lineWidth, 5);

        x -= cx;
        y -= cy;
        var d = Math.sqrt(x * x + y * y);
        if ((d - _l > r) || (d + _l < r)) {
            return false;
        }
        if (Math.abs(startAngle - endAngle) >= PI2) {
            // Is a circle
            return true;
        }
        if (anticlockwise) {
            var tmp = startAngle;
            startAngle = this.normalizeRadian(endAngle);
            endAngle = this.normalizeRadian(tmp);
        } else {
            startAngle = this.normalizeRadian(startAngle);
            endAngle = this.normalizeRadian(endAngle);
        }
        if (startAngle > endAngle) {
            endAngle += PI2;
        }

        var angle = Math.atan2(y, x);
        if (angle < 0) {
            angle += PI2;
        }
        return (angle >= startAngle && angle <= endAngle)
            || (angle + PI2 >= startAngle && angle + PI2 <= endAngle);
    }

    /**
     * @function LevelRenderer.Tool.Areal.prototype.isInsideBrokenLine
     * @description 图形 BrokenLine 是否包含鼠标位置, true表示坐标处在图形内。
     * @param {Array} points - 曲线点对象。
     * @param {number} lineWidth - 线宽。
     * @param {number} x - 鼠标位置横坐标。
     * @param {number} y - 鼠标位置纵坐标。
     * @returns {boolean} 图形是否包含鼠标位置, true表示坐标处在图形内。
     */
    isInsideBrokenLine(points, lineWidth, x, y) {
        var _lineWidth = Math.max(lineWidth, 10);
        for (var i = 0, l = points.length - 1; i < l; i++) {
            var x0 = points[i][0];
            var y0 = points[i][1];
            var x1 = points[i + 1][0];
            var y1 = points[i + 1][1];

            if (this.isInsideLine(x0, y0, x1, y1, _lineWidth, x, y)) {
                return true;
            }
        }

        return false;
    }

    /**
     * @function LevelRenderer.Tool.Areal.prototype.isInsideRing
     * @description  图形 Ring 是否包含鼠标位置, true表示坐标处在图形内。
     * @returns {boolean} 图形是否包含鼠标位置, true表示坐标处在图形内。
     */
    isInsideRing(cx, cy, r0, r, x, y) {
        var d = (x - cx) * (x - cx) + (y - cy) * (y - cy);
        return (d < r * r) && (d > r0 * r0);
    }

    /**
     * @function LevelRenderer.Tool.Areal.prototype.isInsideRect
     * @description 图形 Rect 是否包含鼠标位置, true表示坐标处在图形内。
     * @returns {boolean} 图形是否包含鼠标位置, true表示坐标处在图形内。
     */
    isInsideRect(x0, y0, width, height, x, y) {
        return x >= x0 && x <= (x0 + width) && y >= y0 && y <= (y0 + height);
    }

    /**
     * @function LevelRenderer.Tool.Areal.prototype.isInsideCircle
     * @description 图形 Circle 是否包含鼠标位置, true表示坐标处在图形内。
     * @returns {boolean} 图形是否包含鼠标位置, true表示坐标处在图形内。
     */
    isInsideCircle(x0, y0, r, x, y) {
        return (x - x0) * (x - x0) + (y - y0) * (y - y0) < r * r;
    }

    /**
     * @function LevelRenderer.Tool.Areal.prototype.isInsideSector
     * @description 图形 Sector 是否包含鼠标位置, true表示坐标处在图形内。
     * @returns {boolean} 图形是否包含鼠标位置, true表示坐标处在图形内。
     */
    isInsideSector(cx, cy, r0, r, startAngle, endAngle, anticlockwise, x, y) {
        return this.isInsideArcStroke(cx, cy, (r0 + r) / 2, startAngle, endAngle, anticlockwise, r - r0, x, y);
    }

    /**
     * @function LevelRenderer.Tool.Areal.prototype.isInsidePolygon
     * @description 图形 Polygon 是否包含鼠标位置, true表示坐标处在图形内。与 canvas 一样采用 non-zero winding rule
     * @returns {boolean} 图形是否包含鼠标位置, true表示坐标处在图形内。
     */
    isInsidePolygon(points, x, y) {
        var N = points.length;
        var w = 0;

        for (var i = 0, j = N - 1; i < N; i++) {
            var x0 = points[j][0];
            var y0 = points[j][1];
            var x1 = points[i][0];
            var y1 = points[i][1];
            w += this.windingLine(x0, y0, x1, y1, x, y);
            j = i;
        }
        return w !== 0;
    }


    /**
     * @function LevelRenderer.Tool.Areal.prototype.windingLine
     */
    windingLine(x0, y0, x1, y1, x, y) {
        if ((y > y0 && y > y1) || (y < y0 && y < y1)) {
            return 0;
        }
        if (y1 == y0) {
            return 0;
        }
        var dir = y1 < y0 ? 1 : -1;
        var t = (y - y0) / (y1 - y0);
        var x_ = t * (x1 - x0) + x0;

        return x_ > x ? dir : 0;
    }

    /**
     * @function LevelRenderer.Tool.Areal.prototype.swapExtrema
     */
    swapExtrema() {
        var tmp = this.extrema[0];
        this.extrema[0] = this.extrema[1];
        this.extrema[1] = tmp;
    }

    /**
     * @function LevelRenderer.Tool.Areal.prototype.windingCubic
     */
    windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x, y) {
        var curve = this.curve;
        var roots = this.roots;
        var extrema = this.extrema;

        // Quick reject
        if (
            (y > y0 && y > y1 && y > y2 && y > y3)
            || (y < y0 && y < y1 && y < y2 && y < y3)
        ) {
            return 0;
        }
        var nRoots = curve.cubicRootAt(y0, y1, y2, y3, y, roots);
        if (nRoots === 0) {
            return 0;
        } else {
            var w = 0;
            var nExtrema = -1;
            var y0_, y1_;
            for (var i = 0; i < nRoots; i++) {
                var t = roots[i];
                var x_ = curve.cubicAt(x0, x1, x2, x3, t);
                if (x_ < x) { // Quick reject
                    continue;
                }
                if (nExtrema < 0) {
                    nExtrema = curve.cubicExtrema(y0, y1, y2, y3, extrema);
                    if (extrema[1] < extrema[0] && nExtrema > 1) {
                        this.swapExtrema();
                    }
                    y0_ = curve.cubicAt(y0, y1, y2, y3, extrema[0]);
                    if (nExtrema > 1) {
                        y1_ = curve.cubicAt(y0, y1, y2, y3, extrema[1]);
                    }
                }
                if (nExtrema == 2) {
                    // 分成三段单调函数
                    if (t < extrema[0]) {
                        w += y0_ < y0 ? 1 : -1;
                    } else if (t < extrema[1]) {
                        w += y1_ < y0_ ? 1 : -1;
                    } else {
                        w += y3 < y1_ ? 1 : -1;
                    }
                } else {
                    // 分成两段单调函数
                    if (t < extrema[0]) {
                        w += y0_ < y0 ? 1 : -1;
                    } else {
                        w += y3 < y0_ ? 1 : -1;
                    }
                }
            }
            return w;
        }
    }

    /**
     * @function LevelRenderer.Tool.Areal.prototype.windingQuadratic
     */
    windingQuadratic(x0, y0, x1, y1, x2, y2, x, y) {
        var curve = this.curve;
        var roots = this.roots;

        // Quick reject
        if (
            (y > y0 && y > y1 && y > y2)
            || (y < y0 && y < y1 && y < y2)
        ) {
            return 0;
        }
        var nRoots = curve.quadraticRootAt(y0, y1, y2, y, roots);
        if (nRoots === 0) {
            return 0;
        } else {
            var t = curve.quadraticExtremum(y0, y1, y2);
            if (t >= 0 && t <= 1) {
                var w = 0;
                var y_ = curve.quadraticAt(y0, y1, y2, t);
                for (let i = 0; i < nRoots; i++) {
                    let x_ = curve.quadraticAt(x0, x1, x2, roots[i]);
                    if (x_ > x) {
                        continue;
                    }
                    if (roots[i] < t) {
                        w += y_ < y0 ? 1 : -1;
                    } else {
                        w += y2 < y_ ? 1 : -1;
                    }
                }
                return w;
            } else {
                let x_ = curve.quadraticAt(x0, x1, x2, roots[0]);
                if (x_ > x) {
                    return 0;
                }
                return y2 < y0 ? 1 : -1;
            }
        }
    }

    /**
     * @function LevelRenderer.Tool.Areal.prototype.windingArc
     * // TODO   Arc 旋转
     */
    windingArc(cx, cy, r, startAngle, endAngle, anticlockwise, x, y) {
        var roots = this.roots;
        var PI2 = this.PI2;

        y -= cy;
        if (y > r || y < -r) {
            return 0;
        }
        let tmp = Math.sqrt(r * r - y * y);
        roots[0] = -tmp;
        roots[1] = tmp;

        if (Math.abs(startAngle - endAngle) >= PI2) {
            // Is a circle
            startAngle = 0;
            endAngle = PI2;
            var dir = anticlockwise ? 1 : -1;
            if (x >= roots[0] + cx && x <= roots[1] + cx) {
                return dir;
            } else {
                return 0;
            }
        }

        if (anticlockwise) {
            let tmp = startAngle;
            startAngle = this.normalizeRadian(endAngle);
            endAngle = this.normalizeRadian(tmp);
        } else {
            startAngle = this.normalizeRadian(startAngle);
            endAngle = this.normalizeRadian(endAngle);
        }
        if (startAngle > endAngle) {
            endAngle += PI2;
        }

        var w = 0;
        for (let i = 0; i < 2; i++) {
            var x_ = roots[i];
            if (x_ + cx > x) {
                let angle = Math.atan2(y, x_);
                let dir = anticlockwise ? 1 : -1;
                if (angle < 0) {
                    angle = PI2 + angle;
                }
                if (
                    (angle >= startAngle && angle <= endAngle)
                    || (angle + PI2 >= startAngle && angle + PI2 <= endAngle)
                ) {
                    if (angle > Math.PI / 2 && angle < Math.PI * 1.5) {
                        dir = -dir;
                    }
                    w += dir;
                }
            }
        }
        return w;
    }


    /**
     * @function LevelRenderer.Tool.Areal.prototype.isInsidePath
     * @description 与 canvas 一样采用 non-zero winding rule
     */
    isInsidePath(pathArray, lineWidth, brushType, x, y) {
        var w = 0;
        var xi = 0;
        var yi = 0;
        var x0 = 0;
        var y0 = 0;
        var beginSubpath = true;
        var firstCmd = true;

        brushType = brushType || 'fill';

        var hasStroke = brushType === 'stroke' || brushType === 'both';
        var hasFill = brushType === 'fill' || brushType === 'both';

        // var roots = [-1, -1, -1];
        for (var i = 0; i < pathArray.length; i++) {
            var seg = pathArray[i];
            var p = seg.points;
            // Begin a new subpath
            if (beginSubpath || seg.command === 'M') {
                if (i > 0) {
                    // Close previous subpath
                    if (hasFill) {
                        w += this.windingLine(xi, yi, x0, y0, x, y);
                    }
                    if (w !== 0) {
                        return true;
                    }
                }
                x0 = p[p.length - 2];
                y0 = p[p.length - 1];
                beginSubpath = false;
                if (firstCmd && seg.command !== 'A') {
                    // 如果第一个命令不是M, 是lineTo, bezierCurveTo
                    // 等绘制命令的话，是会从该绘制的起点开始算的
                    // Arc 会在之后做单独处理所以这里忽略
                    firstCmd = false;
                    xi = x0;
                    yi = y0;
                }
            }
            switch (seg.command) {
                case 'M':
                    xi = p[0];
                    yi = p[1];
                    break;
                case 'L':
                    if (hasStroke) {
                        if (this.isInsideLine(
                                xi, yi, p[0], p[1], lineWidth, x, y
                            )) {
                            return true;
                        }
                    }
                    if (hasFill) {
                        w += this.windingLine(xi, yi, p[0], p[1], x, y);
                    }
                    xi = p[0];
                    yi = p[1];
                    break;
                case 'C':
                    if (hasStroke) {
                        if (this.isInsideCubicStroke(
                                xi, yi, p[0], p[1], p[2], p[3], p[4], p[5],
                                lineWidth, x, y
                            )) {
                            return true;
                        }
                    }
                    if (hasFill) {
                        w += this.windingCubic(
                            xi, yi, p[0], p[1], p[2], p[3], p[4], p[5], x, y
                        );
                    }
                    xi = p[4];
                    yi = p[5];
                    break;
                case 'Q':
                    if (hasStroke) {
                        if (this.isInsideQuadraticStroke(
                                xi, yi, p[0], p[1], p[2], p[3],
                                lineWidth, x, y
                            )) {
                            return true;
                        }
                    }
                    if (hasFill) {
                        w += this.windingQuadratic(
                            xi, yi, p[0], p[1], p[2], p[3], x, y
                        );
                    }
                    xi = p[2];
                    yi = p[3];
                    break;
                case 'A':
                    // TODO Arc 旋转
                    // TODO Arc 判断的开销比较大
                    var cx = p[0];
                    var cy = p[1];
                    var rx = p[2];
                    var ry = p[3];
                    var theta = p[4];
                    var dTheta = p[5];
                    var x1 = Math.cos(theta) * rx + cx;
                    var y1 = Math.sin(theta) * ry + cy;
                    // 不是直接使用 arc 命令
                    if (!firstCmd) {
                        w += this.windingLine(xi, yi, x1, y1);
                    } else {
                        firstCmd = false;
                        // 第一个命令起点还未定义
                        x0 = x1;
                        y0 = y1;
                    }
                    // zr 使用scale来模拟椭圆, 这里也对x做一定的缩放
                    var _x = (x - cx) * ry / rx + cx;
                    if (hasStroke) {
                        if (this.isInsideArcStroke(
                                cx, cy, ry, theta, theta + dTheta, 1 - p[7],
                                lineWidth, _x, y
                            )) {
                            return true;
                        }
                    }
                    if (hasFill) {
                        w += this.windingArc(
                            cx, cy, ry, theta, theta + dTheta, 1 - p[7],
                            _x, y
                        );
                    }
                    xi = Math.cos(theta + dTheta) * rx + cx;
                    yi = Math.sin(theta + dTheta) * ry + cy;
                    break;
                case 'z':
                    if (hasStroke) {
                        if (this.isInsideLine(
                                xi, yi, x0, y0, lineWidth, x, y
                            )) {
                            return true;
                        }
                    }
                    beginSubpath = true;
                    break;
            }
        }
        if (hasFill) {
            w += this.windingLine(xi, yi, x0, y0, x, y);
        }
        return w !== 0;
    }

    /**
     * @function LevelRenderer.Tool.Areal.prototype.getTextWidth
     * @description 测算多行文本宽度
     */
    getTextWidth(text, textFont) {
        var key = text + ':' + textFont;
        if (this._textWidthCache[key]) {
            return this._textWidthCache[key];
        }
        this._ctx = this._ctx || this.util.getContext();
        this._ctx.save();

        if (textFont) {
            this._ctx.font = textFont;
        }

        text = (text + '').split('\n');
        var width = 0;
        for (var i = 0, l = text.length; i < l; i++) {
            width = Math.max(
                this._ctx.measureText(text[i]).width,
                width
            );
        }
        this._ctx.restore();

        this._textWidthCache[key] = width;
        if (++this._textWidthCacheCounter > this.TEXT_CACHE_MAX) {
            // 内存释放
            this._textWidthCacheCounter = 0;
            this._textWidthCache = {};
        }

        return width;
    }

    /**
     * @function LevelRenderer.Tool.Areal.prototype.getTextHeight
     * @description 测算多行文本高度
     */
    getTextHeight(text, textFont) {
        var key = text + ':' + textFont;
        if (this._textHeightCache[key]) {
            return this._textHeightCache[key];
        }

        this._ctx = this._ctx || this.util.getContext();

        this._ctx.save();
        if (textFont) {
            this._ctx.font = textFont;
        }

        text = (text + '').split('\n');
        // 比较粗暴
        //var height = (this._ctx.measureText('国').width + 2) * text.length;  //打包不支持中文，替换掉
        var height = (this._ctx.measureText('ZH').width + 2) * text.length;

        this._ctx.restore();

        this._textHeightCache[key] = height;
        if (++this._textHeightCacheCounter > this.TEXT_CACHE_MAX) {
            // 内存释放
            this._textHeightCacheCounter = 0;
            this._textHeightCache = {};
        }
        return height;
    }
}

;// CONCATENATED MODULE: ./src/common/overlay/levelRenderer/Color.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


/**
 * @class  LevelRenderer.Tool.Color
 * @category Visualization Theme
 * @classdesc LevelRenderer 工具-颜色辅助类
 * @private
 */
class Color {



    constructor() {
        /**
         * @member {LevelRenderer.Tool.Util} LevelRenderer.Tool.Color.prototype.util
         * @description LevelRenderer 基础工具对象。
         */
        this.util = new levelRenderer_Util_Util();

        /**
         * @member {Object} LevelRenderer.Tool.Color.prototype._ctx
         * @description _ctx。
         */
        this._ctx = null;

        /**
         * @member {Array.<string>} LevelRenderer.Tool.Color.prototype.palette
         * @description 默认色板。色板是一个包含图表默认颜色系列的数组，当色板中所有颜色被使用过后，又将从新回到色板中的第一个颜色。
         */
        this.palette = [
            '#ff9277', ' #dddd00', ' #ffc877', ' #bbe3ff', ' #d5ffbb',
            '#bbbbff', ' #ddb000', ' #b0dd00', ' #e2bbff', ' #ffbbe3',
            '#ff7777', ' #ff9900', ' #83dd00', ' #77e3ff', ' #778fff',
            '#c877ff', ' #ff77ab', ' #ff6600', ' #aa8800', ' #77c7ff',
            '#ad77ff', ' #ff77ff', ' #dd0083', ' #777700', ' #00aa00',
            '#0088aa', ' #8400dd', ' #aa0088', ' #dd0000', ' #772e00'
        ];

        /**
         * @member {Array.<string>} LevelRenderer.Tool.Color.prototype._palette
         * @description 复位色板，用于复位  palette
         */
        this._palette = this.palette;

        /**
         * @member {string} LevelRenderer.Tool.Color.prototype.highlightColor
         * @description 高亮色
         */
        this.highlightColor = 'rgba(0,0,255,1)';

        /**
         * @member {string} LevelRenderer.Tool.Color.prototype._highlightColor
         * @description 复位高亮色
         */
        this._highlightColor = this.highlightColor;

        /**
         * @member {string} LevelRenderer.Tool.Color.prototype.colorRegExp
         * @description 颜色格式，正则表达式。
         */
        this.colorRegExp = /^\s*((#[a-f\d]{6})|(#[a-f\d]{3})|rgba?\(\s*([\d\.]+%?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+%?(?:\s*,\s*[\d\.]+%?)?)\s*\)|hsba?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+%?(?:\s*,\s*[\d\.]+)?)%?\s*\)|hsla?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+%?(?:\s*,\s*[\d\.]+)?)%?\s*\))\s*$/i;

        /**
         * @member {string} LevelRenderer.Tool.Color.prototype._nameColors
         * @description 颜色名。
         */
        this._nameColors = {
            aliceblue: '#f0f8ff',
            antiquewhite: '#faebd7',
            aqua: '#0ff',
            aquamarine: '#7fffd4',
            azure: '#f0ffff',
            beige: '#f5f5dc',
            bisque: '#ffe4c4',
            black: '#000',
            blanchedalmond: '#ffebcd',
            blue: '#00f',
            blueviolet: '#8a2be2',
            brown: '#a52a2a',
            burlywood: '#deb887',
            cadetblue: '#5f9ea0',
            chartreuse: '#7fff00',
            chocolate: '#d2691e',
            coral: '#ff7f50',
            cornflowerblue: '#6495ed',
            cornsilk: '#fff8dc',
            crimson: '#dc143c',
            cyan: '#0ff',
            darkblue: '#00008b',
            darkcyan: '#008b8b',
            darkgoldenrod: '#b8860b',
            darkgray: '#a9a9a9',
            darkgrey: '#a9a9a9',
            darkgreen: '#006400',
            darkkhaki: '#bdb76b',
            darkmagenta: '#8b008b',
            darkolivegreen: '#556b2f',
            darkorange: '#ff8c00',
            darkorchid: '#9932cc',
            darkred: '#8b0000',
            darksalmon: '#e9967a',
            darkseagreen: '#8fbc8f',
            darkslateblue: '#483d8b',
            darkslategray: '#2f4f4f',
            darkslategrey: '#2f4f4f',
            darkturquoise: '#00ced1',
            darkviolet: '#9400d3',
            deeppink: '#ff1493',
            deepskyblue: '#00bfff',
            dimgray: '#696969',
            dimgrey: '#696969',
            dodgerblue: '#1e90ff',
            firebrick: '#b22222',
            floralwhite: '#fffaf0',
            forestgreen: '#228b22',
            fuchsia: '#f0f',
            gainsboro: '#dcdcdc',
            ghostwhite: '#f8f8ff',
            gold: '#ffd700',
            goldenrod: '#daa520',
            gray: '#808080',
            grey: '#808080',
            green: '#008000',
            greenyellow: '#adff2f',
            honeydew: '#f0fff0',
            hotpink: '#ff69b4',
            indianred: '#cd5c5c',
            indigo: '#4b0082',
            ivory: '#fffff0',
            khaki: '#f0e68c',
            lavender: '#e6e6fa',
            lavenderblush: '#fff0f5',
            lawngreen: '#7cfc00',
            lemonchiffon: '#fffacd',
            lightblue: '#add8e6',
            lightcoral: '#f08080',
            lightcyan: '#e0ffff',
            lightgoldenrodyellow: '#fafad2',
            lightgray: '#d3d3d3',
            lightgrey: '#d3d3d3',
            lightgreen: '#90ee90',
            lightpink: '#ffb6c1',
            lightsalmon: '#ffa07a',
            lightseagreen: '#20b2aa',
            lightskyblue: '#87cefa',
            lightslategray: '#789',
            lightslategrey: '#789',
            lightsteelblue: '#b0c4de',
            lightyellow: '#ffffe0',
            lime: '#0f0',
            limegreen: '#32cd32',
            linen: '#faf0e6',
            magenta: '#f0f',
            maroon: '#800000',
            mediumaquamarine: '#66cdaa',
            mediumblue: '#0000cd',
            mediumorchid: '#ba55d3',
            mediumpurple: '#9370d8',
            mediumseagreen: '#3cb371',
            mediumslateblue: '#7b68ee',
            mediumspringgreen: '#00fa9a',
            mediumturquoise: '#48d1cc',
            mediumvioletred: '#c71585',
            midnightblue: '#191970',
            mintcream: '#f5fffa',
            mistyrose: '#ffe4e1',
            moccasin: '#ffe4b5',
            navajowhite: '#ffdead',
            navy: '#000080',
            oldlace: '#fdf5e6',
            olive: '#808000',
            olivedrab: '#6b8e23',
            orange: '#ffa500',
            orangered: '#ff4500',
            orchid: '#da70d6',
            palegoldenrod: '#eee8aa',
            palegreen: '#98fb98',
            paleturquoise: '#afeeee',
            palevioletred: '#d87093',
            papayawhip: '#ffefd5',
            peachpuff: '#ffdab9',
            peru: '#cd853f',
            pink: '#ffc0cb',
            plum: '#dda0dd',
            powderblue: '#b0e0e6',
            purple: '#800080',
            red: '#f00',
            rosybrown: '#bc8f8f',
            royalblue: '#4169e1',
            saddlebrown: '#8b4513',
            salmon: '#fa8072',
            sandybrown: '#f4a460',
            seagreen: '#2e8b57',
            seashell: '#fff5ee',
            sienna: '#a0522d',
            silver: '#c0c0c0',
            skyblue: '#87ceeb',
            slateblue: '#6a5acd',
            slategray: '#708090',
            slategrey: '#708090',
            snow: '#fffafa',
            springgreen: '#00ff7f',
            steelblue: '#4682b4',
            tan: '#d2b48c',
            teal: '#008080',
            thistle: '#d8bfd8',
            tomato: '#ff6347',
            turquoise: '#40e0d0',
            violet: '#ee82ee',
            wheat: '#f5deb3',
            white: '#fff',
            whitesmoke: '#f5f5f5',
            yellow: '#ff0',
            yellowgreen: '#9acd32'
        };

        this.CLASS_NAME = "SuperMap.LevelRenderer.Tool.Color";
    }

    /**
     * @function LevelRenderer.Tool.Color.prototype.customPalette
     * @description 自定义调色板。
     * @param {Array.<string>} userPalete - 颜色板。
     */
    customPalette(userPalete) {
        this.palette = userPalete;
    }

    /**
     * @function LevelRenderer.Tool.Color.prototype.resetPalette
     * @description 复位默认色板。
     */
    resetPalette() {
        this.palette = this._palette;
    }

    /**
     * @function LevelRenderer.Tool.Color.prototype.getColor
     * @description 获取色板颜色。
     * @param {number} idx - 色板位置。
     * @param {Array.<string>} userPalete - 色板。
     * @returns {string} 颜色值。
     */
    getColor(idx, userPalete) {
        idx = idx | 0;
        userPalete = userPalete || this.palette;
        return userPalete[idx % userPalete.length];
    }

    /**
     * @function LevelRenderer.Tool.Color.prototype.customHighlight
     * @description 自定义默认高亮颜色。
     * @param {string} userHighlightColor - 自定义高亮色。
     */
    customHighlight(userHighlightColor) {
        this.highlightColor = userHighlightColor;
    }

    /**
     * @function LevelRenderer.Tool.Color.prototype.resetHighlight
     * @description 重置默认高亮颜色。将当前的高亮色作为默认高亮颜色
     */
    resetHighlight() {
        this.highlightColor = this._highlightColor;
    }

    /**
     * @function LevelRenderer.Tool.Color.prototype.getHighlightColor
     * @description 获取默认高亮颜色
     * @returns {string} 颜色值。
     */
    getHighlightColor() {
        return this.highlightColor;
    }

    /**
     * @function LevelRenderer.Tool.Color.prototype.getRadialGradient
     * @description 径向渐变。
     * @param {number} x0 - 渐变起点横坐标。
     * @param {number} y0 - 渐变起点纵坐标。
     * @param {number} r0 - 半径
     * @param {number} x1 - 渐变终点横坐标。
     * @param {number} y1 - 渐变终点纵坐标。
     * @param {number} r1 - 半径
     * @param {Array} colorList - 颜色列表。
     * @returns {CanvasGradient} Cavans 渐变颜色。
     */
    getRadialGradient(x0, y0, r0, x1, y1, r1, colorList) {
        var util = this.util;

        if (!this._ctx) {
            this._ctx = util.getContext();
        }
        var gradient = this._ctx.createRadialGradient(x0, y0, r0, x1, y1, r1);
        for (var i = 0, l = colorList.length; i < l; i++) {

            gradient.addColorStop(colorList[i][0], colorList[i][1]);
        }
        gradient.__nonRecursion = true;
        return gradient;
    }


    /**
     * @function LevelRenderer.Tool.Color.prototype.getLinearGradient
     * @description 线性渐变。
     * @param {number} x0 - 渐变起点横坐标。
     * @param {number} y0 - 渐变起点纵坐标。
     * @param {number} x1 - 渐变终点横坐标。
     * @param {number} y1 - 渐变终点纵坐标。
     * @param {Array} colorList - 颜色列表。
     * @returns {CanvasGradient} Cavans 渐变颜色。
     */
    getLinearGradient(x0, y0, x1, y1, colorList) {
        var util = this.util;

        if (!this._ctx) {
            this._ctx = util.getContext();
        }
        var gradient = this._ctx.createLinearGradient(x0, y0, x1, y1);
        for (var i = 0, l = colorList.length; i < l; i++) {
            gradient.addColorStop(colorList[i][0], colorList[i][1]);
        }
        gradient.__nonRecursion = true;
        return gradient;
    }

    /**
     * @function LevelRenderer.Tool.Color.prototype.getStepColors
     * @description 获取两种颜色之间渐变颜色数组。
     * @param {Object} start - 起始颜色对象。
     * @param {Object} end - 结束颜色对象。
     * @param {number} step - 渐变级数。
     * @returns {Array} 颜色数组。
     */
    getStepColors(start, end, step) {
        start = this.toRGBA(start);
        end = this.toRGBA(end);
        start = this.getData(start);
        end = this.getData(end);

        var colors = [];
        var stepR = (end[0] - start[0]) / step;
        var stepG = (end[1] - start[1]) / step;
        var stepB = (end[2] - start[2]) / step;
        var stepA = (end[3] - start[3]) / step;
        // 生成颜色集合
        // fix by linfeng 颜色堆积
        for (var i = 0, r = start[0], g = start[1], b = start[2], a = start[3]; i < step; i++) {
            colors[i] = this.toColor([
                this.adjust(Math.floor(r), [0, 255]),
                this.adjust(Math.floor(g), [0, 255]),
                this.adjust(Math.floor(b), [0, 255]),
                a.toFixed(4) - 0
            ], 'rgba');
            r += stepR;
            g += stepG;
            b += stepB;
            a += stepA;
        }
        r = end[0];
        g = end[1];
        b = end[2];
        a = end[3];
        colors[i] = this.toColor([r, g, b, a], 'rgba');
        return colors;
    }

    /**
     * @function LevelRenderer.Tool.Color.prototype.getGradientColors
     * @description 获取指定级数的渐变颜色数组。
     * @param {Array.<string>} colors - 颜色数组。
     * @param {number} [step=20] - 渐变级数。
     * @returns {Array.<string>} 颜色数组。
     */
    getGradientColors(colors, step) {
        var ret = [];
        var len = colors.length;
        if (step === undefined) {
            step = 20;
        }
        if (len === 1) {
            ret = this.getStepColors(colors[0], colors[0], step);
        } else if (len > 1) {
            for (var i = 0, n = len - 1; i < n; i++) {
                var steps = this.getStepColors(colors[i], colors[i + 1], step);
                if (i < n - 1) {
                    steps.pop();
                }
                ret = ret.concat(steps);
            }
        }
        return ret;
    }

    /**
     * @function LevelRenderer.Tool.Color.prototype.toColor
     * @description 颜色值数组转为指定格式颜色。
     * @param {Array} data - 颜色值数组。
     * @param {string} format - 格式，默认'rgb'
     * @returns {string} 颜色。
     */
    toColor(data, format) {
        format = format || 'rgb';
        if (data && (data.length === 3 || data.length === 4)) {
            data = this.map(data,
                function (c) {
                    return c > 1 ? Math.ceil(c) : c;
                }
            );

            if (format.indexOf('hex') > -1) {
                return '#' + ((1 << 24) + (data[0] << 16) + (data[1] << 8) + (+data[2])).toString(16).slice(1);
            } else if (format.indexOf('hs') > -1) {
                var sx = this.map(data.slice(1, 3),
                    function (c) {
                        return c + '%';
                    }
                );
                data[1] = sx[0];
                data[2] = sx[1];
            }

            if (format.indexOf('a') > -1) {
                if (data.length === 3) {
                    data.push(1);
                }
                data[3] = this.adjust(data[3], [0, 1]);
                return format + '(' + data.slice(0, 4).join(',') + ')';
            }

            return format + '(' + data.slice(0, 3).join(',') + ')';
        }
    }

    /**
     * @function LevelRenderer.Tool.Color.prototype.toArray
     * @description 颜色字符串转换为rgba数组。
     * @param {string} color - 颜色。
     * @returns {Array.<number>} 颜色值数组。
     */
    toArray(color) {
        color = this.trim(color);
        if (color.indexOf('rgba') < 0) {
            color = this.toRGBA(color);
        }

        var data = [];
        var i = 0;
        color.replace(/[\d.]+/g, function (n) {
            if (i < 3) {
                n = n | 0;
            } else {
                // Alpha
                n = +n;
            }
            data[i++] = n;
        });
        return data;
    }

    /**
     * @function LevelRenderer.Tool.Color.prototype.convert
     * @description 颜色格式转化。
     * @param {Array} data - 颜色值数组。
     * @param {string} format - 格式，默认'rgb'
     * @returns {string} 颜色。
     */
    convert(color, format) {
        if (!this.isCalculableColor(color)) {
            return color;
        }
        var data = this.getData(color);
        var alpha = data[3];
        if (typeof alpha === 'undefined') {
            alpha = 1;
        }

        if (color.indexOf('hsb') > -1) {
            data = this._HSV_2_RGB(data);
        } else if (color.indexOf('hsl') > -1) {
            data = this._HSL_2_RGB(data);
        }

        if (format.indexOf('hsb') > -1 || format.indexOf('hsv') > -1) {
            data = this._RGB_2_HSB(data);
        } else if (format.indexOf('hsl') > -1) {
            data = this._RGB_2_HSL(data);
        }

        data[3] = alpha;

        return this.toColor(data, format);
    }

    /**
     * @function LevelRenderer.Tool.Color.prototype.toRGBA
     * @description 转换为rgba格式的颜色。
     * @param {string} color - 颜色。
     * @returns {string} 颜色。
     */
    toRGBA(color) {
        return this.convert(color, 'rgba');
    }

    /**
     * @function LevelRenderer.Tool.Color.prototype.toRGB
     * @description 转换为rgb数字格式的颜色。
     * @param {string} color - 颜色。
     * @returns {string} 颜色。
     */
    toRGB(color) {
        return this.convert(color, 'rgb');
    }

    /**
     * @function LevelRenderer.Tool.Color.prototype.toHex
     * @description 转换为16进制颜色。
     * @param {string} color - 颜色。
     * @returns {string} 16进制颜色，#rrggbb格式
     */
    toHex(color) {
        return this.convert(color, 'hex');
    }

    /**
     * @function LevelRenderer.Tool.Color.prototype.toHSVA
     * @description 转换为HSV颜色。
     * @param {string} color - 颜色。
     * @returns {string} HSVA颜色，hsva(h,s,v,a)
     */
    toHSVA(color) {
        return this.convert(color, 'hsva');
    }

    /**
     * @function LevelRenderer.Tool.Color.prototype.toHSV
     * @description 转换为HSV颜色。
     * @param {string} color - 颜色。
     * @returns {string} HSV颜色，hsv(h,s,v)
     */
    toHSV(color) {
        return this.convert(color, 'hsv');
    }

    /**
     * @function LevelRenderer.Tool.Color.prototype.toHSBA
     * @description 转换为HSBA颜色。
     * @param {string} color - 颜色。
     * @returns {string} HSBA颜色，hsba(h,s,b,a)
     */
    toHSBA(color) {
        return this.convert(color, 'hsba');
    }

    /**
     * @function LevelRenderer.Tool.Color.prototype.toHSB
     * @description 转换为HSB颜色。
     * @param {string} color - 颜色。
     * @returns {string} HSB颜色，hsb(h,s,b)
     */
    toHSB(color) {
        return this.convert(color, 'hsb');
    }

    /**
     * @function LevelRenderer.Tool.Color.prototype.toHSLA
     * @description 转换为HSLA颜色。
     * @param {string} color - 颜色。
     * @returns {string} HSLA颜色，hsla(h,s,l,a)
     */
    toHSLA(color) {
        return this.convert(color, 'hsla');
    }

    /**
     * @function LevelRenderer.Tool.Color.prototype.toHSL
     * @description 转换为HSL颜色。
     * @param {string} color - 颜色。
     * @returns {string}  HSL颜色，hsl(h,s,l)
     */
    toHSL(color) {
        return this.convert(color, 'hsl');
    }

    /**
     * @function LevelRenderer.Tool.Color.prototype.toName
     * @description 转换颜色名。
     * @param {string} color - 颜色。
     * @returns {string} 颜色名
     */
    toName(color) {
        for (var key in this._nameColors) {
            if (this.toHex(this._nameColors[key]) === this.toHex(color)) {
                return key;
            }
        }
        return null;
    }

    /**
     * @function LevelRenderer.Tool.Color.prototype.trim
     * @description 移除颜色中多余空格。
     * @param {string} color - 颜色。
     * @returns {string} 无空格颜色
     */
    trim(color) {
        return String(color).replace(/\s+/g, '');
    }

    /**
     * @function LevelRenderer.Tool.Color.prototype.normalize
     * @description 颜色规范化。
     * @param {string} color - 颜色。
     * @returns {string} 规范化后的颜色
     */
    normalize(color) {
        // 颜色名
        if (this._nameColors[color]) {
            color = this._nameColors[color];
        }
        // 去掉空格
        color = this.trim(color);
        // hsv与hsb等价
        color = color.replace(/hsv/i, 'hsb');
        // rgb转为rrggbb
        if (/^#[\da-f]{3}$/i.test(color)) {
            color = parseInt(color.slice(1), 16);
            var r = (color & 0xf00) << 8;
            var g = (color & 0xf0) << 4;
            var b = color & 0xf;

            color = '#' + ((1 << 24) + (r << 4) + r + (g << 4) + g + (b << 4) + b).toString(16).slice(1);
        }
        // 或者使用以下正则替换，不过 chrome 下性能相对差点
        // color = color.replace(/^#([\da-f])([\da-f])([\da-f])$/i, '#$1$1$2$2$3$3');
        return color;
    }

    /**
     * @function LevelRenderer.Tool.Color.prototype.lift
     * @description 颜色加深或减淡，当level>0加深，当level<0减淡。
     * @param {string} color - 颜色。
     * @param {number} level - 升降程度，取值区间[-1,1]。
     * @returns {string} 加深或减淡后颜色值
     */
    lift(color, level) {
        if (!this.isCalculableColor(color)) {
            return color;
        }
        var direct = level > 0 ? 1 : -1;
        if (typeof level === 'undefined') {
            level = 0;
        }
        level = Math.abs(level) > 1 ? 1 : Math.abs(level);
        color = this.toRGB(color);
        var data = this.getData(color);
        for (var i = 0; i < 3; i++) {
            if (direct === 1) {
                data[i] = data[i] * (1 - level) | 0;
            } else {
                data[i] = ((255 - data[i]) * level + data[i]) | 0;
            }
        }
        return 'rgb(' + data.join(',') + ')';
    }

    /**
     * @function LevelRenderer.Tool.Color.prototype.reverse
     * @description 颜色翻转。[255-r,255-g,255-b,1-a]
     * @param {string} color - 颜色。
     * @returns {string} 翻转颜色
     */
    reverse(color) {
        if (!this.isCalculableColor(color)) {
            return color;
        }
        var data = this.getData(this.toRGBA(color));
        data = this.map(data,
            function (c) {
                return 255 - c;
            }
        );
        return this.toColor(data, 'rgb');
    }

    /**
     * @function LevelRenderer.Tool.Color.prototype.mix
     * @description 简单两种颜色混合
     * @param {string} color1 - 第一种颜色。
     * @param {string} color2 - 第二种颜色。
     * @param {number} weight - 混合权重[0-1]。
     * @returns {string} 结果色。rgb(r,g,b)或rgba(r,g,b,a)
     */
    mix(color1, color2, weight) {
        if (!this.isCalculableColor(color1) || !this.isCalculableColor(color2)) {
            return color1;
        }

        if (typeof weight === 'undefined') {
            weight = 0.5;
        }
        weight = 1 - this.adjust(weight, [0, 1]);

        var w = weight * 2 - 1;
        var data1 = this.getData(this.toRGBA(color1));
        var data2 = this.getData(this.toRGBA(color2));

        var d = data1[3] - data2[3];

        var weight1 = (((w * d === -1) ? w : (w + d) / (1 + w * d)) + 1) / 2;
        var weight2 = 1 - weight1;

        var data = [];

        for (var i = 0; i < 3; i++) {
            data[i] = data1[i] * weight1 + data2[i] * weight2;
        }

        var alpha = data1[3] * weight + data2[3] * (1 - weight);
        alpha = Math.max(0, Math.min(1, alpha));

        if (data1[3] === 1 && data2[3] === 1) {// 不考虑透明度
            return this.toColor(data, 'rgb');
        }
        data[3] = alpha;
        return this.toColor(data, 'rgba');
    }

    /**
     * @function LevelRenderer.Tool.Color.prototype.random
     * @description 随机颜色
     * @returns {string}  颜色值，#rrggbb格式
     */
    random() {
        return '#' + Math.random().toString(16).slice(2, 8);
    }

    /**
     * @function LevelRenderer.Tool.Color.prototype.getData
     * @description 获取颜色值数组，返回值范围。
     * RGB 范围[0-255]
     * HSL/HSV/HSB 范围[0-1]
     * A透明度范围[0-1]
     * 支持格式：
     * #rgb
     * #rrggbb
     * rgb(r,g,b)
     * rgb(r%,g%,b%)
     * rgba(r,g,b,a)
     * hsb(h,s,b) // hsv与hsb等价
     * hsb(h%,s%,b%)
     * hsba(h,s,b,a)
     * hsl(h,s,l)
     * hsl(h%,s%,l%)
     * hsla(h,s,l,a)
     * @param {string} color - 颜色。
     * @returns {Array.<number>} 颜色值数组或null
     */
    getData(color) {
        color = this.normalize(color);
        var r = color.match(this.colorRegExp);
        if (r === null) {
            throw new Error('The color format error'); // 颜色格式错误
        }
        var d;
        var a;
        var data = [];
        var rgb;

        if (r[2]) {
            // #rrggbb
            d = r[2].replace('#', '').split('');
            rgb = [d[0] + d[1], d[2] + d[3], d[4] + d[5]];
            data = this.map(rgb,
                function (c) {
                    return Color.prototype.adjust.call(this, parseInt(c, 16), [0, 255]);
                }
            );

        } else if (r[4]) {
            // rgb rgba
            var rgba = (r[4]).split(',');
            a = rgba[3];
            rgb = rgba.slice(0, 3);
            data = this.map(
                rgb,
                function (c) {
                    c = Math.floor(
                        c.indexOf('%') > 0 ? parseInt(c, 0) * 2.55 : c
                    );
                    return Color.prototype.adjust.call(this, c, [0, 255]);
                }
            );

            if (typeof a !== 'undefined') {
                data.push(this.adjust(parseFloat(a), [0, 1]));
            }
        } else if (r[5] || r[6]) {
            // hsb hsba hsl hsla
            var hsxa = (r[5] || r[6]).split(',');
            var h = parseInt(hsxa[0], 0) / 360;
            var s = hsxa[1];
            var x = hsxa[2];
            a = hsxa[3];
            data = this.map([s, x],
                function (c) {
                    return Color.prototype.adjust.call(this, parseFloat(c) / 100, [0, 1]);
                }
            );
            data.unshift(h);
            if (typeof a !== 'undefined') {
                data.push(this.adjust(parseFloat(a), [0, 1]));
            }
        }
        return data;
    }

    /**
     * @function LevelRenderer.Tool.Color.prototype.alpha
     * @description 设置颜色透明度
     * @param {string} color - 颜色。
     * @param {number} a - 透明度,区间[0,1]。
     * @returns {string} rgba颜色值
     */
    alpha(color, a) {
        if (!this.isCalculableColor(color)) {
            return color;
        }
        if (a === null) {
            a = 1;
        }
        var data = this.getData(this.toRGBA(color));
        data[3] = this.adjust(Number(a).toFixed(4), [0, 1]);

        return this.toColor(data, 'rgba');
    }

    /**
     * @function LevelRenderer.Tool.Color.prototype.map
     * @description 数组映射
     * @param {Array} array - 数组。
     * @param {function} fun - 函数。
     * @returns {string} 数组映射结果
     */
    map(array, fun) {
        if (typeof fun !== 'function') {
            throw new TypeError();
        }
        var len = array ? array.length : 0;
        for (var i = 0; i < len; i++) {
            array[i] = fun(array[i]);
        }
        return array;
    }

    /**
     * @function LevelRenderer.Tool.Color.prototype.adjust
     * @description 调整值区间
     * @param {Array.<number>} value - 数组。
     * @param {Array.<number>} region - 区间。
     * @returns {number} 调整后的值
     */
    adjust(value, region) {
        // < to <= & > to >=
        // modify by linzhifeng 2014-05-25 because -0 == 0
        if (value <= region[0]) {
            value = region[0];
        } else if (value >= region[1]) {
            value = region[1];
        }
        return value;
    }

    /**
     * @function LevelRenderer.Tool.Color.prototype.isCalculableColor
     * @description 判断是否是可计算的颜色
     * @param {string} color - 颜色。
     * @returns {boolean} 是否是可计算的颜色
     */
    isCalculableColor(color) {
        return color instanceof Array || typeof color === 'string';
    }

    /**
     * @function LevelRenderer.Tool.Color.prototype._HSV_2_RGB。参见{@link http://www.easyrgb.com/index.php?X=MATH}
     */
    _HSV_2_RGB(data) {
        var H = data[0];
        var S = data[1];
        var V = data[2];
        // HSV from 0 to 1
        var R;
        var G;
        var B;
        if (S === 0) {
            R = V * 255;
            G = V * 255;
            B = V * 255;
        } else {
            var h = H * 6;
            if (h === 6) {
                h = 0;
            }
            var i = h | 0;
            var v1 = V * (1 - S);
            var v2 = V * (1 - S * (h - i));
            var v3 = V * (1 - S * (1 - (h - i)));
            var r = 0;
            var g = 0;
            var b = 0;

            if (i === 0) {
                r = V;
                g = v3;
                b = v1;
            } else if (i === 1) {
                r = v2;
                g = V;
                b = v1;
            } else if (i === 2) {
                r = v1;
                g = V;
                b = v3;
            } else if (i === 3) {
                r = v1;
                g = v2;
                b = V;
            } else if (i === 4) {
                r = v3;
                g = v1;
                b = V;
            } else {
                r = V;
                g = v1;
                b = v2;
            }

            // RGB results from 0 to 255
            R = r * 255;
            G = g * 255;
            B = b * 255;
        }
        return [R, G, B];
    }

    /**
     * @function LevelRenderer.Tool.Color.prototype._HSL_2_RGB。参见{@link http://www.easyrgb.com/index.php?X=MATH}
     */
    _HSL_2_RGB(data) {
        var H = data[0];
        var S = data[1];
        var L = data[2];
        // HSL from 0 to 1
        var R;
        var G;
        var B;
        if (S === 0) {
            R = L * 255;
            G = L * 255;
            B = L * 255;
        } else {
            var v2;
            if (L < 0.5) {
                v2 = L * (1 + S);
            } else {
                v2 = (L + S) - (S * L);
            }

            var v1 = 2 * L - v2;

            R = 255 * this._HUE_2_RGB(v1, v2, H + (1 / 3));
            G = 255 * this._HUE_2_RGB(v1, v2, H);
            B = 255 * this._HUE_2_RGB(v1, v2, H - (1 / 3));
        }
        return [R, G, B];
    }

    /**
     * @function LevelRenderer.Tool.Color.prototype._HUE_2_RGB。参见{@link http://www.easyrgb.com/index.php?X=MATH}
     */
    _HUE_2_RGB(v1, v2, vH) {
        if (vH < 0) {
            vH += 1;
        }
        if (vH > 1) {
            vH -= 1;
        }
        if ((6 * vH) < 1) {
            return (v1 + (v2 - v1) * 6 * vH);
        }
        if ((2 * vH) < 1) {
            return (v2);
        }
        if ((3 * vH) < 2) {
            return (v1 + (v2 - v1) * ((2 / 3) - vH) * 6);
        }
        return v1;
    }

    /**
     * @function LevelRenderer.Tool.Color.prototype._RGB_2_HSB。参见{@link http://www.easyrgb.com/index.php?X=MATH}
     */
    _RGB_2_HSB(data) {
        // RGB from 0 to 255
        var R = (data[0] / 255);
        var G = (data[1] / 255);
        var B = (data[2] / 255);

        var vMin = Math.min(R, G, B); // Min. value of RGB
        var vMax = Math.max(R, G, B); // Max. value of RGB
        var delta = vMax - vMin; // Delta RGB value
        var V = vMax;
        var H;
        var S;

        // HSV results from 0 to 1
        if (delta === 0) {
            H = 0;
            S = 0;
        } else {
            S = delta / vMax;

            var deltaR = (((vMax - R) / 6) + (delta / 2)) / delta;
            var deltaG = (((vMax - G) / 6) + (delta / 2)) / delta;
            var deltaB = (((vMax - B) / 6) + (delta / 2)) / delta;

            if (R === vMax) {
                H = deltaB - deltaG;
            } else if (G === vMax) {
                H = (1 / 3) + deltaR - deltaB;
            } else if (B === vMax) {
                H = (2 / 3) + deltaG - deltaR;
            }

            if (H < 0) {
                H += 1;
            }
            if (H > 1) {
                H -= 1;
            }
        }
        H = H * 360;
        S = S * 100;
        V = V * 100;
        return [H, S, V];
    }

    /**
     * @function LevelRenderer.Tool.Color.prototype._RGB_2_HSL。参见{@link http://www.easyrgb.com/index.php?X=MATH}
     */
    _RGB_2_HSL(data) {

        // RGB from 0 to 255
        var R = (data[0] / 255);
        var G = (data[1] / 255);
        var B = (data[2] / 255);

        var vMin = Math.min(R, G, B); // Min. value of RGB
        var vMax = Math.max(R, G, B); // Max. value of RGB
        var delta = vMax - vMin; // Delta RGB value

        var L = (vMax + vMin) / 2;
        var H;
        var S;
        // HSL results from 0 to 1
        if (delta === 0) {
            H = 0;
            S = 0;
        } else {
            if (L < 0.5) {
                S = delta / (vMax + vMin);
            } else {
                S = delta / (2 - vMax - vMin);
            }

            var deltaR = (((vMax - R) / 6) + (delta / 2)) / delta;
            var deltaG = (((vMax - G) / 6) + (delta / 2)) / delta;
            var deltaB = (((vMax - B) / 6) + (delta / 2)) / delta;

            if (R === vMax) {
                H = deltaB - deltaG;
            } else if (G === vMax) {
                H = (1 / 3) + deltaR - deltaB;
            } else if (B === vMax) {
                H = (2 / 3) + deltaG - deltaR;
            }

            if (H < 0) {
                H += 1;
            }

            if (H > 1) {
                H -= 1;
            }
        }

        H = H * 360;
        S = S * 100;
        L = L * 100;

        return [H, S, L];
    }

}

;// CONCATENATED MODULE: ./src/common/overlay/levelRenderer/ComputeBoundingBox.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/



/**
 * @class  LevelRenderer.Tool.ComputeBoundingBox
 * @category Visualization Theme
 * @classdesc LevelRenderer 工具-图形 Bounds 计算
 * @private
 */
class ComputeBoundingBox {
    constructor() {
        if (arguments.length === 3) {
            this.computeBoundingBox(arguments);
        }

        this.CLASS_NAME = "SuperMap.LevelRenderer.Tool.ComputeBoundingBox";
    }

    /**
     * @function LevelRenderer.Tool.ComputeBoundingBox.prototype.computeBoundingBox
     * @description 从顶点数组中计算出最小包围盒，写入'min'和'max'中。
     * @param {Array.<Object>} points - 顶点数组。
     * @param {Array.<number>} min - 最小
     * @param {Array.<number>} max - 最大
     */
    computeBoundingBox(points, min, max) {
        if (points.length === 0) {
            return;
        }
        var left = points[0][0];
        var right = points[0][0];
        var top = points[0][1];
        var bottom = points[0][1];

        for (var i = 1; i < points.length; i++) {
            var p = points[i];
            if (p[0] < left) {
                left = p[0];
            }
            if (p[0] > right) {
                right = p[0];
            }
            if (p[1] < top) {
                top = p[1];
            }
            if (p[1] > bottom) {
                bottom = p[1];
            }
        }

        min[0] = left;
        min[1] = top;
        max[0] = right;
        max[1] = bottom;
    }

    /**
     * @function LevelRenderer.Tool.ComputeBoundingBox.prototype.cubeBezier
     * @description 从三阶贝塞尔曲线(p0, p1, p2, p3)中计算出最小包围盒，写入'min'和'max'中。原：computeCubeBezierBoundingBox。
     * @param {Array.<number>} p0 - 三阶贝塞尔曲线p0点
     * @param {Array.<number>} p1 - 三阶贝塞尔曲线p1点
     * @param {Array.<number>} p2 - 三阶贝塞尔曲线p2点
     * @param {Array.<number>} p3 - 三阶贝塞尔曲线p3点
     * @param {Array.<number>} min - 最小
     * @param {Array.<number>} max - 最大
     */
    cubeBezier(p0, p1, p2, p3, min, max) {
        var curve = new Curve_Curve();

        var xDim = [];
        curve.cubicExtrema(p0[0], p1[0], p2[0], p3[0], xDim);
        for (let i = 0; i < xDim.length; i++) {
            xDim[i] = curve.cubicAt(p0[0], p1[0], p2[0], p3[0], xDim[i]);
        }
        var yDim = [];
        curve.cubicExtrema(p0[1], p1[1], p2[1], p3[1], yDim);
        for (let i = 0; i < yDim.length; i++) {
            yDim[i] = curve.cubicAt(p0[1], p1[1], p2[1], p3[1], yDim[i]);
        }

        xDim.push(p0[0], p3[0]);
        yDim.push(p0[1], p3[1]);

        var left = Math.min.apply(null, xDim);
        var right = Math.max.apply(null, xDim);
        var top = Math.min.apply(null, yDim);
        var bottom = Math.max.apply(null, yDim);

        min[0] = left;
        min[1] = top;
        max[0] = right;
        max[1] = bottom;
    }

    /**
     * @function LevelRenderer.Tool.ComputeBoundingBox.prototype.quadraticBezier
     * @description 从二阶贝塞尔曲线(p0, p1, p2)中计算出最小包围盒，写入'min'和'max'中。原：computeQuadraticBezierBoundingBox。
     * @param {Array.<number>} p0 - 二阶贝塞尔曲线p0点
     * @param {Array.<number>} p1 - 二阶贝塞尔曲线p1点
     * @param {Array.<number>} p2 - 二阶贝塞尔曲线p2点
     * @param {Array.<number>} min - 最小
     * @param {Array.<number>} max - 最大
     */
    quadraticBezier(p0, p1, p2, min, max) {
        var curve = new Curve_Curve();

        // Find extremities, where derivative in x dim or y dim is zero
        var t1 = curve.quadraticExtremum(p0[0], p1[0], p2[0]);
        var t2 = curve.quadraticExtremum(p0[1], p1[1], p2[1]);

        t1 = Math.max(Math.min(t1, 1), 0);
        t2 = Math.max(Math.min(t2, 1), 0);

        var ct1 = 1 - t1;
        var ct2 = 1 - t2;

        var x1 = ct1 * ct1 * p0[0]
            + 2 * ct1 * t1 * p1[0]
            + t1 * t1 * p2[0];
        var y1 = ct1 * ct1 * p0[1]
            + 2 * ct1 * t1 * p1[1]
            + t1 * t1 * p2[1];

        var x2 = ct2 * ct2 * p0[0]
            + 2 * ct2 * t2 * p1[0]
            + t2 * t2 * p2[0];
        var y2 = ct2 * ct2 * p0[1]
            + 2 * ct2 * t2 * p1[1]
            + t2 * t2 * p2[1];
        min[0] = Math.min(p0[0], p2[0], x1, x2);
        min[1] = Math.min(p0[1], p2[1], y1, y2);
        max[0] = Math.max(p0[0], p2[0], x1, x2);
        max[1] = Math.max(p0[1], p2[1], y1, y2);
    }

    /**
     * @function LevelRenderer.Tool.ComputeBoundingBox.prototype.arc
     * @description 从圆弧中计算出最小包围盒，写入'min'和'max'中。原：computeArcBoundingBox。
     * @param {number} x - 圆弧中心点 x
     * @param {number} y - 圆弧中心点 y
     * @param {number} r - 圆弧半径
     * @param {number} startAngle - 圆弧开始角度
     * @param {number} endAngle - 圆弧结束角度
     * @param {number} anticlockwise - 是否是顺时针
     * @param {number} min - 最小
     * @param {number} max - 最大
     */
    arc(x, y, r, startAngle, endAngle, anticlockwise, min, max) {
        var vec2 = new Vector_Vector();

        var start = vec2.create();
        var end = vec2.create();
        var extremity = vec2.create();

        start[0] = Math.cos(startAngle) * r + x;
        start[1] = Math.sin(startAngle) * r + y;

        end[0] = Math.cos(endAngle) * r + x;
        end[1] = Math.sin(endAngle) * r + y;

        vec2.min(min, start, end);
        vec2.max(max, start, end);

        // Thresh to [0, Math.PI * 2]
        startAngle = startAngle % (Math.PI * 2);
        if (startAngle < 0) {
            startAngle = startAngle + Math.PI * 2;
        }
        endAngle = endAngle % (Math.PI * 2);
        if (endAngle < 0) {
            endAngle = endAngle + Math.PI * 2;
        }

        if (startAngle > endAngle && !anticlockwise) {
            endAngle += Math.PI * 2;
        } else if (startAngle < endAngle && anticlockwise) {
            startAngle += Math.PI * 2;
        }
        if (anticlockwise) {
            var tmp = endAngle;
            endAngle = startAngle;
            startAngle = tmp;
        }

        // var number = 0;
        // var step = (anticlockwise ? -Math.PI : Math.PI) / 2;
        for (var angle = 0; angle < endAngle; angle += Math.PI / 2) {
            if (angle > startAngle) {
                extremity[0] = Math.cos(angle) * r + x;
                extremity[1] = Math.sin(angle) * r + y;

                vec2.min(min, extremity, min);
                vec2.max(max, extremity, max);
            }
        }
    }
}

;// CONCATENATED MODULE: ./src/common/overlay/levelRenderer/Env.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/
/**
 * @class  LevelRenderer.Tool.Env
 * @category Visualization Theme
 * @classdesc 环境识别
 * @private
 */
class Env {
    constructor() {
        // Zepto.js
        // (c) 2010-2013 Thomas Fuchs
        // Zepto.js may be freely distributed under the MIT license.
        this.CLASS_NAME = "SuperMap.LevelRenderer.Tool.Env";
        var me = this;

        function detect(ua) {
            var os = me.os = {};
            var browser = me.browser = {};
            var webkit = ua.match(/Web[kK]it[\/]{0,1}([\d.]+)/);
            var android = ua.match(/(Android);?[\s\/]+([\d.]+)?/);
            var ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
            var ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
            var iphone = !ipad && ua.match(/(iPhone\sOS)\s([\d_]+)/);
            var webos = ua.match(/(webOS|hpwOS)[\s\/]([\d.]+)/);
            var touchpad = webos && ua.match(/TouchPad/);
            var kindle = ua.match(/Kindle\/([\d.]+)/);
            var silk = ua.match(/Silk\/([\d._]+)/);
            var blackberry = ua.match(/(BlackBerry).*Version\/([\d.]+)/);
            var bb10 = ua.match(/(BB10).*Version\/([\d.]+)/);
            var rimtabletos = ua.match(/(RIM\sTablet\sOS)\s([\d.]+)/);
            var playbook = ua.match(/PlayBook/);
            var chrome = ua.match(/Chrome\/([\d.]+)/) || ua.match(/CriOS\/([\d.]+)/);
            var firefox = ua.match(/Firefox\/([\d.]+)/);
            var ie = ua.match(/MSIE ([\d.]+)/);
            var safari = webkit && ua.match(/Mobile\//) && !chrome;
            var webview = ua.match(/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/) && !chrome;

            // Todo: clean this up with a better OS/browser seperation:
            // - discern (more) between multiple browsers on android
            // - decide if kindle fire in silk mode is android or not
            // - Firefox on Android doesn't specify the Android version
            // - possibly devide in os, device and browser hashes

            /*eslint-disable*/
            if (browser.webkit = !!webkit) {
                browser.version = webkit[1];
            }

            if (android) {
                os.android = true;
                os.version = android[2];
            }
            if (iphone && !ipod) {
                os.ios = os.iphone = true;
                os.version = iphone[2].replace(/_/g, '.');
            }
            if (ipad) {
                os.ios = os.ipad = true;
                os.version = ipad[2].replace(/_/g, '.');
            }
            if (ipod) {
                os.ios = os.ipod = true;
                os.version = ipod[3] ? ipod[3].replace(/_/g, '.') : null;
            }
            if (webos) {
                os.webos = true;
                os.version = webos[2];
            }
            if (touchpad) {
                os.touchpad = true;
            }
            if (blackberry) {
                os.blackberry = true;
                os.version = blackberry[2];
            }
            if (bb10) {
                os.bb10 = true;
                os.version = bb10[2];
            }
            if (rimtabletos) {
                os.rimtabletos = true;
                os.version = rimtabletos[2];
            }
            if (playbook) {
                browser.playbook = true;
            }
            if (kindle) {
                os.kindle = true;
                os.version = kindle[1];
            }
            if (silk) {
                browser.silk = true;
                browser.version = silk[1];
            }
            if (!silk && os.android && ua.match(/Kindle Fire/)) {
                browser.silk = true;
            }
            if (chrome) {
                browser.chrome = true;
                browser.version = chrome[1];
            }
            if (firefox) {
                browser.firefox = true;
                browser.version = firefox[1];
            }
            if (ie) {
                browser.ie = true;
                browser.version = ie[1];
            }
            if (safari && (ua.match(/Safari/) || !!os.ios)) {
                browser.safari = true;
            }
            if (webview) {
                browser.webview = true;
            }
            if (ie) {
                browser.ie = true;
                browser.version = ie[1];
            }

            os.tablet = !!(ipad || playbook || (android && !ua.match(/Mobile/)) ||
                (firefox && ua.match(/Tablet/)) || (ie && !ua.match(/Phone/) && ua.match(/Touch/)));
            os.phone = !!(!os.tablet && !os.ipod && (android || iphone || webos || blackberry || bb10 ||
                (chrome && ua.match(/Android/)) || (chrome && ua.match(/CriOS\/([\d.]+)/)) ||
                (firefox && ua.match(/Mobile/)) || (ie && ua.match(/Touch/))));

            return {
                browser: browser,
                os: os,
                // 原生canvas支持
                canvasSupported: document.createElement('canvas').getContext ? true : false
            };
        }

        return detect(navigator.userAgent);
    }
    destory() {
        return true;
    }
}

;// CONCATENATED MODULE: ./src/common/overlay/levelRenderer/Event.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/
/**
 * @class  LevelRenderer.Tool.Event
 * @category Visualization Theme
 * @classdesc LevelRenderer 工具-事件辅助类
 * @private
 */
class Event {
    constructor() {
        /**
         * @member {function} LevelRenderer.Tool.Event.prototype.stop
         * @description 停止冒泡和阻止默认行为
         */
        this.stop = typeof window.addEventListener === 'function'
            ? function (e) {
                e.preventDefault();
                e.stopPropagation();
                e.cancelBubble = true;
            }
            : function (e) {
                e.returnValue = false;
                e.cancelBubble = true;
            };

        this.CLASS_NAME = "SuperMap.LevelRenderer.Tool.Event";
    }


    /**
     * @function LevelRenderer.Tool.Event.prototype.getX
     * @description 提取鼠标（手指）x坐标。
     * @param {Event} e - 事件。
     * @returns {number} 鼠标（手指）x坐标。
     */
    getX(e) {
        return typeof e.zrenderX != 'undefined' && e.zrenderX
            || typeof e.offsetX != 'undefined' && e.offsetX
            || typeof e.layerX != 'undefined' && e.layerX
            || typeof e.clientX != 'undefined' && e.clientX;
    }


    /**
     * @function LevelRenderer.Tool.Event.prototype.getY
     * @description 提取鼠标（手指）y坐标。
     * @param {Event} e - 事件。
     * @returns {number} 鼠标（手指）y坐标。
     */
    getY(e) {
        return typeof e.zrenderY != 'undefined' && e.zrenderY
            || typeof e.offsetY != 'undefined' && e.offsetY
            || typeof e.layerY != 'undefined' && e.layerY
            || typeof e.clientY != 'undefined' && e.clientY;
    }


    /**
     * @function LevelRenderer.Tool.Event.prototype.getDelta
     * @description 提取鼠标滚轮变化。
     * @param {Event} e - 事件。
     * @returns {number} 滚轮变化，正值说明滚轮是向上滚动，如果是负值说明滚轮是向下滚动。
     */
    getDelta(e) {
        return typeof e.zrenderDelta != 'undefined' && e.zrenderDelta
            || typeof e.wheelDelta != 'undefined' && e.wheelDelta
            || typeof e.detail != 'undefined' && -e.detail;
    }
}

;// CONCATENATED MODULE: ./src/common/overlay/levelRenderer/Http.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/
/**
 * @private
 * @class  LevelRenderer.Tool.Http
 * @category Visualization Theme
 * @classdesc LevelRenderer 工具-Http
 */
class Http {
    constructor() {
        this.CLASS_NAME = "SuperMap.LevelRenderer.Tool.Http"
    }

    /**
     * @function LevelRenderer.Tool.Http.prototype.get
     * @description get请求。
     * @param {(string|IHTTPGetOption)} url - 请求url
     * @param {function} onsuccess - 请求成功函数
     * @param {function} onerror - 请求失败函数
     * @param {Object} opts - 额外参数
     * @returns {number} cos值
     */
    get(url, onsuccess, onerror) {
        if (typeof(url) === 'object') {
            var obj = url;
            url = obj.url;
            onsuccess = obj.onsuccess;
            onerror = obj.onerror;

        }
        var xhr = window.XMLHttpRequest
            ? new XMLHttpRequest()
            : new window.ActiveXObject('Microsoft.XMLHTTP');
        xhr.open('GET', url, true);
        xhr.onreadystatechange = function () {
            if (xhr.readyState == 4) {
                if (xhr.status >= 200 && xhr.status < 300 || xhr.status === 304) {
                    onsuccess && onsuccess(xhr.responseText);
                } else {
                    onerror && onerror();
                }
                xhr.onreadystatechange = new Function();
                xhr = null;
            }
        };

        xhr.send(null);
    }

}

;// CONCATENATED MODULE: ./src/common/overlay/levelRenderer/Config.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/
class Config {

}
/**
 * @enum EVENT
 * @description 事件
 * @type {Object}
 * @private 
 */
Config.EVENT = {
    //窗口大小变化
    RESIZE: 'resize',

    //鼠标按钮被（手指）按下，事件对象是：目标图形元素或空
    CLICK: 'click',

    //双击事件
    DBLCLICK: 'dblclick',

    //鼠标滚轮变化，事件对象是：目标图形元素或空
    MOUSEWHEEL: 'mousewheel',

    //鼠标（手指）被移动，事件对象是：目标图形元素或空
    MOUSEMOVE: 'mousemove',

    //鼠标移到某图形元素之上，事件对象是：目标图形元素
    MOUSEOVER: 'mouseover',

    //鼠标从某图形元素移开，事件对象是：目标图形元素
    MOUSEOUT: 'mouseout',

    //鼠标按钮（手指）被按下，事件对象是：目标图形元素或空
    MOUSEDOWN: 'mousedown',

    //鼠标按键（手指）被松开，事件对象是：目标图形元素或空
    MOUSEUP: 'mouseup',

    //全局离开，MOUSEOUT触发比较频繁，一次离开优化绑定
    GLOBALOUT: 'globalout',

    // 一次成功元素拖拽的行为事件过程是：
    // dragstart > dragenter > dragover [> dragleave] > drop > dragend

    //开始拖拽时触发，事件对象是：被拖拽图形元素
    DRAGSTART: 'dragstart',

    //拖拽完毕时触发（在drop之后触发），事件对象是：被拖拽图形元素
    DRAGEND: 'dragend',

    //拖拽图形元素进入目标图形元素时触发，事件对象是：目标图形元素
    DRAGENTER: 'dragenter',

    //拖拽图形元素在目标图形元素上移动时触发，事件对象是：目标图形元素
    DRAGOVER: 'dragover',

    //拖拽图形元素离开目标图形元素时触发，事件对象是：目标图形元素
    DRAGLEAVE: 'dragleave',

    //拖拽图形元素放在目标图形元素内时触发，事件对象是：目标图形元素
    DROP: 'drop',

    //touch end - start < delay is click
    touchClickDelay: 300
};

/**
 * @enum catchBrushException
 * @description 是否异常捕获
 * @type {boolean}
 * @private 
 */
Config.catchBrushException = false;

/**
 * @enum debugMode
 * @description debug 日志选项：catchBrushException 为 true 下有效。
 * 0 : 不生成debug数据，发布用
 * 1 : 异常抛出，调试用
 * 2 : 控制台输出，调试用
 * @type {boolean}
 * @private 
 */
Config.debugMode = 0;
;// CONCATENATED MODULE: ./src/common/overlay/levelRenderer/Log.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


/**
 * @private
 * @class  LevelRenderer.Tool.Log
 * @category Visualization Theme
 * @classdesc LevelRenderer 工具-日志
 */
class Log {
    constructor() {

        this.CLASS_NAME = "SuperMap.LevelRenderer.Tool.Log";
        return function () {
            if (+Config.debugMode === 0) {
                return;
            } else if (+Config.debugMode === 1) {
                for (let k in arguments) {
                    throw new Error(arguments[k]);
                }
            } else if (+Config.debugMode > 1) {
                for (let k in arguments) {
                    console.log(arguments[k]);
                }
            }
        };

        /* for debug
         return function(mes) {
         document.getElementById('wrong-message').innerHTML =
         mes + ' ' + (new Date() - 0)
         + '<br/>'
         + document.getElementById('wrong-message').innerHTML;
         };
         */
    }

    destory() {
        return true;
    }
}

;// CONCATENATED MODULE: ./src/common/overlay/levelRenderer/Math.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/
/**
 * @private
 * @class  LevelRenderer.Tool.Math
 * @category Visualization Theme
 * @classdesc LevelRenderer 工具-数学辅助类
 */
class MathTool {

    constructor() {

        /**
         * @member {number} LevelRenderer.Tool.Math._radians
         * @description 角度与弧度转化参数
         */
        this._radians = window.Math.PI / 180;

        this.CLASS_NAME = "SuperMap.LevelRenderer.Tool.Math";
    }

    /**
     * @function LevelRenderer.Tool.Math.prototype.sin
     * @description 正弦函数。
     * @param {number} angle - 弧度（角度）参数。
     * @param {boolean} [isDegrees=false] - angle参数是否为角度计算，angle为以弧度计量的角度。
     * @returns {number} sin 值。
     */
    sin(angle, isDegrees) {
        return window.Math.sin(isDegrees ? angle * this._radians : angle);
    }

    /**
     * @function LevelRenderer.Tool.Math.prototype.cos
     * @description 余弦函数。
     * @param {number} angle - 弧度（角度）参数。
     * @param {boolean} [isDegrees=false] - angle参数是否为角度计算，angle为以弧度计量的角度。
     * @returns {number} cos 值。
     */
    cos(angle, isDegrees) {
        return window.Math.cos(isDegrees ? angle * this._radians : angle);
    }

    /**
     * @function LevelRenderer.Tool.Math.prototype.degreeToRadian
     * @description 角度转弧度。
     * @param {number} angle - 弧度（角度）参数。
     * @param {boolean} [isDegrees=false] - angle参数是否为角度计算，angle为以弧度计量的角度。
     * @returns {number} 弧度值。
     */
    degreeToRadian(angle) {
        return angle * this._radians;
    }

    /**
     * @function LevelRenderer.Tool.Math.prototype.radianToDegree
     * @description 弧度转角度。
     * @param {number} angle - 弧度（角度）参数。
     * @param {boolean} [isDegrees=false] - angle参数是否为角度计算，angle为以弧度计量的角度。
     * @returns {number} 角度。
     */

    radianToDegree(angle) {
        return angle / this._radians;
    }

}

;// CONCATENATED MODULE: ./src/common/overlay/levelRenderer/Matrix.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/
/**
 * @private
 * @class  LevelRenderer.Tool.Matrix
 * @category Visualization Theme
 * @classdesc LevelRenderer 工具-3x2矩阵操作类
 */
class Matrix {

    constructor() {
        /**
         * @member {Object} LevelRenderer.Tool.Matrix.prototype.ArrayCtor
         * @description 数组类型控制
         */
        this.ArrayCtor = typeof Float32Array === 'undefined'
            ? Array
            : Float32Array;

        this.CLASS_NAME = "SuperMap.LevelRenderer.Tool.Matrix";
    }


    /**
     * @function LevelRenderer.Tool.Matrix.prototype.create
     * @description 创建一个单位矩阵。
     * @returns {(Float32Array|Array.<number>)} 单位矩阵。
     */
    create() {
        var ArrayCtor = this.ArrayCtor;

        var out = new ArrayCtor(6);
        this.identity(out);

        return out;
    }

    /**
     * @function LevelRenderer.Tool.Matrix.prototype.identity
     * @description 设置矩阵为单位矩阵。
     * @param {(Float32Array|Array.<number>)} out - 单位矩阵。
     * @returns {(Float32Array|Array.<number>)} 单位矩阵。
     */
    identity(out) {
        out[0] = 1;
        out[1] = 0;
        out[2] = 0;
        out[3] = 1;
        out[4] = 0;
        out[5] = 0;
        return out;
    }


    /**
     * @function LevelRenderer.Tool.Matrix.prototype.copy
     * @description 复制矩阵。
     * @param {(Float32Array|Array.<number>)} out - 单位矩阵。
     * @returns {(Float32Array|Array.<number>)} 克隆矩阵。
     */
    copy(out, m) {
        out[0] = m[0];
        out[1] = m[1];
        out[2] = m[2];
        out[3] = m[3];
        out[4] = m[4];
        out[5] = m[5];
        return out;
    }

    /**
     * @function LevelRenderer.Tool.Matrix.prototype.mul
     * @description 矩阵相乘。
     * @param {(Float32Array|Array.<number>)} out - 单位矩阵。
     * @param {(Float32Array|Array.<number>)} m1 - 矩阵m1。
     * @param {(Float32Array|Array.<number>)} m2- 矩阵m2。
     * @returns {(Float32Array|Array.<number>)} 结果矩阵。
     */
    mul(out, m1, m2) {
        out[0] = m1[0] * m2[0] + m1[2] * m2[1];
        out[1] = m1[1] * m2[0] + m1[3] * m2[1];
        out[2] = m1[0] * m2[2] + m1[2] * m2[3];
        out[3] = m1[1] * m2[2] + m1[3] * m2[3];
        out[4] = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];
        out[5] = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];
        return out;
    }

    /**
     * @function LevelRenderer.Tool.Matrix.prototype.mul
     * @description 平移变换。
     * @param {(Float32Array|Array.<number>)} out - 单位矩阵。
     * @param {(Float32Array|Array.<number>)} a - 矩阵。
     * @param {(Float32Array|Array.<number>)} v- 平移参数。
     * @returns {(Float32Array|Array.<number>)} 结果矩阵。
     */
    translate(out, a, v) {
        out[0] = a[0];
        out[1] = a[1];
        out[2] = a[2];
        out[3] = a[3];
        out[4] = a[4] + v[0];
        out[5] = a[5] + v[1];
        return out;
    }

    /**
     * @function LevelRenderer.Tool.Matrix.prototype.rotate
     * @description 平移变换。
     * @param {(Float32Array|Array.<number>)} out - 单位矩阵。
     * @param {(Float32Array|Array.<number>)} a - 矩阵。
     * @param {(Float32Array|Array.<number>)} rad - 旋转参数。
     * @returns {(Float32Array|Array.<number>)} 结果矩阵。
     */
    rotate(out, a, rad) {
        var aa = a[0];
        var ac = a[2];
        var atx = a[4];
        var ab = a[1];
        var ad = a[3];
        var aty = a[5];
        var st = Math.sin(rad);
        var ct = Math.cos(rad);

        out[0] = aa * ct + ab * st;
        out[1] = -aa * st + ab * ct;
        out[2] = ac * ct + ad * st;
        out[3] = -ac * st + ct * ad;
        out[4] = ct * atx + st * aty;
        out[5] = ct * aty - st * atx;
        return out;
    }

    /**
     * @function LevelRenderer.Tool.Matrix.prototype.scale
     * @description 缩放变换。
     * @param {(Float32Array|Array.<number>)} out - 单位矩阵。
     * @param {(Float32Array|Array.<number>)} a - 矩阵。
     * @param {(Float32Array|Array.<number>)} v - 缩放参数。
     * @returns {(Float32Array|Array.<number>)} 结果矩阵。
     */
    scale(out, a, v) {
        var vx = v[0];
        var vy = v[1];
        out[0] = a[0] * vx;
        out[1] = a[1] * vy;
        out[2] = a[2] * vx;
        out[3] = a[3] * vy;
        out[4] = a[4] * vx;
        out[5] = a[5] * vy;
        return out;
    }

    /**
     * @function LevelRenderer.Tool.Matrix.prototype.invert
     * @description 求逆矩阵。
     * @param {(Float32Array|Array.<number>)} out - 单位矩阵。
     * @param {(Float32Array|Array.<number>)} a - 矩阵。
     * @returns {(Float32Array|Array.<number>)} 结果矩阵。
     */
    invert(out, a) {
        var aa = a[0];
        var ac = a[2];
        var atx = a[4];
        var ab = a[1];
        var ad = a[3];
        var aty = a[5];

        var det = aa * ad - ab * ac;
        if (!det) {
            return null;
        }
        det = 1.0 / det;

        out[0] = ad * det;
        out[1] = -ab * det;
        out[2] = -ac * det;
        out[3] = aa * det;
        out[4] = (ac * aty - ad * atx) * det;
        out[5] = (ab * atx - aa * aty) * det;
        return out;
    }

    /**
     * @function LevelRenderer.Tool.Matrix.prototype.mulVector
     * @description 矩阵左乘向量。
     * @param {(Float32Array|Array.<number>)} out - 单位矩阵。
     * @param {(Float32Array|Array.<number>)} a - 矩阵。
     * @param {(Float32Array|Array.<number>)} v - 缩放参数。
     * @returns {(Float32Array|Array.<number>)} 结果矩阵。
     */
    mulVector(out, a, v) {
        var aa = a[0];
        var ac = a[2];
        var atx = a[4];
        var ab = a[1];
        var ad = a[3];
        var aty = a[5];

        out[0] = v[0] * aa + v[1] * ac + atx;
        out[1] = v[0] * ab + v[1] * ad + aty;

        return out;
    }

}

;// CONCATENATED MODULE: ./src/common/overlay/levelRenderer/SUtil.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/













class SUtil_SUtil {
    /**
     * @function LevelRenderer.SUtil.SUtil_smoothBezier
     * @description 贝塞尔平滑曲线。
     * @private
     * @param {Array} points - 线段顶点数组。
     * @param {number} smooth - 平滑等级, 0-1。
     * @param {boolean} isLoop - isLoop。
     * @param {Array} constraint - 将计算出来的控制点约束在一个包围盒内，比如 [[0, 0], [100, 100]], 这个包围盒会与整个折线的包围盒做一个并集用来约束控制点。
     * @param {Array.<number>} [originalPosition=[0, 0]] - 参考原点。
     * @return {Array} 生成的平滑节点数组。
     */
    static SUtil_smoothBezier(points, smooth, isLoop, constraint, originalPosition) {
        if (!originalPosition || originalPosition.length !== 2) {
            originalPosition = [0, 0];
        }
        var __OP = originalPosition;

        var cps = [];

        var v = [];
        var v1 = [];
        var v2 = [];

        var hasConstraint = !!constraint;
        var min, max;
        if (hasConstraint) {
            min = [Infinity, Infinity];
            max = [-Infinity, -Infinity];
            let len = points.length;
            for (let i = 0; i < len; i++) {
                SUtil_SUtil.Util_vector.min(min, min, [points[i][0] + __OP[0], points[i][1] + __OP[1]]);
                SUtil_SUtil.Util_vector.max(max, max, [points[i][0] + __OP[0], points[i][1] + __OP[1]]);
            }
            // 与指定的包围盒做并集
            SUtil_SUtil.Util_vector.min(min, min, constraint[0]);
            SUtil_SUtil.Util_vector.max(max, max, constraint[1]);
        }

        let len = points.length;
        for (let i = 0; i < len; i++) {
            let point = [points[i][0] + __OP[0], points[i][1] + __OP[1]];
            let prevPoint;
            let nextPoint;

            if (isLoop) {
                prevPoint = [points[i ? i - 1 : len - 1][0] + __OP[0], points[i ? i - 1 : len - 1][1] + __OP[1]];
                nextPoint = [points[(i + 1) % len][0] + __OP[0], points[(i + 1) % len][1] + __OP[1]];
            } else {
                if (i === 0 || i === len - 1) {
                    cps.push([points[i][0] + __OP[0], points[i][1] + __OP[1]]);
                    continue;
                } else {
                    prevPoint = [points[i - 1][0] + __OP[0], points[i - 1][1] + __OP[1]];
                    nextPoint = [points[i + 1][0] + __OP[0], points[i + 1][1] + __OP[1]];
                }
            }

            SUtil_SUtil.Util_vector.sub(v, nextPoint, prevPoint);

            // use degree to scale the handle length
            SUtil_SUtil.Util_vector.scale(v, v, smooth);

            let d0 = SUtil_SUtil.Util_vector.distance(point, prevPoint);
            let d1 = SUtil_SUtil.Util_vector.distance(point, nextPoint);
            let sum = d0 + d1;
            if (sum !== 0) {
                d0 /= sum;
                d1 /= sum;
            }

            SUtil_SUtil.Util_vector.scale(v1, v, -d0);
            SUtil_SUtil.Util_vector.scale(v2, v, d1);
            let cp0 = SUtil_SUtil.Util_vector.add([], point, v1);
            let cp1 = SUtil_SUtil.Util_vector.add([], point, v2);
            if (hasConstraint) {
                SUtil_SUtil.Util_vector.max(cp0, cp0, min);
                SUtil_SUtil.Util_vector.min(cp0, cp0, max);
                SUtil_SUtil.Util_vector.max(cp1, cp1, min);
                SUtil_SUtil.Util_vector.min(cp1, cp1, max);
            }
            cps.push(cp0);
            cps.push(cp1);
        }

        if (isLoop) {
            cps.push(cps.shift());
        }

        return cps;
    }

    /**
     * @function LevelRenderer.SUtil.SUtil_smoothSpline
     * @description 插值折线。
     * @private
     * @param {Array} points - 线段顶点数组。
     * @param {boolean} isLoop - isLoop。
     * @param {Array} constraint - 将计算出来的控制点约束在一个包围盒内，比如 [[0, 0], [100, 100]], 这个包围盒会与整个折线的包围盒做一个并集用来约束控制点。
     * @param {Array.<number>} originalPosition - 参考原点。默认值：[0, 0]。
     * @return {Array} 生成的平滑节点数组。
     */
    static SUtil_smoothSpline(points, isLoop, constraint, originalPosition) {
        if (!originalPosition || originalPosition.length !== 2) {
            originalPosition = [0, 0];
        }
        var __OP = originalPosition;

        var len = points.length;
        var ret = [];

        var distance = 0;
        for (let i = 1; i < len; i++) {
            distance += SUtil_SUtil.Util_vector.distance([points[i - 1][0] + __OP[0], points[i - 1][1] + __OP[1]], [points[i][0] + __OP[0], points[i][1] + __OP[1]]);
        }

        var segs = distance / 5;
        segs = segs < len ? len : segs;
        for (let i = 0; i < segs; i++) {
            let pos = i / (segs - 1) * (isLoop ? len : len - 1);
            let idx = Math.floor(pos);

            let w = pos - idx;

            let p0;
            let p1 = [points[idx % len][0] + __OP[0], points[idx % len][1] + __OP[1]];
            let p2;
            let p3;
            if (!isLoop) {
                p0 = [points[idx === 0 ? idx : idx - 1][0] + __OP[0], points[idx === 0 ? idx : idx - 1][1] + __OP[1]];
                p2 = [points[idx > len - 2 ? len - 1 : idx + 1][0] + __OP[0], points[idx > len - 2 ? len - 1 : idx + 1][1] + __OP[1]];
                p3 = [points[idx > len - 3 ? len - 1 : idx + 2][0] + __OP[0], points[idx > len - 3 ? len - 1 : idx + 2][1] + __OP[1]];
            } else {

                p0 = [points[(idx - 1 + len) % len][0] + __OP[0], points[(idx - 1 + len) % len][1] + __OP[1]];
                p2 = [points[(idx + 1) % len][0] + __OP[0], points[(idx + 1) % len][1] + __OP[1]];
                p3 = [points[(idx + 2) % len][0] + __OP[0], points[(idx + 2) % len][1] + __OP[1]];
            }

            let w2 = w * w;
            let w3 = w * w2;

            ret.push([
                interpolate(p0[0], p1[0], p2[0], p3[0], w, w2, w3),
                interpolate(p0[1], p1[1], p2[1], p3[1], w, w2, w3)
            ]);
        }
        return ret;

        // inner Function
        function interpolate(p0, p1, p2, p3, t, t2, t3) {
            var v0 = (p2 - p0) * 0.5;
            var v1 = (p3 - p1) * 0.5;
            return (2 * (p1 - p2) + v0 + v1) * t3
                + (-3 * (p1 - p2) - 2 * v0 - v1) * t2
                + v0 * t + p1;
        }
    }

    /**
     * @function LevelRenderer.SUtil.SUtil_dashedLineTo
     * @description 虚线 lineTo。
     */
    static SUtil_dashedLineTo(ctx, x1, y1, x2, y2, dashLength, customDashPattern) {
        // http://msdn.microsoft.com/en-us/library/ie/dn265063(v=vs.85).aspx
        var dashPattern = [5, 5];
        dashLength = typeof dashLength != 'number'
            ? 5
            : dashLength;

        if (ctx.setLineDash) {
            dashPattern[0] = dashLength;
            dashPattern[1] = dashLength;

            if (customDashPattern && (customDashPattern instanceof Array)) {
                ctx.setLineDash(customDashPattern);
            } else {
                ctx.setLineDash(dashPattern);
            }
            // ctx.setLineDash(dashPattern);

            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            return;
        }

        var dx = x2 - x1;
        var dy = y2 - y1;
        var numDashes = Math.floor(
            Math.sqrt(dx * dx + dy * dy) / dashLength
        );
        dx = dx / numDashes;
        dy = dy / numDashes;
        var flag = true;
        for (var i = 0; i < numDashes; ++i) {
            if (flag) {
                ctx.moveTo(x1, y1);
            } else {
                ctx.lineTo(x1, y1);
            }
            flag = !flag;
            x1 += dx;
            y1 += dy;
        }
        ctx.lineTo(x2, y2);
    }
}
// 把所有工具对象放到全局静态变量上，以便直接调用工具方法，
// 避免使用工具时频繁的创建工具对象带来的性能消耗。
SUtil_SUtil.Util_area = new Area();
SUtil_SUtil.Util_color = new Color();
SUtil_SUtil.Util_computeBoundingBox = new ComputeBoundingBox();
SUtil_SUtil.Util_curve = new Curve_Curve();
SUtil_SUtil.Util_env = new Env();
SUtil_SUtil.Util_event = new Event();
SUtil_SUtil.Util_http = new Http();
SUtil_SUtil.Util_log = new Log();
SUtil_SUtil.Util_math = new MathTool();
SUtil_SUtil.Util_matrix = new Matrix();
SUtil_SUtil.Util = new levelRenderer_Util_Util();
SUtil_SUtil.Util_vector = new Vector_Vector();

;// CONCATENATED MODULE: ./src/common/overlay/levelRenderer/Transformable.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


/**
 * @private
 * @class  LevelRenderer.Transformable
 * @category Visualization Theme
 * @classdesc 可变换超类，所有支持 Canvas Transform 变换操作的类均是此类的子类。此类不可实例化。
 */
class Transformable {
    constructor() {
        /**
         * @member {Array.<number>} LevelRenderer.Transformable.prototype.position
         * @description 平移，默认值：[0, 0]。
         */
        this.position = [0, 0];

        /**
         * @member {Array.<number>} LevelRenderer.Transformable.prototype.rotation
         * @description 旋转，可以通过数组二三项指定旋转的原点，默认值：[0, 0, 0]。
         */
        this.rotation = [0, 0, 0];

        /**
         * @member {Array.<number>} LevelRenderer.Transformable.prototype.scale
         * @description 缩放，可以通过数组三四项指定缩放的原点，默认值：[1, 1, 0, 0]。
         */
        this.scale = [1, 1, 0, 0];

        /**
         * @member {boolean} LevelRenderer.Transformable.prototype.needLocalTransform
         * @description 是否变换。默认值：false。
         */
        this.needLocalTransform = false;

        /**
         * @member {boolean} LevelRenderer.Transformable.prototype.needTransform
         * @description 是否有坐标变换。默认值：false。
         */
        this.needTransform = false;

        this.CLASS_NAME = "SuperMap.LevelRenderer.Transformable";
        /**
         * @function LevelRenderer.Transformable.prototype.lookAt
         * @description 设置图形的朝向。
         */
        this.lookAt = (function () {
            var v = SUtil_SUtil.Util_vector.create();
            // {Array.<Number>|Float32Array} target
            return function (target) {
                if (!this.transform) {
                    this.transform = SUtil_SUtil.Util_matrix.create();
                }
                var m = this.transform;
                SUtil_SUtil.Util_vector.sub(v, target, this.position);
                if (isAroundZero(v[0]) && isAroundZero(v[1])) {
                    return;
                }
                SUtil_SUtil.Util_vector.normalize(v, v);
                // Y Axis
                // TODO Scale origin ?
                m[2] = v[0] * this.scale[1];
                m[3] = v[1] * this.scale[1];
                // X Axis
                m[0] = v[1] * this.scale[0];
                m[1] = -v[0] * this.scale[0];
                // Position
                m[4] = this.position[0];
                m[5] = this.position[1];

                this.decomposeTransform();

                function isAroundZero(val) {
                    var EPSILON = 5e-5;
                    return val > -EPSILON && val < EPSILON;
                }
            };
        })();
    }

    /**
     * @function LevelRenderer.Transformable.prototype.destroy
     * @description 销毁对象，释放资源。调用此函数后所有属性将被置为 null。
     */
    destroy() {
        this.position = null;
        this.rotation = null;
        this.scale = null;
        this.needLocalTransform = null;
        this.needTransform = null;
    }


    /**
     * @function LevelRenderer.Transformable.prototype.updateNeedTransform
     * @description 更新 needLocalTransform
     */
    updateNeedTransform() {
        this.needLocalTransform = isNotAroundZero(this.rotation[0])
            || isNotAroundZero(this.position[0])
            || isNotAroundZero(this.position[1])
            || isNotAroundZero(this.scale[0] - 1)
            || isNotAroundZero(this.scale[1] - 1);

        function isNotAroundZero(val) {
            var EPSILON = 5e-5;
            return val > EPSILON || val < -EPSILON;
        }
    }


    /**
     * @function LevelRenderer.Transformable.prototype.updateTransform
     * @description 判断是否需要有坐标变换，更新 needTransform 属性。如果有坐标变换，则从 position, rotation, scale 以及父节点的 transform 计算出自身的 transform 矩阵。
     */
    updateTransform() {
        this.updateNeedTransform();

        if (this.parent) {
            this.needTransform = this.needLocalTransform || this.parent.needTransform;
        } else {
            this.needTransform = this.needLocalTransform;
        }

        if (!this.needTransform) {
            return;
        }

        var origin = [0, 0];

        var m = this.transform || SUtil_SUtil.Util_matrix.create();
        SUtil_SUtil.Util_matrix.identity(m);

        if (this.needLocalTransform) {
            if (
                isNotAroundZero(this.scale[0])
                || isNotAroundZero(this.scale[1])
            ) {
                origin[0] = -this.scale[2] || 0;
                origin[1] = -this.scale[3] || 0;
                let haveOrigin = isNotAroundZero(origin[0])
                    || isNotAroundZero(origin[1]);
                if (haveOrigin) {
                    SUtil_SUtil.Util_matrix.translate(
                        m, m, origin
                    );
                }
                SUtil_SUtil.Util_matrix.scale(m, m, this.scale);
                if (haveOrigin) {
                    origin[0] = -origin[0];
                    origin[1] = -origin[1];
                    SUtil_SUtil.Util_matrix.translate(
                        m, m, origin
                    );
                }
            }

            if (this.rotation instanceof Array) {
                if (this.rotation[0] !== 0) {
                    origin[0] = -this.rotation[1] || 0;
                    origin[1] = -this.rotation[2] || 0;
                    let haveOrigin = isNotAroundZero(origin[0])
                        || isNotAroundZero(origin[1]);
                    if (haveOrigin) {
                        SUtil_SUtil.Util_matrix.translate(
                            m, m, origin
                        );
                    }
                    SUtil_SUtil.Util_matrix.rotate(m, m, this.rotation[0]);
                    if (haveOrigin) {
                        origin[0] = -origin[0];
                        origin[1] = -origin[1];
                        SUtil_SUtil.Util_matrix.translate(
                            m, m, origin
                        );
                    }
                }
            } else {
                if (+this.rotation !== 0) {
                    SUtil_SUtil.Util_matrix.rotate(m, m, this.rotation);
                }
            }

            if (
                isNotAroundZero(this.position[0]) || isNotAroundZero(this.position[1])
            ) {
                SUtil_SUtil.Util_matrix.translate(m, m, this.position);
            }
        }

        // 保存这个变换矩阵
        this.transform = m;

        // 应用父节点变换
        if (this.parent && this.parent.needTransform) {
            if (this.needLocalTransform) {
                SUtil_SUtil.Util_matrix.mul(this.transform, this.parent.transform, this.transform);
            } else {
                SUtil_SUtil.Util_matrix.copy(this.transform, this.parent.transform);
            }
        }

        function isNotAroundZero(val) {
            var EPSILON = 5e-5;
            return val > EPSILON || val < -EPSILON;
        }
    }


    /**
     * @function LevelRenderer.Transformable.prototype.setTransform
     * @description 将自己的 transform 应用到 context 上。
     *
     * @param {Context2D} ctx - Context2D 上下文。
     */
    setTransform(ctx) {
        if (this.needTransform) {
            var m = this.transform;
            ctx.transform(
                m[0], m[1],
                m[2], m[3],
                m[4], m[5]
            );
        }
    }



    /**
     * @function LevelRenderer.Transformable.prototype.decomposeTransform
     * @description 分解`transform`矩阵到`position`, `rotation`, `scale` 。
     */
    decomposeTransform() {
        if (!this.transform) {
            return;
        }
        var m = this.transform;
        var sx = m[0] * m[0] + m[1] * m[1];
        var position = this.position;
        var scale = this.scale;
        var rotation = this.rotation;
        if (isNotAroundZero(sx - 1)) {
            sx = Math.sqrt(sx);
        }
        var sy = m[2] * m[2] + m[3] * m[3];
        if (isNotAroundZero(sy - 1)) {
            sy = Math.sqrt(sy);
        }
        position[0] = m[4];
        position[1] = m[5];
        scale[0] = sx;
        scale[1] = sy;
        scale[2] = scale[3] = 0;
        rotation[0] = Math.atan2(-m[1] / sy, m[0] / sx);
        rotation[1] = rotation[2] = 0;

        function isNotAroundZero(val) {
            var EPSILON = 5e-5;
            return val > EPSILON || val < -EPSILON;
        }
    }

}

;// CONCATENATED MODULE: ./src/common/overlay/levelRenderer/Group.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/





/**
 * @class  LevelRenderer.Group
 * @category Visualization Theme
 * @private
 * @classdesc Group 是一个容器，可以插入子节点，Group 的变换也会被应用到子节点上。
 * @extends {LevelRenderer.Transformable}
 * (code)
 *     var g = new LevelRenderer.Group();
 *     var Circle = new LevelRenderer.Shape.Circle();
 *     g.position[0] = 100;
 *     g.position[1] = 100;
 *     g.addChild(new Circle({
 *         style: {
 *             x: 100,
 *             y: 100,
 *             r: 20,
 *             brushType: 'fill'
 *         }
 *     }));
 *     LR.addGroup(g);
 * (end)
 * @param {Array} options - Group 的配置（options）项，可以是 Group 的自有属性，也可以是自定义的属性。
 */

class Group extends mixinExt(Eventful, Transformable) {
    constructor(options) {
        super(options)
        options = options || {};
        /**
         * @member {string} LevelRenderer.Group.prototype.id
         * @description Group 的唯一标识。
         */
        this.id = null;

        /**
         * @readonly
         * @member {string} [LevelRenderer.Group.prototype.type='group']
         * @description 类型。
         */
        this.type = 'group';

        //http://www.w3.org/TR/2dcontext/#clipping-region
        /**
         * @member {string} LevelRenderer.Group.prototype.clipShape
         * @description 用于裁剪的图形(shape)，所有 Group 内的图形在绘制时都会被这个图形裁剪，该图形会继承 Group 的变换。
         */
        this.clipShape = null;

        /**
         * @member {Array} LevelRenderer.Group.prototype._children
         * @description _children。
         */
        this._children = [];

        /**
         * @member {Array} LevelRenderer.Group.prototype._storage
         * @description _storage。
         */
        this._storage = null;

        /**
         * @member {boolean} [LevelRenderer.Group.prototype.__dirty=true]
         * @description __dirty。
         */
        this.__dirty = true;

        /**
         * @member {boolean} [LevelRenderer.Group.prototype.ignore=false]
         * @description 是否忽略该 Group 及其所有子节点。
         */
        this.ignore = false;
        Util_Util.extend(this, options);
        this.id = this.id || Util_Util.createUniqueID("smShapeGroup_");
        this.CLASS_NAME = "SuperMap.LevelRenderer.Group";
    }


    /**
     * @function LevelRenderer.Group.prototype.destroy
     * @description 销毁对象，释放资源。调用此函数后所有属性将被置为 null。
     */
    destroy() {
        this.id = null;
        this.type = null;
        this.clipShape = null;
        this._children = null;
        this._storage = null;
        this.__dirty = null;
        this.ignore = null;

        super.destroy();
    }


    /**
     * @function LevelRenderer.Group.prototype.children
     * @description 复制并返回一份新的包含所有儿子节点的数组。
     * @returns {Array.<LevelRenderer.Shape>} 图形数组。
     */
    children() {
        return this._children.slice();
    }


    /**
     * @function LevelRenderer.Group.prototype.childAt
     * @description 获取指定 index 的儿子节点
     * @param {number} idx - 节点索引。
     * @returns {LevelRenderer.Shape} 图形。
     */
    childAt(idx) {
        return this._children[idx];
    }


    /**
     * @function LevelRenderer.Group.prototype.addChild
     * @description 添加子节点，可以是 Shape 或者 Group。
     * @param {(LevelRenderer.Shape|LevelRenderer.Group)} child - 节点图形。
     */
    // TODO Type Check
    addChild(child) {
        if (child == this) {
            return;
        }

        if (child.parent == this) {
            return;
        }
        if (child.parent) {
            child.parent.removeChild(child);
        }

        this._children.push(child);
        child.parent = this;

        if (this._storage && this._storage !== child._storage) {

            this._storage.addToMap(child);

            if (child instanceof Group) {
                child.addChildrenToStorage(this._storage);
            }
        }
    }


    /**
     * @function LevelRenderer.Group.prototype.removeChild
     * @description 移除子节点。
     * @param {LevelRenderer.Shape} child - 需要移除的子节点图形。
     */
    removeChild(child) {
        var idx = Util_Util.indexOf(this._children, child);

        this._children.splice(idx, 1);
        child.parent = null;

        if (this._storage) {

            this._storage.delFromMap(child.id);

            if (child instanceof Group) {
                child.delChildrenFromStorage(this._storage);
            }
        }
    }


    /**
     * @function LevelRenderer.Group.prototype.eachChild
     * @description 遍历所有子节点。
     * @param {function} cb - 回调函数。
     * @param {Object} context - 上下文。
     */
    eachChild(cb, context) {
        var haveContext = !!context;
        for (var i = 0; i < this._children.length; i++) {
            var child = this._children[i];
            if (haveContext) {
                cb.call(context, child);
            } else {
                cb(child);
            }
        }
    }


    /**
     * @function LevelRenderer.Group.prototype.traverse
     * @description 深度优先遍历所有子孙节点。
     * @param {function} cb - 回调函数。
     * @param {Object} context - 上下文。
     */
    traverse(cb, context) {
        var haveContext = !!context;
        for (var i = 0; i < this._children.length; i++) {
            var child = this._children[i];
            if (haveContext) {
                cb.call(context, child);
            } else {
                cb(child);
            }

            if (child.type === 'group') {
                child.traverse(cb, context);
            }
        }
    }


    /**
     * @function LevelRenderer.Group.prototype.addChildrenToStorage
     * @description 把子图形添加到仓库。
     * @param {LevelRenderer.Storage} storage - 图形仓库。
     */
    addChildrenToStorage(storage) {
        for (var i = 0; i < this._children.length; i++) {
            var child = this._children[i];
            storage.addToMap(child);
            if (child.type === 'group') {
                child.addChildrenToStorage(storage);
            }
        }
    }


    /**
     * @function LevelRenderer.Group.prototype.delChildrenFromStorage
     * @description 从仓库把子图形删除。
     * @param {LevelRenderer.Storage} storage - 图形仓库。
     */
    delChildrenFromStorage(storage) {
        for (var i = 0; i < this._children.length; i++) {
            var child = this._children[i];
            storage.delFromMap(child.id);
            if (child.type === 'group') {
                child.delChildrenFromStorage(storage);
            }
        }
    }


    /**
     * @function LevelRenderer.Group.prototype.modSelf
     * @description 是否修改。
     */
    modSelf() {
        this.__dirty = true;
    }

}

;// CONCATENATED MODULE: ./src/common/overlay/levelRenderer/Storage.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/



/**
 * @private
 * @class  LevelRenderer.Storage
 * @category Visualization Theme
 * @classdesc 内容（图像）仓库 (M) 。
 */
class Storage {
    constructor() {
        /**
         * @member {Object} LevelRenderer.Storage.prototype._elements
         * @description 所有常规形状，id 索引的 map。
         */
        this._elements = {};

        /**
         * @member {Array} LevelRenderer.Storage.prototype._hoverElements
         * @description 高亮层形状，不稳定，动态增删，数组位置也是 z 轴方向，靠前显示在下方。
         *
         */
        this._hoverElements = [];

        /**
         * @member {Array} LevelRenderer.Storage.prototype._roots
         * @description _roots。
         *
         */
        this._roots = [];

        /**
         * @member {Array} LevelRenderer.Storage.prototype._shapeList
         * @description _shapeList。
         *
         */
        this._shapeList = [];

        /**
         * @member {number} LevelRenderer.Storage.prototype._shapeListOffset
         * @description _shapeListOffset。默认值：0。
         *
         */
        this._shapeListOffset = 0;

        this.CLASS_NAME = "SuperMap.LevelRenderer.Storage";
    }

    /**
     * @function LevelRenderer.Storage.prototype.destroy
     * @description 销毁对象，释放资源。调用此函数后所有属性将被置为 null。
     */
    destroy() {
        this.dispose();
        this._shapeList = null;
        this._shapeListOffset = null;
    }

    /**
     * @function LevelRenderer.Storage.prototype.iterShape
     * @description 遍历迭代器。
     *
     * @param {function} fun - 迭代回调函数，return true终止迭代。
     * @param {Object} option - 迭代参数，缺省为仅降序遍历普通层图形。
     * @param {boolean} [hover=true] - 是否是高亮层图形。
     * @param {string} [normal='down'] - 是否是普通层图形，迭代时是否指定及z轴顺序。可设值：'down' ，'up'。
     * @param {boolean} [update=false] - 是否在迭代前更新形状列表。
     * @return {LevelRenderer.Storage} this。
     */
    iterShape(fun, option) {
        if (!option) {
            var defaultIterateOption = {
                hover: false,
                normal: 'down',
                update: false
            };
            option = defaultIterateOption;
        }

        if (option.hover) {
            // 高亮层数据遍历
            for (var i = 0, l = this._hoverElements.length; i < l; i++) {
                var el = this._hoverElements[i];
                el.updateTransform();
                if (fun(el)) {
                    return this;
                }
            }
        }

        if (option.update) {
            this.updateShapeList();
        }

        // 遍历: 'down' | 'up'
        switch (option.normal) {
            case 'down':
            {
                // 降序遍历，高层优先
                let l = this._shapeList.length;
                while (l--) {
                    if (fun(this._shapeList[l])) {
                        return this;
                    }
                }
                break;
            }
            // case 'up':
            default:
            {
                // 升序遍历，底层优先
                for (let i = 0, l = this._shapeList.length; i < l; i++) {
                    if (fun(this._shapeList[i])) {
                        return this;
                    }
                }
                break;
            }
        }

        return this;
    }

    /**
     * @function LevelRenderer.Storage.prototype.getHoverShapes
     * @param {boolean} [update=false] - 是否在返回前更新图形的变换。
     * @return {Array.<LevelRenderer.Shape>} 图形数组。
     */
    getHoverShapes(update) {
        // hoverConnect
        var hoverElements = [], len = this._hoverElements.length;
        for (let i = 0; i < len; i++) {
            hoverElements.push(this._hoverElements[i]);
            var target = this._hoverElements[i].hoverConnect;
            if (target) {
                var shape;
                target = target instanceof Array ? target : [target];
                for (var j = 0, k = target.length; j < k; j++) {
                    shape = target[j].id ? target[j] : this.get(target[j]);
                    if (shape) {
                        hoverElements.push(shape);
                    }
                }
            }
        }
        hoverElements.sort(Storage.shapeCompareFunc);
        if (update) {
            for (let i = 0, l = hoverElements.length; i < l; i++) {
                hoverElements[i].updateTransform();
            }
        }
        return hoverElements;
    }

    /**
     * @function LevelRenderer.Storage.prototype.getShapeList
     * @description 返回所有图形的绘制队列。
     *
     * @param {boolean} [update=false] - 是否在返回前更新该数组。详见：<LevelRenderer.Shape> updateShapeList。
     * @return {LevelRenderer.Shape} 图形。
     */
    getShapeList(update) {
        if (update) {
            this.updateShapeList();
        }
        return this._shapeList;
    }

    /**
     * @function LevelRenderer.Storage.prototype.updateShapeList
     * @description 更新图形的绘制队列。每次绘制前都会调用，该方法会先深度优先遍历整个树，更新所有Group和Shape的变换并且把所有可见的Shape保存到数组中，最后根据绘制的优先级（zlevel > z > 插入顺序）排序得到绘制队列。
     */
    updateShapeList() {
        this._shapeListOffset = 0;
        var rootsLen = this._roots.length;
        for (let i = 0; i < rootsLen; i++) {
            let root = this._roots[i];
            this._updateAndAddShape(root);
        }
        this._shapeList.length = this._shapeListOffset;

        var shapeListLen = this._shapeList.length;
        for (let i = 0; i < shapeListLen; i++) {
            this._shapeList[i].__renderidx = i;
        }

        this._shapeList.sort(Storage.shapeCompareFunc);
    }

    /**
     * @function LevelRenderer.Storage.prototype._updateAndAddShape
     * @description 更新并添加图形。
     *
     */
    _updateAndAddShape(el, clipShapes) {
        if (el.ignore) {
            return;
        }

        el.updateTransform();

        if (el.type == 'group') {

            if (el.clipShape) {
                // clipShape 的变换是基于 group 的变换
                el.clipShape.parent = el;
                el.clipShape.updateTransform();

                // PENDING 效率影响
                if (clipShapes) {
                    clipShapes = clipShapes.slice();
                    clipShapes.push(el.clipShape);
                } else {
                    clipShapes = [el.clipShape];
                }
            }

            for (var i = 0; i < el._children.length; i++) {
                var child = el._children[i];

                // Force to mark as dirty if group is dirty
                child.__dirty = el.__dirty || child.__dirty;

                this._updateAndAddShape(child, clipShapes);
            }

            // Mark group clean here
            el.__dirty = false;

        } else {
            el.__clipShapes = clipShapes;

            this._shapeList[this._shapeListOffset++] = el;
        }
    }

    /**
     * @function LevelRenderer.Storage.prototype.mod
     * @description 修改图形(Shape)或者组(Group)。
     *
     * @param {string} elId - 唯一标识。
     * @param {Object} params - 参数。
     * @return {LevelRenderer.Storage} this。
     */
    mod(elId, params) {
        var el = this._elements[elId];
        if (el) {

            el.modSelf();

            if (params) {
                // 如果第二个参数直接使用 shape
                // parent, _storage, __startClip 三个属性会有循环引用
                // 主要为了向 1.x 版本兼容，2.x 版本不建议使用第二个参数
                if (params.parent || params._storage || params.__startClip) {
                    var target = {};
                    for (var name in params) {
                        if (
                            name == 'parent'
                            || name == '_storage'
                            || name == '__startClip'
                        ) {
                            continue;
                        }
                        if (params.hasOwnProperty(name)) {
                            target[name] = params[name];
                        }
                    }
                    new levelRenderer_Util_Util().merge(el, target, true);
                } else {
                    new levelRenderer_Util_Util().merge(el, params, true);
                }
            }
        }

        return this;
    }

    /**
     * @function LevelRenderer.Storage.prototype.drift
     * @description 移动指定的图形(Shape)的位置。
     * @param {string} shapeId - 唯一标识。
     * @param {number} dx
     * @param {number} dy
     * @return {LevelRenderer.Storage} this。
     */
    drift(shapeId, dx, dy) {
        var shape = this._elements[shapeId];
        if (shape) {
            shape.needTransform = true;
            if (shape.draggable === 'horizontal') {
                dy = 0;
            } else if (shape.draggable === 'vertical') {
                dx = 0;
            }
            if (!shape.ondrift // ondrift
                // 有onbrush并且调用执行返回false或undefined则继续
                || (shape.ondrift && !shape.ondrift(dx, dy))
            ) {
                shape.drift(dx, dy);
            }
        }

        return this;
    }

    /**
     * @function LevelRenderer.Storage.prototype.addHover
     * @description 添加高亮层数据。
     * @param {LevelRenderer.Shape} shape - 图形。
     * @return {LevelRenderer.Storage} this。
     */
    addHover(shape) {
        shape.updateNeedTransform();
        this._hoverElements.push(shape);
        return this;
    }

    /**
     * @function LevelRenderer.Storage.prototype.delHover
     * @description 清空高亮层数据。
     * @return {LevelRenderer.Storage} this。
     */
    delHover() {
        this._hoverElements = [];
        return this;
    }

    /**
     * @function LevelRenderer.Storage.prototype.hasHoverShape
     * @description 是否有图形在高亮层里。
     * @return {boolean} 是否有图形在高亮层里。
     */
    hasHoverShape() {
        return this._hoverElements.length > 0;
    }

    /**
     * @function LevelRenderer.Storage.prototype.addRoot
     * @description 添加图形(Shape)或者组(Group)到根节点。
     *
     * @param {(LevelRenderer.Shape/LevelRenderer.Group)} el - 图形。
     *
     */
    addRoot(el) {
        if (el instanceof Group) {
            el.addChildrenToStorage(this);
        }

        this.addToMap(el);
        this._roots.push(el);
    }

    /**
     * @function LevelRenderer.Storage.prototype.delRoot
     * @description 删除指定的图形(Shape)或者组(Group)。
     *
     * @param {Array.<string>} elId - 删除图形(Shape)或者组(Group)的 ID 数组。如果为空清空整个Storage。
     *
     */
    delRoot(elId) {
        if (typeof(elId) == 'undefined') {
            // 不指定elId清空
            for (var i = 0; i < this._roots.length; i++) {
                var root = this._roots[i];

                if (root instanceof Group) {
                    root.delChildrenFromStorage(this);
                }
            }

            this._elements = {};
            this._hoverElements = [];
            this._roots = [];

            return;
        }

        if (elId instanceof Array) {
            var elIdLen = elId.length;
            for (let i = 0; i < elIdLen; i++) {
                this.delRoot(elId[i]);
            }
            return;
        }

        var el;
        if (typeof(elId) == 'string') {
            el = this._elements[elId];
        } else {
            el = elId;
        }

        var idx = new levelRenderer_Util_Util().indexOf(this._roots, el);
        if (idx >= 0) {
            this.delFromMap(el.id);
            this._roots.splice(idx, 1);
            if (el instanceof Group) {
                el.delChildrenFromStorage(this);
            }
        }
    }

    /**
     * @function LevelRenderer.Storage.prototype.addToMap
     * @description 添加图形到 map。
     *
     * @param {LevelRenderer.Shape} el - 图形。
     * @return {LevelRenderer.Storage} this。
     */
    addToMap(el) {
        if (el instanceof Group) {
            el._storage = this;
        }
        el.modSelf();

        this._elements[el.id] = el;

        return this;
    }

    /**
     * @function LevelRenderer.Storage.prototype.get
     * @description 获取指定图形。
     *
     * @param {string} elId - 图形 id。
     * @return {LevelRenderer.Shape} 图形。
     */
    get(elId) {
        return this._elements[elId];
    }

    /**
     * @function LevelRenderer.Storage.prototype.delFromMap
     * @description 从 map 中删除指定图形。
     *
     * @param {string} elId - 图形id。
     * @return {LevelRenderer.Storage} this。
     */
    delFromMap(elId) {
        var el = this._elements[elId];
        if (el) {
            delete this._elements[elId];

            if (el instanceof Group) {
                el._storage = null;
            }
        }

        return this;
    }

    /**
     * @function LevelRenderer.Storage.prototype.dispose
     * @description 清空并且释放 Storage。
     */
    dispose() {
        this._elements = null;
        // this._renderList = null;
        this._roots = null;
        this._hoverElements = null;
    }

    static shapeCompareFunc(a, b) {
        if (a.zlevel == b.zlevel) {
            if (a.z == b.z) {
                return a.__renderidx - b.__renderidx;
            }
            return a.z - b.z;
        }
        return a.zlevel - b.zlevel;
    }

}

;// CONCATENATED MODULE: ./src/common/commontypes/geometry/Rectangle.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/



/**
 * @class  GeometryRectangle
 * @aliasclass Geometry.Rectangle
 * @deprecatedclass SuperMap.Geometry.Rectangle
 * @classdesc 矩形几何对象类。
 * @category BaseTypes Geometry
 * @param {number} x - 矩形左下角点的横坐标。
 * @param {number} y - 矩形左下角点的纵坐标。
 * @param {number} width - 矩形的宽度。
 * @param {number} height -  矩形的高度。
 * @extends {Geometry}
 * @example
 *  //x 为矩形左下角点的横坐标；y 为矩形左下角点的纵坐标；w 为矩形的宽度；h 为矩形的高度
 *  var x = 1;
 *  var y = 2;
 *  var w = 10;
 *  var h = 20;
 *  var recttangle = new GeometryRectangle(x, y, w, h);
 * @usage
 */

class Rectangle extends Geometry_Geometry {


    constructor(x, y, width, height) {
        super(x, y, width, height);
        /**
         * @member {number} GeometryRectangle.prototype.x
         * @description 矩形左下角点的横坐标。
         */
        this.x = x;

        /**
         * @member {number} GeometryRectangle.prototype.y
         * @description 矩形左下角点的纵坐标。
         */
        this.y = y;

        /**
         * @member {number} GeometryRectangle.prototype.width
         * @description 矩形的宽度。
         */
        this.width = width;

        /**
         * @member {number} GeometryRectangle.prototype.height
         * @description 矩形的高度。
         */
        this.height = height;

        this.CLASS_NAME = "SuperMap.Geometry.Rectangle";
        this.geometryType = "Rectangle";
    }

    /**
     * @function GeometryRectangle.prototype.calculateBounds
     * @description 计算出此矩形对象的 bounds。
     */
    calculateBounds() {
        this.bounds = new Bounds(this.x, this.y,
            this.x + this.width,
            this.y + this.height);
    }


    /**
     * @function GeometryRectangle.prototype.getArea
     * @description 获取矩形对象的面积。
     * @returns {number} 矩形对象面积。
     */
    getArea() {
        var area = this.width * this.height;
        return area;
    }


}

;// CONCATENATED MODULE: ./src/common/commontypes/geometry/index.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/























;// CONCATENATED MODULE: ./src/common/commontypes/Credential.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/

/**
 * @class Credential
 * @deprecatedclass SuperMap.Credential
 * @category Security
 * @classdesc SuperMap 的安全证书类，其中包括 token 等安全验证信息。</br>
 * 需要使用用户名和密码在："http://localhost:8090/iserver/services/security/tokens" 下申请 value。</br>
 * 获得形如："2OMwGmcNlrP2ixqv1Mk4BuQMybOGfLOrljruX6VcYMDQKc58Sl9nMHsqQaqeBx44jRvKSjkmpZKK1L596y7skQ.." 的 value。</br>
 * 目前支持的功能包括：地图服务、专题图、量算、查询、公交换乘、空间分析、网络分析，不支持轮询功能。</br>
 * @param {string} value - 访问受安全限制的服务时用于通过安全认证的验证信息。
 * @param {string} [name='token'] - 验证信息前缀，name=value 部分的 name 部分。
 * @example
 * var pixcel = new Credential("valueString","token");
 * pixcel.destroy();
 * @usage
 */
class Credential {

    constructor(value, name) {

        /**
         * @member {string} Credential.prototype.value
         * @description 访问受安全限制的服务时用于通过安全认证的验证信息。
         */
        this.value = value ? value : "";

        /**
         * @member {string} [Credential.prototype.name='token']
         * @description 验证信息前缀，name=value 部分的 name 部分。
         */
        this.name = name ? name : "token";
        this.CLASS_NAME = "SuperMap.Credential";
    }

    /**
     * @function Credential.prototype.getUrlParameters
     * @description 获取 name=value 的表达式。
     * @example
     * var credential = new Credential("valueString","token");
     * //这里 str = "token=valueString";
     * var str = credential.getUrlParameters();
     * @returns {string} 安全信息组成的 url 片段。
     */
    getUrlParameters() {
        //当需要其他安全信息的时候，则需要return this.name + "=" + this.value + "&" + "...";的形式添加。
        return this.name + "=" + this.value;
    }


    /**
     * @function Credential.prototype.getValue
     * @description 获取 value。
     * @example
     * var credential = new Credential("2OMwGmcNlrP2ixqv1Mk4BuQMybOGfLOrljruX6VcYMDQKc58Sl9nMHsqQaqeBx44jRvKSjkmpZKK1L596y7skQ..","token");
     * //这里 str = "2OMwGmcNlrP2ixqv1Mk4BuQMybOGfLOrljruX6VcYMDQKc58Sl9nMHsqQaqeBx44jRvKSjkmpZKK1L596y7skQ..";
     * var str = credential.getValue();
     * @returns {string} value 字符串，在 iServer 服务下该 value 值即为 token 值。
     */
    getValue() {
        return this.value;
    }

    /**
     *
     * @function Credential.prototype.destroy
     * @description 销毁此对象。销毁后此对象的所有属性为 null，而不是初始值。
     * @example
     * var credential = new Credential("valueString","token");
     * credential.destroy();
     */
    destroy() {
        this.value = null;
        this.name = null;
    }

}

/**
 * @member {Credential} Credential.CREDENTIAL
 * @description 这个对象保存一个安全类的实例，在服务端需要安全验证的时候必须进行设置。
 * @example
 * 代码实例:
 *  // 当iServer启用服务安全的时候，下边的代码是必须的。安全证书类能够接收一个value和一个name参数。
 *  var value = "(以iServer为例，这里是申请的token值)";
 *  var name = "token";
 *  // 默认name参数为token，所以当使用iServer服务的时候可以不进行设置。
 *  Credential.CREDENTIAL = new Credential(value, name);
 *
 */

 Credential.CREDENTIAL = null;

;// CONCATENATED MODULE: ./src/common/commontypes/Date.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/
/**
 * @name Date
 * @namespace
 * @category BaseTypes Util
 * @description 包含 parse、toISOString 方法的实现，两个方法用来解析 RFC 3339 日期，遵循 ECMAScript 5 规范。
 * @private
 */
var DateExt = {

    /**
     * @description 生成代表一个具体的日期字符串，该日期遵循 ISO 8601 标准（详情查看{@link http://tools.ietf.org/html/rfc3339}）。
     * @example
     *  var dateString = DateExt.toISOString(new Date());
     * @param {Date} date - 日期对象。
     * @returns {string} 一个代表日期的字符串。（例如 "2010-08-07T16:58:23.123Z"）。
     */
    toISOString: (function () {
        //标准的Date会存在toISOString方法，可以直接调用
        if ("toISOString" in Date.prototype) {
            return function (date) {
                return date.toISOString();
            };
        } else {// 部分浏览器没有，就得自己组合，组合后的字符串规则不变
            function pad(num, len) {
                var str = num + "";
                while (str.length < len) {
                    str = "0" + str;
                }
                return str;
            }

            return function (date) {
                var str;
                if (isNaN(date.getTime())) {
                    // ECMA-262 says throw RangeError, Firefox returns
                    // "Invalid Date"
                    str = "Invalid Date";
                } else {
                    str =
                        date.getUTCFullYear() + "-" +
                        pad(date.getUTCMonth() + 1, 2) + "-" +
                        pad(date.getUTCDate(), 2) + "T" +
                        pad(date.getUTCHours(), 2) + ":" +
                        pad(date.getUTCMinutes(), 2) + ":" +
                        pad(date.getUTCSeconds(), 2) + "." +
                        pad(date.getUTCMilliseconds(), 3) + "Z";
                }
                return str;
            };
        }

    })(),

    /**
     * @description 从一个字符串生成一个日期对象。
     * @example
     *  var date = DateExt.parse("2010-08-07");
     * @param {string} str - 日期的字符串。（例如： "2010", "2010-08", "2010-08-07", "2010-08-07T16:58:23.123Z","2010-08-07T11:58:23.123-06"）。
     * @returns {Date} 日期对象，如果字符串无法被解析，则返回一个无效的日期。(例如 isNaN(date.getTime()))。
     */
    parse: function (str) {
        var date;
        var match = str.match(/^(?:(\d{4})(?:-(\d{2})(?:-(\d{2}))?)?)?(?:(?:T(\d{1,2}):(\d{2}):(\d{2}(?:\.\d+)?)(Z|(?:[+-]\d{1,2}(?::(\d{2}))?)))|Z)?$/);
        if (match && (match[1] || match[7])) { // must have at least year or time
            var year = parseInt(match[1], 10) || 0;
            var month = (parseInt(match[2], 10) - 1) || 0;
            var day = parseInt(match[3], 10) || 1;
            date = new Date(Date.UTC(year, month, day));
            // optional time
            var type = match[7];
            if (type) {
                var hours = parseInt(match[4], 10);
                var minutes = parseInt(match[5], 10);
                var secFrac = parseFloat(match[6]);
                var seconds = secFrac | 0;
                var milliseconds = Math.round(1000 * (secFrac - seconds));
                date.setUTCHours(hours, minutes, seconds, milliseconds);
                // check offset
                if (type !== "Z") {
                    var hoursOffset = parseInt(type, 10);
                    var minutesOffset = parseInt(match[8], 10) || 0;
                    var offset = -1000 * (60 * (hoursOffset * 60) + minutesOffset * 60);
                    date = new Date(date.getTime() + offset);
                }
            }
        } else {
            date = new Date("invalid");
        }
        return date;
    }
};

;// CONCATENATED MODULE: ./src/common/commontypes/Event.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/
 

 /**
  * @name Event
  * @namespace
  * @category BaseTypes Events
  * @description 事件处理函数.
  * @usage
  * ```
  * // 浏览器
  * <script type="text/javascript" src="{cdn}"></script>
  * <script>
  *   const element = {namespace}.Event.element();
  *
  *   // 弃用的写法
  *   const result = SuperMap.Event.element();
  *
  * </script>
  *
  * // ES6 Import
  * import { Event } from '{npm}';
  * 
  * const result = Event.element();
  * ```
  */
 var Event_Event = {

     /**
      * @description  事件观察者列表。
      * @type {Object}
      * @default false
      */
     observers: false,

     /**
      * @description KEY_SPACE
      * @type {number}
      * @default 32
      */
     KEY_SPACE: 32,

     /**
      * @description KEY_BACKSPACE
      * @type {number}
      * @default 8
      */
     KEY_BACKSPACE: 8,

     /**
      * @description KEY_TAB
      * @type {number}
      * @default 9
      */
     KEY_TAB: 9,

     /**
      * @description KEY_RETURN
      * @type {number}
      * @default 13
      */
     KEY_RETURN: 13,

     /**
      * @description KEY_ESC
      * @type {number}
      * @default 27
      */
     KEY_ESC: 27,

     /**
      * @description KEY_LEFT
      * @type {number}
      * @default 37
      */
     KEY_LEFT: 37,

     /**
      * @description KEY_UP
      * @type {number}
      * @default 38
      */
     KEY_UP: 38,

     /**
      * @description KEY_RIGHT
      * @type {number}
      * @default 39
      */
     KEY_RIGHT: 39,

     /**
      * @description KEY_DOWN
      * @type {number}
      * @default 40
      */
     KEY_DOWN: 40,

     /**
      * @description KEY_DELETE
      * @type {number}
      * @default 46
      */
     KEY_DELETE: 46,


     /**
      * @description 监听浏览器 DOM 事件。
      * @param {Event} event - Event 对象。
      * @returns {HTMLElement} 触发事件的 DOM 元素。
      */
     element: function (event) {
         return event.target || event.srcElement;
     },

     /**
      * @description 判断事件是否由单次触摸引起。
      * @param {Event} event - Event 对象。
      * @returns {boolean} 是否有且只有一个当前在与触摸表面接触的 Touch 对象。
      */
     isSingleTouch: function (event) {
         return event.touches && event.touches.length === 1;
     },

     /**
      * @description 判断事件是否由多点触控引起。
      * @param {Event} event - Event 对象。
      * @returns {boolean} 是否存在多个当前在与触摸表面接触的 Touch 对象。
      */
     isMultiTouch: function (event) {
         return event.touches && event.touches.length > 1;
     },

     /**
      * @description 确定事件是否由左键单击引起。
      * @param {Event} event - Event 对象。
      * @returns {boolean} 是否点击鼠标左键。
      */
     isLeftClick: function (event) {
         return (((event.which) && (event.which === 1)) ||
             ((event.button) && (event.button === 1)));
     },

     /**
      * @description 确定事件是否由鼠标右键单击引起。
      * @param {Event} event - Event 对象。
      * @returns {boolean} 是否点击鼠标右键。
      */
     isRightClick: function (event) {
         return (((event.which) && (event.which === 3)) ||
             ((event.button) && (event.button === 2)));
     },

     /**
      * @description 阻止事件冒泡。
      * @param {Event} event - Event 对象。
      * @param {boolean} allowDefault - 默认为 false，表示阻止事件的默认行为。
      */
     stop: function (event, allowDefault) {

         if (!allowDefault) {
             if (event.preventDefault) {
                 event.preventDefault();
             } else {
                 event.returnValue = false;
             }
         }

         if (event.stopPropagation) {
             event.stopPropagation();
         } else {
             event.cancelBubble = true;
         }
     },

     /**
      * @description 查询触发指定事件的 DOM 元素。
      * @param {Event} event - Event 对象。
      * @param {string} tagName - html 标签名。
      * @returns {HTMLElement} DOM 元素。
      */
     findElement: function (event, tagName) {
         var element = Event_Event.element(event);
         while (element.parentNode && (!element.tagName ||
             (element.tagName.toUpperCase() != tagName.toUpperCase()))) {
             element = element.parentNode;
         }
         return element;
     },

     /**
      * @description 监听事件，注册事件处理方法。
      * @param {(HTMLElement|string)} elementParam - 待监听的 DOM 对象或者其 ID 标识。
      * @param {string} name - 监听事件的类别名称。
      * @param {function} observer - 注册的事件处理方法。
      * @param {boolean} [useCapture=false] - 是否捕获。
      */
     observe: function (elementParam, name, observer, useCapture) {
         var element = Util_Util.getElement(elementParam);
         useCapture = useCapture || false;

         if (name === 'keypress' &&
             (navigator.appVersion.match(/Konqueror|Safari|KHTML/)
                 || element.attachEvent)) {
             name = 'keydown';
         }

         //if observers cache has not yet been created, create it
         if (!this.observers) {
             this.observers = {};
         }

         //if not already assigned, make a new unique cache ID
         if (!element._eventCacheID) {
             var idPrefix = "eventCacheID_";
             if (element.id) {
                 idPrefix = element.id + "_" + idPrefix;
             }
             element._eventCacheID = Util_Util.createUniqueID(idPrefix);
         }

         var cacheID = element._eventCacheID;

         //if there is not yet a hash entry for this element, add one
         if (!this.observers[cacheID]) {
             this.observers[cacheID] = [];
         }

         //add a new observer to this element's list
         this.observers[cacheID].push({
             'element': element,
             'name': name,
             'observer': observer,
             'useCapture': useCapture
         });

         //add the actual browser event listener
         if (element.addEventListener) {
             if(name === 'mousewheel'){
                 // https://www.chromestatus.com/features/6662647093133312
                 element.addEventListener(name, observer, {useCapture: useCapture, passive: false} );
             } else {
                 element.addEventListener(name, observer, useCapture);
             }
         } else if (element.attachEvent) {
             element.attachEvent('on' + name, observer);
         }
     },

     /**
      * @description 移除给定 DOM 元素的监听事件。
      * @param {(HTMLElement|string)} elementParam - 待监听的 DOM 对象或者其 ID 标识。
      */
     stopObservingElement: function (elementParam) {
         var element = Util_Util.getElement(elementParam);
         var cacheID = element._eventCacheID;
         this._removeElementObservers(Event_Event.observers[cacheID]);
     },
     _removeElementObservers: function (elementObservers) {
         if (elementObservers) {
             for (var i = elementObservers.length - 1; i >= 0; i--) {
                 var entry = elementObservers[i];
                 var args = new Array(entry.element, entry.name, entry.observer, entry.useCapture);
                 Event_Event.stopObserving.apply(this, args);
             }
         }
     },

     /**
      * @description 移除事件监听和注册的事件处理方法。注意：事件的移除和监听相对应，移除时的各属性信息必须监听时保持一致才能确保事件移除成功。
      * @param {(HTMLElement|string)} elementParam - 被监听的 DOM 元素或者其 ID。
      * @param {string} name - 需要移除的被监听事件名称。
      * @param {function} observer - 需要移除的事件处理方法。
      * @param {boolean} [useCapture=false] - 是否捕获。
      * @returns {boolean} 监听事件是否被移除。
      */
     stopObserving: function (elementParam, name, observer, useCapture) {
         useCapture = useCapture || false;

         var element = Util_Util.getElement(elementParam);
         var cacheID = element._eventCacheID;

         if (name === 'keypress') {
             if (navigator.appVersion.match(/Konqueror|Safari|KHTML/) ||
                 element.detachEvent) {
                 name = 'keydown';
             }
         }

         // find element's entry in this.observers cache and remove it
         var foundEntry = false;
         var elementObservers = Event_Event.observers[cacheID];
         if (elementObservers) {

             // find the specific event type in the element's list
             var i = 0;
             while (!foundEntry && i < elementObservers.length) {
                 var cacheEntry = elementObservers[i];

                 if ((cacheEntry.name === name) &&
                     (cacheEntry.observer === observer) &&
                     (cacheEntry.useCapture === useCapture)) {

                     elementObservers.splice(i, 1);
                     if (elementObservers.length == 0) {
                         delete Event_Event.observers[cacheID];
                     }
                     foundEntry = true;
                     break;
                 }
                 i++;
             }
         }

         //actually remove the event listener from browser
         if (foundEntry) {
             if (element.removeEventListener) {
                 element.removeEventListener(name, observer, useCapture);
             } else if (element && element.detachEvent) {
                 element.detachEvent('on' + name, observer);
             }
         }
         return foundEntry;
     },

     /**
      * @description 移除缓存中的监听事件。
      */
     unloadCache: function () {
         // check for Event before checking for observers, because
         // Event may be undefined in IE if no map instance was
         // created
         if (Event_Event && Event_Event.observers) {
             for (var cacheID in Event_Event.observers) {
                 var elementObservers = Event_Event.observers[cacheID];
                 Event_Event._removeElementObservers.apply(this,
                     [elementObservers]);
             }
             Event_Event.observers = false;
         }
     },

     CLASS_NAME: "SuperMap.Event"
 };
 /* prevent memory leaks in IE */
 Event_Event.observe(window, 'resize', Event_Event.unloadCache, false);

;// CONCATENATED MODULE: ./src/common/commontypes/Events.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/





/**
 * @class Events
 * @deprecatedclass SuperMap.Events
 * @classdesc 事件类。
 * @category BaseTypes Events
 * @param {Object} object - 当前事件对象被添加到的 JS 对象。
 * @param {HTMLElement} element - 响应浏览器事件的 DOM 元素。
 * @param {Array.<string>} eventTypes - 自定义应用事件的数组。
 * @param {boolean} [fallThrough=false] - 是否允许事件处理之后向上传递（冒泡），为 false 的时候阻止事件冒泡。
 * @param {Object} options - 事件对象选项。
 * @usage
 */
class Events {

    constructor(object, element, eventTypes, fallThrough, options) {
        /**
         * @member {Array.<string>} Events.prototype.BROWSER_EVENTS
         * @description 支持的事件。
         * @constant
         * @default [
         "mouseover", "mouseout","mousedown", "mouseup", "mousemove",
         "click", "dblclick", "rightclick", "dblrightclick","resize",
         "focus", "blur","touchstart", "touchmove", "touchend","keydown",
         "MSPointerDown", "MSPointerUp", "pointerdown", "pointerup",
         "MSGestureStart", "MSGestureChange", "MSGestureEnd","contextmenu"
         ]
         */
        this.BROWSER_EVENTS = [
            "mouseover", "mouseout",
            "mousedown", "mouseup", "mousemove",
            "click", "dblclick", "rightclick", "dblrightclick",
            "resize", "focus", "blur",
            "touchstart", "touchmove", "touchend",
            "keydown", "MSPointerDown", "MSPointerUp", "pointerdown", "pointerup",
            "MSGestureStart", "MSGestureChange", "MSGestureEnd",
            "contextmenu"
        ];

        /**
         * @member {Object} Events.prototype.listeners
         * @description 事件监听器函数。
         */
        this.listeners = {};

        /**
         * @member {Object} Events.prototype.object
         * @description  发布应用程序事件的对象。
         */
        this.object = object;

        /**
         * @member {HTMLElement} Events.prototype.element
         * @description 接受浏览器事件的 DOM 节点。
         */
        this.element = null;

        /**
         * @member {Array.<string>} Events.prototype.eventTypes
         * @description 支持的事件类型列表。
         */
        this.eventTypes = [];

        /**
         * @member {function} Events.prototype.eventHandler
         * @description 绑定在元素上的事件处理器对象。
         */
        this.eventHandler = null;

        /**
         * @member {boolean} [Events.prototype.fallThrough=false]
         * @description 是否允许事件处理之后向上传递（冒泡），为 false 的时候阻止事件冒泡。
         */
        this.fallThrough = fallThrough;

        /**
         * @member {boolean} [Events.prototype.includeXY=false]
         * @description 判断是否让 xy 属性自动创建到浏览器上的鼠标事件，一般设置为 false，如果设置为 true，鼠标事件将会在事件传递过程中自动产生 xy 属性。可根据事件对象的 'evt.object' 属性在相关的事件句柄上调用 getMousePosition 函数。这个选项习惯默认为 false 的原因在于，当创建一个事件对象，其主要目的是管理。在一个 div 的相对定位的鼠标事件，将其设为 true 也是有意义的。这个选项也可以用来控制是否抵消缓存。如果设为 false 不抵消，如果设为 true，用 this.clearMouseCache() 清除缓存偏移（边界元素偏移，元素在页面的位置偏移）。
         * @example
         *  function named(evt) {
         *        this.xy = this.object.events.getMousePosition(evt);
         *  }
         */
        this.includeXY = false;

        /**
         * @member {Object} Events.prototype.extensions
         * @description 事件扩展。Keys 代表事件类型，values 代表事件对象。
         */
        this.extensions = {};

        /**
         * @member {Object} Events.prototype.extensionCount
         * @description 事件扩展数量。
         */
        this.extensionCount = {};
        /**
         * @member {Object} Events.prototype.clearMouseListener
         * @description 待移除的鼠标监听事件。
         */
        this.clearMouseListener = null;

        Util_Util.extend(this, options);

        if (eventTypes != null) {
            for (var i = 0, len = eventTypes.length; i < len; i++) {
                this.addEventType(eventTypes[i]);
            }
        }

        if (element != null) {
            this.attachToElement(element);
        }

        this.CLASS_NAME = "SuperMap.Events";
    }

    /**
     * @function Events.prototype.destroy
     * @description 移除当前要素 element 上的所有事件监听和处理。
     */
    destroy() {
        for (var e in this.extensions) {
            if (typeof this.extensions[e] !== "boolean") {
                this.extensions[e].destroy();
            }
        }
        this.extensions = null;
        if (this.element) {
            Event_Event.stopObservingElement(this.element);
            if (this.element.hasScrollEvent) {
                Event_Event.stopObserving(
                    window, "scroll", this.clearMouseListener
                );
            }
        }
        this.element = null;

        this.listeners = null;
        this.object = null;
        this.eventTypes = null;
        this.fallThrough = null;
        this.eventHandler = null;
    }

    /**
     * @function Events.prototype.addEventType
     * @description 在此事件对象中添加新的事件类型，如果这个事件类型已经添加过了，则不做任何事情。
     * @param {string} eventName - 事件名。
     */
    addEventType(eventName) {
        if (!this.listeners[eventName]) {
            this.eventTypes.push(eventName);
            this.listeners[eventName] = [];
        }
    }

    /**
     * @function Events.prototype.attachToElement
     * @description 给 DOM 元素绑定浏览器事件。
     * @param {HTMLElement} element - 绑定浏览器事件的 DOM 元素。
     */
    attachToElement(element) {
        if (this.element) {
            Event_Event.stopObservingElement(this.element);
        } else {
            // keep a bound copy of handleBrowserEvent() so that we can
            // pass the same function to both Event.observe() and .stopObserving()
            this.eventHandler = FunctionExt.bindAsEventListener(
                this.handleBrowserEvent, this
            );

            // to be used with observe and stopObserving
            this.clearMouseListener = FunctionExt.bind(
                this.clearMouseCache, this
            );
        }
        this.element = element;
        for (var i = 0, len = this.BROWSER_EVENTS.length; i < len; i++) {
            var eventType = this.BROWSER_EVENTS[i];

            // every browser event has a corresponding application event
            // (whether it's listened for or not).
            this.addEventType(eventType);

            // use Prototype to register the event cross-browser
            Event_Event.observe(element, eventType, this.eventHandler);
        }
        // disable dragstart in IE so that mousedown/move/up works normally
        Event_Event.observe(element, "dragstart", Event_Event.stop);
    }


    /**
     * @function Events.prototype.on
     * @description 在一个相同的范围内注册监听器的方法，此方法调用 register 函数。
     * @example
     * // 注册一个 "loadstart" 监听事件
     * events.on({"loadstart": loadStartListener});
     *
     * // 同样注册一个 "loadstart" 监听事件
     * events.register("loadstart", undefined, loadStartListener);
     *
     * // 同时为对象注册多个监听事件
     * events.on({
     *     "loadstart": loadStartListener,
     *     "loadend": loadEndListener,
     *     scope: object
     * });
     *
     * // 同时为对象注册多个监听事件，多次调用 register 方法
     * events.register("loadstart", object, loadStartListener);
     * events.register("loadend", object, loadEndListener);
     *
     *
     * @param {Object} object - 添加监听的对象。
     */
    on(object) {
        for (var type in object) {
            if (type !== "scope" && object.hasOwnProperty(type)) {
                this.register(type, object.scope, object[type]);
            }
        }
    }


    /**
     * @function Events.prototype.register
     * @description 在事件对象上注册一个事件。当事件被触发时，'func' 函数被调用，假设我们触发一个事件，
     *              指定 Bounds 作为 "obj"，当事件被触发时，回调函数的上下文作为 Bounds 对象。
     * @param {string} type - 事件注册者的名字。
     * @param {Object} [obj=this.object] - 对象绑定的回调。
     * @param {function} [func] - 回调函数，如果没有特定的回调，则这个函数不做任何事情。
     * @param {(boolean|Object)} [priority] - 当为 true 时将新的监听加在事件队列的前面。
     */
    register(type, obj, func, priority) {
        if (type in Events && !this.extensions[type]) {
            this.extensions[type] = new Events[type](this);
        }
        if ((func != null) &&
            (Util_Util.indexOf(this.eventTypes, type) !== -1)) {

            if (obj == null) {
                obj = this.object;
            }
            var listeners = this.listeners[type];
            if (!listeners) {
                listeners = [];
                this.listeners[type] = listeners;
                this.extensionCount[type] = 0;
            }
            var listener = {obj: obj, func: func};
            if (priority) {
                listeners.splice(this.extensionCount[type], 0, listener);
                if (typeof priority === "object" && priority.extension) {
                    this.extensionCount[type]++;
                }
            } else {
                listeners.push(listener);
            }
        }
    }

    /**
     * @function Events.prototype.registerPriority
     * @description 相同的注册方法，但是在前面增加新的监听者事件查询而代替到方法的结束。
     * @param {string} type - 事件注册者的名字。
     * @param {Object} [obj=this.object] - 对象绑定的回调。
     * @param {function} [func] - 回调函数，如果没有特定的回调，则这个函数不做任何事情。
     */
    registerPriority(type, obj, func) {
        this.register(type, obj, func, true);
    }


    /**
     * @function Events.prototype.un
     * @description 在一个相同的范围内取消注册监听器的方法，此方法调用 unregister 函数。
     * @example
     * // 移除 "loadstart" 事件监听
     * events.un({"loadstart": loadStartListener});
     *
     * // 使用 "unregister" 方法移除 "loadstart" 事件监听
     * events.unregister("loadstart", undefined, loadStartListener);
     *
     * // 取消对象多个事件监听
     * events.un({
     *     "loadstart": loadStartListener,
     *     "loadend": loadEndListener,
     *     scope: object
     * });
     *
     * // 取消对象多个事件监听，多次调用unregister方法。
     * events.unregister("loadstart", object, loadStartListener);
     * events.unregister("loadend", object, loadEndListener);
     *
     * @param {Object} object - 移除监听的对象。
     */
    un(object) {
        for (var type in object) {
            if (type !== "scope" && object.hasOwnProperty(type)) {
                this.unregister(type, object.scope, object[type]);
            }
        }
    }

    /**
     * @function Events.prototype.unregister
     * @description 取消注册。
     * @param {string} type - 事件类型。
     * @param {Object} [obj=this.object] - 对象绑定的回调。
     * @param {function} [func] - 回调函数，如果没有特定的回调，则这个函数不做任何事情。
     */
    unregister(type, obj, func) {
        if (obj == null) {
            obj = this.object;
        }
        var listeners = this.listeners[type];
        if (listeners != null) {
            for (var i = 0, len = listeners.length; i < len; i++) {
                if (listeners[i].obj === obj && listeners[i].func === func) {
                    listeners.splice(i, 1);
                    break;
                }
            }
        }
    }


    /**
     * @function Events.prototype.remove
     * @description 删除某个事件类型的所有监听，如果该事件类型没有注册，则不做任何操作。
     * @param {string} type - 事件类型。
     */
    remove(type) {
        if (this.listeners[type] != null) {
            this.listeners[type] = [];
        }
    }

    /**
     * @function Events.prototype.triggerEvent
     * @description 触发一个特定的注册事件。
     * @param {string} type - 触发事件类型。
     * @param {Event} evt - 事件对象。
     * @returns {Event|boolean} 监听对象，如果返回是 false，则停止监听。
     */
    triggerEvent(type, evt) {
        var listeners = this.listeners[type];

        // fast path
        if (!listeners || listeners.length == 0) {
            return undefined;
        }

        // prep evt object with object & div references
        if (evt == null) {
            evt = {};
        }
        evt.object = this.object;
        evt.element = this.element;
        if (!evt.type) {
            evt.type = type;
        }

        // execute all callbacks registered for specified type
        // get a clone of the listeners array to
        // allow for splicing during callbacks
        listeners = listeners.slice();
        var continueChain;
        for (var i = 0, len = listeners.length; i < len; i++) {
            var callback = listeners[i];
            // bind the context to callback.obj
            continueChain = callback.func.apply(callback.obj, [evt]);

            if ((continueChain != undefined) && (continueChain === false)) {
                // if callback returns false, execute no more callbacks.
                break;
            }
        }
        // don't fall through to other DOM elements
        if (!this.fallThrough) {
            Event_Event.stop(evt, true);
        }
        return continueChain;
    }


    /**
     * @function Events.prototype.handleBrowserEvent
     * @description 对 triggerEvent 函数的包装，给事件对象设置了 xy 属性（即当前鼠标点的 xy 坐标）。
     * @param {Event} evt - 事件对象。
     */
    handleBrowserEvent(evt) {
        var type = evt.type, listeners = this.listeners[type];
        if (!listeners || listeners.length == 0) {
            // noone's listening, bail out
            return;
        }
        // add clientX & clientY to all events - corresponds to average x, y
        var touches = evt.touches;
        if (touches && touches[0]) {
            var x = 0;
            var y = 0;
            var num = touches.length;
            var touch;
            for (var i = 0; i < num; ++i) {
                touch = touches[i];
                x += touch.clientX;
                y += touch.clientY;
            }
            evt.clientX = x / num;
            evt.clientY = y / num;
        }
        if (this.includeXY) {
            evt.xy = this.getMousePosition(evt);
        }
        this.triggerEvent(type, evt);
    }


    /**
     * @function Events.prototype.clearMouseCache
     * @description 清除鼠标缓存。
     */
    clearMouseCache() {
        this.element.scrolls = null;
        this.element.lefttop = null;
        var body = document.body;
        if (body && !((body.scrollTop != 0 || body.scrollLeft != 0) &&
                navigator.userAgent.match(/iPhone/i))) {
            this.element.offsets = null;
        }
    }

    /**
     * @function Events.prototype.getMousePosition
     * @description 获取当前鼠标的位置。
     * @param {Event} evt - 事件对象。
     * @returns {Pixel} 当前的鼠标的 xy 坐标点。
     */
    getMousePosition(evt) {
        if (!this.includeXY) {
            this.clearMouseCache();
        } else if (!this.element.hasScrollEvent) {
            Event_Event.observe(window, "scroll", this.clearMouseListener);
            this.element.hasScrollEvent = true;
        }

        if (!this.element.scrolls) {
            var viewportElement = Util_Util.getViewportElement();
            this.element.scrolls = [
                viewportElement.scrollLeft,
                viewportElement.scrollTop
            ];
        }

        if (!this.element.lefttop) {
            this.element.lefttop = [
                (document.documentElement.clientLeft || 0),
                (document.documentElement.clientTop || 0)
            ];
        }

        if (!this.element.offsets) {
            this.element.offsets = Util_Util.pagePosition(this.element);
        }

        return new Pixel(
            (evt.clientX + this.element.scrolls[0]) - this.element.offsets[0]
            - this.element.lefttop[0],
            (evt.clientY + this.element.scrolls[1]) - this.element.offsets[1]
            - this.element.lefttop[1]
        );
    }

}
Events.prototype.BROWSER_EVENTS = [
  "mouseover", "mouseout",
  "mousedown", "mouseup", "mousemove",
  "click", "dblclick", "rightclick", "dblrightclick",
  "resize", "focus", "blur",
  "touchstart", "touchmove", "touchend",
  "keydown", "MSPointerDown", "MSPointerUp", "pointerdown", "pointerup",
  "MSGestureStart", "MSGestureChange", "MSGestureEnd",
  "contextmenu"
];

;// CONCATENATED MODULE: ./src/common/commontypes/Geometry3D.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/



/**
 * @class Geometry3D
 * @deprecatedclass SuperMap.Geometry3D
 * @category BaseTypes Geometry3D
 * @classdesc 所有三维几何类的基类。
 * @usage
 */
class Geometry3D extends ServerGeometry{

    constructor(options) {
        super(options);

        this.CLASS_NAME = "SuperMap.Geometry3D";
        /**
         * @member {GeometryPoint|L.LatLng|L.Point|ol.geom.Point|mapboxgl.LngLat|Array.<number>} Geometry3D.prototype.position 
         * @description  三维几何对象的位置。
         *
         */
        this.position = null;

        /**
         * @member {number} Geometry3D.prototype.rotationX 
         * @description 三维几何对象沿 X 轴方向的旋转角度，单位为度。
         */
        this.rotationX = null;

        /**
         * @member {number} Geometry3D.prototype.rotationY
         * @description 三维几何对象沿 Y 轴方向的旋转角度，单位为度。
         */
        this.rotationY = null;

        /**
         * @member {number} Geometry3D.prototype.rotationZ
         * @description 三维几何对象沿 Z 轴方向的旋转角度，单位为度。
         */
        this.rotationZ = null;

        /**
         * @member {number} Geometry3D.prototype.scaleX 
         * @description 三维几何对象沿 X 轴方向的缩放比例。
         */
        this.scaleX = null;

        /**
         * @member {number} Geometry3D.prototype.scaleY
         * @description 三维几何对象沿 Y 轴方向的缩放比例。
         */
        this.scaleY = null;

        /**
         * @member {number} Geometry3D.prototype.scaleZ
         * @description 三维几何对象沿 Z 轴方向的缩放比例。
         */
        this.scaleZ = null;

        Util_Util.extend(this, options);
    }


    /**
     * @function Geometry3D.prototype.destroy
     * @description 释放资源。
     */
    destroy() {
        this.position = null;
        this.rotationX = null;
        this.rotationY = null;
        this.rotationZ = null;
        this.scaleX = null;
        this.scaleY = null;
        this.scaleZ = null;
    }
}

;// CONCATENATED MODULE: ./src/common/commontypes/index.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/































;// CONCATENATED MODULE: ./src/common/overlay/levelRenderer/Shape.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/






/**
 * @private
 * @class  LevelRenderer.Shape
 * @category Visualization Theme
 * @classdesc 图形（shape）基类。
 * @extends LevelRenderer.Eventful
 * @extends LevelRenderer.Transformable
 * @param {Array} options - shape 的配置（options）项，可以是 shape 的自有属性，也可以是自定义的属性。
 */
class Shape_Shape extends mixinExt(Eventful, Transformable) {
    constructor(options) {
        super(options);

        options = options || {};
        /**
         * @member {string} LevelRenderer.Shape.prototype.id
         * @description 唯一标识。
         */
        this.id = null;

        /**
         * @member {Object} LevelRenderer.Shape.prototype.style
         * @description 基础绘制样式。
         * @param {string} style.brushType - 画笔类型。可设值："fill", "stroke", "both"。默认值："fill"。
         * @param {string} style.color - 填充颜色。默认值："#000000'"。
         * @param {string} style.strokeColor - 描边颜色。默认值："#000000'"。
         * @param {string} style.lineCape - 线帽样式。可设值："butt", "round", "square"。默认值："butt"。
         * @param {number} style.lineWidth - 描边宽度。默认值：1。
         * @param {number} style.opacity - 绘制透明度。默认值：1。
         * @param {number} style.shadowBlur - 阴影模糊度，大于0有效。默认值：0。
         * @param {number} style.shadowColor - 阴影颜色。默认值："#000000'"。
         * @param {number} style.shadowOffsetX - 阴影横向偏移。默认值：0。
         * @param {number} style.shadowOffsetY -  阴影纵向偏移。默认值：0。
         * @param {string} style.text -  图形中的附加文本。默认值：""。
         * @param {string} style.textColor -  文本颜色。默认值："#000000'"。
         * @param {string} style.textFont -  附加文本样式。示例:'bold 18px verdana'。
         * @param {string} style.textPosition -  附加文本位置。可设值："inside", "left", "right", top", "bottom", "end"。默认值："end"。
         * @param {string} style.textAlign -  附加文本水平对齐。可设值："start", "end", "left", "right", "center"。默认根据 textPosition 自动设置。
         * @param {string} style.textBaseline - 附加文本垂直对齐。可设值："top", "bottom", "middle", "alphabetic", "hanging", "ideographic"。默认根据 textPosition 自动设置。
         *
         */
        this.style = {};

        /**
         * @member {Object} LevelRenderer.Shape.prototype.style.__rect
         * @description 包围图形的最小矩形盒子。
         *
         * @param {number} x - 左上角顶点x轴坐标。
         * @param {number} y - 左上角顶点y轴坐标。
         * @param {number} width - 包围盒矩形宽度。
         * @param {number} height - 包围盒矩形高度。
         */

        /**
         * @member {Object} LevelRenderer.Shape.prototype.highlightStyle
         * @description 高亮样式。
         *
         * @param {string} highlightStyle.brushType - 画笔类型。可设值："fill", "stroke", "both"。默认值："fill"。
         * @param {string} highlightStyle.color -  填充颜色。默认值："#000000'"。
         * @param {string} highlightStyle.strokeColor - 描边颜色。默认值："#000000'"。
         * @param {string} highlightStyle.lineCape - 线帽样式。可设值："butt", "round", "square"。默认值："butt"。
         * @param {number} highlightStyle.lineWidth - 描边宽度。默认值：1。
         * @param {number} highlightStyle.opacity -  绘制透明度。默认值：1。
         * @param {number} highlightStyle.shadowBlur - 阴影模糊度，大于0有效。默认值：0。
         * @param {number} highlightStyle.shadowColor - 阴影颜色。默认值："#000000'"。
         * @param {number} highlightStyle.shadowOffsetX - 阴影横向偏移。默认值：0。
         * @param {number} highlightStyle.shadowOffsetY - 阴影纵向偏移。默认值：0。
         * @param {string} highlightStyle.text - 图形中的附加文本。默认值：""。
         * @param {string} highlightStyle.textColor - 文本颜色。默认值："#000000'"。
         * @param {string} highlightStyle.textFont - 附加文本样式。示例:'bold 18px verdana'。
         * @param {string} highlightStyle.textPosition - 附加文本位置。可设值："inside", "left", "right", top", "bottom", "end"。默认值："end"。
         * @param {string} highlightStyle.textAlign -  附加文本水平对齐。可设值："start", "end", "left", "right", "center"。默认根据 textPosition 自动设置。
         * @param {string} highlightStyle.textBaseline - 附加文本垂直对齐。可设值："top", "bottom", "middle", "alphabetic", "hanging", "ideographic"。默认根据 textPosition 自动设置。
         */
        this.highlightStyle = null;

        /**
         * @member {Object} LevelRenderer.Shape.prototype.parent
         * @description 父节点，只读属性。<LevelRenderer.Group>
         */
        this.parent = null;

        /**
         * @member {boolean} LevelRenderer.Shape.prototype.__dirty
         * @description {boolean}
         */
        this.__dirty = true;

        /**
         * @member {Array} LevelRenderer.Shape.prototype.__clipShapes
         * @description {Array}
         *
         */
        this.__clipShapes = [];

        /**
         * @member {boolean} LevelRenderer.Shape.prototype.invisible
         * @description 图形是否可见，为 true 时不绘制图形，但是仍能触发鼠标事件。默认值：false。
         */
        this.invisible = false;

        /**
         * @member {boolean} LevelRenderer.Shape.prototype.ignore
         * @description 图形是否忽略，为 true 时忽略图形的绘制以及事件触发。默认值：false。
         */
        this.ignore = false;

        /**
         * @member {boolean} LevelRenderer.Shape.prototype.zlevel
         * @description z 层 level，决定绘画在哪层 canvas 中。默认值：0。
         */
        this.zlevel = 0;

        /**
         * @member {boolean} LevelRenderer.Shape.prototype.draggable
         * @description 是否可拖拽。默认值：false。
         */
        this.draggable = false;

        /**
         * @member {boolean} LevelRenderer.Shape.prototype.clickable
         * @description 是否可点击。默认值：false。
         */
        this.clickable = false;

        /**
         * @member {boolean} LevelRenderer.Shape.prototype.hoverable
         * @description 是否可以 hover。默认值：true。
         */
        this.hoverable = true;

        /**
         * @member {number} LevelRenderer.Shape.prototype.z
         * @description z值，跟zlevel一样影响shape绘制的前后顺序，z值大的shape会覆盖在z值小的上面，但是并不会创建新的canvas，所以优先级低于zlevel，而且频繁改动的开销比zlevel小很多。默认值：0。
         */
        this.z = 0;

        //地理扩展
        /**
         * @member {Array.<number>} LevelRenderer.Shape.prototype.refOriginalPosition
         * @description 图形参考原点位置，图形的参考中心位置。
         * refOriginalPosition 是长度为 2 的数组，第一个元素表示 x 坐标，第二个元素表示 y 坐标。
         *
         * refOriginalPosition 表示图形的参考中心，通常情况下，图形是使用 canvas 的原点位置作为位置参考，
         * 但 refOriginalPosition 可以改变图形的参考位置，例如： refOriginalPosition = [80, 80],
         * 图形圆的 style.x = 20, style.y = 20，那么圆在 canvas 中的实际位置是 [100, 100]。
         *
         * 图形（Shape） 的所有位置相关属性都是以 refOriginalPosition 为参考中心，
         * 也就是说图形的所有位置信息在 canvas 中都是以 refOriginalPosition 为参考的相对位置，只有
         * refOriginalPosition 的值为 [0, 0] 时，形的位置信息才是 canvas 绝对位置。
         *
         * 图形的位置信息通常有：style.pointList，style.x，style.y。
         *
         * refOriginalPosition。默认值是： [0, 0]。
         */
        this.refOriginalPosition = [0, 0];

        /**
         * @member {string} LevelRenderer.Shape.prototype.refDataID
         * @description 图形所关联数据的 ID。
         *
         */
        this.refDataID = null;

        /**
         * @member {boolean} LevelRenderer.Shape.prototype.isHoverByRefDataID
         * @description 是否根据 refDataID 进行高亮。用于同时高亮所有 refDataID 相同的图形。
         *
         */
        this.isHoverByRefDataID = false;

        /**
         *  @member {string} LevelRenderer.Shape.prototype.refDataHoverGroup
         *  @description 高亮图形组的组名。此属性在 refDataID 有效且 isHoverByRefDataID 为 true 时生效。
         * 一旦设置此属性，且属性值有效，只有关联同一个数据的图形且此属性相同的图形才会高亮。
         *
         */
        this.refDataHoverGroup = null;

        /**
         * @member {Object} LevelRenderer.Shape.prototype.dataInfo
         * @description 图形的数据信息。
         *
         */
        this.dataInfo = null;
        Util_Util.extend(this, options);
        this.id = this.id  || Util_Util.createUniqueID("smShape_");
        this.CLASS_NAME = "SuperMap.LevelRenderer.Shape";
        /**
         * @function LevelRenderer.Shape.prototype.getTansform
         * @description 变换鼠标位置到 shape 的局部坐标空间
         *
         */
        this.getTansform = (function () {
            var invTransform = [];

            return function (x, y) {
                var originPos = [x, y];
                // 对鼠标的坐标也做相同的变换
                if (this.needTransform && this.transform) {
                    SUtil_SUtil.Util_matrix.invert(invTransform, this.transform);

                    SUtil_SUtil.Util_matrix.mulVector(originPos, invTransform, [x, y, 1]);

                    if (x == originPos[0] && y == originPos[1]) {
                        // 避免外部修改导致的 needTransform 不准确
                        this.updateNeedTransform();
                    }
                }
                return originPos;
            };
        })();

    }


    /**
     * @function LevelRenderer.Shape.prototype.destroy
     * @description 销毁对象，释放资源。调用此函数后所有属性将被置为 null。
     */
    destroy() {
        this.id = null;
        this.style = null;
        this.highlightStyle = null;
        this.parent = null;
        this.__dirty = null;
        this.__clipShapes = null;
        this.invisible = null;
        this.ignore = null;
        this.zlevel = null;
        this.draggable = null;
        this.clickable = null;
        this.hoverable = null;
        this.z = null;

        this.refOriginalPosition = null;
        this.refDataID = null;
        this.refDataHoverGroup = null;
        this.isHoverByRefDataID = null;
        this.dataInfo = null;
        super.destroy();
    }


    /**
     * @function LevelRenderer.Shape.prototype.brush
     * @description 绘制图形。
     *
     * @param {CanvasRenderingContext2D} ctx - Context2D 上下文。
     * @param {boolean} isHighlight - 是否使用高亮属性。
     * @param {function} updateCallback - 需要异步加载资源的 shape 可以通过这个 callback(e),让painter更新视图，base.brush 没用，需要的话重载 brush。
     */
    brush(ctx, isHighlight) {

        var style = this.beforeBrush(ctx, isHighlight);

        ctx.beginPath();
        this.buildPath(ctx, style);

        switch (style.brushType) {
            /* jshint ignore:start */
            case 'both':
                this.setCtxGlobalAlpha(ctx, "fill", style);
                ctx.fill();
                if (style.lineWidth > 0) {
                    this.setCtxGlobalAlpha(ctx, "stroke", style);
                    ctx.stroke();
                }
                this.setCtxGlobalAlpha(ctx, "reset", style);
                break;
            case 'stroke':
                this.setCtxGlobalAlpha(ctx, "stroke", style);
                style.lineWidth > 0 && ctx.stroke();
                this.setCtxGlobalAlpha(ctx, "reset", style);
                break;
            /* jshint ignore:end */
            default:
                this.setCtxGlobalAlpha(ctx, "fill", style);
                ctx.fill();
                this.setCtxGlobalAlpha(ctx, "reset", style);
                break;
        }

        this.drawText(ctx, style, this.style);

        this.afterBrush(ctx);
    }


    /**
     * @function LevelRenderer.Shape.prototype.beforeBrush
     * @description 具体绘制操作前的一些公共操作。
     *
     * @param {CanvasRenderingContext2D} ctx - Context2D 上下文。
     * @param {boolean} isHighlight - 是否使用高亮属性。
     * @return {Object} 处理后的样式。
     */
    beforeBrush(ctx, isHighlight) {
        var style = this.style;

        if (this.brushTypeOnly) {
            style.brushType = this.brushTypeOnly;
        }

        if (isHighlight) {
            // 根据style扩展默认高亮样式
            style = this.getHighlightStyle(
                style,
                this.highlightStyle || {},
                this.brushTypeOnly
            );
        }

        if (this.brushTypeOnly == 'stroke') {
            style.strokeColor = style.strokeColor || style.color;
        }

        ctx.save();

        this.doClip(ctx);

        this.setContext(ctx, style);

        // 设置transform
        this.setTransform(ctx);

        return style;
    }


    /**
     * @function LevelRenderer.Shape.prototype.afterBrush
     * @description 绘制后的处理。
     *
     * @param {CanvasRenderingContext2D} ctx - Context2D 上下文。
     *
     */
    afterBrush(ctx) {
        ctx.restore();
    }


    /**
     * @function LevelRenderer.Shape.prototype.setContext
     * @description 设置 fillStyle, strokeStyle, shadow 等通用绘制样式。
     *
     * @param {CanvasRenderingContext2D} ctx - Context2D 上下文。
     * @param {Object} style - 样式。
     *
     */
    setContext(ctx, style) {
        var STYLE_CTX_MAP = [
            ['color', 'fillStyle'],
            ['strokeColor', 'strokeStyle'],
            ['opacity', 'globalAlpha'],
            ['lineCap', 'lineCap'],
            ['lineJoin', 'lineJoin'],
            ['miterLimit', 'miterLimit'],
            ['lineWidth', 'lineWidth'],
            ['shadowBlur', 'shadowBlur'],
            ['shadowColor', 'shadowColor'],
            ['shadowOffsetX', 'shadowOffsetX'],
            ['shadowOffsetY', 'shadowOffsetY']
        ];

        for (var i = 0, len = STYLE_CTX_MAP.length; i < len; i++) {
            var styleProp = STYLE_CTX_MAP[i][0];
            var styleValue = style[styleProp];
            var ctxProp = STYLE_CTX_MAP[i][1];

            if (typeof styleValue != 'undefined') {
                ctx[ctxProp] = styleValue;
            }
        }
    }


    /**
     * @function LevelRenderer.Shape.prototype.doClip
     *
     */
    doClip(ctx) {
        var clipShapeInvTransform = SUtil_SUtil.Util_matrix.create();

        if (this.__clipShapes) {
            for (var i = 0; i < this.__clipShapes.length; i++) {
                var clipShape = this.__clipShapes[i];
                if (clipShape.needTransform) {
                    let m = clipShape.transform;
                    SUtil_SUtil.Util_matrix.invert(clipShapeInvTransform, m);
                    ctx.transform(
                        m[0], m[1],
                        m[2], m[3],
                        m[4], m[5]
                    );
                }
                ctx.beginPath();
                clipShape.buildPath(ctx, clipShape.style);
                ctx.clip();
                // Transform back
                if (clipShape.needTransform) {
                    let m = clipShapeInvTransform;
                    ctx.transform(
                        m[0], m[1],
                        m[2], m[3],
                        m[4], m[5]
                    );
                }
            }
        }
    }


    /**
     * @function LevelRenderer.Shape.prototype.getHighlightStyle
     * @description 根据默认样式扩展高亮样式
     *
     * @param {Object} style - 样式。
     * @param {Object} highlightStyle - 高亮样式。
     * @param {string} brushTypeOnly - brushTypeOnly。
     *
     */
    getHighlightStyle(style, highlightStyle, brushTypeOnly) {
        var newStyle = {};
        for (let k in style) {
            newStyle[k] = style[k];
        }

        var highlightColor = SUtil_SUtil.Util_color.getHighlightColor();
        // 根据highlightStyle扩展
        if (style.brushType != 'stroke') {
            // 带填充则用高亮色加粗边线
            newStyle.strokeColor = highlightColor;
            // SMIC-方法修改 - start
            newStyle.lineWidth = (style.lineWidth || 1);
            // 原始代码
            //      newStyle.lineWidth = (style.lineWidth || 1)
            //          + this.getHighlightZoom();
            // 修改代码1
            // if(!style.lineType || style.lineType === "solid"){
            //     newStyle.lineWidth = (style.lineWidth || 1)
            //         + this.getHighlightZoom();
            // }
            // else{
            //     newStyle.lineWidth = (style.lineWidth || 1);
            // }
            // SMIC-方法修改 - end
            newStyle.brushType = 'both';
        } else {
            if (brushTypeOnly != 'stroke') {
                // 描边型的则用原色加工高亮
                newStyle.strokeColor = highlightColor;
                // SMIC-方法修改 - start
                newStyle.lineWidth = (style.lineWidth || 1);
                // 原始代码
                //      newStyle.lineWidth = (style.lineWidth || 1)
                //          + this.getHighlightZoom();
                // 修改代码1
                // if(!style.lineType || style.lineType === "solid"){
                //     newStyle.lineWidth = (style.lineWidth || 1)
                //         + this.getHighlightZoom();
                // }
                // else{
                //     newStyle.lineWidth = (style.lineWidth || 1);
                // }
                // SMIC-方法修改 - end
            } else {
                // 线型的则用原色加工高亮
                newStyle.strokeColor = highlightStyle.strokeColor
                    || SUtil_SUtil.Util_color.mix(
                        style.strokeColor,
                        SUtil_SUtil.Util_color.toRGB(highlightColor)
                    );
            }
        }

        // 可自定义覆盖默认值
        for (let k in highlightStyle) {
            if (typeof highlightStyle[k] != 'undefined') {
                newStyle[k] = highlightStyle[k];
            }
        }

        return newStyle;
    }


    /**
     * @function LevelRenderer.Shape.prototype.getHighlightZoom
     * @description 高亮放大效果参数，当前统一设置为6，如有需要差异设置，通过 this.type 判断实例类型
     *
     */
    getHighlightZoom() {
        return this.type != 'text' ? 6 : 2;
    }


    /**
     * @function LevelRenderer.Shape.prototype.drift
     * @description 移动位置
     *
     * @param {Object} dx - 横坐标变化。
     * @param {Object} dy - 纵坐标变化。
     *
     */
    drift(dx, dy) {
        this.position[0] += dx;
        this.position[1] += dy;
    }




    /**
     * @function LevelRenderer.Shape.prototype.buildPath
     * @description 构建绘制的Path。子类必须重新实现此方法。
     *
     * @param {CanvasRenderingContext2D} ctx - Context2D 上下文。
     * @param {Object} style - 样式。
     */
    buildPath(ctx, style) { // eslint-disable-line no-unused-vars
        SUtil_SUtil.Util_log('buildPath not implemented in ' + this.type);
    }


    /**
     * @function LevelRenderer.Shape.prototype.getRect
     * @description 计算返回包围盒矩形。子类必须重新实现此方法。
     *
     * @param {Object} style - 样式。
     */
    getRect(style) { // eslint-disable-line no-unused-vars
        SUtil_SUtil.Util_log('getRect not implemented in ' + this.type);
    }


    /**
     * @function LevelRenderer.Shape.prototype.isCover
     * @description 判断鼠标位置是否在图形内。
     *
     * @param {number} x - x。
     * @param {number} y - y。
     */
    isCover(x, y) {
        var originPos = this.getTansform(x, y);
        x = originPos[0];
        y = originPos[1];

        // 快速预判并保留判断矩形
        var rect = this.style.__rect;
        if (!rect) {
            rect = this.style.__rect = this.getRect(this.style);
        }

        if (x >= rect.x
            && x <= (rect.x + rect.width)
            && y >= rect.y
            && y <= (rect.y + rect.height)
        ) {
            // 矩形内
            return SUtil_SUtil.Util_area.isInside(this, this.style, x, y);
        }

        return false;
    }


    /**
     * @function LevelRenderer.Shape.prototype.drawText
     * @description 绘制附加文本。
     *
     * @param {CanvasRenderingContext2D} ctx - Context2D 上下文。
     * @param {string} style - 样式。
     * @param {string} normalStyle - normalStyle 默认样式，用于定位文字显示。
     */
    drawText(ctx, style, normalStyle) {
        if (typeof(style.text) == 'undefined' || style.text === false) {
            return;
        }
        // 字体颜色策略
        var textColor = style.textColor || style.color || style.strokeColor;
        ctx.fillStyle = textColor;

        // 文本与图形间空白间隙
        var dd = 10;
        var al;         // 文本水平对齐
        var bl;         // 文本垂直对齐
        var tx;         // 文本横坐标
        var ty;         // 文本纵坐标

        var textPosition = style.textPosition       // 用户定义
            || this.textPosition     // shape默认
            || 'top';                // 全局默认

        // Smic 方法修改 -start
        var __OP = [];
        if (!this.refOriginalPosition || this.refOriginalPosition.length !== 2) {
            __OP = [0, 0];
        } else {
            __OP = this.refOriginalPosition;
        }
        //原代码：
        // Smic 方法修改 -end

        switch (textPosition) {
            case 'inside':
            case 'top':
            case 'bottom':
            case 'left':
            case 'right':
                if (this.getRect) {
                    var rect = (normalStyle || style).__rect
                        || this.getRect(normalStyle || style);

                    switch (textPosition) {
                        case 'inside':
                            tx = rect.x + rect.width / 2;
                            ty = rect.y + rect.height / 2;
                            al = 'center';
                            bl = 'middle';
                            if (style.brushType != 'stroke'
                                && textColor == style.color
                            ) {
                                ctx.fillStyle = '#fff';
                            }
                            break;
                        case 'left':
                            tx = rect.x - dd;
                            ty = rect.y + rect.height / 2;
                            al = 'end';
                            bl = 'middle';
                            break;
                        case 'right':
                            tx = rect.x + rect.width + dd;
                            ty = rect.y + rect.height / 2;
                            al = 'start';
                            bl = 'middle';
                            break;
                        case 'top':
                            tx = rect.x + rect.width / 2;
                            ty = rect.y - dd;
                            al = 'center';
                            bl = 'bottom';
                            break;
                        case 'bottom':
                            tx = rect.x + rect.width / 2;
                            ty = rect.y + rect.height + dd;
                            al = 'center';
                            bl = 'top';
                            break;
                    }
                }
                break;
            case 'start':
            case 'end':
                var xStart = 0;
                var xEnd = 0;
                var yStart = 0;
                var yEnd = 0;
                if (typeof style.pointList != 'undefined') {
                    var pointList = style.pointList;
                    if (pointList.length < 2) {
                        // 少于2个点就不画了~
                        return;
                    }
                    var length = pointList.length;
                    switch (textPosition) {
                        // Smic 方法修改 -start
                        case 'start':
                            xStart = pointList[0][0] + __OP[0];
                            xEnd = pointList[1][0] + __OP[0];
                            yStart = pointList[0][1] + __OP[1];
                            yEnd = pointList[1][1] + __OP[1];
                            break;
                        case 'end':
                            xStart = pointList[length - 2][0] + __OP[0];
                            xEnd = pointList[length - 1][0] + __OP[0];
                            yStart = pointList[length - 2][1] + __OP[1];
                            yEnd = pointList[length - 1][1] + __OP[1];
                            break;
                        //原代码：
                        /*
                         case 'start':
                         xStart = pointList[0][0];
                         xEnd = pointList[1][0];
                         yStart = pointList[0][1];
                         yEnd = pointList[1][1];
                         break;
                         case 'end':
                         xStart = pointList[length - 2][0];
                         xEnd = pointList[length - 1][0];
                         yStart = pointList[length - 2][1];
                         yEnd = pointList[length - 1][1];
                         break;
                         */
                        // Smic 方法修改 -end
                    }
                } else {
                    // Smic 方法修改 -start
                    xStart = (style.xStart + __OP[0]) || 0;
                    xEnd = (style.xEnd + __OP[0]) || 0;
                    yStart = (style.yStart + __OP[1]) || 0;
                    yEnd = (style.yEnd + __OP[1]) || 0;
                    //原代码：
                    /*
                     xStart = style.xStart || 0;
                     xEnd = style.xEnd || 0;
                     yStart = style.yStart || 0;
                     yEnd = style.yEnd || 0;
                     */
                    // Smic 方法修改 -end
                }

                switch (textPosition) {
                    case 'start':
                        al = xStart < xEnd ? 'end' : 'start';
                        bl = yStart < yEnd ? 'bottom' : 'top';
                        tx = xStart;
                        ty = yStart;
                        break;
                    case 'end':
                        al = xStart < xEnd ? 'start' : 'end';
                        bl = yStart < yEnd ? 'top' : 'bottom';
                        tx = xEnd;
                        ty = yEnd;
                        break;
                }
                dd -= 4;
                if (xStart && xEnd && xStart != xEnd) {
                    tx -= (al == 'end' ? dd : -dd);
                } else {
                    al = 'center';
                }

                if (yStart != yEnd) {
                    ty -= (bl == 'bottom' ? dd : -dd);
                } else {
                    bl = 'middle';
                }
                break;
            case 'specific':
                tx = style.textX || 0;
                ty = style.textY || 0;
                al = 'start';
                bl = 'middle';
                break;
        }

        // Smic 方法修改 -start
        if (style.labelXOffset && !isNaN(style.labelXOffset)) {
            tx += style.labelXOffset;
        }
        if (style.labelYOffset && !isNaN(style.labelYOffset)) {
            ty += style.labelYOffset;
        }
        //原代码：
        // Smic 方法修改 -end

        if (tx != null && ty != null) {
            Shape_Shape._fillText(
                ctx,
                style.text,
                tx, ty,
                style.textFont,
                style.textAlign || al,
                style.textBaseline || bl
            );
        }
    }


    /**
     * @function LevelRenderer.Shape.prototype.modSelf
     * @description 图形发生改变
     */
    modSelf() {
        this.__dirty = true;
        if (this.style) {
            this.style.__rect = null;
        }
        if (this.highlightStyle) {
            this.highlightStyle.__rect = null;
        }
    }


    /**
     * @function LevelRenderer.Shape.prototype.isSilent
     * @description 图形是否会触发事件，通过 bind 绑定的事件
     */
    isSilent() {
        return !(
            this.hoverable || this.draggable || this.clickable
            || this.onmousemove || this.onmouseover || this.onmouseout
            || this.onmousedown || this.onmouseup || this.onclick
            || this.ondragenter || this.ondragover || this.ondragleave
            || this.ondrop
        );
    }


    /**
     * @function LevelRenderer.Shape.prototype.setCtxGlobalAlpha
     * @description 设置 Cavans 上下文全局透明度
     *
     * @param {Object} _ctx - Cavans 上下文
     * @param {string} type - one of 'stroke', 'fill', or 'reset'
     * @param {Object} style - Symbolizer hash
     */
    setCtxGlobalAlpha(_ctx, type, style) {
        if (type === "fill") {
            _ctx.globalAlpha = typeof(style["fillOpacity"]) === "undefined" ? (typeof(style["opacity"]) === "undefined" ? 1 : style['opacity']) : style['fillOpacity'];
        } else if (type === "stroke") {
            _ctx.globalAlpha = typeof(style["strokeOpacity"]) === "undefined" ? (typeof(style["opacity"]) === "undefined" ? 1 : style['opacity']) : style['strokeOpacity'];
        } else {
            _ctx.globalAlpha = typeof(style["opacity"]) === "undefined" ? 1 : style['opacity'];
        }
    }

    /**
     * @function LevelRenderer.Shape.prototype._fillText
     * @description 填充文本
     */
    static _fillText(ctx, text, x, y, textFont, textAlign, textBaseline) {
        if (textFont) {
            ctx.font = textFont;
        }
        ctx.textAlign = textAlign;
        ctx.textBaseline = textBaseline;
        var rect = Shape_Shape._getTextRect(
            text, x, y, textFont, textAlign, textBaseline
        );

        text = (text + '').split('\n');

        var lineHeight = SUtil_SUtil.Util_area.getTextHeight('ZH', textFont);

        switch (textBaseline) {
            case 'top':
                y = rect.y;
                break;
            case 'bottom':
                y = rect.y + lineHeight;
                break;
            default:
                y = rect.y + lineHeight / 2;
        }

        for (var i = 0, l = text.length; i < l; i++) {
            ctx.fillText(text[i], x, y);
            y += lineHeight;
        }
    }

    /**
     * @function LevelRenderer.Shape._getTextRect
     * @description 返回矩形区域，用于局部刷新和文字定位
     *
     * @param {string} text - text。
     * @param {number} x - x。
     * @param {number} y - y。
     * @param {string} textFont -  textFont。
     * @param {string} textAlign - textAlign。
     * @param {string} textBaseline - textBaseline。
     * @return {Object} 矩形区域。
     */
    static _getTextRect(text, x, y, textFont, textAlign, textBaseline) {
        var width = SUtil_SUtil.Util_area.getTextWidth(text, textFont);
        var lineHeight = SUtil_SUtil.Util_area.getTextHeight('ZH', textFont);

        text = (text + '').split('\n');

        switch (textAlign) {
            case 'end':
            case 'right':
                x -= width;
                break;
            case 'center':
                x -= (width / 2);
                break;
        }

        switch (textBaseline) {
            case 'top':
                break;
            case 'bottom':
                y -= lineHeight * text.length;
                break;
            default:
                y -= lineHeight * text.length / 2;
        }

        return {
            x: x,
            y: y,
            width: width,
            height: lineHeight * text.length
        };
    }

}

;// CONCATENATED MODULE: ./src/common/overlay/levelRenderer/SmicImage.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


/**
 * @private
 * @class  LevelRenderer.Shape.SmicImage
 * @category Visualization Theme
 * @classdesc 图片绘制。
 * @extends LevelRenderer.Shape
 * @example
 *   var shape = new LevelRenderer.Shape.SmicImage({
 *         style: {
 *             image: 'test.jpg',
 *             x: 100,
 *             y: 100
 *         }
 *   });
 *   levelRenderer.addShape(shape);
 * @param {Array} options - shape 的配置（options）项，可以是 shape 的自有属性，也可以是自定义的属性。
 *
 */
class SmicImage extends Shape_Shape {
    constructor(options) {
        super(options);
        /**
         * @member {string} LevelRenderer.Shape.SmicImage.prototype.type
         * @description  图形类型。
         */
        this.type = 'smicimage';

        /**
         * @member {string} LevelRenderer.Shape.SmicImage.prototype._imageCache
         * @description 图片缓存。
         */
        this._imageCache = {};
        if (!this.refOriginalPosition || this.refOriginalPosition.length !== 2) {
            this.refOriginalPosition = [0, 0];
        }
        this.CLASS_NAME = "SuperMap.LevelRenderer.Shape.SmicImage";
    }


    /**
     * @function LevelRenderer.Shape.SmicImage.prototype.destroy
     * @description 销毁对象，释放资源。调用此函数后所有属性将被置为 null。
     */
    destroy() {
        this.type = null;
        this._imageCache = null;
        super.destroy();
    }


    /**
     * @function LevelRenderer.Shape.SmicImage.prototype.buildPath
     * @description 创建图片。
     *
     * @param {CanvasRenderingContext2D} ctx - Context2D 上下文。
     * @param {Object} style - style。
     *
     */
    brush(ctx, isHighlight, refresh) {
        if (!this.refOriginalPosition || this.refOriginalPosition.length !== 2) {
            this.refOriginalPosition = [0, 0];
        }
        var __OP = this.refOriginalPosition;

        var style = this.style || {};

        if (isHighlight) {
            // 根据style扩展默认高亮样式
            style = this.getHighlightStyle(
                style, this.highlightStyle || {}
            );
        }

        var image = style.image;
        var me = this;

        if (typeof(image) === 'string') {
            var src = image;
            if (this._imageCache[src]) {
                image = this._imageCache[src];
            } else {
                image = new Image();
                image.onload = function () {
                    image.onload = null;
                    clearTimeout(SmicImage._refreshTimeout);
                    SmicImage._needsRefresh.push(me);
                    // 防止因为缓存短时间内触发多次onload事件
                    SmicImage._refreshTimeout = setTimeout(function () {
                        refresh && refresh(SmicImage._needsRefresh);
                        // 清空 needsRefresh
                        SmicImage._needsRefresh = [];
                    }, 10);
                };

                image.src = src;
                this._imageCache[src] = image;
            }
        }
        if (image) {
            // 图片已经加载完成
            if (image.nodeName.toUpperCase() == 'IMG') {
                if (window.ActiveXObject) {
                    if (image.readyState != 'complete') {
                        return;
                    }
                } else {
                    if (!image.complete) {
                        return;
                    }
                }
            }
            // Else is canvas
            var width = style.width || image.width;
            var height = style.height || image.height;
            var x = style.x + __OP[0];
            var y = style.y + __OP[1];

            // 图片加载失败
            if (!image.width || !image.height) {
                return;
            }

            ctx.save();

            this.doClip(ctx);

            this.setContext(ctx, style);

            // 设置transform
            this.setTransform(ctx);

            if (style.sWidth && style.sHeight) {
                let sx = (style.sx + __OP[0]) || 0;
                let sy = (style.sy + __OP[1]) || 0;
                ctx.drawImage(
                    image,
                    sx, sy, style.sWidth, style.sHeight,
                    x, y, width, height
                );
            } else if (style.sx && style.sy) {
                let sx = style.sx + __OP[0];
                let sy = style.sy + __OP[1];
                var sWidth = width - sx;
                var sHeight = height - sy;
                ctx.drawImage(
                    image,
                    sx, sy, sWidth, sHeight,
                    x, y, width, height
                );
            } else {
                ctx.drawImage(image, x, y, width, height);
            }
            // 如果没设置宽和高的话自动根据图片宽高设置
            if (!style.width) {
                style.width = width;
            }
            if (!style.height) {
                style.height = height;
            }
            if (!this.style.width) {
                this.style.width = width;
            }
            if (!this.style.height) {
                this.style.height = height;
            }

            this.drawText(ctx, style, this.style);

            ctx.restore();
        }
    }


    /**
     * @function LevelRenderer.Shape.SmicImage.prototype.getRect
     * @description 计算返回图片的包围盒矩形。
     *
     * @param {Object} style - style
     * @return {Object} 边框对象。包含属性：x，y，width，height。
     */
    getRect(style) {
        if (!this.refOriginalPosition || this.refOriginalPosition.length !== 2) {
            this.refOriginalPosition = [0, 0];
        }
        var __OP = this.refOriginalPosition;

        return {
            x: style.x + __OP[0],
            y: style.y + __OP[1],
            width: style.width,
            height: style.height
        };
    }


    /**
     * @function LevelRenderer.Shape.SmicImage.prototype.clearCache
     * @description 清除图片缓存。
     *
     * @param {Object} style - style
     * @return {Object} 边框对象。包含属性：x，y，width，height。
     *
     */
    clearCache() {
        this._imageCache = {};
    }

}
SmicImage._needsRefresh = [];
SmicImage._refreshTimeout = null;

;// CONCATENATED MODULE: ./src/common/overlay/levelRenderer/Painter.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/







/**
 * @private
 * @class  LevelRenderer.Painter
 * @category Visualization Theme
 * @classdesc Painter 绘图模块。
 * @param {HTMLElement} root - 绘图区域（DIV）。
 * @param {LevelRenderer.Storage} storage - Storage 实例。
 */
class Painter {
    constructor(root, storage) {
        /**
         * @member {HTMLElement} LevelRenderer.Painter.prototype.root
         * @description  绘图容器。
         *
         */
        this.root = root;

        /**
         * @member {Array} LevelRenderer.Painter.prototype.storage
         * @description 图形仓库。
         *
         */
        this.storage = storage;

        /**
         * @member {HTMLElement} LevelRenderer.Painter.prototype._domRoot
         * @description 容器根 dom 对象。
         *
         */
        this._domRoot = null;

        /**
         * @member {Object} LevelRenderer.Painter.prototype._layers
         * @description 绘制层对象。
         *
         */
        this._layers = {};

        /**
         * @member {Array} LevelRenderer.Painter.prototype._zlevelList
         * @description  层列表。
         *
         */
        this._zlevelList = [];

        /**
         * @member {Object} LevelRenderer.Painter.prototype._layerConfig
         * @description 绘制层配置对象。
         *
         */
        this._layerConfig = {};

        /**
         * @member {Object} LevelRenderer.Painter.prototype._bgDom
         * @description 背景层 Canvas （Dom）。
         *
         */
        this._bgDom = null;

        /**
         * @member {function} LevelRenderer.Painter.prototype.shapeToImage
         * @description 形状转图像函数。
         *
         */
        this.shapeToImage = null;
        // retina 屏幕优化
        Painter.devicePixelRatio = Math.max((window.devicePixelRatio || 1), 1);

        this.CLASS_NAME = "SuperMap.LevelRenderer.Painter";
        this.root.innerHTML = '';
        this._width = this._getWidth(); // 宽，缓存记录
        this._height = this._getHeight(); // 高，缓存记录

        var domRoot = document.createElement('div');
        this._domRoot = domRoot;

        // domRoot.onselectstart = returnFalse; // 避免页面选中的尴尬
        domRoot.style.position = 'relative';
        domRoot.style.overflow = 'hidden';
        domRoot.style.width = this._width + 'px';
        domRoot.style.height = this._height + 'px';
        this.root.appendChild(domRoot);

        this.shapeToImage = this._createShapeToImageProcessor();

        // 创建各层canvas
        // 背景
        //this._bgDom = Painter.createDom('bg', 'div', this);
        this._bgDom = Painter.createDom(Util_Util.createUniqueID("SuperMap.Theme_background_"), 'div', this);
        domRoot.appendChild(this._bgDom);
        this._bgDom.onselectstart = returnFalse;
        this._bgDom.style['-webkit-user-select'] = 'none';
        this._bgDom.style['user-select'] = 'none';
        this._bgDom.style['-webkit-touch-callout'] = 'none';

        // 高亮
        //var hoverLayer = new PaintLayer('_hoverLayer_', this);
        var hoverLayer = new PaintLayer(Util_Util.createUniqueID("_highLightLayer_"), this);
        this._layers['hover'] = hoverLayer;
        domRoot.appendChild(hoverLayer.dom);
        hoverLayer.initContext();

        hoverLayer.dom.onselectstart = returnFalse;
        hoverLayer.dom.style['-webkit-user-select'] = 'none';
        hoverLayer.dom.style['user-select'] = 'none';
        hoverLayer.dom.style['-webkit-touch-callout'] = 'none';

        var me = this;
        this.updatePainter = function (shapeList, callback) {
            me.refreshShapes(shapeList, callback);
        };

        // 返回false的方法，用于避免页面被选中
        function returnFalse() {
            return false;
        }

        /* eslint-disable */
        // 什么都不干的空方法
        function doNothing() {  //NOSONAR
        }
        /* eslint-enable */
    }


    /**
     * @function LevelRenderer.Painter.prototype.destroy
     * @description 销毁对象，释放资源。调用此函数后所有属性将被置为 null。
     */
    destroy() {
        this.dispose();
        this._zlevelList = null;
        this._layerConfig = null;
        this._bgDom = null;
        this.shapeToImage = null;
    }


    /**
     * @function LevelRenderer.Painter.prototype.render
     * @description 渲染。首次绘图，创建各种 dom 和 context。
     *
     * @param {function} callback - 绘画结束后的回调函数。
     * @return {LevelRenderer.Painter} this。
     */
    render(callback) {
        // TODO
        this.refresh(callback, true);

        return this;
    }


    /**
     * @function LevelRenderer.Painter.prototype.refresh
     * @description 刷新。
     *
     * @param {function} callback - 刷新结束后的回调函数。
     * @param {boolean} paintAll - 强制绘制所有 shape。
     * @return {LevelRenderer.Painter} this。
     */
    refresh(callback, paintAll) {
        var list = this.storage.getShapeList(true);
        this._paintList(list, paintAll);

        if (typeof callback == 'function') {
            callback();
        }

        return this;
    }


    /**
     * Method: _paintList
     * 按列表绘制图形。
     */
    _paintList(list, paintAll) {
        if (typeof(paintAll) == 'undefined') {
            paintAll = false;
        }

        this._updateLayerStatus(list);

        var currentLayer;
        var currentZLevel;
        var ctx;

        for (var id in this._layers) {
            if (id !== 'hover') {
                this._layers[id].unusedCount++;
                this._layers[id].updateTransform();
            }
        }

        var invTransform = [];

        for (var i = 0, l = list.length; i < l; i++) {
            var shape = list[i];

            if (currentZLevel !== shape.zlevel) {
                if (currentLayer && currentLayer.needTransform) {
                    ctx.restore();
                }

                currentLayer = this.getLayer(shape.zlevel);
                ctx = currentLayer.ctx;
                currentZLevel = shape.zlevel;

                // Reset the count
                currentLayer.unusedCount = 0;

                if (currentLayer.dirty || paintAll) {
                    currentLayer.clear();
                }

                if (currentLayer.needTransform) {
                    ctx.save();
                    currentLayer.setTransform(ctx);
                }
            }

            // Start group clipping
            if (ctx && shape.__startClip) {
                var clipShape = shape.__startClip;
                ctx.save();
                // Set transform
                if (clipShape.needTransform) {
                    let m = clipShape.transform;
                    SUtil_SUtil.Util_matrix.invert(invTransform, m);
                    ctx.transform(
                        m[0], m[1],
                        m[2], m[3],
                        m[4], m[5]
                    );
                }

                ctx.beginPath();
                clipShape.buildPath(ctx, clipShape.style);
                ctx.clip();

                // Transform back
                if (clipShape.needTransform) {
                    let m = invTransform;
                    ctx.transform(
                        m[0], m[1],
                        m[2], m[3],
                        m[4], m[5]
                    );
                }
            }

            if (((currentLayer && currentLayer.dirty) || paintAll) && !shape.invisible) {
                if (
                    !shape.onbrush
                    || (shape.onbrush && !shape.onbrush(ctx, false))
                ) {
                    if (Config.catchBrushException) {
                        try {
                            shape.brush(ctx, false, this.updatePainter);
                        } catch (error) {
                            SUtil_SUtil.Util_log(
                                error,
                                'brush error of ' + shape.type,
                                shape
                            );
                        }
                    } else {
                        shape.brush(ctx, false, this.updatePainter);
                    }
                }
            }

            // Stop group clipping
            if (ctx && shape.__stopClip) {
                ctx.restore();
            }

            shape.__dirty = false;
        }

        if (ctx && currentLayer && currentLayer.needTransform) {
            ctx.restore();
        }

        for (let id in this._layers) {
            if (id !== 'hover') {
                var layer = this._layers[id];
                layer.dirty = false;
                // 删除过期的层
                // PENDING
                // if (layer.unusedCount >= 500) {
                //     this.delLayer(id);
                // }
                if (layer.unusedCount == 1) {
                    layer.clear();
                }
            }
        }

    }


    /**
     * @function LevelRenderer.Painter.prototype.getLayer
     * @description 获取 zlevel 所在层，如果不存在则会创建一个新的层。
     *
     * @param {number} zlevel - zlevel。
     * @return {LevelRenderer.Painter} this。
     */
    getLayer(zlevel) {
        // Change draw layer
        var currentLayer = this._layers[zlevel];
        if (!currentLayer) {
            var len = this._zlevelList.length;
            var prevLayer = null;
            var i = -1;
            if (len > 0 && zlevel > this._zlevelList[0]) {
                for (i = 0; i < len - 1; i++) {
                    if (
                        this._zlevelList[i] < zlevel
                        && this._zlevelList[i + 1] > zlevel
                    ) {
                        break;
                    }
                }
                prevLayer = this._layers[this._zlevelList[i]];
            }
            this._zlevelList.splice(i + 1, 0, zlevel);

            // Create a new layer
            //currentLayer = new PaintLayer(zlevel, this);
            currentLayer = new PaintLayer(Util_Util.createUniqueID("_levelLayer_" + zlevel), this);
            var prevDom = prevLayer ? prevLayer.dom : this._bgDom;
            if (prevDom.nextSibling) {
                prevDom.parentNode.insertBefore(
                    currentLayer.dom,
                    prevDom.nextSibling
                );
            } else {
                prevDom.parentNode.appendChild(
                    currentLayer.dom
                );
            }
            currentLayer.initContext();

            this._layers[zlevel] = currentLayer;

            if (this._layerConfig[zlevel]) {
                new levelRenderer_Util_Util().merge(currentLayer, this._layerConfig[zlevel], true);
            }

            currentLayer.updateTransform();
        }

        return currentLayer;
    }


    /**
     * @function LevelRenderer.Painter.prototype.getLayers
     * @description 获取所有已创建的层。
     * @return {Array.<Painter.Layer>} 已创建的层
     */
    getLayers() {
        return this._layers;
    }


    /**
     * Method: _updateLayerStatus
     * 更新绘制层状态。
     */
    _updateLayerStatus(list) {
        var layers = this._layers;

        var elCounts = {};
        for (let z in layers) {
            if (z !== 'hover') {
                elCounts[z] = layers[z].elCount;
                layers[z].elCount = 0;
            }
        }

        for (let i = 0; i < list.length; i++) {
            var shape = list[i];
            var zlevel = shape.zlevel;
            var layer = layers[zlevel];
            if (layer) {
                layer.elCount++;
                // 已经被标记为需要刷新
                if (layer.dirty) {
                    continue;
                }
                layer.dirty = shape.__dirty;
            }
        }

        // 层中的元素数量有发生变化
        for (let z in layers) {
            if (z !== 'hover') {
                if (elCounts[z] !== layers[z].elCount) {
                    layers[z].dirty = true;
                }
            }
        }
    }


    /**
     * @function LevelRenderer.Painter.prototype.refreshShapes
     * @description 更新的图形元素列表。
     *
     * @param {number} shapeList - 需要更新的图形元素列表。
     * @param {number} callback - 视图更新后回调函数。
     * @return {LevelRenderer.Painter} this。
     */
    refreshShapes(shapeList, callback) {
        for (var i = 0, l = shapeList.length; i < l; i++) {
            var shape = shapeList[i];
            this.storage.mod(shape.id);
        }

        this.refresh(callback);
        return this;
    }


    /**
     * @function LevelRenderer.Painter.prototype.clear
     * @description 清除 hover 层外所有内容。
     * @return {LevelRenderer.Painter} this。
     */
    clear() {
        for (var k in this._layers) {
            if (k == 'hover') {
                continue;
            }
            this._layers[k].clear();
        }

        return this;
    }


    /**
     * @function LevelRenderer.Painter.prototype.modLayer
     * @description 修改指定 zlevel 的绘制参数。
     *
     * @param {string} zlevel - zlevel。
     * @param {Object} config - 配置对象。
     * @param {string} [config.clearColor=0] - 每次清空画布的颜色。
     * @param {boolean} [config.motionBlur=false] - 是否开启动态模糊。
     * @param {number} [config.lastFrameAlpha=0.7] - 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显。默认值：0.7。
     * @param {Array.<number>} config.position - 层的平移。
     * @param {Array.<number>} config.rotation - 层的旋转。
     * @param {Array.<number>} config.scale - 层的缩放。
     * @param {boolean} config.zoomable - 层是否支持鼠标缩放操作。默认值：false。
     * @param {boolean} config.panable - 层是否支持鼠标平移操作。默认值：false。
     *
     */
    modLayer(zlevel, config) {
        if (config) {
            if (!this._layerConfig[zlevel]) {
                this._layerConfig[zlevel] = config;
            } else {
                new levelRenderer_Util_Util().merge(this._layerConfig[zlevel], config, true);
            }

            var layer = this._layers[zlevel];

            if (layer) {
                new levelRenderer_Util_Util().merge(layer, this._layerConfig[zlevel], true);
            }
        }
    }


    /**
     * @function LevelRenderer.Painter.prototype.delLayer
     * @description 删除指定层。
     *
     * @param {string} zlevel - 层所在的 zlevel。
     */
    delLayer(zlevel) {
        var layer = this._layers[zlevel];
        if (!layer) {
            return;
        }
        // Save config
        this.modLayer(zlevel, {
            position: layer.position,
            rotation: layer.rotation,
            scale: layer.scale
        });
        layer.dom.parentNode.removeChild(layer.dom);
        delete this._layers[zlevel];

        this._zlevelList.splice(new levelRenderer_Util_Util().indexOf(this._zlevelList, zlevel), 1);
    }


    /**
     * @function LevelRenderer.Painter.prototype.refreshHover
     * @description 刷新 hover 层。
     * @return {LevelRenderer.Painter} this。
     */
    refreshHover() {
        this.clearHover();
        var list = this.storage.getHoverShapes(true);
        for (var i = 0, l = list.length; i < l; i++) {
            this._brushHover(list[i]);
        }
        this.storage.delHover();

        return this;
    }


    /**
     * @function LevelRenderer.Painter.prototype.clearHover
     * @description 清除 hover 层所有内容。
     * @return {LevelRenderer.Painter} this。
     */
    clearHover() {
        var hover = this._layers.hover;
        hover && hover.clear();

        return this;
    }


    /**
     * @function LevelRenderer.Painter.prototype.resize
     * @description 区域大小变化后重绘。
     * @return {LevelRenderer.Painter} this。
     */
    resize() {
        var domRoot = this._domRoot;
        domRoot.style.display = 'none';

        var width = this._getWidth();
        var height = this._getHeight();

        domRoot.style.display = '';

        // 优化没有实际改变的resize
        if (this._width != width || height != this._height) {
            this._width = width;
            this._height = height;

            domRoot.style.width = width + 'px';
            domRoot.style.height = height + 'px';

            for (var id in this._layers) {

                this._layers[id].resize(width, height);
            }

            this.refresh(null, true);
        }

        return this;
    }


    /**
     * @function LevelRenderer.Painter.prototype.clearLayer
     * @description 清除指定的一个层。
     * @param {number} zLevel - 层。
     */
    clearLayer(zLevel) {
        var layer = this._layers[zLevel];
        if (layer) {
            layer.clear();
        }
    }


    /**
     * @function LevelRenderer.Painter.prototype.dispose
     * @description 释放。
     *
     */
    dispose() {
        this.root.innerHTML = '';

        this.root = null;
        this.storage = null;
        this._domRoot = null;
        this._layers = null;
    }


    /**
     * @function LevelRenderer.Painter.prototype.getDomHover
     * @description 获取 Hover 层的 Dom。
     */
    getDomHover() {
        return this._layers.hover.dom;
    }


    /**
     * @function LevelRenderer.Painter.prototype.toDataURL
     * @description 图像导出。
     * @param {string} type - 图片类型。
     * @param {string} backgroundColor - 背景色。默认值：'#fff'。
     * @param {Object} args
     * @return {string} 图片的Base64 url。
     */
    toDataURL(type, backgroundColor, args) {
        //var imageDom = Painter.createDom('image', 'canvas', this);
        var imageDom = Painter.createDom(Util_Util.createUniqueID("SuperMap.Theme.image_"), 'canvas', this);
        this._bgDom.appendChild(imageDom);
        var ctx = imageDom.getContext('2d');
        Painter.devicePixelRatio != 1
        && ctx.scale(Painter.devicePixelRatio, Painter.devicePixelRatio);

        ctx.fillStyle = backgroundColor || '#fff';
        ctx.rect(
            0, 0,
            this._width * Painter.devicePixelRatio,
            this._height * Painter.devicePixelRatio
        );
        ctx.fill();

        var self = this;
        // 升序遍历，shape上的zlevel指定绘画图层的z轴层叠

        this.storage.iterShape(
            function (shape) {
                if (!shape.invisible) {
                    if (!shape.onbrush // 没有onbrush
                        // 有onbrush并且调用执行返回false或undefined则继续粉刷
                        || (shape.onbrush && !shape.onbrush(ctx, false))
                    ) {
                        if (Config.catchBrushException) {
                            try {
                                shape.brush(ctx, false, self.updatePainter);
                            } catch (error) {
                                SUtil_SUtil.Util_log(
                                    error,
                                    'brush error of ' + shape.type,
                                    shape
                                );
                            }
                        } else {
                            shape.brush(ctx, false, self.updatePainter);
                        }
                    }
                }
            },
            {normal: 'up', update: true}
        );
        var image = imageDom.toDataURL(type, args);
        ctx = null;
        this._bgDom.removeChild(imageDom);
        return image;
    }


    /**
     * @function LevelRenderer.Painter.prototype.getWidth
     * @description  获取绘图区域宽度。
     * @return {number} 绘图区域宽度。
     */
    getWidth() {
        return this._width;
    }


    /**
     * @function LevelRenderer.Painter.prototype.getHeight
     * @description 获取绘图区域高度。
     * @return {number} 绘图区域高度。
     */
    getHeight() {
        return this._height;
    }


    /**
     * Method: _getWidth
     *
     */
    _getWidth() {
        var root = this.root;
        var stl = root.currentStyle
            || document.defaultView.getComputedStyle(root);

        return ((root.clientWidth || parseInt(stl.width, 10))
            - parseInt(stl.paddingLeft, 10) // 请原谅我这比较粗暴
            - parseInt(stl.paddingRight, 10)).toFixed(0) - 0;
    }


    /**
     * Method: _getHeight
     *
     */
    _getHeight() {
        var root = this.root;
        var stl = root.currentStyle
            || document.defaultView.getComputedStyle(root);

        return ((root.clientHeight || parseInt(stl.height, 10))
            - parseInt(stl.paddingTop, 10) // 请原谅我这比较粗暴
            - parseInt(stl.paddingBottom, 10)).toFixed(0) - 0;
    }


    /**
     * Method: _brushHover
     *
     */
    _brushHover(shape) {
        var ctx = this._layers.hover.ctx;

        if (!shape.onbrush // 没有onbrush
            // 有onbrush并且调用执行返回false或undefined则继续粉刷
            || (shape.onbrush && !shape.onbrush(ctx, true))
        ) {
            var layer = this.getLayer(shape.zlevel);
            if (layer.needTransform) {
                ctx.save();
                layer.setTransform(ctx);
            }
            // Retina 优化
            if (Config.catchBrushException) {
                try {
                    shape.brush(ctx, true, this.updatePainter);
                } catch (error) {
                    SUtil_SUtil.Util_log(
                        error, 'hoverBrush error of ' + shape.type, shape
                    );
                }
            } else {
                shape.brush(ctx, true, this.updatePainter);
            }
            if (layer.needTransform) {
                ctx.restore();
            }
        }

    }


    /**
     * Method: _shapeToImage
     *
     */
    _shapeToImage(id, shape, width, height, devicePixelRatio) {
        var canvas = document.createElement('canvas');
        var ctx = canvas.getContext('2d');
        var _devicePixelRatio = devicePixelRatio || window.devicePixelRatio || 1;

        canvas.style.width = width + 'px';
        canvas.style.height = height + 'px';
        canvas.setAttribute('width', width * _devicePixelRatio);
        canvas.setAttribute('height', height * _devicePixelRatio);

        ctx.clearRect(0, 0, width * _devicePixelRatio, height * _devicePixelRatio);

        var shapeTransform = {
            position: shape.position,
            rotation: shape.rotation,
            scale: shape.scale
        };
        shape.position = [0, 0, 0];
        shape.rotation = 0;
        shape.scale = [1, 1];
        if (shape) {
            shape.brush(ctx, false);
        }

        var imgShape = new SmicImage({
            id: id,
            style: {
                x: 0,
                y: 0,
                image: canvas
            }
        });

        if (shapeTransform.position != null) {
            imgShape.position = shape.position = shapeTransform.position;
        }

        if (shapeTransform.rotation != null) {
            imgShape.rotation = shape.rotation = shapeTransform.rotation;
        }

        if (shapeTransform.scale != null) {
            imgShape.scale = shape.scale = shapeTransform.scale;
        }

        return imgShape;
    }


    /**
     * Method: _createShapeToImageProcessor
     *
     */
    _createShapeToImageProcessor() {
        var me = this;

        return function (id, e, width, height) {
            return me._shapeToImage(
                id, e, width, height, Painter.devicePixelRatio
            );
        };
    }


    // SMIC-方法扩展 - start
    /**
     * @function LevelRenderer.Painter.prototype.updateHoverLayer
     * @description 更新设置显示高亮图层。
     * @param {Array} shapes - 图形数组。
     */
    updateHoverLayer(shapes) {
        if (!(shapes instanceof Array)) {
            return this;
        }

        //清除高亮
        this.clearHover();
        this.storage.delHover();

        for (var i = 0; i < shapes.length; i++) {
            this.storage.addHover(shapes[i]);
            this._brushHover(shapes[i]);
        }
    }


    /**
     * @function LevelRenderer.Painter.prototype.createDom
     * @description 创建 Dom。
     *
     * @param {string} id - Dom id
     * @param {string} type - Dom type
     * @param {LevelRenderer.Painter} painter - Painter 实例。
     * @return {Object} Dom
     */
    static createDom(id, type, painter) {
        var newDom = document.createElement(type);
        var width = painter._width;
        var height = painter._height;

        // 没append呢，请原谅我这样写，清晰~
        newDom.style.position = 'absolute';
        newDom.style.left = 0;
        newDom.style.top = 0;
        newDom.style.width = width + 'px';
        newDom.style.height = height + 'px';
        newDom.setAttribute('width', width * Painter.devicePixelRatio);
        newDom.setAttribute('height', height * Painter.devicePixelRatio);

        // id不作为索引用，避免可能造成的重名，定义为私有属性
        //newDom.setAttribute('data-zr-dom-id', id);
        newDom.setAttribute('id', id);
        return newDom;
    }
}

/**
 * @private
 * @class Painter.Layer
 * @classdesc 绘制层类。
 * @extends LevelRenderer.Transformable
 */
class PaintLayer extends Transformable {

    /**
     * @function Painter.Layer.constructor
     * @description 构造函数。
     *
     * @param {string} id - id。
     * @param {LevelRenderer.Painter} painter - Painter 实例。
     *
     */
    constructor(id, painter) {
        super(id, painter);
        /**
         * @member {Object} Painter.Layer.prototype.dom
         * @description  dom。
         */
        this.dom = null;

        /**
         * @member {Object} Painter.Layer.prototype.domBack
         * @description domBack。
         */
        this.domBack = null;

        /**
         * @member {Object} Painter.Layer.prototype.ctxBack
         * @description ctxBack。
         */
        this.ctxBack = null;

        /**
         * @member {LevelRenderer.Painter} Painter.Layer.prototype.painter
         * @description painter。
         */
        this.painter = painter;

        /**
         * @member {number} Painter.Layer.prototype.unusedCount
         * @description unusedCount。
         */
        this.unusedCount = 0;

        /**
         * @member {Object} Painter.Layer.prototype.config
         * @description  config。
         */
        this.config = null;

        /**
         * @member {boolean} Painter.Layer.prototype.dirty
         * @description dirty。
         */
        this.dirty = true;

        /**
         * @member {number} Painter.Layer.prototype.elCount
         * @description elCount。
         */
        this.elCount = 0;

        // Configs
        /**
         * @member {string} Painter.Layer.prototype.clearColor
         * @description 每次清空画布的颜色。默认值：0；
         */
        this.clearColor = 0;

        /**
         * @member {boolean} Painter.Layer.prototype.motionBlur
         * @description 是否开启动态模糊。默认值：false；
         */
        this.motionBlur = false;

        /**
         * @member {number} Painter.Layer.prototype.lastFrameAlpha
         * @description 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显
         */
        this.lastFrameAlpha = 0.7;

        /**
         * @member {boolean} Painter.Layer.prototype.zoomable
         * @description 层是否支持鼠标平移操作。默认值：false；
         */
        this.zoomable = false;

        /**
         * @member {boolean} Painter.Layer.prototype.panable
         * @description 层是否支持鼠标缩放操作。默认值：false；
         */
        this.panable = false;

        /**
         * @member {number} Painter.Layer.prototype.maxZoom
         * @description maxZoom。默认值：Infinity。
         */
        this.maxZoom = Infinity;

        /**
         * @member {number} Painter.Layer.prototype.minZoom
         * @description minZoom。默认值：0。
         */
        this.minZoom = 0;

        /**
         * @member {number} Painter.Layer.prototype.ctx
         * @description Canvas 上下文。
         */
        this.ctx = null;
        this.dom = Painter.createDom(Util_Util.createUniqueID("SuperMap.Theme" + id), 'canvas', painter);
        this.dom.onselectstart = returnFalse; // 避免页面选中的尴尬
        this.dom.style['-webkit-user-select'] = 'none';
        this.dom.style['user-select'] = 'none';
        this.dom.style['-webkit-touch-callout'] = 'none';
        // Function
        // 返回false的方法，用于避免页面被选中
        function returnFalse() {
            return false;
        }
        this.CLASS_NAME = "SuperMap.LevelRenderer.Painter.Layer";
    }

    /**
     * @function Painter.Layer.prototype.destroy
     * @description 销毁对象，释放资源。调用此函数后所有属性将被置为 null。
     */
    destroy() {
        this.dom = null;
        this.domBack = null;
        this.ctxBack = null;
        this.painter = null;
        this.unusedCount = null;
        this.config = null;
        this.dirty = null;
        this.elCount = null;
        this.clearColor = null;
        this.motionBlur = null;
        this.lastFrameAlpha = null;
        this.zoomable = null;
        this.panable = null;
        this.maxZoom = null;
        this.minZoom = null;
        this.ctx = null;

        Transformable.destroy.apply(this, arguments);
    }

    /**
     * @function Painter.Layer.prototype.initContext
     * @description 初始化 Canvan 2D 上下文。
     */
    initContext() {
        this.ctx = this.dom.getContext('2d');
        if (Painter.devicePixelRatio != 1) {
            this.ctx.scale(Painter.devicePixelRatio, Painter.devicePixelRatio);
        }
    }

    /**
     * @function Painter.Layer.prototype.createBackBuffer
     * @description  创建备份缓冲。
     */
    createBackBuffer() {
        this.domBack = Painter.createDom(Util_Util.createUniqueID("SuperMap.Theme.back-" + this.id), 'canvas', this.painter);
        this.ctxBack = this.domBack.getContext('2d');

        if (Painter.devicePixelRatio != 1) {
            this.ctxBack.scale(Painter.devicePixelRatio, Painter.devicePixelRatio);
        }
    }

    /**
     * @function Painter.Layer.prototype.resize
     * @description 改变大小。
     *
     * @param {number} width - 宽。
     * @param {number} height - 高。
     */
    resize(width, height) {
        this.dom.style.width = width + 'px';
        this.dom.style.height = height + 'px';

        this.dom.setAttribute('width', width * Painter.devicePixelRatio);
        this.dom.setAttribute('height', height * Painter.devicePixelRatio);

        if (Painter.devicePixelRatio != 1) {
            this.ctx.scale(Painter.devicePixelRatio, Painter.devicePixelRatio);
        }

        if (this.domBack) {
            this.domBack.setAttribute('width', width * Painter.devicePixelRatio);
            this.domBack.setAttribute('height', height * Painter.devicePixelRatio);

            if (Painter.devicePixelRatio != 1) {
                this.ctxBack.scale(Painter.devicePixelRatio, Painter.devicePixelRatio);
            }
        }
    }

    /**
     * @function Painter.Layer.prototype.clear
     * @description 清空该层画布。
     */
    clear() {
        var dom = this.dom;
        var ctx = this.ctx;
        var width = dom.width;
        var height = dom.height;

        var haveClearColor = this.clearColor;
        var haveMotionBLur = this.motionBlur;
        var lastFrameAlpha = this.lastFrameAlpha;

        if (haveMotionBLur) {
            if (!this.domBack) {
                this.createBackBuffer();
            }

            this.ctxBack.globalCompositeOperation = 'copy';
            this.ctxBack.drawImage(
                dom, 0, 0,
                width / Painter.devicePixelRatio,
                height / Painter.devicePixelRatio
            );
        }

        if (haveClearColor) {
            ctx.save();
            ctx.fillStyle = this.config.clearColor;
            ctx.fillRect(
                0, 0,
                width / Painter.devicePixelRatio,
                height / Painter.devicePixelRatio
            );
            ctx.restore();
        } else {
            ctx.clearRect(
                0, 0,
                width / Painter.devicePixelRatio,
                height / Painter.devicePixelRatio
            );
        }

        if (haveMotionBLur) {
            var domBack = this.domBack;
            ctx.save();
            ctx.globalAlpha = lastFrameAlpha;
            ctx.drawImage(
                domBack, 0, 0,
                width / Painter.devicePixelRatio,
                height / Painter.devicePixelRatio
            );
            ctx.restore();
        }
    }

}

;// CONCATENATED MODULE: ./src/common/overlay/levelRenderer/Handler.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/




/**
 * @private
 * @class  LevelRenderer.Handler
 * @category Visualization Theme
 * @classdesc Handler控制模块。
 * @extends {LevelRenderer.Eventful}
 * @param {HTMLElement} root - 绘图区域。
 * @param {LevelRenderer.Storage} storage - Storage 实例。
 * @param {LevelRenderer.Painter} painter - Painter 实例。
 */
class Handler extends Eventful {
    constructor(root, storage, painter) {
        super(root, storage, painter);
        /**
         * @member {HTMLElement} LevelRenderer.Handler.prototype.root
         * @description 绘图区域
         */
        this.root = root;
        /**
         * @member {LevelRenderer.Storage} LevelRenderer.Handler.prototype.storage
         * @description Storage 实例
         */
        this.storage = storage;
        /**
         * @member {LevelRenderer.Painter} LevelRenderer.Handler.prototype.Painter
         * @description Painter 实例
         */
        this.painter = painter;
        /**
         * @member {number} [LevelRenderer.Handler.prototype._lastX=0]
         * @description 上一次鼠标位置x坐标值
         */
        this._lastX = 0;
        /**
         * @member {number} [LevelRenderer.Handler.prototype._lastY=0]
         * @description 上一次鼠标位置y坐标值
         */
        this._lastY = 0;
        /**
         * @member {number} [LevelRenderer.Handler.prototype._mouseX=0]
         * @description 当前鼠标位置x坐标值
         */
        this._mouseX = 0;
        /**
         * @member {number} [LevelRenderer.Handler.prototype._mouseY=0]
         * @description 当前鼠标位置y坐标值
         */
        this._mouseY = 0;
        /**
         * @member {function} LevelRenderer.Handler.prototype._findHover
         * @description 查找 Hover 图形
         */
        this._findHover = null;
        /**
         * @member {Object} LevelRenderer.Handler.prototype._domHover
         * @description 高亮 DOM
         */
        this._domHover = null;

        // 各种事件标识的私有变量
        // this._hasfound = false;              // 是否找到 hover 图形元素
        // this._lastHover = null;              // 最后一个 hover 图形元素
        // this._mouseDownTarget = null;
        // this._draggingTarget = null;         // 当前被拖拽的图形元素
        // this._isMouseDown = false;
        // this._isDragging = false;
        // this._lastMouseDownMoment;
        // this._lastTouchMoment;
        // this._lastDownButton;

        this._findHover = bind3Arg(findHover, this);
        this._domHover = painter.getDomHover();

        this.CLASS_NAME = "SuperMap.LevelRenderer.Handler";
        var domHandlers = {
            /**
             * Method: resize
             * 窗口大小改变响应函数。
             *
             * Parameters:
             * event - {Event} event。
             *
             */
            resize: function (event) {
                event = event || window.event;
                this._lastHover = null;
                this._isMouseDown = 0;

                // 分发SuperMap.LevelRenderer.Config.EVENT.RESIZE事件，global
                this.dispatch(Config.EVENT.RESIZE, event);
            },

            /**
             * Method: click
             * 点击响应函数。
             *
             * Parameters:
             * event - {Event} event。
             *
             */
            click: function (event) {
                event = this._zrenderEventFixed(event);

                // 分发SuperMap.LevelRenderer.Config.EVENT.CLICK事件
                var _lastHover = this._lastHover;
                if ((_lastHover && _lastHover.clickable)
                    || !_lastHover
                ) {

                    // 判断没有发生拖拽才触发click事件
                    if (this._clickThreshold < 10) {
                        this._dispatchAgency(_lastHover, Config.EVENT.CLICK, event);
                    }
                }

                this._mousemoveHandler(event);
            },

            /**
             * Method: dblclick
             * 双击响应函数。
             *
             * Parameters:
             * event - {Event} event。
             *
             */
            dblclick: function (event) {
                event = event || window.event;
                event = this._zrenderEventFixed(event);

                // 分发SuperMap.LevelRenderer.Config.EVENT.DBLCLICK事件
                var _lastHover = this._lastHover;
                if ((_lastHover && _lastHover.clickable)
                    || !_lastHover
                ) {

                    // 判断没有发生拖拽才触发dblclick事件
                    if (this._clickThreshold < 5) {
                        this._dispatchAgency(_lastHover, Config.EVENT.DBLCLICK, event);
                    }
                }

                this._mousemoveHandler(event);
            },

            /**
             * Method: mousewheel
             * 鼠标滚轮响应函数。
             *
             * Parameters:
             * event - {Event} event。
             *
             */
            mousewheel: function (event) {
                event = this._zrenderEventFixed(event);

                // http://www.sitepoint.com/html5-javascript-mouse-wheel/
                // https://developer.mozilla.org/en-US/docs/DOM/DOM_event_reference/mousewheel
                var delta = event.wheelDelta // Webkit
                    || -event.detail; // Firefox
                var scale = delta > 0 ? 1.1 : 1 / 1.1;

                var layers = this.painter.getLayers();

                var needsRefresh = false;
                for (var z in layers) {
                    if (z !== 'hover') {
                        var layer = layers[z];
                        var pos = layer.position;
                        if (layer.zoomable) {
                            layer.__zoom = layer.__zoom || 1;
                            var newZoom = layer.__zoom;
                            newZoom *= scale;
                            newZoom = Math.max(
                                Math.min(layer.maxZoom, newZoom),
                                layer.minZoom
                            );
                            scale = newZoom / layer.__zoom;
                            layer.__zoom = newZoom;
                            // Keep the mouse center when scaling
                            pos[0] -= (this._mouseX - pos[0]) * (scale - 1);
                            pos[1] -= (this._mouseY - pos[1]) * (scale - 1);
                            layer.scale[0] *= scale;
                            layer.scale[1] *= scale;
                            layer.dirty = true;
                            needsRefresh = true;
                        }
                    }
                }
                if (needsRefresh) {
                    this.painter.refresh();
                }

                // 分发SuperMap.LevelRenderer.Config.EVENT.MOUSEWHEEL事件
                this._dispatchAgency(this._lastHover, Config.EVENT.MOUSEWHEEL, event);
                this._mousemoveHandler(event);
            },

            /**
             * Method: mousemove
             * 鼠标（手指）移动响应函数。
             *
             * Parameters:
             * event - {Event} event。
             *
             */
            mousemove: function (event) {
                // 拖拽不触发click事件
                this._clickThreshold++;

                event = this._zrenderEventFixed(event);
                this._lastX = this._mouseX;
                this._lastY = this._mouseY;
                this._mouseX = SUtil_SUtil.Util_event.getX(event);
                this._mouseY = SUtil_SUtil.Util_event.getY(event);
                var dx = this._mouseX - this._lastX;
                var dy = this._mouseY - this._lastY;

                // 可能出现SuperMap.LevelRenderer.Config.EVENT.DRAGSTART事件
                // 避免手抖点击误认为拖拽
                // if (this._mouseX - this._lastX > 1 || this._mouseY - this._lastY > 1) {
                this._processDragStart(event);
                // }
                this._hasfound = 0;
                this._event = event;

                this._iterateAndFindHover();

                // 找到的在迭代函数里做了处理，没找到得在迭代完后处理
                if (!this._hasfound) {
                    // 过滤首次拖拽产生的mouseout和dragLeave
                    if (!this._draggingTarget
                        || (this._lastHover && this._lastHover != this._draggingTarget)
                    ) {
                        // 可能出现SuperMap.LevelRenderer.Config.EVENT.MOUSEOUT事件
                        this._processOutShape(event);

                        // 可能出现SuperMap.LevelRenderer.Config.EVENT.DRAGLEAVE事件
                        this._processDragLeave(event);
                    }

                    this._lastHover = null;
                    this.storage.delHover();
                    this.painter.clearHover();
                }

                // set cursor for root element
                var cursor = '';

                // 如果存在拖拽中元素，被拖拽的图形元素最后addHover
                if (this._draggingTarget) {
                    this.storage.drift(this._draggingTarget.id, dx, dy);
                    this._draggingTarget.modSelf();
                    this.storage.addHover(this._draggingTarget);
                } else if (this._isMouseDown) {
                    // Layer dragging
                    var layers = this.painter.getLayers();

                    var needsRefresh = false;
                    for (var z in layers) {
                        if (z !== 'hover') {
                            var layer = layers[z];
                            if (layer.panable) {
                                // PENDING
                                cursor = 'move';
                                // Keep the mouse center when scaling
                                layer.position[0] += dx;
                                layer.position[1] += dy;
                                needsRefresh = true;
                                layer.dirty = true;
                            }
                        }
                    }
                    if (needsRefresh) {
                        this.painter.refresh();
                    }
                }

                if (this._draggingTarget || (this._hasfound && this._lastHover.draggable)) {
                    cursor = 'move';
                } else if (this._hasfound && this._lastHover.clickable) {
                    cursor = 'pointer';
                }
                this.root.style.cursor = cursor;

                // 分发SuperMap.LevelRenderer.Config.EVENT.MOUSEMOVE事件
                this._dispatchAgency(this._lastHover, Config.EVENT.MOUSEMOVE, event);

                if (this._draggingTarget || this._hasfound || this.storage.hasHoverShape()) {
                    this.painter.refreshHover();
                }
            },

            /**
             * Method: mouseout
             * 鼠标（手指）离开响应函数。
             *
             * Parameters:
             * event - {Event} event。
             *
             */
            mouseout: function (event) {
                event = this._zrenderEventFixed(event);

                var element = event.toElement || event.relatedTarget;
                if (element != this.root) {
                    while (element && element.nodeType != 9) {
                        // 忽略包含在root中的dom引起的mouseOut
                        if (element == this.root) {
                            this._mousemoveHandler(event);
                            return;
                        }

                        element = element.parentNode;
                    }
                }

                event.zrenderX = this._lastX;
                event.zrenderY = this._lastY;
                this.root.style.cursor = '';
                this._isMouseDown = 0;

                this._processOutShape(event);
                this._processDrop(event);
                this._processDragEnd(event);

                this.painter.refreshHover();

                this.dispatch(Config.EVENT.GLOBALOUT, event);
            },

            /**
             * Method: mousedown
             * 鼠标（手指）按下响应函数。
             *
             * Parameters:
             * event - {Event} event。
             *
             */
            mousedown: function (event) {
                // 重置 clickThreshold
                this._clickThreshold = 0;

                if (this._lastDownButton == 2) {
                    this._lastDownButton = event.button;
                    this._mouseDownTarget = null;
                    // 仅作为关闭右键菜单使用
                    return;
                }

                this._lastMouseDownMoment = new Date();
                event = this._zrenderEventFixed(event);
                this._isMouseDown = 1;

                // 分发SuperMap.LevelRenderer.Config.EVENT.MOUSEDOWN事件
                this._mouseDownTarget = this._lastHover;
                this._dispatchAgency(this._lastHover, Config.EVENT.MOUSEDOWN, event);
                this._lastDownButton = event.button;
            },

            /**
             * Method: mouseup
             * 鼠标（手指）抬起响应函数。
             *
             * Parameters:
             * event - {Event} event。
             *
             */
            mouseup: function (event) {
                event = this._zrenderEventFixed(event);
                this.root.style.cursor = '';
                this._isMouseDown = 0;
                this._mouseDownTarget = null;

                // 分发SuperMap.LevelRenderer.Config.EVENT.MOUSEUP事件
                this._dispatchAgency(this._lastHover, Config.EVENT.MOUSEUP, event);
                this._processDrop(event);
                this._processDragEnd(event);
            },

            /**
             * Method: touchstart
             * Touch 开始响应函数。
             *
             * Parameters:
             * event - {Event} event。
             *
             */
            touchstart: function (event) {
                // SUtil.Util_event.stop(event);// 阻止浏览器默认事件，重要
                event = this._zrenderEventFixed(event, true);
                this._lastTouchMoment = new Date();

                // 平板补充一次findHover
                this._mobildFindFixed(event);
                this._mousedownHandler(event);
            },

            /**
             * Method: touchmove
             * Touch 移动响应函数。
             *
             * Parameters:
             * event - {Event} event。
             *
             */
            touchmove: function (event) {
                event = this._zrenderEventFixed(event, true);
                this._mousemoveHandler(event);
                if (this._isDragging) {
                    SUtil_SUtil.Util_event.stop(event);// 阻止浏览器默认事件，重要
                }
            },

            /**
             * Method: touchend
             * Touch 结束响应函数。
             *
             * Parameters:
             * event - {Event} event。
             *
             */
            touchend: function (event) {
                // SUtil.Util_event.stop(event);// 阻止浏览器默认事件，重要
                event = this._zrenderEventFixed(event, true);
                this._mouseupHandler(event);

                var now = new Date();
                if (now - this._lastTouchMoment < Config.EVENT.touchClickDelay) {
                    this._mobildFindFixed(event);
                    this._clickHandler(event);
                    if (now - this._lastClickMoment < Config.EVENT.touchClickDelay / 2) {
                        this._dblclickHandler(event);
                        if (this._lastHover && this._lastHover.clickable) {
                            SUtil_SUtil.Util_event.stop(event);// 阻止浏览器默认事件，重要
                        }
                    }
                    this._lastClickMoment = now;
                }
                this.painter.clearHover();
            }
        };

        initDomHandler(this);

        // 初始化，事件绑定，支持的所有事件都由如下原生事件计算得来
        if (window.addEventListener) {
            window.addEventListener('resize', this._resizeHandler);

            if (SUtil_SUtil.Util_env.os.tablet || SUtil_SUtil.Util_env.os.phone) {
                // mobile支持
                root.addEventListener('touchstart', this._touchstartHandler);
                root.addEventListener('touchmove', this._touchmoveHandler);
                root.addEventListener('touchend', this._touchendHandler);
            } else {
                // mobile的click/move/up/down自己模拟
                root.addEventListener('click', this._clickHandler);
                root.addEventListener('dblclick', this._dblclickHandler);
                root.addEventListener('mousewheel', this._mousewheelHandler);
                root.addEventListener('mousemove', this._mousemoveHandler);
                root.addEventListener('mousedown', this._mousedownHandler);
                root.addEventListener('mouseup', this._mouseupHandler);
            }
            root.addEventListener('DOMMouseScroll', this._mousewheelHandler);
            root.addEventListener('mouseout', this._mouseoutHandler);
        } else {
            window.attachEvent('onresize', this._resizeHandler);

            root.attachEvent('onclick', this._clickHandler);
            //root.attachEvent('ondblclick ', this._dblclickHandler);
            root.ondblclick = this._dblclickHandler;
            root.attachEvent('onmousewheel', this._mousewheelHandler);
            root.attachEvent('onmousemove', this._mousemoveHandler);
            root.attachEvent('onmouseout', this._mouseoutHandler);
            root.attachEvent('onmousedown', this._mousedownHandler);
            root.attachEvent('onmouseup', this._mouseupHandler);
        }

        // 辅助函数 start
        /**
         * Method: bind1Arg
         * bind 一个参数的 function。
         *
         * Parameters:
         * handler - {function} 要 bind 的 function。
         * context - {Object} 运行时 this 环境。
         *
         * Returns:
         * {function}
         */
        function bind1Arg(handler, context) {
            return function (e) {
                return handler.call(context, e);
            };
        }

        /*
         // bind 两个参数的 function
         function bind2Arg(handler, context) {
         return function (arg1, arg2) {
         return handler.call(context, arg1, arg2);
         };
         }
         */

        // bind 三个参数的 function
        function bind3Arg(handler, context) {
            return function (arg1, arg2, arg3) {
                return handler.call(context, arg1, arg2, arg3);
            };
        }

        /**
         * Method: initDomHandler
         * 为控制类实例初始化 dom 事件处理函数。
         *
         * Parameters:
         * instance - {<LevelRenderer.Handler>} 控制类实例 。
         *
         * Returns:
         * {function}
         */
        function initDomHandler(instance) {
            var domHandlerNames = [
                'resize', 'click', 'dblclick',
                'mousewheel', 'mousemove', 'mouseout', 'mouseup', 'mousedown',
                'touchstart', 'touchend', 'touchmove'
            ];

            var len = domHandlerNames.length;
            while (len--) {
                var name = domHandlerNames[len];
                instance['_' + name + 'Handler'] = bind1Arg(domHandlers[name], instance);
            }
        }

        /**
         * Method: findHover
         * 迭代函数，查找 hover 到的图形元素并即时做些事件分发。
         *
         * Parameters:
         * shape - {Object} 图形。
         * x - {number} 鼠标 x。
         * y - {number} 鼠标 y。
         *
         * Returns:
         * {boolean} 是否找到图形。
         *
         */
        function findHover(shape, x, y) {
            var me = this;
            if (
                (me._draggingTarget && me._draggingTarget.id == shape.id) // 迭代到当前拖拽的图形上
                || shape.isSilent() // 打酱油的路过，啥都不响应的shape~
            ) {
                return false;
            }

            var event = me._event;
            if (shape.isCover(x, y)) {
                if (shape.hoverable) {
                    // SMIC-修改 - start
                    if (shape.isHoverByRefDataID && shape.isHoverByRefDataID === true) {
                        if (shape.refDataID) {
                            var fid = shape.refDataID;
                            //me.painter.clearHover();
                            //me.storage.delHover();

                            var hoverGroup = null;
                            if (shape.refDataHoverGroup) {
                                hoverGroup = shape.refDataHoverGroup;
                            }

                            //查找同一个用户数据 feature 的所有图形
                            var shapeList = me.storage._shapeList;
                            for (var i = 0, len = shapeList.length; i < len; i++) {
                                var si = shapeList[i];
                                if (si.refDataID && fid === si.refDataID) {
                                    if (hoverGroup) {
                                        if (si.refDataHoverGroup && hoverGroup === si.refDataHoverGroup) {
                                            me.storage.addHover(si);
                                        }
                                    } else {
                                        me.storage.addHover(si);
                                    }
                                }
                            }
                        }
                    } else {
                        me.storage.addHover(shape);
                    }
                    //初始代码：
                    //  me.storage.addHover(shape);
                    // SMIC-修改 - end
                }
                // 查找是否在 clipShape 中
                var p = shape.parent;
                while (p) {
                    if (p.clipShape && !p.clipShape.isCover(me._mouseX, me._mouseY)) {
                        // 已经被祖先 clip 掉了
                        return false;
                    }
                    p = p.parent;
                }

                if (me._lastHover != shape) {
                    me._processOutShape(event);

                    // 可能出现SuperMap.LevelRenderer.Config.EVENT.DRAGLEAVE事件
                    me._processDragLeave(event);

                    me._lastHover = shape;

                    // 可能出现SuperMap.LevelRenderer.Config.EVENT.DRAGENTER事件
                    me._processDragEnter(event);
                }

                me._processOverShape(event);

                // 可能出现SuperMap.LevelRenderer.Config.EVENT.DRAGOVER
                me._processDragOver(event);

                me._hasfound = 1;

                return true;    // 找到则中断迭代查找
            }

            return false;
        }

        // 辅助函数 end
    }

    /**
     * @function LevelRenderer.Handler.prototype.destroy
     * @description 销毁对象，释放资源。调用此函数后所有属性将被置为null。
     */
    destroy() {
        this.dispose();
        this._lastX = null;
        this._lastY = null;
        this._mouseX = null;
        this._mouseY = null;
        this._findHover = null;

        Eventful.prototype.destroy.apply(this, arguments);
    }


    /**
     * @function LevelRenderer.Handler.prototype.on
     * @description 自定义事件绑定。
     * @param {string} eventName - 事件名称，resize、hover、drag等。
     * @param {function} handler - 响应函数。
     * @returns {LevelRenderer.Handler} this。
     */
    on(eventName, handler) {
        this.bind(eventName, handler);
        return this;
    }

    /**
     * @function LevelRenderer.Handler.prototype.un
     * @description 自定义事件解除绑定。
     * @param {string} eventName - 事件名称，resize、hover、drag等。
     * @param {function} handler - 响应函数。
     * @returns {LevelRenderer.Handler} this。
     */
    un(eventName, handler) {
        this.unbind(eventName, handler);
        return this;
    }

    /**
     * @function LevelRenderer.Handler.prototype.trigger
     * @description 事件触发。
     * @param {string} eventName - 事件名称，resize、hover、drag等。
     * @param {event} eventArgs - dom事件对象。
     */
    trigger(eventName, eventArgs) {
        var EVENT = Config.EVENT;
        switch (eventName) {
            case EVENT.RESIZE:
            case EVENT.CLICK:
            case EVENT.DBLCLICK:
            case EVENT.MOUSEWHEEL:
            case EVENT.MOUSEMOVE:
            case EVENT.MOUSEDOWN:
            case EVENT.MOUSEUP:
            case EVENT.MOUSEOUT:
                this['_' + eventName + 'Handler'](eventArgs);
                break;
        }
    }

    /**
     * @function LevelRenderer.Handler.prototype.dispose
     * @description 释放，解绑所有事件。
     */
    dispose() {
        var root = this.root;

        if (window.removeEventListener) {
            window.removeEventListener('resize', this._resizeHandler);

            if (SUtil_SUtil.Util_env.os.tablet || SUtil_SUtil.Util_env.os.phone) {
                // mobile支持
                root.removeEventListener('touchstart', this._touchstartHandler);
                root.removeEventListener('touchmove', this._touchmoveHandler);
                root.removeEventListener('touchend', this._touchendHandler);
            } else {
                // mobile的click自己模拟
                root.removeEventListener('click', this._clickHandler);
                root.removeEventListener('dblclick', this._dblclickHandler);
                root.removeEventListener('mousewheel', this._mousewheelHandler);
                root.removeEventListener('mousemove', this._mousemoveHandler);
                root.removeEventListener('mousedown', this._mousedownHandler);
                root.removeEventListener('mouseup', this._mouseupHandler);
            }
            root.removeEventListener('DOMMouseScroll', this._mousewheelHandler);
            root.removeEventListener('mouseout', this._mouseoutHandler);
        } else {
            window.detachEvent('onresize', this._resizeHandler);

            root.detachEvent('onclick', this._clickHandler);
            root.detachEvent('dblclick', this._dblclickHandler);
            root.detachEvent('onmousewheel', this._mousewheelHandler);
            root.detachEvent('onmousemove', this._mousemoveHandler);
            root.detachEvent('onmouseout', this._mouseoutHandler);
            root.detachEvent('onmousedown', this._mousedownHandler);
            root.detachEvent('onmouseup', this._mouseupHandler);
        }

        this.root = null;
        this._domHover = null;
        this.storage = null;
        this.painter = null;

        this.un();
    }


    /**
     * Method: _processDragStart
     * 拖拽开始。
     *
     * Parameters:
     * event - {Object} 事件对象。
     *
     */
    _processDragStart(event) {
        var _lastHover = this._lastHover;

        if (this._isMouseDown
            && _lastHover
            && _lastHover.draggable
            && !this._draggingTarget
            && this._mouseDownTarget == _lastHover
        ) {
            // 拖拽点击生效时长阀门，某些场景需要降低拖拽敏感度
            if (_lastHover.dragEnableTime &&
                new Date() - this._lastMouseDownMoment < _lastHover.dragEnableTime
            ) {
                return;
            }

            var _draggingTarget = _lastHover;
            this._draggingTarget = _draggingTarget;
            this._isDragging = 1;

            _draggingTarget.invisible = true;
            this.storage.mod(_draggingTarget.id);

            // 分发 Config.EVENT.DRAGSTART事件
            this._dispatchAgency(
                _draggingTarget,
                Config.EVENT.DRAGSTART,
                event
            );
            this.painter.refresh();
        }
    }


    /**
     * Method: _processDragEnter
     * 拖拽进入目标元素。
     *
     * Parameters:
     * event - {Object} 事件对象。
     *
     */
    _processDragEnter(event) {
        if (this._draggingTarget) {
            // 分发SuperMap.LevelRenderer.Config.EVENT.DRAGENTER事件
            this._dispatchAgency(
                this._lastHover,
                Config.EVENT.DRAGENTER,
                event,
                this._draggingTarget
            );
        }
    }


    /**
     * Method: _processDragOver
     * 拖拽在目标元素上移动。
     *
     * Parameters:
     * event - {Object} 事件对象。
     *
     */
    _processDragOver(event) {
        if (this._draggingTarget) {
            // 分发SuperMap.LevelRenderer.Config.EVENT.DRAGOVER事件
            this._dispatchAgency(
                this._lastHover,
                Config.EVENT.DRAGOVER,
                event,
                this._draggingTarget
            );
        }
    }


    /**
     * Method: _processDragLeave
     * 拖拽离开目标元素。
     *
     * Parameters:
     * event - {Object} 事件对象。
     *
     */
    _processDragLeave(event) {
        if (this._draggingTarget) {
            // 分发SuperMap.LevelRenderer.Config.EVENT.DRAGLEAVE事件
            this._dispatchAgency(
                this._lastHover,
                Config.EVENT.DRAGLEAVE,
                event,
                this._draggingTarget
            );
        }
    }


    /**
     * Method: _processDrop
     * 拖拽在目标元素上完成。
     *
     * Parameters:
     * event - {Object} 事件对象。
     *
     */
    _processDrop(event) {
        if (this._draggingTarget) {
            this._draggingTarget.invisible = false;
            this.storage.mod(this._draggingTarget.id);
            this.painter.refresh();

            // 分发SuperMap.LevelRenderer.Config.EVENT.DROP事件
            this._dispatchAgency(
                this._lastHover,
                Config.EVENT.DROP,
                event,
                this._draggingTarget
            );
        }
    }


    /**
     * Method: _processDragEnd
     * 拖拽结束。
     *
     * Parameters:
     * event - {Object} 事件对象。
     *
     */
    _processDragEnd(event) {
        if (this._draggingTarget) {
            // 分发SuperMap.LevelRenderer.Config.EVENT.DRAGEND事件
            this._dispatchAgency(
                this._draggingTarget,
                Config.EVENT.DRAGEND,
                event
            );

            this._lastHover = null;
        }

        this._isDragging = 0;
        this._draggingTarget = null;
    }


    /**
     * Method: _processOverShape
     * 鼠标在某个图形元素上移动。
     *
     * Parameters:
     * event - {Object} 事件对象。
     *
     */
    _processOverShape(event) {
        // 分发SuperMap.LevelRenderer.Config.EVENT.MOUSEOVER事件
        this._dispatchAgency(this._lastHover, Config.EVENT.MOUSEOVER, event);
    }


    /**
     * Method: _processOutShape
     * 鼠标离开某个图形元素。
     *
     * Parameters:
     * event - {Object} 事件对象。
     *
     */
    _processOutShape(event) {
        // 分发SuperMap.LevelRenderer.Config.EVENT.MOUSEOUT事件
        this._dispatchAgency(this._lastHover, Config.EVENT.MOUSEOUT, event);
    }


    /**
     * Method: _dispatchAgency
     * 鼠标离开某个图形元素。
     *
     * Parameters:
     * targetShape - {Object} 目标图形元素。
     * eventName - {Object} 事件名称。
     * event - {Object} 事件对象。
     * draggedShape - {Object} 拖拽事件特有，当前被拖拽图形元素。
     *
     */
    _dispatchAgency(targetShape, eventName, event, draggedShape) {
        var eventHandler = 'on' + eventName;
        var eventPacket = {
            type: eventName,
            event: event,
            target: targetShape,
            cancelBubble: false
        };

        var el = targetShape;

        if (draggedShape) {
            eventPacket.dragged = draggedShape;
        }

        while (el) {
            el[eventHandler]
            && (eventPacket.cancelBubble = el[eventHandler](eventPacket));
            el.dispatch(eventName, eventPacket);

            el = el.parent;

            if (eventPacket.cancelBubble) {
                break;
            }
        }

        if (targetShape) {
            // 冒泡到顶级 zrender 对象
            if (!eventPacket.cancelBubble) {
                this.dispatch(eventName, eventPacket);
            }
        } else if (!draggedShape) {
            // 无hover目标，无拖拽对象，原生事件分发
            this.dispatch(eventName, {
                type: eventName,
                event: event
            });
        }
    }


    /**
     * Method: _iterateAndFindHover
     * 迭代寻找 hover shape。
     *
     */
    _iterateAndFindHover() {
        var invTransform = SUtil_SUtil.Util_matrix.create();

        var list = this.storage.getShapeList();
        var currentZLevel;
        var currentLayer;
        var tmp = [0, 0];
        for (var i = list.length - 1; i >= 0; i--) {
            var shape = list[i];

            if (currentZLevel !== shape.zlevel) {
                currentLayer = this.painter.getLayer(shape.zlevel, currentLayer);
                tmp[0] = this._mouseX;
                tmp[1] = this._mouseY;

                if (currentLayer.needTransform) {
                    SUtil_SUtil.Util_matrix.invert(invTransform, currentLayer.transform);
                    SUtil_SUtil.Util_vector.applyTransform(tmp, tmp, invTransform);
                }
            }

            if (this._findHover(shape, tmp[0], tmp[1])) {
                break;
            }
        }
    }


    /**
     * Method: _mobildFindFixed
     * touch 有指尖错觉，四向尝试，让touch上的点击更好触发事件。
     *
     * Parameters:
     * event - {Object} 事件对象。
     *
     */
    _mobildFindFixed(event) {
        // touch指尖错觉的尝试偏移量配置
        var MOBILE_TOUCH_OFFSETS = [
            {x: 10},
            {x: -20},
            {x: 10, y: 10},
            {y: -20}
        ];

        this._lastHover = null;
        this._mouseX = event.zrenderX;
        this._mouseY = event.zrenderY;

        this._event = event;

        this._iterateAndFindHover();

        for (var i = 0; !this._lastHover && i < MOBILE_TOUCH_OFFSETS.length; i++) {
            var offset = MOBILE_TOUCH_OFFSETS[i];
            offset.x && (this._mouseX += offset.x);
            offset.y && (this._mouseX += offset.y);

            this._iterateAndFindHover();
        }

        if (this._lastHover) {
            event.zrenderX = this._mouseX;
            event.zrenderY = this._mouseY;
        }
    }


    /**
     * Method: _zrenderEventFixed
     * 如果存在第三方嵌入的一些dom触发的事件，或touch事件，需要转换一下事件坐标 。
     *
     * Parameters:
     * event - {Object} 事件。
     * isTouch - {boolean} 是否触摸。
     *
     */
    _zrenderEventFixed(event, isTouch) {
        if (event.zrenderFixed) {
            return event;
        }

        if (!isTouch) {
            event = event || window.event;
            // 进入对象优先~
            var target = event.toElement
                || event.relatedTarget
                || event.srcElement
                || event.target;

            if (target && target != this._domHover) {
                event.zrenderX = (typeof event.offsetX != 'undefined'
                    ? event.offsetX
                    : event.layerX)
                    + target.offsetLeft;
                event.zrenderY = (typeof event.offsetY != 'undefined'
                    ? event.offsetY
                    : event.layerY)
                    + target.offsetTop;
            }
        } else {
            var touch = event.type != 'touchend'
                ? event.targetTouches[0]
                : event.changedTouches[0];
            if (touch) {
                var rBounding = this.root.getBoundingClientRect();
                // touch事件坐标是全屏的~
                event.zrenderX = touch.clientX - rBounding.left;
                event.zrenderY = touch.clientY - rBounding.top;
            }
        }

        event.zrenderFixed = 1;
        return event;
    }


    // SMIC-方法扩展 - start

    /**
     * @function LevelRenderer.Handler.prototype.getLastHoverOne
     * @description 获取单个高亮图形
     */
    getLastHoverOne() {
        if (this._lastHover) {
            return this._lastHover;
        }
        return null;
    }

    // SMIC-方法扩展 - end

}

;// CONCATENATED MODULE: ./src/common/overlay/levelRenderer/Easing.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/
/**
 * @class  LevelRenderer.Animation.easing
 * @category Visualization Theme
 * @classdesc 缓动
 * @private
 */
// 缓动代码来自 https://github.com/sole/tween.js/blob/master/src/Tween.js
// http://sole.github.io/tween.js/examples/03_graphs.html
class Easing {
    constructor() {
        this.CLASS_NAME = "SuperMap.LevelRenderer.Animation.easing";
    }


    /**
     * @function LevelRenderer.Animation.easing.destroy
     * @description 销毁对象，释放资源。调用此函数后所有属性将被置为 null。
     */
    destroy() {

    }


    /**
     * @function LevelRenderer.Animation.easing.Linear
     * @description 线性缓动
     * @param {number} k - 参数
     * @return {number} 输入值
     */
    Linear(k) {
        return k;
    }


    /**
     * @function LevelRenderer.Animation.easing.QuadraticIn
     * @description 二次方的缓动（t^2）
     * @param {number} k - 参数
     * @return {number} 二次方的缓动的值
     */
    QuadraticIn(k) {
        return k * k;
    }

    /**
     * @function LevelRenderer.Animation.easing.QuadraticOut
     * @description 返回按二次方缓动退出的值
     * @param {number} k - 参数
     * @return {number} 按二次方缓动退出的值
     */
    QuadraticOut(k) {
        return k * (2 - k);
    }

    /**
     * @function LevelRenderer.Animation.easing.QuadraticInOut
     * @description 返回按二次方缓动进入和退出的值
     * @param {number} k - 参数
     * @return {number} 按二次方缓动进入和退出的值
     */
    QuadraticInOut(k) {
        if ((k *= 2) < 1) {
            return 0.5 * k * k;
        }
        return -0.5 * (--k * (k - 2) - 1);
    }


    /**
     * @function LevelRenderer.Animation.easing.CubicIn
     * @description 三次方的缓动（t^3）
     * @param {number} k - 参数
     * @return {number} 按三次方缓动的值
     */
    CubicIn(k) {
        return k * k * k;
    }

    /**
     * @function LevelRenderer.Animation.easing.CubicOut
     * @description 返回按三次方缓动退出的值
     * @param {number} k - 参数
     * @return {number} 按三次方缓动退出的值
     */
    CubicOut(k) {
        return --k * k * k + 1;
    }

    /**
     * @function LevelRenderer.Animation.easing.CubicInOut
     * @description 返回按三次方缓动进入退出的值
     * @param {number} k - 参数
     * @return {number} 按三次方缓动进入退出的值
     */
    CubicInOut(k) {
        if ((k *= 2) < 1) {
            return 0.5 * k * k * k;
        }
        return 0.5 * ((k -= 2) * k * k + 2);
    }


    /**
     * @function LevelRenderer.Animation.easing.QuarticIn
     * @description  返回按四次方缓动进入的值
     * @param {number} k - 参数
     * @return {number}  按四次方缓动进入的值
     */
    QuarticIn(k) {
        return k * k * k * k;
    }

    /**
     * @function LevelRenderer.Animation.easing.QuarticOut
     * @description  返回按四次方缓动退出的值
     * @param {number} k - 参数
     * @return {number}  按四次方缓动退出的值
     */
    QuarticOut(k) {
        return 1 - (--k * k * k * k);
    }

    /**
     * @function LevelRenderer.Animation.easing.QuarticInOut
     * @description  返回按四次方缓动进入退出的值
     * @param {number} k - 参数
     * @return {number}  按四次方缓动进入退出的值
     */
    QuarticInOut(k) {
        if ((k *= 2) < 1) {
            return 0.5 * k * k * k * k;
        }
        return -0.5 * ((k -= 2) * k * k * k - 2);
    }


    // 五次方的缓动（t^5）
    /**
     * @function LevelRenderer.Animation.easing.QuinticIn
     * @description  返回按五次方缓动的值
     * @param {number} k - 参数
     * @return {number}  按五次方缓动的值
     */
    QuinticIn(k) {
        return k * k * k * k * k;
    }

    /**
     * @function LevelRenderer.Animation.easing.QuinticOut
     * @description  返回按五次方缓动退出的值
     * @param {number} k - 参数
     * @return {number}  按五次方缓动退出的值
     */
    QuinticOut(k) {
        return --k * k * k * k * k + 1;
    }

    /**
     * @function LevelRenderer.Animation.easing.QuinticInOut
     * @description 返回按五次方缓动进入退出的值
     * @param {number} k - 参数
     * @return {number} 按五次方缓动进入退出的值
     */
    QuinticInOut(k) {
        if ((k *= 2) < 1) {
            return 0.5 * k * k * k * k * k;
        }
        return 0.5 * ((k -= 2) * k * k * k * k + 2);
    }


    // 正弦曲线的缓动（sin(t)）
    /**
     * @function LevelRenderer.Animation.easing.SinusoidalIn
     * @description 返回按正弦曲线的缓动进入的值
     * @param {number} k - 参数
     * @return {number} 按正弦曲线的缓动进入的值
     */
    SinusoidalIn(k) {
        return 1 - Math.cos(k * Math.PI / 2);
    }

    /**
     * @function LevelRenderer.Animation.easing.SinusoidalOut
     * @description 返回按正弦曲线的缓动退出的值
     * @param {number} k - 参数
     * @return {number} 按正弦曲线的缓动退出的值
     */
    SinusoidalOut(k) {
        return Math.sin(k * Math.PI / 2);
    }

    /**
     * @function LevelRenderer.Animation.easing.SinusoidalInOut
     * @description 返回按正弦曲线的缓动进入退出的值
     * @param {number} k - 参数
     * @return {number} 按正弦曲线的缓动进入退出的值
     */
    SinusoidalInOut(k) {
        return 0.5 * (1 - Math.cos(Math.PI * k));
    }


    // 指数曲线的缓动（2^t）
    /**
     * @function LevelRenderer.Animation.easing.ExponentialIn
     * @description 返回按指数曲线的缓动进入的值
     * @param {number} k - 参数
     * @return {number} 按指数曲线的缓动进入的值
     */
    ExponentialIn(k) {
        return k === 0 ? 0 : Math.pow(1024, k - 1);
    }

    /**
     * @function LevelRenderer.Animation.easing.ExponentialOut
     * @description 返回按指数曲线的缓动退出的值
     * @param {number} k - 参数
     * @return {number} 按指数曲线的缓动退出的值
     */
    ExponentialOut(k) {
        return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);
    }

    /**
     * @function LevelRenderer.Animation.easing.ExponentialInOut
     * @description 返回按指数曲线的缓动进入退出的值
     * @param {number} k - 参数
     * @return {number} 按指数曲线的缓动进入退出的值
     */
    ExponentialInOut(k) {
        if (k === 0) {
            return 0;
        }
        if (k === 1) {
            return 1;
        }
        if ((k *= 2) < 1) {
            return 0.5 * Math.pow(1024, k - 1);
        }
        return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);
    }


    // 圆形曲线的缓动（sqrt(1-t^2)）
    /**
     * @function LevelRenderer.Animation.easing.CircularIn
     * @description 返回按圆形曲线的缓动进入的值
     * @param {number} k - 参数
     * @return {number} 按圆形曲线的缓动进入的值
     */
    CircularIn(k) {
        return 1 - Math.sqrt(1 - k * k);
    }

    /**
     * @function LevelRenderer.Animation.easing.CircularOut
     * @description 返回按圆形曲线的缓动退出的值
     * @param {number} k - 参数
     * @return {number} 按圆形曲线的缓动退出的值
     */
    CircularOut(k) {
        return Math.sqrt(1 - (--k * k));
    }

    /**
     * @function LevelRenderer.Animation.easing.CircularInOut
     * @description 返回按圆形曲线的缓动进入退出的值
     * @param {number} k - 参数
     * @return {number} 按圆形曲线的缓动进入退出的值
     */
    CircularInOut(k) {
        if ((k *= 2) < 1) {
            return -0.5 * (Math.sqrt(1 - k * k) - 1);
        }
        return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);
    }


    // 创建类似于弹簧在停止前来回振荡的动画
    /**
     * @function LevelRenderer.Animation.easing.ElasticIn
     * @description 返回按类似于弹簧在停止前来回振荡的动画的缓动进入的值
     * @param {number} k - 参数
     * @return {number} 按类似于弹簧在停止前来回振荡的动画的缓动进入的值
     */
    ElasticIn(k) {
        var s;
        var a = 0.1;
        var p = 0.4;
        if (k === 0) {
            return 0;
        }
        if (k === 1) {
            return 1;
        }
        if (a < 1) {
            a = 1;
            s = p / 4;
        } else {
            s = p * Math.asin(1 / a) / (2 * Math.PI);
        }
        return -(a * Math.pow(2, 10 * (k -= 1)) *
            Math.sin((k - s) * (2 * Math.PI) / p));
    }

    /**
     * @function LevelRenderer.Animation.easing.ElasticOut
     * @description 返回按类似于弹簧在停止前来回振荡的动画的缓动退出的值
     * @param {number} k - 参数
     * @return {number} 按类似于弹簧在停止前来回振荡的动画的缓动退出的值
     */
    ElasticOut(k) {
        var s;
        var a = 0.1;
        var p = 0.4;
        if (k === 0) {
            return 0;
        }
        if (k === 1) {
            return 1;
        }
        if (a < 1) {
            a = 1;
            s = p / 4;
        } else {
            s = p * Math.asin(1 / a) / (2 * Math.PI);
        }
        return (a * Math.pow(2, -10 * k) *
            Math.sin((k - s) * (2 * Math.PI) / p) + 1);
    }

    /**
     * @function LevelRenderer.Animation.easing.ElasticInOut
     * @description 返回按类似于弹簧在停止前来回振荡的动画的缓动进入退出的值
     * @param {number} k - 参数
     * @return {number} 按类似于弹簧在停止前来回振荡的动画的缓动进入退出的值
     */
    ElasticInOut(k) {
        var s;
        var a = 0.1;
        var p = 0.4;
        if (k === 0) {
            return 0;
        }
        if (k === 1) {
            return 1;
        }
        if (a < 1) {
            a = 1;
            s = p / 4;
        } else {
            s = p * Math.asin(1 / a) / (2 * Math.PI);
        }
        if ((k *= 2) < 1) {
            return -0.5 * (a * Math.pow(2, 10 * (k -= 1))
                * Math.sin((k - s) * (2 * Math.PI) / p));
        }
        return a * Math.pow(2, -10 * (k -= 1))
            * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;

    }


    // 在某一动画开始沿指示的路径进行动画处理前稍稍收回该动画的移动
    /**
     * @function LevelRenderer.Animation.easing.BackIn
     * @description 返回按在某一动画开始沿指示的路径进行动画处理前稍稍收回该动画的移动的缓动进入的值
     * @param {number} k - 参数
     * @return {number} 按在某一动画开始沿指示的路径进行动画处理前稍稍收回该动画的移动的缓动进入的值
     */
    BackIn(k) {
        var s = 1.70158;
        return k * k * ((s + 1) * k - s);
    }

    /**
     * @function LevelRenderer.Animation.easing.BackOut
     * @description 返回按在某一动画开始沿指示的路径进行动画处理前稍稍收回该动画的移动的缓动退出的值
     * @param {number} k - 参数
     * @return {number} 按在某一动画开始沿指示的路径进行动画处理前稍稍收回该动画的移动的缓动退出的值
     */
    BackOut(k) {
        var s = 1.70158;
        return --k * k * ((s + 1) * k + s) + 1;
    }

    /**
     * @function LevelRenderer.Animation.easing.BackInOut
     * @description 返回按在某一动画开始沿指示的路径进行动画处理前稍稍收回该动画的移动的缓动进入退出的值
     * @param {number} k - 参数
     * @return {number} 按在某一动画开始沿指示的路径进行动画处理前稍稍收回该动画的移动的缓动进入退出的值
     */
    BackInOut(k) {
        var s = 1.70158 * 1.525;
        if ((k *= 2) < 1) {
            return 0.5 * (k * k * ((s + 1) * k - s));
        }
        return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);
    }


    // 创建弹跳效果
    /**
     * @function LevelRenderer.Animation.easing.BounceIn
     * @description 返回按弹跳效果的缓动进入的值
     * @param {number} k - 参数
     * @return {number} 按弹跳效果的缓动进入的值
     */
    BounceIn(k) {
        return 1 - this.BounceOut(1 - k);
    }

    /**
     * @function LevelRenderer.Animation.easing.BounceOut
     * @description 返回按弹跳效果的缓动退出的值
     * @param {number} k - 参数
     * @return {number} 按弹跳效果的缓动退出的值
     */
    BounceOut(k) {
        if (k < (1 / 2.75)) {
            return 7.5625 * k * k;
        } else if (k < (2 / 2.75)) {
            return 7.5625 * (k -= (1.5 / 2.75)) * k + 0.75;
        } else if (k < (2.5 / 2.75)) {
            return 7.5625 * (k -= (2.25 / 2.75)) * k + 0.9375;
        } else {
            return 7.5625 * (k -= (2.625 / 2.75)) * k + 0.984375;
        }
    }

    /**
     * @function LevelRenderer.Animation.easing.BounceInOut
     * @description 返回按弹跳效果的缓动进入退出的值
     * @param {number} k - 参数
     * @return {number} 按弹跳效果的缓动进入退出的值
     */
    BounceInOut(k) {
        if (k < 0.5) {
            return this.BounceIn(k * 2) * 0.5;
        }
        return this.BounceOut(k * 2 - 1) * 0.5 + 0.5;
    }

}

;// CONCATENATED MODULE: ./src/common/overlay/levelRenderer/Clip.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


/**
 * @class  LevelRenderer.Animation.Clip
 * @category Visualization Theme
 * @classdesc 动画片段
 * @param {Object} options - 参数。
 * @param {Object} options.target - 动画对象，可以是数组，如果是数组的话会批量分发 onframe 等事件。
 * @param {number} [options.life=1000] - 动画时长。
 * @param {number} [options.delay=0] - 动画延迟时间。
 * @param {boolean} [options.loop=true] - 是否循环。
 * @param {number} [options.gap=0] - 循环的间隔时间。
 * @param {Object} options.onframe -  帧。
 * @param {boolean} options.easing - 是否消除。
 * @param {boolean} options.ondestroy - 是否销毁。
 * @param {boolean} options.onrestart - 是否重播。
 * @private
 */
class Clip {
    constructor(options) {
        this._targetPool = options.target || {};
        if (!(this._targetPool instanceof Array)) {
            this._targetPool = [this._targetPool];
        }

        // 生命周期
        this._life = options.life || 1000;
        // 延时
        this._delay = options.delay || 0;
        // 开始时间
        this._startTime = new Date().getTime() + this._delay;// 单位毫秒

        // 结束时间
        this._endTime = this._startTime + this._life * 1000;

        // 是否循环
        this.loop = typeof options.loop == 'undefined'
            ? false : options.loop;

        this.gap = options.gap || 0;

        this.easing = options.easing || 'Linear';

        this.onframe = options.onframe;
        this.ondestroy = options.ondestroy;
        this.onrestart = options.onrestart;
        this.CLASS_NAME = "SuperMap.LevelRenderer.Animation.Clip";
    }

    /**
     * @function LevelRenderer.Animation.Clip.prototype.destroy
     * @description 销毁对象，释放资源。调用此函数后所有属性将被置为 null。
     */
    destroy() {

    }

    step(time) {
        var easing = new Easing();
        var percent = (time - this._startTime) / this._life;

        // 还没开始
        if (percent < 0) {
            return;
        }

        percent = Math.min(percent, 1);

        var easingFunc = typeof this.easing == 'string'
            ? easing[this.easing]
            : this.easing;
        var schedule = typeof easingFunc === 'function'
            ? easingFunc(percent)
            : percent;

        this.fire('frame', schedule);

        // 结束
        if (percent == 1) {
            if (this.loop) {
                this.restart();
                // 重新开始周期
                // 抛出而不是直接调用事件直到 stage.update 后再统一调用这些事件
                return 'restart';

            }

            // 动画完成将这个控制器标识为待删除
            // 在Animation.update中进行批量删除
            this._needsRemove = true;
            return 'destroy';
        }

        return null;
    }

    restart() {
        var time = new Date().getTime();
        var remainder = (time - this._startTime) % this._life;
        this._startTime = new Date().getTime() - remainder + this.gap;
    }

    fire(eventType, arg) {
        for (var i = 0, len = this._targetPool.length; i < len; i++) {
            if (this['on' + eventType]) {
                this['on' + eventType](this._targetPool[i], arg);
            }
        }
    }

}

;// CONCATENATED MODULE: ./src/common/overlay/levelRenderer/Animation.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/






/**
 * @class LevelRenderer.Animation
 * @classdesc 动画主类, 调度和管理所有动画控制器
 * @category Visualization Theme
 * @extends {LevelRenderer.Eventful}
 * @param {Object} options - 动画参数。
 * @param {Object} options.onframe - onframe。
 * @param {Object} options.stage - stage。
 * @example 例如：
 * (start code)
 *     var animation = new LevelRenderer.Animation();
 *     var obj = {
 *         x: 100,
 *         y: 100
 *     };
 *     animation.animate(node.position)
 *         .when(1000, {
 *             x: 500,
 *             y: 500
 *         })
 *         .when(2000, {
 *             x: 100,
 *             y: 100
 *         })
 *         .start('spline');
 * (end)
 * @private
 */
class Animation extends Eventful {
    constructor(options) {
        super(options);

        options = options || {};
        /**
         * @member {Object} LevelRenderer.Animation.prototype.stage
         * @description stage。
         */
        this.stage = {};

        /**
         * @member {Object} LevelRenderer.Animation.prototype.onframe
         * @description onframe。
         */
        this.onframe = function () {
        };

        /**
         * @member {Array} LevelRenderer.Animation.prototype._clips
         * @description _clips。
         */
        this._clips = [];

        /**
         * @member {boolean} LevelRenderer.Animation.prototype._running
         * @description _running。
         */
        this._running = false;

        /**
         * @member {number} LevelRenderer.Animation.prototype._time
         * @description _time。
         */
        this._time = 0;

        Util_Util.extend(this, options);

        this.CLASS_NAME = "SuperMap.LevelRenderer.Animation";

    }


    /**
     * @function LevelRenderer.Animation.prototype.add
     * @description 添加动画片段。
     * @param {LevelRenderer.Animation.Clip} clip - 动画片段。
     */
    add(clip) {
        this._clips.push(clip);
    }


    /**
     * @function LevelRenderer.Animation.prototype.remove
     * @description 删除动画片段。
     * @param {LevelRenderer.Animation.Clip} clip - 动画片段。
     */
    remove(clip) {
        var idx = new levelRenderer_Util_Util().indexOf(this._clips, clip);
        if (idx >= 0) {
            this._clips.splice(idx, 1);
        }
    }


    /**
     * @function LevelRenderer.Animation.prototype.update
     * @description 更新动画片段。
     */
    _update() {
        var time = new Date().getTime();
        var delta = time - this._time;
        var clips = this._clips;
        var len = clips.length;

        var deferredEvents = [];
        var deferredClips = [];
        for (let i = 0; i < len; i++) {
            var clip = clips[i];
            var e = clip.step(time);
            // Throw out the events need to be called after
            // stage.update, like destroy
            if (e) {
                deferredEvents.push(e);
                deferredClips.push(clip);
            }
        }
        if (this.stage.update) {
            this.stage.update();
        }

        // Remove the finished clip
        for (let i = 0; i < len;) {
            if (clips[i]._needsRemove) {
                clips[i] = clips[len - 1];
                clips.pop();
                len--;
            } else {
                i++;
            }
        }

        len = deferredEvents.length;
        for (let i = 0; i < len; i++) {
            deferredClips[i].fire(deferredEvents[i]);
        }

        this._time = time;

        this.onframe(delta);

        this.dispatch('frame', delta);
    }


    /**
     * @function LevelRenderer.Animation.prototype.start
     * @description 开始运行动画。
     */
    start() {
        var requestAnimationFrame = window.requestAnimationFrame
            || window.msRequestAnimationFrame
            || window.mozRequestAnimationFrame
            || window.webkitRequestAnimationFrame
            || function (func) {
                setTimeout(func, 16);
            };

        var self = this;

        this._running = true;

        function step() {
            if (self._running) {
                self._update();
                requestAnimationFrame(step);
            }
        }

        this._time = new Date().getTime();
        requestAnimationFrame(step);
    }


    /**
     * @function LevelRenderer.Animation.prototype.stop
     * @description 停止运行动画。
     */
    stop() {
        this._running = false;
    }


    /**
     * @function LevelRenderer.Animation.prototype.clear
     * @description 清除所有动画片段。
     */
    clear() {
        this._clips = [];
    }


    /**
     * @function LevelRenderer.Animation.prototype.animate
     * @description 对一个目标创建一个animator对象，可以指定目标中的属性使用动画。
     * @param {Object} target - 目标对象。
     * @param {Object} options - 动画参数选项。
     * @param {boolean} [options.loop=false] - 是否循环播放动画。
     * @param {function} [options.getter] - 如果指定getter函数，会通过getter函数取属性值。
     * @param {function} [options.setter] - 如果指定setter函数，会通过setter函数设置属性值。
     * @returns {LevelRenderer.Animation.Animator} Animator。
     */
    animate(target, options) {
        options = options || {};
        var deferred = new Animator(
            target,
            options.loop,
            options.getter,
            options.setter
        );
        deferred.animation = this;
        return deferred;
    }

    static _interpolateNumber(p0, p1, percent) {
        return (p1 - p0) * percent + p0;
    }

    static _interpolateArray(p0, p1, percent, out, arrDim) {
        var len = p0.length;
        if (arrDim == 1) {
            for (let i = 0; i < len; i++) {
                out[i] = Animation._interpolateNumber(p0[i], p1[i], percent);
            }
        } else {
            var len2 = p0[0].length;
            for (let i = 0; i < len; i++) {
                for (let j = 0; j < len2; j++) {
                    out[i][j] = Animation._interpolateNumber(
                        p0[i][j], p1[i][j], percent
                    );
                }
            }
        }
    }

    static _isArrayLike(data) {
        switch (typeof data) {
            case 'undefined':
            case 'string':
                return false;
        }

        return typeof data.length !== 'undefined';
    }

    static _catmullRomInterpolateArray(p0, p1, p2, p3, t, t2, t3, out, arrDim) {
        var len = p0.length;
        if (arrDim == 1) {
            for (let i = 0; i < len; i++) {
                out[i] = Animation._catmullRomInterpolate(
                    p0[i], p1[i], p2[i], p3[i], t, t2, t3
                );
            }
        } else {
            var len2 = p0[0].length;
            for (let i = 0; i < len; i++) {
                for (var j = 0; j < len2; j++) {
                    out[i][j] = Animation._catmullRomInterpolate(
                        p0[i][j], p1[i][j], p2[i][j], p3[i][j],
                        t, t2, t3
                    );
                }
            }
        }
    }

    static _catmullRomInterpolate(p0, p1, p2, p3, t, t2, t3) {
        var v0 = (p2 - p0) * 0.5;
        var v1 = (p3 - p1) * 0.5;
        return (2 * (p1 - p2) + v0 + v1) * t3
            + (-3 * (p1 - p2) - 2 * v0 - v1) * t2
            + v0 * t + p1;
    }

    static _cloneValue(value) {
        var arraySlice = Array.prototype.slice;

        if (Animation._isArrayLike(value)) {
            var len = value.length;
            if (Animation._isArrayLike(value[0])) {
                var ret = [];
                for (var i = 0; i < len; i++) {
                    ret.push(arraySlice.call(value[i]));
                }
                return ret;
            } else {
                return arraySlice.call(value);
            }
        } else {
            return value;
        }
    }

    static rgba2String(rgba) {
        rgba[0] = Math.floor(rgba[0]);
        rgba[1] = Math.floor(rgba[1]);
        rgba[2] = Math.floor(rgba[2]);

        return 'rgba(' + rgba.join(',') + ')';
    }
}

/**
 * @class LevelRenderer.Animation.Animator
 */
class Animator {

    /**
     * @function LevelRenderer.Animation.Animator.prototype.animate
     * @description 构造函数
     * @param {Object} target - 目标对象。
     * @param {Object} options - 动画参数选项。
     * @param {boolean} [loop=false] - 是否循环播放动画。
     * @param {function} [getterl] - 如果指定getter函数，会通过getter函数取属性值。
     * @param {function} [setter] - 如果指定setter函数，会通过setter函数设置属性值。
     */
    constructor(target, loop, getter, setter) {
        /**
         * @member {Object} LevelRenderer.Animation.Animator.prototype._tracks
         * @description _tracks。
         */
        this._tracks = {};

        /**
         * @member {Object} LevelRenderer.Animation.Animator.prototype._target
         * @description _target。
         */
        this._target = target;

        /**
         * @member {boolean} LevelRenderer.Animation.Animator.prototype._loop
         * @description _loop。
         */
        this._loop = loop || false;

        /**
         * @member {function} LevelRenderer.Animation.Animator.prototype._getter
         * @description _getter。
         */
        this._getter = getter || _defaultGetter;

        /**
         * @member {function} LevelRenderer.Animation.Animator.prototype._setter
         * @description _setter。
         */
        this._setter = setter || _defaultSetter;

        /**
         * @member {number} LevelRenderer.Animation.Animator.prototype._clipCount
         * @description _clipCount。
         */
        this._clipCount = 0;

        /**
         * @member {number} LevelRenderer.Animation.Animator.prototype._delay
         * @description _delay。
         */
        this._delay = 0;

        /**
         * @member {Array} LevelRenderer.Animation.Animator.prototype._doneList
         * @description _doneList。
         */
        this._doneList = [];

        /**
         * @member {Array} LevelRenderer.Animation.Animator.prototype._onframeList
         * @description _onframeList。
         */
        this._onframeList = [];

        /**
         * @member {Array} LevelRenderer.Animation.Animator.prototype._clipList
         * @description _clipList。
         */
        this._clipList = [];
        this.CLASS_NAME = "SuperMap.LevelRenderer.Animation.Animator";
        //Function
        function _defaultGetter(target, key) {
            return target[key];
        }

        function _defaultSetter(target, key, value) {
            target[key] = value;
        }
    }


    /**
     * @function LevelRenderer.Animation.Animator.prototype.when
     * @description 设置动画关键帧
     * @param {number} time - 关键帧时间，单位是ms
     * @param {Object} props - 关键帧的属性值，key-value表示
     * @returns {LevelRenderer.Animation.Animator} Animator
     */
    when(time /* ms */, props) {
        for (var propName in props) {
            if (!this._tracks[propName]) {
                this._tracks[propName] = [];
                // If time is 0
                //  Then props is given initialize value
                // Else
                //  Initialize value from current prop value
                if (time !== 0) {
                    this._tracks[propName].push({
                        time: 0,
                        value: Animation._cloneValue(
                            this._getter(this._target, propName)
                        )
                    });
                }
            }
            this._tracks[propName].push({
                time: parseInt(time, 10),
                value: props[propName]
            });
        }
        return this;
    }


    /**
     * @function LevelRenderer.Animation.Animator.prototype.during
     * @description 添加动画每一帧的回调函数
     * @param {RequestCallback} callback - 回调函数
     * @returns {LevelRenderer.Animation.Animator} Animator
     */
    during(callback) {
        this._onframeList.push(callback);
        return this;
    }


    /**
     * @function LevelRenderer.Animation.Animator.prototype.start
     * @description 开始执行动画
     * @param {(string|function)} easing - 动画缓动函数。详见：<{@link LevelRenderer.Animation.easing}>。
     * @returns {LevelRenderer.Animation.Animator} Animator
     */
    start(easing) {
        var self = this;
        var setter = this._setter;
        var getter = this._getter;
        var onFrameListLen = self._onframeList.length;
        var useSpline = easing === 'spline';

        var ondestroy = function () {
            self._clipCount--;
            if (self._clipCount === 0) {
                // Clear all tracks
                self._tracks = {};

                var len = self._doneList.length;
                for (var i = 0; i < len; i++) {
                    self._doneList[i].call(self);
                }
            }
        };

        var createTrackClip = function (keyframes, propName) {
            var trackLen = keyframes.length;
            if (!trackLen) {
                return;
            }
            // Guess data type
            var firstVal = keyframes[0].value;
            var isValueArray = Animation._isArrayLike(firstVal);
            var isValueColor = false;

            // For vertices morphing
            var arrDim = (
                isValueArray
                && Animation._isArrayLike(firstVal[0])
            )
                ? 2 : 1;
            // Sort keyframe as ascending
            keyframes.sort(function (a, b) {
                return a.time - b.time;
            });
            var trackMaxTime = keyframes[trackLen - 1].time;
            // Percents of each keyframe
            var kfPercents = [];
            // Value of each keyframe
            var kfValues = [];
            for (let i = 0; i < trackLen; i++) {
                kfPercents.push(keyframes[i].time / trackMaxTime);
                // Assume value is a color when it is a string
                var value = keyframes[i].value;
                if (typeof(value) == 'string') {
                    value = SUtil_SUtil.Util_color.toArray(value);
                    if (value.length === 0) {    // Invalid color
                        value[0] = value[1] = value[2] = 0;
                        value[3] = 1;
                    }
                    isValueColor = true;
                }
                kfValues.push(value);
            }

            // Cache the key of last frame to speed up when
            // animation playback is sequency
            var cacheKey = 0;
            var cachePercent = 0;
            var start;
            var i;
            var w;
            var p0;
            var p1;
            var p2;
            var p3;


            if (isValueColor) {
                var rgba = [0, 0, 0, 0];
            }

            var onframe = function (target, percent) {
                // Find the range keyframes
                // kf1-----kf2---------current--------kf3
                // find kf2 and kf3 and do interpolation
                if (percent < cachePercent) {
                    // Start from next key
                    start = Math.min(cacheKey + 1, trackLen - 1);
                    for (i = start; i >= 0; i--) {
                        if (kfPercents[i] <= percent) {
                            break;
                        }
                    }
                    i = Math.min(i, trackLen - 2);
                } else {
                    for (i = cacheKey; i < trackLen; i++) {
                        if (kfPercents[i] > percent) {
                            break;
                        }
                    }
                    i = Math.min(i - 1, trackLen - 2);
                }
                cacheKey = i;
                cachePercent = percent;

                var range = (kfPercents[i + 1] - kfPercents[i]);
                if (range === 0) {
                    return;
                } else {
                    w = (percent - kfPercents[i]) / range;
                }
                if (useSpline) {
                    p1 = kfValues[i];
                    p0 = kfValues[i === 0 ? i : i - 1];
                    p2 = kfValues[i > trackLen - 2 ? trackLen - 1 : i + 1];
                    p3 = kfValues[i > trackLen - 3 ? trackLen - 1 : i + 2];
                    if (isValueArray) {
                        Animation._catmullRomInterpolateArray(
                            p0, p1, p2, p3, w, w * w, w * w * w,
                            getter(target, propName),
                            arrDim
                        );
                    } else {
                        let value;
                        if (isValueColor) {
                            // value = LevelRenderer.Animation._catmullRomInterpolateArray(
                            //     p0, p1, p2, p3, w, w * w, w * w * w,
                            //     rgba, 1
                            // );
                            value = Animation.rgba2String(rgba);
                        } else {
                            value = Animation._catmullRomInterpolate(
                                p0, p1, p2, p3, w, w * w, w * w * w
                            );
                        }
                        setter(
                            target,
                            propName,
                            value
                        );
                    }
                } else {
                    if (isValueArray) {
                        Animation._interpolateArray(
                            kfValues[i], kfValues[i + 1], w,
                            getter(target, propName),
                            arrDim
                        );
                    } else {
                        let value;
                        if (isValueColor) {
                            Animation._interpolateArray(
                                kfValues[i], kfValues[i + 1], w,
                                rgba, 1
                            );
                            value = Animation.rgba2String(rgba);
                        } else {
                            value = Animation._interpolateNumber(kfValues[i], kfValues[i + 1], w);
                        }
                        setter(
                            target,
                            propName,
                            value
                        );
                    }
                }

                for (i = 0; i < onFrameListLen; i++) {
                    self._onframeList[i](target, percent);
                }
            };

            var clip = new Clip({
                target: self._target,
                life: trackMaxTime,
                loop: self._loop,
                delay: self._delay,
                onframe: onframe,
                ondestroy: ondestroy
            });

            if (easing && easing !== 'spline') {
                clip.easing = easing;
            }
            self._clipList.push(clip);
            self._clipCount++;
            self.animation.add(clip);
        };

        for (var propName in this._tracks) {
            createTrackClip(this._tracks[propName], propName);
        }
        return this;
    }


    /**
     * @function LevelRenderer.Animation.Animator.prototype.stop
     * @description 停止动画
     */
    stop() {
        for (var i = 0; i < this._clipList.length; i++) {
            var clip = this._clipList[i];
            this.animation.remove(clip);
        }
        this._clipList = [];
    }


    /**
     * @function LevelRenderer.Animation.Animator.prototype.delay
     * @description 设置动画延迟开始的时间
     * @param {number} time - 时间，单位ms
     * @returns {LevelRenderer.Animation.Animator} Animator
     */
    delay(time) {
        this._delay = time;
        return this;
    }


    /**
     * @function LevelRenderer.Animation.Animator.prototype.done
     * @description 添加动画结束的回调
     * @param {function} cb - Function
     * @returns {LevelRenderer.Animation.Animator} Animator
     */
    done(cb) {
        if (cb) {
            this._doneList.push(cb);
        }
        return this;
    }

}



;// CONCATENATED MODULE: ./src/common/overlay/levelRenderer/Render.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/

 
 
 
 
 
 
 

 /**
 * @private
 * @class LevelRenderer.Render
 * @category Visualization Theme
 * @classdesc Render 接口类，对外可用的所有接口都在这里。内部使用非 get 接口统一返回 this 对象，支持链式调用。
 * @param {string} id - 唯一标识。
 * @param {HTMLElement} dom - Dom 对象。
 */

class Render {
    constructor(id, dom) {
        /**
         * @member {string} LevelRenderer.Render.prototype.id
         * @description 唯一标识。
         */
        this.id = id;

        /**
         * @member {LevelRenderer.Storage} LevelRenderer.Render.prototype.storage
         * @description 图形仓库对象。
         */
        this.storage = new Storage();

        /**
         * @member {LevelRenderer.Painter} LevelRenderer.Render.prototype.painter
         * @description 绘制器对象。
         *
         */
        this.painter = new Painter(dom, this.storage);

        /**
         * @member {LevelRenderer.Handler} LevelRenderer.Render.prototype.handler
         * @description 事件处理对象。
         *
         */
        this.handler = new Handler(dom, this.storage, this.painter);

        /**
         * @member {Array} LevelRenderer.Render.prototype.animatingElements
         * @description 动画控制数组。
         *
         */
        this.animatingElements = [];

        /**
         * @member {LevelRenderer.animation.Animation} LevelRenderer.Render.prototype.animation
         * @description 动画对象。
         *
         */
        this.animation = new Animation({
            stage: {
                update: Render.getFrameCallback(this)
            }
        });

        /**
         * @member {boolean} LevelRenderer.Render.prototype._needsRefreshNextFrame
         * @description 是否需要刷新下一帧。
         *
         */
        this._needsRefreshNextFrame = false;
        this.animation.start();
        this.CLASS_NAME = "SuperMap.LevelRenderer.Render";

    }

    /**
     * @function LevelRenderer.Render.prototype.destory
     * @description 销毁对象，释放资源。调用此函数后所有属性将被置为 null。
     */
    destroy() {
        this.id = null;
        this.storage = null;
        this.painter = null;
        this.handler = null;
        this.animatingElements = null;
        this.animation = null;
        this._needsRefreshNextFrame = null;
    }

    /**
     * @function LevelRenderer.Render.prototype.getId
     * @description 获取实例唯一标识。
     * @return {string} 实例唯一标识。
     */
    getId() {
        return this.id;
    }

    /**
     * @function LevelRenderer.Render.prototype.addShape
     * @description 添加图形形状到根节点。
     *
     * @param {LevelRenderer.Shape} shape - 图形对象，可用属性全集，详见各 shape。
     * @return {LevelRenderer.Render} this。
     */
    addShape(shape) {
        this.storage.addRoot(shape);
        return this;
    }

    /**
     * @function LevelRenderer.Render.prototype.addGroup
     * @description 添加组到根节点。
     *
     * (code)
     * //添加组到根节点例子
     * var render = new LevelRenderer.Render("Render",document.getElementById('lRendertest'));
     * render.clear();
     * var g = new LevelRenderer.Group();
     * g.addChild(new LevelRenderer.Shape.Circle({
     *     style: {
     *         x: 100,
     *         y: 100,
     *         r: 20,
     *         brushType: 'fill'
     *     }
     * }));
     * render.addGroup(g);
     * render.render();
     * (end)
     *
     * @param {LevelRenderer.Group} group - 组对象。
     * @return {LevelRenderer.Render} this。
     */
    addGroup(group) {
        this.storage.addRoot(group);
        return this;
    }

    /**
     * @function LevelRenderer.Render.prototype.delShape
     * @description 从根节点删除图形形状。
     *
     * @param {string} shapeId - 图形对象唯一标识。
     * @return {LevelRenderer.Render} this。
     */
    delShape(shapeId) {
        this.storage.delRoot(shapeId);
        return this;
    }

    /**
     * @function LevelRenderer.Render.prototype.delGroup
     * @description 从根节点删除组。
     *
     * @param {string} groupId - 组对象唯一标识。
     * @return {LevelRenderer.Render} this。
     */
    delGroup(groupId) {
        this.storage.delRoot(groupId);
        return this;
    }

    /**
     * @function LevelRenderer.Render.prototype.modShape
     * @description 修改图形形状。
     *
     * @param {string} shapeId - 图形对象唯一标识。
     * @param {LevelRenderer.Shape} shape - 图形对象。
     * @return {LevelRenderer.Render} this。
     */
    modShape(shapeId, shape) {
        this.storage.mod(shapeId, shape);
        return this;
    }

    /**
     * @function LevelRenderer.Render.prototype.modGroup
     * @description 修改组。
     *
     * @param {string} groupId - 组对象唯一标识。
     * @param {LevelRenderer.Group} group - 组对象。
     * @return {LevelRenderer.Render} this。
     */
    modGroup(groupId, group) {
        this.storage.mod(groupId, group);
        return this;
    }

    /**
     * @function LevelRenderer.Render.prototype.modLayer
     * @description 修改指定 zlevel 的绘制配置项。
     *
     * @param {string} zLevel - 组对象唯一标识。
     * @param {Object} config - 配置对象。
     * @param {string} clearColor - 每次清空画布的颜色。默认值：0。
     * @param {noolean} motionBlur - 是否开启动态模糊。默认值：false。
     * @param {number}  lastFrameAlpha - 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显。默认值：0.7。
     * @param {Array.<number>} position - 层的平移。
     * @param {Array.<number>} rotation - 层的旋转。
     * @param {Array.<number>} scale - 层的缩放。
     * @param {boolean} zoomable - 层是否支持鼠标缩放操作。默认值：false。
     * @param {boolean} panable - 层是否支持鼠标平移操作。默认值：false。
     * @return {LevelRenderer.Render} this。
     */
    modLayer(zLevel, config) {
        this.painter.modLayer(zLevel, config);
        return this;
    }

    /**
     * @function LevelRenderer.Render.prototype.addHoverShape
     * @description 添加额外高亮层显示，仅提供添加方法，每次刷新后高亮层图形均被清空。
     *
     * @param {LevelRenderer.Shape} shape - 图形对象。
     * @return {LevelRenderer.Render} this。
     */
    addHoverShape(shape) {
        this.storage.addHover(shape);
        return this;
    }

    /**
     * @function LevelRenderer.Render.prototype.render
     * @description 渲染。
     *
     * @callback {function} callback - 渲染结束后回调函数。
     * @return {LevelRenderer.Render} this。
     */
    render(callback) {
        this.painter.render(callback);
        this._needsRefreshNextFrame = false;
        return this;
    }

    /**
     * @function LevelRenderer.Render.prototype.refresh
     * @description 视图更新。
     *
     * @callback {function} callback - 视图更新后回调函数。
     * @return {LevelRenderer.Render} this。
     */
    refresh(callback) {
        this.painter.refresh(callback);
        this._needsRefreshNextFrame = false;
        return this;
    }

    /**
     * @function LevelRenderer.Render.prototype.refreshNextFrame
     * @description 标记视图在浏览器下一帧需要绘制。
     * @return {LevelRenderer.Render} this。
     */
    refreshNextFrame() {
        this._needsRefreshNextFrame = true;
        return this;
    }

    /**
     * @function LevelRenderer.Render.prototype.refreshHover
     * @description 绘制（视图更新）高亮层。
     * @callback {function} callback - 视图更新后回调函数。
     * @return {LevelRenderer.Render} this。
     */
    refreshHover(callback) {
        this.painter.refreshHover(callback);
        return this;
    }

    /**
     * @function LevelRenderer.Render.prototype.refreshShapes
     * @description 视图更新。
     *
     * @param {Array.<LevelRenderer.Shape>} shapeList - 需要更新的图形列表。
     * @callback {function} callback - 视图更新后回调函数。
     * @return {LevelRenderer.Render} this。
     */
    refreshShapes(shapeList, callback) {
        this.painter.refreshShapes(shapeList, callback);
        return this;
    }

    /**
     * @function LevelRenderer.Render.prototype.resize
     * @description 调整视图大小。
     * @return {LevelRenderer.Render} this。
     */
    resize() {
        this.painter.resize();
        return this;
    }

    /**
     * @function LevelRenderer.Render.prototype.animate
     * @description 动画。
     *
     * @example
     *     zr.animate(circle.id, 'style', false)
     *         .when(1000, {x: 10} )
     *         .done(function(){ // Animation done })
     *         .start()
     *
     *
     * @param {Array.<(LevelRenderer.Shape/LevelRenderer.Group)>} el - 动画对象。
     * @param {string} path - 需要添加动画的属性获取路径，可以通过 a.b.c 来获取深层的属性。若传入对象为<LevelRenderer.Group>,path需为空字符串。
     * @param {function} loop - 动画是否循环。
     * @return {LevelRenderer.animation.Animator} Animator。
     */
    animate(el, path, loop) {
        if (typeof(el) === 'string') {
            el = this.storage.get(el);
        }
        if (el) {
            var target;
            if (path) {
                var pathSplitted = path.split('.');
                var prop = el;
                for (var i = 0, l = pathSplitted.length; i < l; i++) {
                    if (!prop) {
                        continue;
                    }
                    prop = prop[pathSplitted[i]];
                }
                if (prop) {
                    target = prop;
                }
            } else {
                target = el;
            }

            if (!target) {
                SUtil_SUtil.Util_log(
                    'Property "'
                    + path
                    + '" is not existed in element '
                    + el.id
                );
                return;
            }

            var animatingElements = this.animatingElements;
            if (typeof el.__aniCount === 'undefined') {
                // 正在进行的动画记数
                el.__aniCount = 0;
            }
            if (el.__aniCount === 0) {
                animatingElements.push(el);
            }
            el.__aniCount++;

            return this.animation.animate(target, {loop: loop})
                .done(function () {
                    el.__aniCount--;
                    if (el.__aniCount === 0) {
                        // 从animatingElements里移除
                        var idx = new levelRenderer_Util_Util().indexOf(animatingElements, el);
                        animatingElements.splice(idx, 1);
                    }
                });
        } else {
            SUtil_SUtil.Util_log('Element not existed');
        }
    }

    /**
     * @function LevelRenderer.Render.prototype.clearAnimation
     * @description 停止所有动画。
     *
     */
    clearAnimation() {
        this.animation.clear();
    }

    /**
     * @function LevelRenderer.Render.prototype.getWidth
     * @description 获取视图宽度。
     * @return {number} 视图宽度。
     */
    getWidth() {
        return this.painter.getWidth();
    }

    /**
     * @function LevelRenderer.Render.prototype.getHeight
     * @description 获取视图高度。
     * @return {number} 视图高度。
     */
    getHeight() {
        return this.painter.getHeight();
    }

    /**
     * @function LevelRenderer.Render.prototype.toDataURL
     * @description 图像导出。
     *
     * @param {string} type - 类型。
     * @param {string} backgroundColor - 背景色，默认值："#FFFFFF"。
     * @param {string} args - 参数。
     * @return {string} 图片的 Base64 url。
     */
    toDataURL(type, backgroundColor, args) {
        return this.painter.toDataURL(type, backgroundColor, args);
    }

    /**
     * @function LevelRenderer.Render.prototype.shapeToImage
     * @description 将常规 shape 转成 image shape。
     *
     * @param {LevelRenderer.Shape} e - 图形。
     * @param {number} width - 宽度。
     * @param {number} height - 高度。
     * @return {Object} image shape。
     */
    shapeToImage(e, width, height) {
        var id = Util_Util.createUniqueID("SuperMap.LevelRenderer.ToImage_");
        return this.painter.shapeToImage(id, e, width, height);
    }

    /**
     * @function LevelRenderer.Render.prototype.on
     * @description 事件绑定。
     *
     * @param {string} eventName - 事件名称。
     * @param {function} eventHandler - 响应函数。
     * @return {LevelRenderer.Render} this。
     */
    on(eventName, eventHandler) {
        this.handler.on(eventName, eventHandler);
        return this;
    }

    /**
     * @function LevelRenderer.Render.prototype.un
     * @description 事件解绑定，参数为空则解绑所有自定义事件。
     *
     * @param {string} eventName - 事件名称。
     * @param {function} eventHandler - 响应函数。
     * @return {LevelRenderer.Render} this。
     */
    un(eventName, eventHandler) {
        this.handler.un(eventName, eventHandler);
        return this;
    }

    /**
     * @function LevelRenderer.Render.prototype.trigger
     * @description  事件触发。
     *
     * @param {string} eventName - 事件名称，resize，hover，drag，etc。
     * @param {event} event - event dom事件对象。
     * @return {LevelRenderer.Render} this。
     */
    trigger(eventName, event) {
        this.handler.trigger(eventName, event);
        this.handler.dispatch(eventName, event);
        return this;
    }

    /**
     * @function LevelRenderer.Render.prototype.clear
     * @description 清除当前 Render 下所有类图的数据和显示，clear 后 MVC 和已绑定事件均还存在在，Render 可用。
     * @return {LevelRenderer.Render} this。
     */
    clear() {
        this.storage.delRoot();
        this.painter.clear();
        return this;
    }

    /**
     * @function LevelRenderer.Render.prototype.dispose
     * @description 释放当前 Render 实例（删除包括 dom，数据、显示和事件绑定），dispose后 Render 不可用。
     */
    dispose() {
        this.animation.stop();

        this.clear();
        this.storage.dispose();
        this.painter.dispose();
        this.handler.dispose();

        this.animation = null;
        this.animatingElements = null;
        this.storage = null;
        this.painter = null;
        this.handler = null;

        // 释放后告诉全局删除对自己的索引，没想到啥好方法
        // zrender.delInstance(this.id);

    }

    // SMIC-方法扩展 - start
    /**
     * @function LevelRenderer.Render.prototype.updateHoverShapes
     * @description 更新设置显示高亮图层。
     *
     * @param {Array.<LevelRenderer.Shape>} shapes - 图形数组。
     * @return {LevelRenderer.Render} this。
     */
    updateHoverShapes(shapes) {
        this.painter.updateHoverLayer(shapes);
        return this;
    }

    /**
     * @function LevelRenderer.Render.prototype.getAllShapes
     * @description 获取所有图形。
     * @return {Array.<LevelRenderer.Shape>} 图形数组。
     */
    getAllShapes() {
        return this.storage._shapeList;
    }

    /**
     * @function LevelRenderer.Render.prototype.clearAll
     * @description 清除高亮和图形图层。
     * @return {LevelRenderer.Render} this。
     */
    clearAll() {
        this.clear();
        this.painter.clearHover();
        return this;
    }

    /**
     * @function LevelRenderer.Render.prototype.getHoverOne
     * @description 获取单个高亮图形，当前鼠标对应。
     * @return {LevelRenderer.Shape} 高亮图形。
     */
    getHoverOne() {
        return this.handler.getLastHoverOne();
    }

    static getFrameCallback(renderInstance) {
        return function () {
            var animatingElements = renderInstance.animatingElements;

            //animatingElements instanceof Array 临时解决 destory 报错
            if (animatingElements instanceof Array) {
                for (var i = 0, l = animatingElements.length; i < l; i++) {
                    renderInstance.storage.mod(animatingElements[i].id);
                }

                if (animatingElements.length || renderInstance._needsRefreshNextFrame) {
                    renderInstance.refresh();
                }
            }
        };
    }

    // SMIC-方法扩展 - end


}

;// CONCATENATED MODULE: ./src/common/overlay/levelRenderer/LevelRenderer.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/



/**
 * @class  LevelRenderer
 * @deprecatedclass SuperMap.LevelRenderer
 * @category Visualization Theme
 * @classdesc LevelRenderer 渲染器
 * @example
 * //在渲染器上加上图形
 * var levelRenderer = new LevelRenderer();
 * var zr = levelRenderer.init(document.getElementById('lRendertest'));
 * zr.clear();
 * zr.addShape(new LevelRenderer.Shape.Circle({
 *     style:{
 *         x : 100,
 *         y : 100,
 *         r : 50,
 *         brushType: 'fill'
 *     }
 * }));
 * zr.render();
 * @private
 */
class LevelRenderer {
    constructor() {
        /**
         * @member {Object} LevelRenderer.prototype._instances
         * @description LevelRenderer 实例 map 索引
         */
        LevelRenderer._instances = {};

        // 工具
        LevelRenderer.Tool = {};

        /**
         * @member {string} LevelRenderer.prototype.version
         * @description 版本。zRender（Baidu）的版本号
         *              记录当前 LevelRenderer 是在 zRender 的那个版本上构建而来。
         *              在每次完整评判和实施由 zRender（Baidu）升级带来的 LevelRenderer 升级后修改。
         */
        this.version = '2.0.4';

        this.CLASS_NAME = "SuperMap.LevelRenderer";

    }

    /**
     * @function LevelRenderer.prototype.destroy
     * @description 销毁对象，释放资源。调用此函数后所有属性将被置为null。
     */
    destroy() {
        this.dispose();
        this.version = null;
    }

    /**
     * @function LevelRenderer.prototype.init
     * @description 创建 LevelRenderer 实例。
     * @param {HTMLElement} dom - 绘图容器。
     * @returns {LevelRenderer} LevelRenderer 实例。
     */
    init(dom) {
        var zr = new Render(Util_Util.createUniqueID("LRenderer_"), dom);
        LevelRenderer._instances[zr.id] = zr;
        return zr;
    }

    /**
     * @function LevelRenderer.prototype.dispose
     * @description LevelRenderer 实例销毁。
     *              可以通过 zrender.dispose(zr) 销毁指定 LevelRenderer.Render 实例。
     *              也可以通过 zr.dispose() 直接销毁
     * @param {LevelRenderer.Render} zr - ZRender对象，不传此参数则销毁全部。
     * @returns {LevelRenderer} this。
     */
    dispose(zr) {
        if (zr) {
            zr.dispose();
            this.delInstance(zr.id);
        } else {
            for (var key in LevelRenderer._instances) {
                LevelRenderer._instances[key].dispose();
            }
            LevelRenderer._instances = {};
        }

        return this;
    }

    /**
     * @function LevelRenderer.prototype.getInstance
     * @description 获取 LevelRenderer.Render 实例。
     * @param {string} id - ZRender对象索引。
     * @returns {LevelRenderer.Render} LevelRenderer.Render 实例。
     */
    getInstance(id) {
        return LevelRenderer._instances[id];
    }

    /**
     * @function LevelRenderer.prototype.delInstance
     * @description 删除 zrender 实例，LevelRenderer.Render 实例 dispose 时会调用，删除后 getInstance 则返回 undefined
     * @param {string} id - ZRender对象索引。
     * @param {string} id - LevelRenderer.Render 对象索引。
     * @returns {LevelRenderer} this。
     */
    delInstance(id) {
        delete LevelRenderer._instances[id];
        return this;
    }

}

;// CONCATENATED MODULE: ./src/common/iServer/ServerFeature.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/




/**
 * @class ServerFeature
 * @deprecatedclass SuperMap.ServerFeature
 * @category  iServer Data Feature
 * @classdesc 服务端矢量要素类。该类描述了服务端返回的矢量要素的相关信息，包括字段和几何信息。
 * @param {ServerGeometry} geometry - 矢量要素的几何信息。
 * @param {Object} options - 参数。
 * @param {Array.<string>} [options.fieldNames] - 矢量要素的属性字段名集合。
 * @param {Array.<string>} [options.fieldValues] - 矢量要素的属性字段值集合。
 * @usage
 */
class ServerFeature {

    constructor(options) {

        /**
         * @member {Array.<string>} [ServerFeature.prototype.fieldNames]
         * @description 矢量要素的属性字段名集合。
         */
        this.fieldNames = null;

        /**
         * @member {Array.<string>} [ServerFeature.prototype.fieldValues]
         * @description 矢量要素的属性字段值集合。
         */
        this.fieldValues = null;

        /**
         * @member {ServerGeometry} ServerFeature.prototype.geometry
         * @description 矢量要素的几何信息。
         */
        this.geometry = null;
        if (options) {
            Util_Util.extend(this, options);
        }

        this.CLASS_NAME = "SuperMap.ServerFeature";
    }

    /**
     * @function ServerFeature.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        var me = this;
        me.fieldNames = null;
        me.fieldValues = null;
        if (me.geometry) {
            me.geometry.destroy();
            me.geometry = null;
        }
    }

    /**
     * @function ServerFeature.prototype.toFeature
     * @description 将服务端矢量要素 ServerFeature 转换为客户端矢量要素 Feature。
     * @returns {Vector} 转换后的客户端矢量要素。
     */
    toFeature() {
        var names, values, geo,
            attr = {},
            me = this,
            feature;

        names = me.fieldNames;
        values = me.fieldValues;
        for (var i in names) {
            attr[names[i]] = values[i];
        }
        if (me.geometry) {
            geo = me.geometry.toGeometry();
        }
        feature = new Vector(geo, attr);
        if (me.geometry && me.geometry.id) {
            feature.fid = me.geometry.id;
        }

        return feature;
    }

    /**
     * @function ServerFeature.prototype.fromJson
     * @description 将 JSON 对象表示服务端矢量要素转换为 ServerFeature。
     * @param {Object} jsonObject - 要转换的 JSON 对象。
     * @returns {ServerFeature} 转化后的 ServerFeature 对象。
     */
    static fromJson(jsonObject) {
        var geo = null;
        if (!jsonObject) {
            return;
        }
        geo = jsonObject.geometry;
        if (geo) {
            geo = ServerGeometry.fromJson(geo);
        }
        return new ServerFeature({
            fieldNames: jsonObject.fieldNames,
            fieldValues: jsonObject.fieldValues,
            geometry: geo
        });
    }

}


;// CONCATENATED MODULE: ./src/mapboxgl/overlay/theme/ThemeLayer.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/












/**
 * @class ThemeLayer
 * @category Visualization Theme
 * @classdesc 专题图基类。
 * @modulecategory Overlay
 * @param {string} name - 专题图图层名。
 * @param {Object} options -可选参数。
 * @param {mapboxgl.Map} options.map - MapBoxGL Map 对象，将在下个版本弃用，请用 map.addLayer()方法添加图层。
 * @param {string} [options.id] - 专题图层 ID。默认使用 CommonUtil.createUniqueID("themeLayer_") 创建专题图层 ID。
 * @param {boolean} [options.loadWhileAnimating=true] - 是否实时重绘。
 * @param {boolean} [options.visibility=true] - 图层是否可见。
 * @param {number} [options.opacity=1] - 图层不透明度。
 * @fires ThemeLayer#changelayer
 * @fires ThemeLayer#featuresremoved
 * @usage
 */
class ThemeLayer_Theme {

    constructor(name, opt_options) {
        var options = opt_options ? opt_options : {};
        /**
         * @member {string} ThemeLayer.prototype.name
         * @description 专题图图层名称。
         */
        this.name = name;

        /**
         * @member {string} [ThemeLayer.prototype.id]
         * @description 专题图图层 ID。
         */
        this.id = options.id ? options.id : Util_Util.createUniqueID("themeLayer_");
        /**
         * @member {number} [ThemeLayer.prototype.opacity=1]
         * @description 图层不透明度。
         */
        this.opacity = options.opacity ? options.opacity : 1;

        /**
         * @member {boolean} [ThemeLayer.prototype.visibility=true]
         * @description 图层是否可见。
         */
        this.visibility = true;

        /**
         * @member {boolean} [ThemeLayer.prototype.loadWhileAnimating=true]
         * @description 是否实时重绘。(当绘制大数据量要素的情况下会出现卡顿，建议把该参数设为 false)。
         */
        this.loadWhileAnimating = options.loadWhileAnimating === undefined ? true : options.loadWhileAnimating;

        /**
         * @member {mapboxgl.Map} ThemeLayer.prototype.map
         * @description MapBoxGL Map 对象。
         */
        this.map = options.map ? options.map : null;

        this.features = [];
        this.TFEvents = [];

        //todo 保留之前创建图层同时添加到图层的用法，在下个版本遗弃
        if (this.map) {
            this.map.addLayer(this);
        }

    }

    /**
     * @function ThemeLayer.prototype.onAdd
     * @description 添加该图层。
     */
    onAdd(map) {
        this.map = map;
        this._createCanvasContainer();

        //处理用户预先（在图层添加到 map 前）监听的事件
        this.addTFEvents();
        this.map.on('resize', this.resizeEvent.bind(this));
        this.map.on('zoomstart', this.zoomStartEvent.bind(this));
        this.map.on('zoomend', this.zoomEndEvent.bind(this));
        this.map.on('rotatestart', this.rotateStartEvent.bind(this));
        this.map.on('rotate', this.rotateEvent.bind(this));
        this.map.on('rotateend', this.rotateEndEvent.bind(this));
        this.map.on('dragend', this.dragEndEvent.bind(this));
        this.map.on('movestart', this.moveStartEvent.bind(this));
        this.map.on('move', this.moveEvent.bind(this));
        this.map.on('moveend', this.moveEndEvent.bind(this));
        this.map.on('remove', this.removeFromMap.bind(this));

        this.refresh();
    }

    /**
     * @function ThemeLayer.prototype.refresh
     * @description 强制刷新当前热点显示，在图层热点数组发生变化后调用，更新显示。
     */
    refresh() {
        if (this.features.length === 0) {
            return;
        }
        if (this.map) {
            this.redrawThematicFeatures(this.map.getBounds());
        }
    }

    _createCanvasContainer() {
        this.movingOffset = [0, 0];
        this.mapContainer = this.map.getCanvasContainer();
        this.div = document.createElement('div');
        this.div.id = this.id;
        this.div.style.position = 'absolute';
        var container = this.map.getCanvasContainer();
        var canvas = this.map.getCanvas();
        this.mapContainer.style.perspective = this.map.transform.cameraToCenterDistance + 'px';
        this.div.style.width = canvas.style.width;
        this.div.style.height = canvas.style.height;
        this.div.className = "themeLayer";
        this.div.width = parseInt(canvas.width);
        this.div.height = parseInt(canvas.height);
        container.appendChild(this.div);
        this.setOpacity(this.opacity);
        this.levelRenderer = new LevelRenderer();
        this.renderer = this.levelRenderer.init(this.div);
        this.renderer.clear();
    }

    /**
     * @function ThemeLayer.prototype.destroyFeatures
     * @description 销毁要素。
     * @param {Array.<FeatureVector>|FeatureVector} features - 将被销毁的要素。
     */
    destroyFeatures(features) {
      var all = (features === undefined);
      if (all) {
          features = this.features;
      }
      if (features) {
          this.removeFeatures(features);
          if (!Array.isArray(features)) {
            features = [features];
          }
          for (var i = features.length - 1; i >= 0; i--) {
              features[i].destroy();
          }
      }
    }

    /**
     * @function ThemeLayer.prototype.setVisibility
     * @description 设置图层可见性。
     * @param {boolean} [visibility] - 是否显示图层（当前地图的 resolution 在最大最小 resolution 之间）。
     */
    setVisibility(visibility) {
        if (visibility !== this.visibility) {
            this.visibility = visibility;
            this.display(visibility);
            this.redrawThematicFeatures(this.map.getBounds());
        }
    }

    /**
     * @function ThemeLayer.prototype.display
     * @description 隐藏或者显示图层。（通过对 CSS 控制产生即时效果，重新渲染失效。）
     * @param {boolean} [display] - 是否显示图层。
     */
    display(display) {
        this.div.style.display = display ? "block" : "none";
    }

    /**
     * @function ThemeLayer.prototype.setOpacity
     * @description 设置图层的不透明度。
     * @param {number} [opacity] - 不透明度，取值[0-1]之间。
     */
    setOpacity(opacity) {
        if (opacity !== this.opacity) {
            this.opacity = opacity;
            var element = this.div;
            Util_Util.modifyDOMElement(element, null, null, null,
                null, null, null, opacity);

            if (this.map !== null) {
                 /**
                 * @event ThemeLayer#changelayer
                 * @description 图层属性改变之后触发。
                 * @property {Object} layer - 图层。
                 * @property {string} property - 被改变的属性。
                 */
                external_mapboxgl_default().Evented.prototype.fire('changelayer', {layer: this, property: "opacity"});
            }
        }
    }

    /**
     * @function ThemeLayer.prototype.addFeatures
     * @param {ThemeFeature|ServerFeature|GeoJSONObject} features - 待添加要素。
     * @description 向专题图图层中添加数据
     */
    addFeatures(features) { // eslint-disable-line no-unused-vars

    }

    /**
     * @function ThemeLayer.prototype.removeFeatures
     * @param {(Array.<FeatureVector>|FeatureVector|Function)} features - 待删除 feature 的数组或用来过滤的回调函数。 
     * @description 删除专题图中的features。
     *              参数中的 features 数组中的每一项，必须是已经添加到当前图层中的 feature，
     *              如果要删除的 features 数组中的元素过多，推荐使用 removeAllFeatures删除所有 feature后，再重新添加。这样效率会更高。
     */
    removeFeatures(features) {
      var me = this;
      if (!features) {
          return;
      }
      if (features === me.features) {
          return me.removeAllFeatures();
      }
      if (!Util_Util.isArray(features) && !(typeof features === 'function')) {
          features = [features];
      }

      var featuresFailRemoved = [];

      for (var i = 0; i < me.features.length; i++) {
          var feature = me.features[i];

          //如果我们传入的feature在features数组中没有的话，则不进行删除，
          //并将其放入未删除的数组中。
          if (features && typeof features === 'function') {
            if (features(feature)) {
              me.features.splice(i--, 1);
            }
          } else {
            var findex = Util_Util.indexOf(features, feature);
            if (findex === -1) {
                featuresFailRemoved.push(feature);
            } else {
              me.features.splice(i--, 1);
            }
          }
      }

      var drawFeatures = [];
      for (var hex = 0, len = this.features.length; hex < len; hex++) {
          feature = this.features[hex];
          drawFeatures.push(feature);
      }
      this.features = [];
      this.addFeatures(drawFeatures);
      //绘制专题要素
      if (this.renderer) {
          this.redrawThematicFeatures(this.map.getBounds());
      }
      var succeed = featuresFailRemoved.length == 0 ? true : false;
      /**
       * @event ThemeLayer#featuresremoved
       * @description 要素删除之后触发。
       * @property {Array.<FeatureVector>} features - 未被成功删除的要素。
       * @property {boolean} succeed - 删除成功与否。
       */
      external_mapboxgl_default().Evented.prototype.fire("featuresremoved", {features: featuresFailRemoved, succeed: succeed});
    }

    /**
     * @function ThemeLayer.prototype.removeAllFeatures
     * @description 清除当前图层所有的矢量要素。
     */
    removeAllFeatures() {
        if (this.renderer) {
            this.renderer.clear();
        }
        this.features = [];
        external_mapboxgl_default().Evented.prototype.fire('featuresremoved', {features: [], succeed: true});
    }

    /**
     * @function ThemeLayer.prototype.getFeatures
     * @description 查看当前图层中的有效数据。
     * @param {Function} [filter] - 根据条件过滤要素的回调函数。
     * @returns {Array.<FeatureVector>} 用户加入图层的有效数据。
     */
    getFeatures(filter) {
      var len = this.features.length;
      var clonedFeatures = [];
      for (var i = 0; i < len; ++i) {
        if (!filter || (filter && typeof filter === 'function' && filter(this.features[i]))) {
          clonedFeatures.push(this.features[i]);
        }
      }
      return clonedFeatures;
    }

    /**
     * @function ThemeLayer.prototype.getFeatureBy
     * @description 在专题图的要素中，获取第一个feature[property] === value的矢量要素。
     * @param {string} property - 属性名称。
     * @param {string} value - 属性值。
     * @returns {FeatureVector} 矢量要素。
     */
    getFeatureBy(property, value) {
        var feature = null;
        for (var id in this.features) {
            if (this.features[id][property] === value) {
                feature = this.features[id];
                break;
            }
        }
        return feature;
    }

    /**
     * @function ThemeLayer.prototype.getFeatureById
     * @description 获取指定featureId的矢量要素。
     * @param {string} featureId - 矢量要素的属性 ID。
     * @returns {FeatureVector} 对应featureId的矢量要素，不存在则返回 null。
     */
    getFeatureById(featureId) {
        return this.getFeatureBy('id', featureId);
    }

    /**
     * @function ThemeLayer.prototype.getFeaturesByAttribute
     * @description 通过属性的 key 值和 value 值，获取匹配的要素数组。
     * @param {string} attrName - 属性的 key。
     * @param {string} attrValue - 属性的 value。
     * @returns {Array.<FeatureVector>} 要素数组。
     */
    getFeaturesByAttribute(attrName, attrValue) {
        var feature,
            foundFeatures = [];
        for (var id in this.features) {
            feature = this.features[id];
            if (feature && feature.attributes) {
                if (feature.attributes[attrName] === attrValue) {
                    foundFeatures.push(feature);
                }
            }
        }
        return foundFeatures;
    }

    /**
     * @function ThemeLayer.prototype.redrawThematicFeatures
     * @description 重绘专题要素。
     * @param {mapboxgl.LngLatBounds} extent - 重绘的范围。
     */
    redrawThematicFeatures(extent) { // eslint-disable-line no-unused-vars
    }

    /**
     * @function ThemeLayer.prototype.on
     * @description 添加专题要素事件监听。
     * @param {Event} event - 监听事件。
     * @param {function} callback - 回调函数。
     * @param {string} context - 信息。
     */
    on(event, callback, context) { // eslint-disable-line no-unused-vars
        if (this.renderer) {
            this.renderer.on(event, callback);
        } else {
            this.map.on(event, callback);
        }
        return this;
    }

    /**
     * @function ThemeLayer.prototype.off
     * @description 移除专题要素事件监听。
     * @param {Event} event - 监听事件。
     * @param {function} callback - 回调函数。
     * @param {string} context - 信息。
     */
    off(event, callback, context) { // eslint-disable-line no-unused-vars
        var me = this;
        if (me.renderer) {
            me.renderer.un(event, callback);
        } else {
            this.map.off(event, callback);
        }
        return this;
    }

    /**
     * @function ThemeLayer.prototype.addTFEvents
     * @description 将事件监听添加到图层。
     * @private
     */
    addTFEvents() {
        var tfEs = this.TFEvents;
        var len = tfEs.length;
        for (var i = 0; i < len; i++) {
            this.renderer.on(tfEs[i][0], tfEs[i][1]);
        }

    }

    /**
     * @function ThemeLayer.prototype.getLocalXY
     * @description 地理坐标转为像素坐标。
     * @param {Object} [coordinate] - 坐标位置。
     * @returns {Array} 像素坐标数组。
     */
    getLocalXY(coordinate) {
        var pixelP, map = this.map;
        if (coordinate instanceof Point || coordinate instanceof GeoText) {
            let tempPoint = map.project(new (external_mapboxgl_default()).LngLat(coordinate.x, coordinate.y));
            pixelP = [tempPoint.x, tempPoint.y];
        }
        if (coordinate instanceof LonLat) {
            let tempPoint = map.project(new (external_mapboxgl_default()).LngLat(coordinate.lon, coordinate.lat));
            pixelP = [tempPoint.x, tempPoint.y];
        }
        return pixelP;
    }

    /**
     * @function ThemeLayer.prototype.toiClientFeature
     * @description 转为 iClient 要素。
     * @param {(Array.<ServerFeature>|Array.<ThemeFeature>|Array.<GeoJSONObject>|ServerFeature|ThemeFeature|GeoJSONObject)} features - 待转要素。
     * @returns {Array.<FeatureVector>} 转换后的 iClient 要素。
     */
    toiClientFeature(features) {
        if (!Util_Util.isArray(features)) {
            features = [features];
        }

        let featuresTemp = [];
        for (let i = 0; i < features.length; i++) {
            //ThemeFeature 类型
            if (features[i] instanceof ThemeFeature) {
                featuresTemp.push(features[i].toFeature());
            } else if (features[i] instanceof Vector) {
                // 若是 FeatureVector 直接返回
                featuresTemp.push(features[i]);
            } else if (["FeatureCollection", "Feature", "Geometry"].indexOf(features[i].type) != -1) {
                //GeoJSON 规范数据类型
                let format = new GeoJSON();
                featuresTemp = featuresTemp.concat(format.read(features[i]));
            } else if (features[i].geometry && features[i].geometry.parts) {
                //iServer服务器返回数据格式
                featuresTemp.push(ServerFeature.fromJson(features[i]).toFeature());
            } else {
                throw new Error(`features's type is not be supported.`);
            }

        }
        return featuresTemp;
    }

    /**
     * @function ThemeLayer.prototype.toFeature
     * @deprecated
     * @description 转为 iClient 要素，该方法将被弃用，由 {@link ThemeLayer#toiClientFeature} 代替。
     * @param {(Array.<ServerFeature>|Array.<ThemeFeature>|Array.<GeoJSONObject>|ServerFeature|ThemeFeature|GeoJSONObject)} features - 待转要素。
     * @returns {FeatureVector} 转换后的 iClient 要素。
     */
    toFeature(features) {
        return this.toiClientFeature(features);
    }

    moveEndEvent() {
        if (this.loadWhileAnimating || !this.visibility) {
            return;
        }
        this.div.style.transform = '';
        this.redrawThematicFeatures(this.map.getBounds());
        this._show();
    }

    moveStartEvent() {
        if (this.loadWhileAnimating || !this.visibility) {
            return;
        }
        this.startPitch = this.map.getPitch();
        this.startBearing = this.map.getBearing();
        var startMovePoint = this.map.project(new (external_mapboxgl_default()).LngLat(0, 0));
        this.startMoveX = startMovePoint.x;
        this.startMoveY = startMovePoint.y;
    }

    moveEvent() {
        if (this.loadWhileAnimating || !this.visibility) {
            this.redrawThematicFeatures(this.map.getBounds());
            return;
        }
        if (this.rotating || this.zooming) {
            return;
        }
        if (this.map.getPitch() !== 0) {
            this._hide();
        }
        this.mapContainer.style.perspective = this.map.transform.cameraToCenterDistance + 'px';
        var tPitch = this.map.getPitch() - this.startPitch;
        var tBearing = -this.map.getBearing() + this.startBearing;
        var endMovePoint = this.map.project(new (external_mapboxgl_default()).LngLat(0, 0));
        var tMoveX = endMovePoint.x - this.startMoveX;
        var tMoveY = endMovePoint.y - this.startMoveY;
        this.div.style.transform = 'rotateX(' + tPitch + 'deg)' + ' rotateZ(' + tBearing + 'deg)' + ' translate3d(' + tMoveX + 'px, ' + tMoveY + 'px, 0px)';
    }

    zoomStartEvent() {
        if (this.loadWhileAnimating || !this.visibility) {
            return;
        }
        this.zooming = true;
        this._hide();
    }

    zoomEndEvent() {
        if (this.loadWhileAnimating || !this.visibility) {
            return;
        }
        this.zooming = false;
        this._show();
    }

    rotateStartEvent() {
        if (this.loadWhileAnimating || !this.visibility) {
            return;
        }
        this.rotating = true;
    }

    rotateEvent() {
        if (this.loadWhileAnimating || !this.visibility) {
            return;
        }
        if (this.map.getPitch() !== 0) {
            this._hide();
        }
        this.mapContainer.style.perspective = this.map.transform.cameraToCenterDistance + 'px';
        var tPitch = this.map.getPitch() - this.startPitch;
        var tBearing = -this.map.getBearing() + this.startBearing;
        this.div.style.transform = 'rotateX(' + tPitch + 'deg)' + ' rotateZ(' + tBearing + 'deg)'
    }

    rotateEndEvent() {
        if (this.loadWhileAnimating || !this.visibility) {
            return;
        }
        this.rotating = false;
        this._show();
    }

    dragEndEvent() {
        if (this.loadWhileAnimating || !this.visibility) {
            return;
        }
        this._hide();
    }

    resizeEvent() {
        this.mapContainer.style.perspective = this.map.transform.cameraToCenterDistance + 'px';
        var canvas = this.map.getCanvas();
        this.div.style.width = canvas.style.width;
        this.div.style.height = canvas.style.height;
        this.div.width = parseInt(canvas.width);
        this.div.height = parseInt(canvas.height);
        this.renderer.resize();
    }

    /**
     * @function ThemeLayer.prototype.removeFromMap
     * @description 移除图层。
     */
    removeFromMap() {
        this.mapContainer.removeChild(this.div);
        this.removeAllFeatures();
    }

    /**
     * @function ThemeLayer.prototype.moveTo
     * @description 将图层移动到某个图层之前。
     * @param {string} layerID - 待插入的图层 ID。
     * @param {boolean} [before=true] - 是否将本图层插入到图层 ID 为 layerID 的图层之前。
     */
    moveTo(layerID, before) {
        const layer = document.getElementById(this.div.id);
        before = before !== undefined ? before : true;
        if (before) {
            const beforeLayer = document.getElementById(layerID);
            if (layer && beforeLayer) {
                beforeLayer.parentNode.insertBefore(layer, beforeLayer);
            }
            return;
        }
        const nextLayer = document.getElementById(layerID);
        if (layer) {
            if (nextLayer.nextSibling) {
                nextLayer.parentNode.insertBefore(layer, nextLayer.nextSibling);
                return;
            }
            nextLayer.parentNode.appendChild(layer);
        }
    }

    _hide() {
        this.renderer.painter.root.style.display = 'none';
    }

    _show() {
        this.renderer.painter.root.style.display = 'block';
    }
}

;// CONCATENATED MODULE: ./src/mapboxgl/overlay/GraphThemeLayer.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/






/**
 * @class GraphThemeLayer
 * @category  Visualization Theme
 * @classdesc 统计专题图层类。
 * @modulecategory Overlay
 * @param {string} name - 图层名。
 * @param {string} chartsType - 图表类别。
 * @param {Object} options - 参数。
 * @param {string} [options.id] - 专题图层 ID。默认使用 CommonUtil.createUniqueID("themeLayer_") 创建专题图层 ID。
 * @param {boolean} [options.loadWhileAnimating=true] - 是否实时重绘。
 * @param {mapboxgl.Map} options.map - MapBoxGL Map 对象。
 * @param {number} [options.opacity=1] - 图层不透明度。
 * @param {string} options.themeFields - 指定创建专题图字段。
 * @param {boolean} [options.isOverLay=true] - 是否进行压盖处理，如果设为 true，图表绘制过程中将隐藏对已在图层中绘制的图表产生压盖的图表。
 * @param {string} [options.chartsType] - 图表类型。目前可用："Bar", "Line", "Pie"。
 * @param {Object} options.chartsSetting - 符号 Circle 配置对象。
 * @param {Array.<number>} options.chartsSetting.codomain - 图表允许展示的数据值域，长度为 2 的一维数组，第一个元素表示值域下限，第二个元素表示值域上限。
 * @param {number} [options.chartsSetting.maxR] - 圆形的最大半径。
 * @param {number} [options.chartsSetting.minR] - 圆形的最小半径。
 * @param {string} options.chartsSetting.fillColor - 圆形的填充色，如：fillColor: "#FFB980"。
 * @param {Object} options.chartsSetting.circleStyle - 圆形的基础 style，此参数控制圆形基础样式，优先级低于 circleStyleByFields 和 circleStyleByCodomain。
 * @param {number} options.chartsSetting.decimalNumber - 数据值数组 dataValues 元素值小数位数，数据的小数位处理参数，取值范围：[0, 16]。默认不对数据做小数位处理。
 * @param {Object} options.chartsSetting.circleHoverStyle - 圆形 hover 状态时的样式，circleHoverAble 为 true 时有效。
 * @param {boolean} [options.chartsSetting.circleHoverAble=true] - 是否允许圆形使用 hover 状态。同时设置 circleHoverAble 和 circleClickAble 为 false，可以直接屏蔽图形对专题图层事件的响应。
 * @param {boolean} [options.chartsSetting.circleClickAble=true] - 是否允许圆形被点击。同时设置 circleHoverAble 和 circleClickAble 为 false，可以直接屏蔽图形对专题图层事件的响应。
 * @extends {ThemeLayer}
 * @fires GraphThemeLayer#beforefeaturesadded
 * @usage
 */
class Graph extends ThemeLayer_Theme {

    constructor(name, chartsType, options) {
        super(name, options);
        this.chartsSetting = options.chartsSetting || {};
        this.themeFields = options.themeFields || null;
        this.overlayWeightField = options.overlayWeightField || null;
        this.isOverLay = options.isOverLay === undefined ? true : options.isOverLay;
        this.charts = options.charts || [];
        this.cache = options.cache || {};
        this.chartsType = chartsType;
    }

    /**
     * @function GraphThemeLayer.prototype.setChartsType
     * @description 设置图表类型，此函数可动态改变图表类型。在调用此函数前请通过 chartsSetting 为新类型的图表做相关配置。
     * @param {string} [chartsType] - 图表类型。目前可用："Bar", "Line", "Pie"。
     */
    setChartsType(chartsType) {
        this.chartsType = chartsType;
        this.redraw();
    }

    /**
     * @function GraphThemeLayer.prototype.addFeatures
     * @description 向专题图图层中添加数据，支持的 feature 类型为：iServer 返回的 feature JSON 对象。
     * @param {ServerFeature} features - 待添加的要素。
     */
    addFeatures(features) {
        /**
         * @event GraphThemeLayer#beforefeaturesadded
         * @description 要素添加之前触发。
         * @property {ServerFeature} features - 要被添加的要素。
         */
        var ret = external_mapboxgl_default().Evented.prototype.fire('beforefeaturesadded', {
            features: features
        });
        if (ret === false) {
            return;
        }
        //转换 features 形式
        this.features = this.toiClientFeature(features);
        //绘制专题要素
        if (this.renderer) {
            this.redrawThematicFeatures(this.map.getBounds());
        }
    }

    /**
     * @function GraphThemeLayer.prototype.redrawThematicFeatures
     * @description 重绘所有专题要素。
     *              此方法包含绘制专题要素的所有步骤，包含用户数据到专题要素的转换，抽稀，缓存等步骤。
     *              地图漫游时调用此方法进行图层刷新。
     */
    redrawThematicFeatures() {
        this.clearCache();
        //清除当前所有可视元素
        this.renderer.clearAll();
        var features = this.features;
        for (var i = 0, len = features.length; i < len; i++) {
            var feature = features[i];
            // // 要素范围判断
            // var feaBounds = feature.geometry.getBounds();
            // //剔除当前视图（地理）范围以外的数据
            // if (extent) {
            //     var bounds = new Bounds(extent.getWest(), extent.getSouth(), extent.getEast(), extent.getNorth());
            //     // if (!bounds.intersectsBounds(feaBounds)) continue;
            // }
            var cache = this.cache;
            // 用 feature id 做缓存标识
            var cacheField = feature.id;
            // 数据对应的图表是否已缓存，没缓存则重新创建图表
            if (cache[cacheField]) {
                continue;
            }
            cache[cacheField] = cacheField;
            var chart = this.createThematicFeature(feature);
            // 压盖处理权重值
            if (chart && this.overlayWeightField) {
                if (feature.attributes[this.overlayWeightField] && !isNaN(feature.attributes[this.overlayWeightField])) {
                    chart["__overlayWeight"] = feature.attributes[this.overlayWeightField];
                }
            }
            if (chart) {
                this.charts.push(chart);
            }
        }
        this.drawCharts();
    }

    /**
     * @function GraphThemeLayer.prototype.createThematicFeature
     * @description  向专题图图层中添加数据, 支持的 feature 类型为:iServer 返回的 feature json 对象。
     * @param {Object} feature - 待添加的要素。
     *
     */
    createThematicFeature(feature) {
        var thematicFeature;
        // 检查图表创建条件并创建图形
        if (Theme[this.chartsType] && this.themeFields && this.chartsSetting) {
            thematicFeature = new Theme[this.chartsType](feature, this, this.themeFields, this.chartsSetting);
        }
        // thematicFeature 是否创建成功
        if (!thematicFeature) {
            return false;
        }
        // 对专题要素执行图形装载
        thematicFeature.assembleShapes();
        return thematicFeature;
    }

    /**
     * @function GraphThemeLayer.prototype.drawCharts
     * @description 绘制图表。包含压盖处理。
     *
     */
    drawCharts() {
        // 判断 rendere r就绪
        if (!this.renderer) {
            return;
        }
        var charts = this.charts;
        // 图表权重值处理des
        if (this.overlayWeightField) {
            charts.sort(function (cs, ce) {
                if (typeof (cs["__overlayWeight"]) == "undefined" && typeof (ce["__overlayWeight"]) == "undefined") {
                    return 0;
                } else if (typeof (cs["__overlayWeight"]) != "undefined" && typeof (ce["__overlayWeight"]) == "undefined") {
                    return -1;
                } else if (typeof (cs["__overlayWeight"]) == "undefined" && typeof (ce["__overlayWeight"]) != "undefined") {
                    return 1;
                } else if (typeof (cs["__overlayWeight"]) != "undefined" && typeof (ce["__overlayWeight"]) != "undefined") {
                    if (parseFloat(cs["__overlayWeight"]) < parseFloat(ce["__overlayWeight"])) {
                        return 1;
                    } else {
                        return -1;
                    }
                }
                return 0;
            });
        }
        // 不进行避让
        if (!this.isOverLay) {
            for (var m = 0, len_m = charts.length; m < len_m; m++) {
                var chart_m = charts[m];
                // 图形参考位置  (reSetLocation 会更新 chartBounds)
                var shapeROP_m = chart_m.resetLocation();
                // 添加图形
                var shapes_m = chart_m.shapes;
                for (var n = 0, slen_n = shapes_m.length; n < slen_n; n++) {
                    shapes_m[n].refOriginalPosition = shapeROP_m;
                    this.renderer.addShape(shapes_m[n]);
                }
            }
        } else {
            // 压盖判断所需 chartsBounds 集合
            var chartsBounds = [];
            //var extent = this.map.getBounds();
            //var mapBounds = new Bounds(extent.getWest(), extent.getSouth(), extent.getEast(), extent.getNorth());
            // 获取地图像素 bounds
            //var mapPxLT = this.getLocalXY(new LonLat(mapBounds.left, mapBounds.top));
            //var mapPxRB = this.getLocalXY(new LonLat(mapBounds.right, mapBounds.bottom));
            //var mBounds = new Bounds(mapPxLT[0], mapPxRB[1], mapPxRB[0], mapPxLT[1]);
            // 压盖处理 & 添加图形
            for (let i = 0, len = charts.length; i < len; i++) {
                var chart = charts[i];
                // 图形参考位置  (reSetLocation 会更新 chartBounds)
                var shapeROP = chart.resetLocation();
                // 图表框
                var cbs = chart.chartBounds;
                var cBounds = [{
                    "x": cbs.left,
                    "y": cbs.top
                }, {
                    "x": cbs.left,
                    "y": cbs.bottom
                }, {
                    "x": cbs.right,
                    "y": cbs.bottom
                }, {
                    "x": cbs.right,
                    "y": cbs.top
                }, {
                    "x": cbs.left,
                    "y": cbs.top
                }];
                // // 地图范围外不绘制
                // if (mBounds) {
                //     // if (!this.isChartInMap(mBounds, cBounds)) continue;
                // }
                // 是否压盖
                var isOL = false;
                if (i !== 0) {
                    for (let j = 0; j < chartsBounds.length; j++) {
                        //压盖判断
                        if (this.isQuadrilateralOverLap(cBounds, chartsBounds[j])) {
                            isOL = true;
                            break;
                        }
                    }
                }
                if (isOL) {
                    continue;
                } else {
                    chartsBounds.push(cBounds);
                }
                // 添加图形
                var shapes = chart.shapes;
                for (let j = 0, slen = shapes.length; j < slen; j++) {
                    shapes[j].refOriginalPosition = shapeROP;
                    this.renderer.addShape(shapes[j]);
                }
            }
        }
        // 绘制图形
        this.renderer.render();
    }

    /**
     * @function GraphThemeLayer.prototype.getShapesByFeatureID
     * @description  通过 FeatureID 获取 feature 关联的所有图形。如果不传入此参数，函数将返回所有图形。
     * @param {number} featureID - 要素 ID。
     */
    getShapesByFeatureID(featureID) {
        var list = [];
        var shapeList = this.renderer.getAllShapes();
        if (!featureID) {
            return shapeList
        }
        for (var i = 0, len = shapeList.length; i < len; i++) {
            var si = shapeList[i];
            if (si.refDataID && featureID === si.refDataID) {
                list.push(si);
            }
        }
        return list;
    }

    /**
     * @function GraphThemeLayer.prototype.isQuadrilateralOverLap
     * @description  判断两个四边形是否有压盖。
     * @param {Array.<Object>} quadrilateral - 四边形节点数组。
     * @param {Array.<Object>} quadrilateral2 - 第二个四边形节点数组。
     */
    isQuadrilateralOverLap(quadrilateral, quadrilateral2) {
        var quadLen = quadrilateral.length,
            quad2Len = quadrilateral2.length;
        if (quadLen !== 5 || quad2Len !== 5) {
            return null;
        } //不是四边形

        var OverLap = false;
        //如果两四边形互不包含对方的节点，则两个四边形不相交
        for (let i = 0; i < quadLen; i++) {
            if (this.isPointInPoly(quadrilateral[i], quadrilateral2)) {
                OverLap = true;
                break;
            }
        }
        for (let i = 0; i < quad2Len; i++) {
            if (this.isPointInPoly(quadrilateral2[i], quadrilateral)) {
                OverLap = true;
                break;
            }
        }
        //加上两矩形十字相交的情况
        for (let i = 0; i < quadLen - 1; i++) {
            if (OverLap) {
                break;
            }
            for (let j = 0; j < quad2Len - 1; j++) {
                var isLineIn = Util_Util.lineIntersection(quadrilateral[i], quadrilateral[i + 1], quadrilateral2[j], quadrilateral2[j + 1]);
                if (isLineIn.CLASS_NAME === "SuperMap.Geometry.Point") {
                    OverLap = true;
                    break;
                }
            }
        }
        return OverLap;
    }

    /**
     * @function GraphThemeLayer.prototype.isPointInPoly
     * @description  判断一个点是否在多边形里面（射线法）。
     * @param {Object} pt - 需要判定的点对象，该对象含有属性 x (横坐标)，属性 y (纵坐标)。
     * @param {Array.<Object>} poly - 多边形节点数组。
     */
    isPointInPoly(pt, poly) {
        for (var isIn = false, i = -1, l = poly.length, j = l - 1; ++i < l; j = i) {
            ((poly[i].y <= pt.y && pt.y < poly[j].y) || (poly[j].y <= pt.y && pt.y < poly[i].y)) &&
            (pt.x < (poly[j].x - poly[i].x) * (pt.y - poly[i].y) / (poly[j].y - poly[i].y) + poly[i].x) &&
            (isIn = !isIn);
        }
        return isIn;
    }

    /**
     * @function GraphThemeLayer.prototype.isChartInMap
     * @description  判断图表是否在地图里。
     * @param {Bounds} mapPxBounds - 地图像素范围。
     * @param {Array.<Object>} chartPxBounds - 图表范围的四边形节点数组。
     */
    isChartInMap(mapPxBounds, chartPxBounds) {
        var mb = mapPxBounds;
        var isIn = false;
        for (var i = 0, len = chartPxBounds.length; i < len; i++) {
            var cb = chartPxBounds[i];

            if (cb.x >= mb.left && cb.x <= mb.right && cb.y >= mb.top && cb.y <= mb.bottom) {
                isIn = true;
                break;
            }
        }
        return isIn;
    }

    /**
     * @function GraphThemeLayer.prototype.clearCache
     * @description  清除缓存。
     */
    clearCache() {
        this.cache = {};
        this.charts = [];
    }

    /**
     * @function GraphThemeLayer.prototype.removeFeatures
     * @description  从专题图中删除 feature。这个函数删除所有传递进来的矢量要素。参数中的 features 数组中的每一项，必须是已经添加到当前图层中的 feature。
     * @param {Array.<FeatureVector>|FeatureVector|Function} features - 要删除的要素。
     */
    removeFeatures(features) {
        this.clearCache();
        super.removeFeatures(features);
    }

    /**
     * @function GraphThemeLayer.prototype.removeAllFeatures
     * @description  移除所有的要素。
     */
    removeAllFeatures() {
        this.clearCache();
        super.removeAllFeatures();
    }

    /**
     * @function GraphThemeLayer.prototype.redraw
     * @description  重绘该图层。
     */
    redraw() {
        this.clearCache();
        if (this.renderer) {
            this.redrawThematicFeatures(this.map.getBounds());
            return true;
        }
        return false
    }

    /**
     * @function GraphThemeLayer.prototype.clear
     * @description  清除的内容包括数据（features） 、专题要素、缓存。
     */
    clear() {
        if (this.renderer) {
            this.renderer.clearAll();
            this.renderer.refresh();
        }
        this.removeAllFeatures();
        this.clearCache();
    }
}

;// CONCATENATED MODULE: ./src/common/overlay/feature/ShapeParameters.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/
/**
 * @class  ShapeParameters
 * @aliasclass Feature.ShapeParameters
 * @deprecatedclass SuperMap.Feature.ShapeParameters
 * @category Visualization Theme
 * @classdesc 图形参数基类
 * @usage
 */
class ShapeParameters {
    constructor() {
        /**
         * @member {Array.<number>} [ShapeParameters.prototype.refOriginalPosition=[0,0]]
         * @description 图形参考原点位置，图形的参考中心位置。
         * refOriginalPosition 是长度为 2 的数组，第一个元素表示 x 坐标，第二个元素表示 y 坐标。
         * refOriginalPosition 表示图形的参考中心，通常情况下，图形是使用 canvas 的原点位置作为位置参考，
         * 但 refOriginalPosition 可以改变图形的参考位置，例如： refOriginalPosition = [80, 80],
         * 图形圆的 style.x = 20, style.y = 20，那么圆在 canvas 中的实际位置是 [100, 100]。
         * 图形（Shape）的所有位置相关属性都是以 refOriginalPosition 为参考中心，
         * 也就是说图形的所有位置信息在 canvas 中都是以 refOriginalPosition 为参考的相对位置，只有
         * refOriginalPosition 的值为 [0, 0] 时，图形的位置信息才是 canvas 绝对位置。
         * 图形的位置信息通常有：style.pointList，style.x，style.y。
         */
        this.refOriginalPosition = [0, 0];

        /**
         * @member {string} ShapeParameters.prototype.refDataID
         * @description 图形所关联数据的 ID（<{@link FeatureVector}> 的 ID）。
         */
        this.refDataID = null;

        /**
         * @member {boolean} ShapeParameters.prototype.isHoverByRefDataID
         * @description 是否根据 refDataID 进行高亮。用于同时高亮所有 refDataID 相同的图形。
         */
        this.isHoverByRefDataID = false;

        /**
         * @member {string} ShapeParameters.prototype.refDataHoverGroup
         * @description 高亮图形组的组名。此属性在 refDataID 有效且 isHoverByRefDataID 为 true 时生效。
         * 一旦设置此属性，且属性值有效，只有关联同一个数据的图形且此属性相同的图形才会高亮。
         */
        this.refDataHoverGroup = null;

        /**
         * @member {Object} ShapeParameters.prototype.dataInfo
         * @description 图形携带的附加数据。
         */
        this.dataInfo = null;

        /**
         * @member {boolean} ShapeParameters.prototype.clickable
         * @description 是否可点击。
         */
        this.clickable = true;

        /**
         * @member {boolean} ShapeParameters.prototype.hoverable
         * @description 是否可点击。
         */
        this.hoverable = true;

        /**
         * @member {Object} ShapeParameters.prototype.style
         * @description 图形样式对象，可设样式属性在子类中确定。
         */
        this.style = null;

        /**
         * @member {Object} ShapeParameters.prototype.highlightStyle
         * @description 高亮样式对象，可设样式属性与 style 的可设样式属性相同。
         */
        this.highlightStyle = {};

        this.CLASS_NAME = "SuperMap.Feature.ShapeParameters";
    }


    /**
     * @function ShapeParameters.prototype.destroy
     * @description 销毁对象。
     */
    destroy() {
        this.refOriginalPosition = null;
        this.refDataID = null;
        this.isHoverByRefDataID = null;
        this.refDataHoverGroup = null;
        this.dataInfo = null;
        this.clickable = null;
        this.hoverable = null;
        this.style = null;
        this.highlightStyle = null;
    }

}

;// CONCATENATED MODULE: ./src/common/overlay/feature/Point.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


/**
 * @class  ShapeParametersPoint
 * @aliasclass Feature.ShapeParameters.Point
 * @deprecatedclass SuperMap.Feature.ShapeParameters.Point
 * @category Visualization Theme
 * @classdesc 点参数对象。
 * @extends {ShapeParameters}
 * @param {number} x - 点 x 坐标。
 * @param {number} y - 点 y 坐标。
 * @usage
 */

class Point_Point extends ShapeParameters {
    constructor(x, y) {
        super(x, y);
        /**
         * @member {number}  ShapeParametersPoint.prototype.x
         * @description 点 x 坐标。
         */
        this.x = !isNaN(x) ? x : 0;

        /**
         * @member {number}  ShapeParametersPoint.prototype.y
         * @description 点 y 坐标。
         */
        this.y = !isNaN(y) ? y : 0;

        /**
         * @member {number}  ShapeParametersPoint.prototype.r
         * @description 点的半径。
         */
        this.r = 6;


        this.CLASS_NAME = "SuperMap.Feature.ShapeParameters.Point";
    }


    /**
     * @function ShapeParametersPoint.prototype.destroy
     * @description 销毁对象。
     */
    destroy() {
        this.x = null;
        this.y = null;
        this.r = null;

        super.destroy();
    }

}

;// CONCATENATED MODULE: ./src/common/overlay/feature/Line.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


/**
 * @class  ShapeParametersLine
 * @aliasclass Feature.ShapeParameters.Line
 * @deprecatedclass SuperMap.Feature.ShapeParameters.Line
 * @category Visualization Theme
 * @classdesc 线参数对象。
 * @extends {ShapeParameters}
 * @param {Array} pointList - 线要素节点数组，二维数组。
 * @usage
 */
class Line_Line extends ShapeParameters {
    constructor(pointList) {
        super(pointList);
        /**
         * @member {Array} ShapeParametersLine.prototype.pointList
         * @description 线要素节点数组，二维数组。
         * 数组形如：
         * (start code)
         *  [
         *  [10, 20],         //节点
         *  [30, 40],
         *  [25, 30]         //最后一个节点和第一个节点不必相同，绘制时自动封闭
         *   ]
         * (end)
         */
        this.pointList = pointList;

        this.CLASS_NAME = "SuperMap.Feature.ShapeParameters.Line";

    }

    /**
     * @function ShapeParametersLine.prototype.destroy
     * @description 销毁对象。
     */
    destroy() {
        this.pointList = null;
        super.destroy();
    }

}

;// CONCATENATED MODULE: ./src/common/overlay/feature/Polygon.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


/**
 * @class  ShapeParametersPolygon
 * @aliasclass Feature.ShapeParameters.Polygon
 * @deprecatedclass SuperMap.Feature.ShapeParameters.Polygon
 * @category Visualization Theme
 * @classdesc 面参数对象。
 * @extends {ShapeParameters}
 * @param {Array} pointList - 横坐标。
 * @usage
 */

class feature_Polygon_Polygon extends ShapeParameters {
    constructor(pointList) {
        super(pointList);
        /**
         * @member {Array} ShapeParametersPolygon.prototype.pointList
         * @description 面要素节点数组，二维数组。
         * 数组形如：
         * (start code)
         *  [
         *  [10, 20],         //节点
         *  [30, 40],
         *  [25, 30]         //最后一个节点和第一个节点不必相同，绘制时自动封闭
         *   ]
         * (end)
         */
        this.pointList = pointList;

        /**
         * @member {Array} ShapeParametersPolygon.prototype.holePolygonPointLists
         * @description 岛洞面多边形顶点数组（三维数组）
         */
        this.holePolygonPointLists = null;

        this.CLASS_NAME = "SuperMap.Feature.ShapeParameters.Polygon";
    }

    /**
     * @function ShapeParametersPolygon.prototype.destroy
     * @description 销毁对象。
     */
    destroy() {
        this.pointList = null;
        this.holePolygonPointLists = null;
        super.destroy();
    }
}

;// CONCATENATED MODULE: ./src/common/overlay/feature/Rectangle.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


/**
 * @class  ShapeParametersRectangle
 * @aliasclass Feature.ShapeParameters.Rectangle
 * @deprecatedclass SuperMap.Feature.ShapeParameters.Rectangle
 * @category Visualization Theme
 * @classdesc 矩形参数对象。
 * @extends {ShapeParameters}
 * @param {number} x - 矩形 x 坐标。
 * @param {number} y - 矩形 y 坐标。
 * @param {number} width - 矩形 width 宽度。
 * @param {number} height - 矩形 height 高度。
 * @usage
 */

class Rectangle_Rectangle extends ShapeParameters {
    constructor(x, y, width, height) {
        super(x, y, width, height);
        /**
         * @member {number} ShapeParametersRectangle.prototype.x
         * @description 左上角 x 坐标。
         */
        this.x = !isNaN(x) ? x : 0;

        /**
         * @member {number} ShapeParametersRectangle.prototype.y
         * @description 左上角 y 坐标。
         */
        this.y = !isNaN(x) ? y : 0;

        /**
         * @member {number} ShapeParametersRectangle.prototype.width
         * @description 宽度。
         */
        this.width = !isNaN(width) ? width : 0;

        /**
         * @member {number} ShapeParametersRectangle.prototype.height
         * @description 高度。
         */
        this.height = !isNaN(height) ? height : 0;

        this.CLASS_NAME = "SuperMap.Feature.ShapeParameters.Rectangle";
    }


    /**
     * @function ShapeParametersRectangle.prototype.destroy
     * @description 销毁对象。
     */
    destroy() {
        this.x = null;
        this.y = null;
        this.width = null;
        this.height = null;

        super.destroy();
    }

}

;// CONCATENATED MODULE: ./src/common/overlay/feature/Sector.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


/**
 * @class  ShapeParametersSector
 * @aliasclass Feature.ShapeParameters.Sector
 * @deprecatedclass SuperMap.Feature.ShapeParameters.Sector
 * @category Visualization Theme
 * @classdesc 扇形参数对象。
 * @extends {ShapeParameters}
 * @param {number} x - 圆心 x 坐标。
 * @param {number} y - 圆心 y 坐标。
 * @param {number} r - 外圆半径。
 * @param {number} startAngle - 起始角度。取值范围[0, 360)。
 * @param {number} endAngle - 结束角度。取值范围(0, 360]。
 * @param {number} [r0=0] - 内圆半径，指定后将出现内弧，同时扇边长度为'r - r0'。取值范围[0, r)。
 * @usage
 */

class Sector extends ShapeParameters {
    constructor(x, y, r, startAngle, endAngle, r0, clockWise) {
        super(x, y, r, startAngle, endAngle, r0, clockWise);
        /**
         * @member {number} ShapeParametersSector.prototype.x
         * @description  圆心 x 坐标。
         */
        this.x = !isNaN(x) ? x : 0;

        /**
         * @member {number} ShapeParametersSector.prototype.Y
         * @description  圆心 Y 坐标。
         */
        this.y = !isNaN(y) ? y : 0;

        /**
         * @member {number} ShapeParametersSector.prototype.r
         * @description  外圆半径。
         */
        this.r = !isNaN(r) ? r : 0;

        /**
         * @member {number} ShapeParametersSector.prototype.startAngle
         * @description  起始角度。取值范围[0, 360)，默认值：null。
         */
        this.startAngle = !isNaN(startAngle) ? startAngle : 0;

        /**
         * @member {number} ShapeParametersSector.prototype.endAngle
         * @description  结束角度。取值范围(0, 360]，默认值：null。
         */
        this.endAngle =  !isNaN(endAngle) ? endAngle : 0;

        /**
         * @member {number} [ShapeParametersSector.prototype.r0=0]
         * @description 内圆半径，指定后将出现内弧，同时扇边长度为 r 减 r0。取值范围[0, r)。
         */
        this.r0 = !isNaN(r0) ? r0 : 0;

        /**
         * @member {number} [ShapeParametersSector.prototype.clockWise=false]
         * @description 是否是顺时针。默认值：false。
         */
        this.clockWise = clockWise;

        this.CLASS_NAME = "SuperMap.Feature.ShapeParameters.Sector";
    }

    /**
     * @function ShapeParametersSector.prototype.destroy
     * @description 销毁对象。
     */
    destroy() {
        this.x = null;
        this.y = null;
        this.r = null;
        this.startAngle = null;
        this.endAngle = null;
        this.r0 = null;
        this.clockWise = null;

        super.destroy();
    }

}

;// CONCATENATED MODULE: ./src/common/overlay/feature/Label.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


/**
 * @class ShapeParametersLabel
 * @aliasclass Feature.ShapeParameters.Label
 * @deprecatedclass SuperMap.Feature.ShapeParameters.Label
 * @category Visualization Theme
 * @classdesc 标签参数对象。
 * @extends {ShapeParameters}
 * @param {number} x - 横坐标。
 * @param {number} y - 纵坐标。
 * @param {string} text - 图形中的附加文本。
 * @usage
 * ```
 * // 浏览器
 * <script type="text/javascript" src="{cdn}"></script>
 * <script>
 *   new {namespace}.Feature.ShapeParameters.Label(x, y, text);
 *
 *   // 弃用的写法
 *   new SuperMap.Feature.ShapeParameters.Label(x, y, text);
 *
 * </script>
 * // ES6 Import
 * import { ShapeParametersLabel } from '{npm}';
 * new ShapeParametersLabel(x, y, text);
 *
 * // 弃用的写法
 * import { Label } from '{npm}';
 * new Label(x, y, text);
 *
 * ```
 */

class Label extends ShapeParameters {
    constructor(x, y, text) {
        super(x, y, text);
        /**
         * @member {number} ShapeParametersLabel.prototype.x
         * @description 标签 x 坐标。
         */
        this.x = x;

        /**
         * @member {number} ShapeParametersLabel.prototype.y
         * @description 标签 y 坐标。
         */
        this.y = y;

        /**
         * @member {number} ShapeParametersLabel.prototype.text
         * @description 标签的文本内容。
         */
        this.text = text;

        this.CLASS_NAME = "SuperMap.Feature.ShapeParameters.Label";
    }


    /**
     * @function ShapeParametersLabel.prototype.destroy
     * @description 销毁对象。
     */
    destroy() {
        this.x = null;
        this.y = null;
        this.text = null;

        super.destroy();
    }


}

;// CONCATENATED MODULE: ./src/common/overlay/feature/Image.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


/**
 * @class ShapeParametersImage
 * @aliasclass Feature.ShapeParameters.Image
 * @deprecatedclass SuperMap.Feature.ShapeParameters.Image
 * @category Visualization Theme
 * @classdesc 图片参数对象。
 * @extends {ShapeParameters}
 * @param {number} x - 左上角横坐标。
 * @param {number} y - 左上角纵坐标。
 * @param {(string|Object)} image - 图片地址或Cavans对象。
 * @param {number} width - 绘制到画布上的宽度，默认为图片高度。
 * @param {number} height - 绘制到画布上的高度，默认为图片高度。
 * @param {number} sx - 从图片中裁剪的左上角横坐标。
 * @param {number} sy - 从图片中裁剪的左上角纵坐标。
 * @param {number} sWidth - 从图片中裁剪的宽度，默认为图片高度。
 * @param {number} sHeight - 绘制到画布上的高度，默认为图片高度。
 * @usage
 */
class Image_Image extends ShapeParameters {
    constructor(x, y, image, width, height, sx, sy, sWidth, sHeight) {
        super(x, y, image, width, height, sx, sy, sWidth, sHeight);
        /**
         * @member {number} ShapeParametersImage.prototype.x
         * @description 左上角横坐标，必设参数。
         */
        this.x = x;

        /**
         * @member {number} ShapeParametersImage.prototype.y
         * @description 左上角纵坐标，必设参数。
         */
        this.y = y;

        /**
         * @member {(string|Object)} ShapeParametersImage.prototype.image
         * @description 图片地址。
         */
        this.image = image;

        /**
         * @member {number} ShapeParametersImage.prototype.width
         * @description 绘制到画布上的宽度，默认为图片高度。
         */
        this.width = width;

        /**
         * @member {number} ShapeParametersImage.prototype.height
         * @description 绘制到画布上的高度，默认为图片高度。
         */
        this.height = height;

        /**
         * @member {number} ShapeParametersImage.prototype.sx
         * @description 从图片中裁剪的左上角横坐标。
         */
        this.sx = sx;

        /**
         * @member {number} ShapeParametersImage.prototype.sy
         * @description 从图片中裁剪的左上角纵坐标。
         */
        this.sy = sy;

        /**
         * @member {number} ShapeParametersImage.prototype.sWidth
         * @description 从图片中裁剪的宽度，默认为图片高度。
         */
        this.sWidth = sWidth;

        /**
         * @member {number} ShapeParametersImage.prototype.sHeight
         * @description 绘制到画布上的高度，默认为图片高度。
         */
        this.sHeight = sHeight;

        this.CLASS_NAME = "SuperMap.Feature.ShapeParameters.Image";

    }


    /**
     * @function ShapeParametersImage.prototype.destroy
     * @description 销毁对象。
     */
    destroy() {
        this.x = null;
        this.y = null;
        this.image = null;
        this.width = null;
        this.height = null;
        this.sx = null;
        this.sy = null;
        this.sWidth = null;
        this.sHeight = null;
        super.destroy();
    }
}

;// CONCATENATED MODULE: ./src/common/overlay/feature/Circle.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


/**
 * @class ShapeParametersCircle
 * @aliasclass Feature.ShapeParameters.Circle
 * @deprecatedclass SuperMap.Feature.ShapeParameters.Circle
 * @classdesc 圆形参数对象。
 * @category Visualization Theme
 * @extends {ShapeParameters}
 * @param {number} x - 圆心 x 坐标。
 * @param {number} y - 圆心 y 坐标。
 * @param {number} r - 圆半径。
 * @usage
 */

class Circle_Circle extends ShapeParameters {
    constructor(x, y, r) {
        super(x, y, r);
        /**
         * @member {number} ShapeParametersCircle.prototype.x
         * @description 圆心 x 坐标。
         */
        this.x = !isNaN(x) ? x : 0;

        /**
         * @member {number} ShapeParametersCircle.prototype.y
         * @description 圆心 y 坐标。
         */
        this.y =  !isNaN(y) ? y : 0;

        /**
         * @member {number} ShapeParametersCircle.prototype.r
         * @description 圆半径。
         */
        this.r =  !isNaN(r) ? r : 0;

        this.CLASS_NAME = "SuperMap.Feature.ShapeParameters.Circle";

    }


    /**
     * @function ShapeParametersCircle.prototype.destroy
     * @description 销毁对象。
     */
    destroy() {
        this.x = null;
        this.y = null;
        this.r = null;
        super.destroy();
    }

}

;// CONCATENATED MODULE: ./src/common/overlay/levelRenderer/SmicPoint.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


/**
 * @private
 * @class  LevelRenderer.Shape.SmicPoint
 * @category Visualization Theme
 * @classdesc 点。
 * @extends LevelRenderer.Shape
 * @example
 *   var shape = new LevelRenderer.Shape.SmicPoint({
 *       style: {
 *           x: 100,
 *           y: 100,
 *           r: 40,
 *           brushType: 'both',
 *           color: 'blue',
 *           strokeColor: 'red',
 *           lineWidth: 3,
 *           text: 'point'
 *       }
 *   });
 *   levelRenderer.addShape(shape);
 * @param {Array} options - shape 的配置（options）项，可以是 shape 的自有属性，也可以是自定义的属性。
 *
 */
class SmicPoint extends Shape_Shape {
    constructor(options) {
        super(options);
        /**
         * @member {string} LevelRenderer.Shape.SmicPoint.prototype.type
         * @description 图形类型。
         */
        this.type = 'smicpoint';
        if (!this.refOriginalPosition || this.refOriginalPosition.length !== 2) {
            this.refOriginalPosition = [0, 0];
        }

        this.CLASS_NAME = "SuperMap.LevelRenderer.Shape.SmicPoint";
    }


    /**
     * @function cdestroy
     * @description 销毁对象，释放资源。调用此函数后所有属性将被置为 null。
     */
    destroy() {
        this.type = null;
        super.destroy();
    }


    /**
     * @function LevelRenderer.Shape.SmicPoint.prototype.buildPath
     * @description 创建点触。
     *
     * @param {CanvasRenderingContext2D} ctx - Context2D 上下文。
     * @param {Object} style - style。
     *
     */
    buildPath(ctx, style) {
        if (!this.refOriginalPosition || this.refOriginalPosition.length !== 2) {
            this.refOriginalPosition = [0, 0];
        }
        var __OP = this.refOriginalPosition;

        ctx.arc(style.x + __OP[0], style.y + __OP[1], style.r, 0, Math.PI * 2, true);
        return;
    }


    /**
     * @function LevelRenderer.Shape.SmicPoint.prototype.getRect
     * @description 计算返回点的包围盒矩形。该包围盒是直接从四个控制点计算，并非最小包围盒。
     *
     * @param {Object} style - style
     * @return {Object} 边框对象。包含属性：x，y，width，height。
     */
    getRect(style) {
        if (!this.refOriginalPosition || this.refOriginalPosition.length !== 2) {
            this.refOriginalPosition = [0, 0];
        }
        var __OP = this.refOriginalPosition;

        if (style.__rect) {
            return style.__rect;
        }

        var lineWidth;
        if (style.brushType == 'stroke' || style.brushType == 'fill') {
            lineWidth = style.lineWidth || 1;
        } else {
            lineWidth = 0;
        }
        style.__rect = {
            x: Math.round((style.x + __OP[0]) - style.r - lineWidth / 2),
            y: Math.round((style.y + __OP[1]) - style.r - lineWidth / 2),
            width: style.r * 2 + lineWidth,
            height: style.r * 2 + lineWidth
        };

        return style.__rect;
    }

}

;// CONCATENATED MODULE: ./src/common/overlay/levelRenderer/SmicText.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/



/**
 * @private
 * @class  LevelRenderer.Shape.SmicText
 * @category Visualization Theme
 * @extends {LevelRenderer.Shape}
 * @example
 *   var shape = new LevelRenderer.Shape.SmicText({
 *         style: {
 *             text: 'Label',
 *             x: 100,
 *             y: 100,
 *             textFont: '14px Arial'
 *         }
 *     });
 *   levelRenderer.addShape(shape);
 * @param {Array} options - shape 的配置（options）项，可以是 shape 的自有属性，也可以是自定义的属性。
 */
class SmicText extends Shape_Shape {
    constructor(options) {
        super(options);
        /**
         * @member {string} LevelRenderer.Shape.SmicText.prototype.type
         * @description 图形类型.
         */
        this.type = 'smictext';
        if (!this.refOriginalPosition || this.refOriginalPosition.length !== 2) {
            this.refOriginalPosition = [0, 0];
        }
        this.CLASS_NAME = "SuperMap.LevelRenderer.Shape.SmicText";
    }


    /**
     * @function LevelRenderer.Shape.SmicText.prototype.destroy
     * @description 销毁对象，释放资源。调用此函数后所有属性将被置为 null。
     */
    destroy() {
        this.type = null;

        super.destroy();
    }


    /**
     * @function LevelRenderer.Shape.SmicText.prototype.brush
     * @description 笔触。
     *
     * @param {CanvasRenderingContext2D} ctx - Context2D 上下文。
     * @param {boolean} isHighlight - 是否使用高亮属性。
     *
     */
    brush(ctx, isHighlight) {
        if (!this.refOriginalPosition || this.refOriginalPosition.length !== 2) {
            this.refOriginalPosition = [0, 0];
        }
        var __OP = this.refOriginalPosition;

        var style = this.style;
        if (isHighlight) {
            // 根据style扩展默认高亮样式
            style = this.getHighlightStyle(
                style, this.highlightStyle || {}
            );
        }

        if (typeof(style.text) == 'undefined' || style.text === false) {
            return;
        }

        ctx.save();
        this.doClip(ctx);

        this.setContext(ctx, style);

        // 设置transform
        this.setTransform(ctx);

        if (style.textFont) {
            ctx.font = style.textFont;
        }
        ctx.textAlign = style.textAlign || 'start';
        ctx.textBaseline = style.textBaseline || 'middle';

        var text = (style.text + '').split('\n');
        var lineHeight = SUtil_SUtil.Util_area.getTextHeight('ZH', style.textFont);
        var rect = this.getRectNoRotation(style);
        // var x = style.x;
        var x = style.x + __OP[0];
        var y;
        if (style.textBaseline == 'top') {
            y = rect.y;
        } else if (style.textBaseline == 'bottom') {
            y = rect.y + lineHeight;
        } else {
            y = rect.y + lineHeight / 2;
        }
        var ox = style.x + __OP[0];
        var oy = style.y + __OP[1];

        //文本绘制
        for (var i = 0, l = text.length; i < l; i++) {
            //是否渲染矩形背景及颜色
            if (style.labelRect) {
                //+4,-2是为了让文字距边框左右边缘有点间隔
                ctx.fillRect(rect.x - 2, rect.y, rect.width + 4, rect.height);
                ctx.fillStyle = style.strokeColor;
                ctx.strokeRect(rect.x - 2, rect.y, rect.width + 4, rect.height);
                ctx.fillStyle = style.textColor;
            }

            switch (style.brushType) {
                case 'stroke':
                    this.setCtxGlobalAlpha(ctx, "stroke", style);
                    if (style.textRotation && style.textRotation !== 0) {
                        ctx.save();
                        ctx.translate(ox, oy);
                        ctx.rotate(style.textRotation * Math.PI / 180);
                        if (style.textBaseline == 'top') {
                            if (style.maxWidth) {
                                ctx.strokeText(text[i], 0, lineHeight * i, style.maxWidth);
                            } else {
                                ctx.strokeText(text[i], 0, lineHeight * i);
                            }
                        } else if (style.textBaseline == 'bottom') {
                            if (style.maxWidth) {
                                ctx.strokeText(text[i], 0, lineHeight * (i + 1) - rect.height, style.maxWidth);
                            } else {
                                ctx.strokeText(text[i], 0, lineHeight * (i + 1) - rect.height);
                            }
                        } else {
                            if (style.maxWidth) {
                                ctx.strokeText(text[i], 0, lineHeight * (i + 1) - rect.height / 2 - lineHeight / 2, style.maxWidth);
                            } else {
                                ctx.strokeText(text[i], 0, lineHeight * (i + 1) - rect.height / 2 - lineHeight / 2);
                            }
                        }
                        ctx.restore();
                    } else {
                        if (style.maxWidth) {
                            ctx.strokeText(text[i], x, y, style.maxWidth);
                        } else {
                            ctx.strokeText(text[i], x, y);
                        }
                    }
                    this.setCtxGlobalAlpha(ctx, "reset", style);
                    break;
                case 'both':
                    if (style.textRotation && style.textRotation !== 0) {
                        ctx.save();
                        ctx.translate(ox, oy);
                        ctx.rotate(style.textRotation * Math.PI / 180);
                        if (style.textBaseline == 'top') {
                            if (style.maxWidth) {
                                this.setCtxGlobalAlpha(ctx, "fill", style);
                                ctx.fillText(text[i], 0, lineHeight * i, style.maxWidth);
                                this.setCtxGlobalAlpha(ctx, "reset", style);

                                this.setCtxGlobalAlpha(ctx, "stroke", style);
                                ctx.strokeText(text[i], 0, lineHeight * i, style.maxWidth);
                                this.setCtxGlobalAlpha(ctx, "reset", style);
                            } else {
                                this.setCtxGlobalAlpha(ctx, "fill", style);
                                ctx.fillText(text[i], 0, lineHeight * i);
                                this.setCtxGlobalAlpha(ctx, "reset", style);

                                this.setCtxGlobalAlpha(ctx, "stroke", style);
                                ctx.strokeText(text[i], 0, lineHeight * i);
                                this.setCtxGlobalAlpha(ctx, "reset", style);
                            }
                        } else if (style.textBaseline == 'bottom') {
                            if (style.maxWidth) {
                                this.setCtxGlobalAlpha(ctx, "fill", style);
                                ctx.fillText(text[i], 0, lineHeight * (i + 1) - rect.height, style.maxWidth);
                                this.setCtxGlobalAlpha(ctx, "reset", style);

                                this.setCtxGlobalAlpha(ctx, "stroke", style);
                                ctx.strokeText(text[i], 0, lineHeight * (i + 1) - rect.height, style.maxWidth);
                                this.setCtxGlobalAlpha(ctx, "reset", style);
                            } else {
                                this.setCtxGlobalAlpha(ctx, "fill", style);
                                ctx.fillText(text[i], 0, lineHeight * (i + 1) - rect.height);
                                this.setCtxGlobalAlpha(ctx, "reset", style);

                                this.setCtxGlobalAlpha(ctx, "stroke", style);
                                ctx.strokeText(text[i], 0, lineHeight * (i + 1) - rect.height);
                                this.setCtxGlobalAlpha(ctx, "reset", style);
                            }
                        } else {
                            if (style.maxWidth) {
                                this.setCtxGlobalAlpha(ctx, "fill", style);
                                ctx.fillText(text[i], 0, lineHeight * (i + 1) - rect.height / 2 - lineHeight / 2, style.maxWidth);
                                this.setCtxGlobalAlpha(ctx, "reset", style);

                                this.setCtxGlobalAlpha(ctx, "stroke", style);
                                ctx.strokeText(text[i], 0, lineHeight * (i + 1) - rect.height / 2 - lineHeight / 2, style.maxWidth);
                                this.setCtxGlobalAlpha(ctx, "reset", style);
                            } else {
                                this.setCtxGlobalAlpha(ctx, "fill", style);
                                ctx.fillText(text[i], 0, lineHeight * (i + 1) - rect.height / 2 - lineHeight / 2);
                                this.setCtxGlobalAlpha(ctx, "reset", style);

                                this.setCtxGlobalAlpha(ctx, "stroke", style);
                                ctx.strokeText(text[i], 0, lineHeight * (i + 1) - rect.height / 2 - lineHeight / 2);
                                this.setCtxGlobalAlpha(ctx, "reset", style);
                            }
                        }
                        ctx.restore();
                    } else {
                        if (style.maxWidth) {
                            this.setCtxGlobalAlpha(ctx, "fill", style);
                            ctx.fillText(text[i], x, y, style.maxWidth);
                            this.setCtxGlobalAlpha(ctx, "reset", style);

                            this.setCtxGlobalAlpha(ctx, "stroke", style);
                            ctx.strokeText(text[i], x, y, style.maxWidth);
                            this.setCtxGlobalAlpha(ctx, "reset", style);
                        } else {
                            this.setCtxGlobalAlpha(ctx, "fill", style);
                            ctx.fillText(text[i], x, y);
                            this.setCtxGlobalAlpha(ctx, "reset", style);

                            this.setCtxGlobalAlpha(ctx, "stroke", style);
                            ctx.strokeText(text[i], x, y);
                            this.setCtxGlobalAlpha(ctx, "reset", style);
                        }
                    }
                    break;
                default:
                    //fill or others
                    this.setCtxGlobalAlpha(ctx, "fill", style);
                    if (style.textRotation && style.textRotation !== 0) {
                        ctx.save();
                        ctx.translate(ox, oy);
                        ctx.rotate(style.textRotation * Math.PI / 180);
                        if (style.textBaseline == 'top') {
                            if (style.maxWidth) {
                                ctx.fillText(text[i], 0, lineHeight * i, style.maxWidth);
                            } else {
                                ctx.fillText(text[i], 0, lineHeight * i);
                            }
                        } else if (style.textBaseline == 'bottom') {
                            if (style.maxWidth) {
                                ctx.fillText(text[i], 0, lineHeight * (i + 1) - rect.height, style.maxWidth);
                            } else {
                                ctx.fillText(text[i], 0, lineHeight * (i + 1) - rect.height);
                            }
                        } else {
                            if (style.maxWidth) {
                                ctx.fillText(text[i], 0, lineHeight * (i + 1) - rect.height / 2 - lineHeight / 2, style.maxWidth);
                            } else {
                                ctx.fillText(text[i], 0, lineHeight * (i + 1) - rect.height / 2 - lineHeight / 2);
                            }
                        }
                        ctx.restore();
                    } else {
                        if (style.maxWidth) {
                            ctx.fillText(text[i], x, y, style.maxWidth);
                        } else {
                            ctx.fillText(text[i], x, y);
                        }
                    }
                    this.setCtxGlobalAlpha(ctx, "reset", style);
            }
            y += lineHeight;
        }

        ctx.restore();
        return;
    }


    /**
     * @function LevelRenderer.Shape.SmicText.prototype.getRect
     * @description 返回文字包围盒矩形
     */
    getRect(style) {
        if (style.__rect) {
            return style.__rect;
        }

        var left, top, right, bottom
        var tbg = this.getTextBackground(style, true);
        for (var i = 0, len = tbg.length; i < len; i++) {
            var poi = tbg[i];

            //用第一个点初始化
            if (i == 0) {
                left = poi[0];
                right = poi[0];
                top = poi[1];
                bottom = poi[1];
            } else {
                if (poi[0] < left) {
                    left = poi[0]
                }
                if (poi[0] > right) {
                    right = poi[0]
                }
                if (poi[1] < top) {
                    top = poi[1]
                }
                if (poi[1] > bottom) {
                    bottom = poi[1]
                }
            }
        }

        style.__rect = {
            x: left,
            y: top,
            width: right - left,
            height: bottom - top
        };

        return style.__rect;
    }


    /**
     * @function LevelRenderer.Shape.SmicText.prototype.getRectNoRotation
     * @description 返回忽略旋转和maxWidth时文字包围盒矩形
     */
    getRectNoRotation(style) {

        if (!this.refOriginalPosition || this.refOriginalPosition.length !== 2) {
            this.refOriginalPosition = [0, 0];
        }
        var __OP = this.refOriginalPosition;

        var lineHeight = SUtil_SUtil.Util_area.getTextHeight('ZH', style.textFont);

        var width = SUtil_SUtil.Util_area.getTextWidth(style.text, style.textFont);
        var height = SUtil_SUtil.Util_area.getTextHeight(style.text, style.textFont);

        //处理文字位置，注：文本的绘制是由此 rect 决定
        var textX = style.x + __OP[0];                 // 默认start == left
        if (style.textAlign == 'end' || style.textAlign == 'right') {
            textX -= width;
        } else if (style.textAlign == 'center') {
            textX -= (width / 2);
        }

        var textY;
        if (style.textBaseline == 'top') {
            // textY = style.y;
            textY = style.y + __OP[1];
        } else if (style.textBaseline == 'bottom') {
            textY = (style.y + __OP[1]) - height;
        } else {
            // middle
            textY = (style.y + __OP[1]) - height / 2;
        }

        var isWidthChangeByMaxWidth = false;
        var widthBeforeChangeByMaxWidth;

        //处理 maxWidth
        if (style.maxWidth) {
            var maxWidth = parseInt(style.maxWidth);
            if (maxWidth < width) {
                widthBeforeChangeByMaxWidth = width;
                isWidthChangeByMaxWidth = true;
                width = maxWidth;
            }

            textX = style.x + __OP[0];
            if (style.textAlign == 'end' || style.textAlign == 'right') {
                textX -= width;
            } else if (style.textAlign == 'center') {
                textX -= (width / 2);
            }
        }

        //处理斜体字
        if (style.textFont) {
            var textFont = style.textFont;
            var textFontStr = textFont.toLowerCase()
            if (textFontStr.indexOf("italic") > -1) {
                if (isWidthChangeByMaxWidth === true) {
                    width += (lineHeight / 3) * (width / widthBeforeChangeByMaxWidth);
                } else {
                    width += lineHeight / 3;
                }
            }
        }

        var rect = {
            x: textX,
            y: textY,
            width: width,
            height: height
        };

        return rect;
    }


    /**
     * @function LevelRenderer.Shape.SmicText.prototype.getTextBackground
     * @description 获取文本背景框范围
     *
     * @param {Object} style - 样式。
     * @param {boolean} redo - 是否强制重新计算 textBackground。
     */
    getTextBackground(style, redo) {
        if (!this.refOriginalPosition || this.refOriginalPosition.length !== 2) {
            this.refOriginalPosition = [0, 0];
        }
        var __OP = this.refOriginalPosition;

        if ((!redo) && style.__textBackground) {
            return style.__textBackground;
        }

        //不旋转时矩形框
        var rect = this.getRectNoRotation(style);

        //旋转中心点
        var ox = style.x + __OP[0];
        var oy = style.y + __OP[1];

        //背景框
        var background = [];

        if (style.textRotation && style.textRotation !== 0) {
            let textRotation = style.textRotation;
            let ltPoi = this.getRotatedLocation(rect.x, rect.y, ox, oy, textRotation);
            let rtPoi = this.getRotatedLocation(rect.x + rect.width, rect.y, ox, oy, textRotation);
            let rbPoi = this.getRotatedLocation(rect.x + rect.width, rect.y + rect.height, ox, oy, textRotation);
            let lbPoi = this.getRotatedLocation(rect.x, rect.y + rect.height, ox, oy, textRotation);

            background.push(ltPoi);
            background.push(rtPoi);
            background.push(rbPoi);
            background.push(lbPoi);
        } else {
            let ltPoi = [rect.x, rect.y];
            let rtPoi = [rect.x + rect.width, rect.y];
            let rbPoi = [rect.x + rect.width, rect.y + rect.height];
            let lbPoi = [rect.x, rect.y + rect.height];

            background.push(ltPoi);
            background.push(rtPoi);
            background.push(rbPoi);
            background.push(lbPoi);
        }

        style.__textBackground = background;

        return style.__textBackground;
    }


    /**
     * @function LevelRenderer.Shape.SmicText.prototype.getRotatedLocation
     * @description 获取一个点绕旋转中心顺时针旋转后的位置。（此方法用于屏幕坐标）
     *
     * @param {number} x - 旋转点横坐标。
     * @param {number} y - 旋转点纵坐标。
     * @param {number} rx - 旋转中心点横坐标。
     * @param {number} ry - 旋转中心点纵坐标。
     * @param {number} angle - 旋转角度（度）。
     * @return {Array.<number>} 旋转后的坐标位置，长度为 2 的一维数组，数组第一个元素表示 x 坐标，第二个元素表示 y 坐标。
     */
    getRotatedLocation(x, y, rx, ry, angle) {
        var loc = new Array(), x0, y0;

        y = -y;
        ry = -ry;
        angle = -angle;//顺时针旋转
        x0 = (x - rx) * Math.cos((angle / 180) * Math.PI) - (y - ry) * Math.sin((angle / 180) * Math.PI) + rx;
        y0 = (x - rx) * Math.sin((angle / 180) * Math.PI) + (y - ry) * Math.cos((angle / 180) * Math.PI) + ry;

        loc[0] = x0;
        loc[1] = -y0;
        return loc;
    }

}

;// CONCATENATED MODULE: ./src/common/overlay/levelRenderer/SmicCircle.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


/**
 * @private
 * @class  LevelRenderer.Shape.SmicCircle
 * @category Visualization Theme
 * @classdesc 圆形
 * @extends LevelRenderer.Shape
 * @example
 *   var shape = new LevelRenderer.Shape.SmicCircle({
 *         style: {
 *             x: 100,
 *             y: 100,
 *             r: 60,
 *             brushType: "both",
 *             color: "blue",
 *             strokeColor: "red",
 *             lineWidth: 3,
 *             text: "Circle"
 *         }
 *   });
 *   levelRenderer.addShape(shape);
 * @param {Array} options - shape 的配置（options）项，可以是 shape 的自有属性，也可以是自定义的属性。
 *
 */
class SmicCircle extends Shape_Shape {
    constructor(options) {
        super(options);
        /**
         * @member {string} LevelRenderer.Shape.SmicCircle.prototype.type
         * @description 图形类型。
         */
        this.type = 'smiccircle';

        if (!this.refOriginalPosition || this.refOriginalPosition.length !== 2) {
            this.refOriginalPosition = [0, 0];
        }
        this.CLASS_NAME = "SuperMap.LevelRenderer.Shape.SmicCircle";
    }


    /**
     * @function LevelRenderer.Shape.SmicCircle.prototype.destroy
     * @description 销毁对象，释放资源。调用此函数后所有属性将被置为 null。
     */
    destroy() {
        this.type = null;
        super.destroy();
    }


    /**
     * @function LevelRenderer.Shape.SmicCircle.prototype.buildPath
     * @description 创建图形路径。
     *
     * @param {CanvasRenderingContext2D} ctx - Context2D 上下文。
     * @param {Object} style - style。
     *
     */
    buildPath(ctx, style) {
        if (!this.refOriginalPosition || this.refOriginalPosition.length !== 2) {
            this.refOriginalPosition = [0, 0];
        }
        var __OP = this.refOriginalPosition;

        var x = style.x + __OP[0];   // 圆心x
        var y = style.y + __OP[1];   // 圆心y

        ctx.moveTo(x + style.r, y);
        ctx.arc(x, y, style.r, 0, Math.PI * 2, true);

        return true;
    }


    /**
     * @function LevelRenderer.Shape.SmicCircle.prototype.getRect
     * @description 返回圆形包围盒矩形
     *
     * @param {Object} style - style
     * @return {Object} 边框对象。包含属性：x，y，width，height。
     *
     */
    getRect(style) {
        if (style.__rect) {
            return style.__rect;
        }

        if (!this.refOriginalPosition || this.refOriginalPosition.length !== 2) {
            this.refOriginalPosition = [0, 0];
        }
        var __OP = this.refOriginalPosition;

        var x = style.x + __OP[0];   // 圆心x
        var y = style.y + __OP[1];   // 圆心y
        var r = style.r;             // 圆r

        var lineWidth;
        if (style.brushType == 'stroke' || style.brushType == 'fill') {
            lineWidth = style.lineWidth || 1;
        } else {
            lineWidth = 0;
        }
        style.__rect = {
            x: Math.round(x - r - lineWidth / 2),
            y: Math.round(y - r - lineWidth / 2),
            width: r * 2 + lineWidth,
            height: r * 2 + lineWidth
        };

        return style.__rect;
    }
}

;// CONCATENATED MODULE: ./src/common/overlay/levelRenderer/SmicPolygon.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/




/**
 * @private
 * @class  LevelRenderer.Shape.SmicPolygon
 * @category Visualization Theme
 * @classdesc 多边形。
 * @extends LevelRenderer.Shape
 * @example
 *   var shape = new LevelRenderer.Shape.SmicPolygon({
 *         style: {
 *             // 100x100 的正方形
 *             pointList: [[0, 0], [100, 0], [100, 100], [0, 100]],
 *             color: 'blue'
 *         }
 *   });
 *   levelRenderer.addShape(shape);
 * @param {Array} options - shape 的配置（options）项，可以是 shape 的自有属性，也可以是自定义的属性。
 */
class SmicPolygon extends Shape_Shape {
    constructor(options) {
        super(options);
        /**
         * @member {string} LevelRenderer.Shape.SmicPolygon.prototype.type
         * @description 图形类型.
         */
        this.type = 'smicpolygon';

        /**
         * @member {Array} LevelRenderer.Shape.SmicPolygon.prototype._holePolygonPointList
         * @description 岛洞面多边形顶点数组（三维数组）
         *
         */
        this.holePolygonPointLists = null;

        if (!this.refOriginalPosition || this.refOriginalPosition.length !== 2) {
            this.refOriginalPosition = [0, 0];
        }
        this.CLASS_NAME = "SuperMap.LevelRenderer.Shape.SmicPolygon";
    }


    /**
     * @function LevelRenderer.Shape.SmicPolygon.prototype.destroy
     * @description 销毁对象，释放资源。调用此函数后所有属性将被置为 null。
     */
    destroy() {
        this.type = null;
        this.holePolygonPointLists = null;
        super.destroy();
    }


    /**
     * @function LevelRenderer.Shape.SmicPolygon.prototype.brush
     * @description 笔触。
     *
     * @param {CanvasRenderingContext2D} ctx - Context2D 上下文。
     * @param {boolean} isHighlight - 是否使用高亮属性。
     *
     */
    brush(ctx, isHighlight) {
        if (!this.refOriginalPosition || this.refOriginalPosition.length !== 2) {
            this.refOriginalPosition = [0, 0];
        }

        var style = this.style;
        if (isHighlight) {
            // 根据style扩展默认高亮样式
            style = this.getHighlightStyle(
                style,
                this.highlightStyle || {}
            );
        }

        ctx.save();
        this.setContext(ctx, style);

        // 设置 transform
        this.setTransform(ctx);

        // 先 fill 再stroke
        var hasPath = false;
        if (style.brushType == 'fill' || style.brushType == 'both' || typeof style.brushType == 'undefined') {    // 默认为fill
            ctx.beginPath();
            if (style.lineType == 'dashed'
                || style.lineType == 'dotted'
                || style.lineType == 'dot'
                || style.lineType == 'dash'
                || style.lineType == 'dashdot'
                || style.lineType == 'longdash'
                || style.lineType == 'longdashdot'
            ) {
                // 特殊处理，虚线围不成path，实线再build一次
                this.buildPath(ctx, {
                        lineType: 'solid',
                        lineWidth: style.lineWidth,
                        pointList: style.pointList
                    }
                );
            } else {
                this.buildPath(ctx, style);
                hasPath = true; // 这个path能用
            }
            ctx.closePath();
            this.setCtxGlobalAlpha(ctx, "fill", style);
            ctx.fill();
            this.setCtxGlobalAlpha(ctx, "reset", style);
        }

        if (style.lineWidth > 0 && (style.brushType == 'stroke' || style.brushType == 'both')) {
            if (!hasPath) {
                ctx.beginPath();
                this.buildPath(ctx, style);
            }
            this.setCtxGlobalAlpha(ctx, "stroke", style);
            ctx.stroke();
            this.setCtxGlobalAlpha(ctx, "reset", style);
        }

        this.drawText(ctx, style, this.style);

        //岛洞
        var hpStyle = Util_Util.cloneObject(style);

        if (hpStyle.pointList) {
            if (this.holePolygonPointLists && this.holePolygonPointLists.length > 0) {
                var holePLS = this.holePolygonPointLists;
                var holePLSen = holePLS.length;
                for (var i = 0; i < holePLSen; i++) {
                    var holePL = holePLS[i];
                    //岛洞面
                    hpStyle.pointList = holePL;

                    ctx.globalCompositeOperation = "destination-out";
                    // 先 fill 再stroke
                    hasPath = false;
                    if (hpStyle.brushType == 'fill' || hpStyle.brushType == 'both' || typeof hpStyle.brushType == 'undefined') {    // 默认为fill
                        ctx.beginPath();
                        if (hpStyle.lineType == 'dashed'
                            || hpStyle.lineType == 'dotted'
                            || hpStyle.lineType == 'dot'
                            || hpStyle.lineType == 'dash'
                            || hpStyle.lineType == 'dashdot'
                            || hpStyle.lineType == 'longdash'
                            || hpStyle.lineType == 'longdashdot'
                        ) {
                            // 特殊处理，虚线围不成path，实线再build一次
                            this.buildPath(ctx, {
                                    lineType: 'solid',
                                    lineWidth: hpStyle.lineWidth,
                                    pointList: hpStyle.pointList
                                }
                            );
                        } else {
                            this.buildPath(ctx, hpStyle);
                            hasPath = true; // 这个path能用
                        }
                        ctx.closePath();
                        this.setCtxGlobalAlpha(ctx, "fill", hpStyle);
                        ctx.fill();
                        this.setCtxGlobalAlpha(ctx, "reset", hpStyle);
                    }

                    if (hpStyle.lineWidth > 0 && (hpStyle.brushType == 'stroke' || hpStyle.brushType == 'both')) {
                        if (!hasPath) {
                            ctx.beginPath();
                            this.buildPath(ctx, hpStyle);
                        }
                        //如果描边，先回复 globalCompositeOperation 默认值再描边。
                        ctx.globalCompositeOperation = "source-over";
                        this.setCtxGlobalAlpha(ctx, "stroke", hpStyle);
                        ctx.stroke();
                        this.setCtxGlobalAlpha(ctx, "reset", hpStyle);
                    } else {
                        ctx.globalCompositeOperation = "source-over";
                    }
                }
            }

        }
        ctx.restore();
        return;
    }


    /**
     * @function LevelRenderer.Shape.SmicPolygon.prototype.buildPath
     * @description 创建多边形路径。
     *
     * @param {CanvasRenderingContext2D} ctx - Context2D 上下文。
     * @param {Object} style - style。
     *
     */
    buildPath(ctx, style) {
        if (style.showShadow) {
            ctx.shadowBlur = style.shadowBlur;
            ctx.shadowColor = style.shadowColor;
            ctx.shadowOffsetX = style.shadowOffsetX;
            ctx.shadowOffsetY = style.shadowOffsetY;
        }
        if (!this.refOriginalPosition || this.refOriginalPosition.length !== 2) {
            this.refOriginalPosition = [0, 0];
        }
        var __OP = this.refOriginalPosition;

        // 虽然能重用 brokenLine，但底层图形基于性能考虑，重复代码减少调用吧
        var pointList = style.pointList;

        if (pointList.length < 2) {
            // 少于2个点就不画了~
            return;
        }

        if (style.smooth && style.smooth !== 'spline') {
            var controlPoints = SUtil_SUtil.SUtil_smoothBezier(pointList, style.smooth, true, style.smoothConstraint, __OP);

            ctx.moveTo(pointList[0][0] + __OP[0], pointList[0][1] + __OP[1]);
            var cp1;
            var cp2;
            var p;
            var len = pointList.length;
            for (var i = 0; i < len; i++) {
                cp1 = controlPoints[i * 2];
                cp2 = controlPoints[i * 2 + 1];
                p = [pointList[(i + 1) % len][0] + __OP[0], pointList[(i + 1) % len][1] + __OP[1]];
                ctx.bezierCurveTo(
                    cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]
                );
            }
        } else {
            if (style.smooth === 'spline') {
                pointList = SUtil_SUtil.SUtil_smoothSpline(pointList, true, null, __OP);
            }

            if (!style.lineType || style.lineType == 'solid') {
                // 默认为实线
                ctx.moveTo(pointList[0][0] + __OP[0], pointList[0][1] + __OP[1]);
                for (let i = 1; i < pointList.length; i++) {
                    ctx.lineTo(pointList[i][0] + __OP[0], pointList[i][1] + __OP[1]);
                }
                ctx.lineTo(pointList[0][0] + __OP[0], pointList[0][1] + __OP[1]);
            } else if (style.lineType === 'dashed'
                || style.lineType === 'dotted'
                || style.lineType === 'dot'
                || style.lineType === 'dash'
                || style.lineType === 'longdash'
            ) {
                // SMIC-方法修改 - start
                let dashLengthForStyle = style._dashLength || (style.lineWidth || 1) * (style.lineType == 'dashed' ? 5 : 1);
                style._dashLength = dashLengthForStyle;

                let dashLength = (style.lineWidth || 1);
                let pattern1 = dashLength;
                let pattern2 = dashLength;

                //dashed
                if (style.lineType === 'dashed') {
                    pattern1 *= 5;
                    pattern2 *= 5;
                    if (style.lineCap && style.lineCap !== "butt") {
                        pattern1 -= dashLength;
                        pattern2 += dashLength;
                    }
                }

                //dotted
                if (style.lineType === 'dotted') {
                    if (style.lineCap && style.lineCap !== "butt") {
                        pattern1 = 1;
                        pattern2 += dashLength;
                    }
                }

                //dot
                if (style.lineType === 'dot') {
                    pattern2 *= 4;
                    if (style.lineCap && style.lineCap !== "butt") {
                        pattern1 = 1;
                        pattern2 += dashLength;
                    }
                }

                //dash
                if (style.lineType === 'dash') {
                    pattern1 *= 4;
                    pattern2 *= 4;
                    if (style.lineCap && style.lineCap !== "butt") {
                        pattern1 -= dashLength;
                        pattern2 += dashLength;
                    }
                }

                //longdash
                if (style.lineType === 'longdash') {
                    pattern1 *= 8;
                    pattern2 *= 4;
                    if (style.lineCap && style.lineCap !== "butt") {
                        pattern1 -= dashLength;
                        pattern2 += dashLength;
                    }
                }


                ctx.moveTo(pointList[0][0] + __OP[0], pointList[0][1] + __OP[1]);
                for (let i = 1; i < pointList.length; i++) {
                    SUtil_SUtil.SUtil_dashedLineTo(
                        ctx,
                        pointList[i - 1][0] + __OP[0],
                        pointList[i - 1][1] + __OP[1],
                        pointList[i][0] + __OP[0],
                        pointList[i][1] + __OP[1],
                        dashLength,
                        [pattern1, pattern2]
                    );
                }
                SUtil_SUtil.SUtil_dashedLineTo(
                    ctx,
                    pointList[pointList.length - 1][0] + __OP[0],
                    pointList[pointList.length - 1][1] + __OP[1],
                    pointList[0][0] + __OP[0],
                    pointList[0][1] + __OP[1],
                    dashLength,
                    [pattern1, pattern2]
                );
            } else if (style.lineType === 'dashdot'
                || style.lineType === 'longdashdot'
            ) {
                let dashLengthForStyle = style._dashLength || (style.lineWidth || 1) * (style.lineType == 'dashed' ? 5 : 1);
                style._dashLength = dashLengthForStyle;

                let dashLength = (style.lineWidth || 1);
                let pattern1 = dashLength;
                let pattern2 = dashLength;
                let pattern3 = dashLength;
                let pattern4 = dashLength;

                //dashdot
                if (style.lineType === 'dashdot') {
                    pattern1 *= 4;
                    pattern2 *= 4;
                    pattern4 *= 4;
                    if (style.lineCap && style.lineCap !== "butt") {
                        pattern1 -= dashLength;
                        pattern2 += dashLength;
                        pattern3 = 1;
                        pattern4 += dashLength;
                    }
                }

                //longdashdot
                if (style.lineType === 'longdashdot') {
                    pattern1 *= 8;
                    pattern2 *= 4;
                    pattern4 *= 4;
                    if (style.lineCap && style.lineCap !== "butt") {
                        pattern1 -= dashLength;
                        pattern2 += dashLength;
                        pattern3 = 1;
                        pattern4 += dashLength;
                    }
                }


                ctx.moveTo(pointList[0][0] + __OP[0], pointList[0][1] + __OP[1]);
                for (let i = 1; i < pointList.length; i++) {
                    SUtil_SUtil.SUtil_dashedLineTo(
                        ctx,
                        pointList[i - 1][0] + __OP[0],
                        pointList[i - 1][1] + __OP[1],
                        pointList[i][0] + __OP[0],
                        pointList[i][1] + __OP[1],
                        dashLength,
                        [pattern1, pattern2, pattern3, pattern4]
                    );
                }
                SUtil_SUtil.SUtil_dashedLineTo(
                    ctx,
                    pointList[pointList.length - 1][0] + __OP[0],
                    pointList[pointList.length - 1][1] + __OP[1],
                    pointList[0][0] + __OP[0],
                    pointList[0][1] + __OP[1],
                    dashLength,
                    [pattern1, pattern2, pattern3, pattern4]
                );
            }

        }
        return;
    }


    /**
     * @function LevelRenderer.Shape.SmicPolygon.prototype.getRect
     * @description 计算返回多边形包围盒矩阵。该包围盒是直接从四个控制点计算，并非最小包围盒。
     *
     * @param {Object} style - style
     * @return {Object} 边框对象。包含属性：x，y，width，height。
     *
     */
    getRect(style, refOriginalPosition) {
        var __OP;
        if (!refOriginalPosition) {
            if (!this.refOriginalPosition || this.refOriginalPosition.length !== 2) {
                this.refOriginalPosition = [0, 0];
            }
            __OP = this.refOriginalPosition;
        } else {
            __OP = refOriginalPosition;
        }

        if (style.__rect) {
            return style.__rect;
        }

        var minX = Number.MAX_VALUE;
        var maxX = Number.MIN_VALUE;
        var minY = Number.MAX_VALUE;
        var maxY = Number.MIN_VALUE;

        var pointList = style.pointList;
        for (var i = 0, l = pointList.length; i < l; i++) {
            if (pointList[i][0] + __OP[0] < minX) {
                minX = pointList[i][0] + __OP[0];
            }
            if (pointList[i][0] + __OP[0] > maxX) {
                maxX = pointList[i][0] + __OP[0];
            }
            if (pointList[i][1] + __OP[1] < minY) {
                minY = pointList[i][1] + __OP[1];
            }
            if (pointList[i][1] + __OP[1] > maxY) {
                maxY = pointList[i][1] + __OP[1];
            }
        }

        var lineWidth;
        if (style.brushType == 'stroke' || style.brushType == 'fill') {
            lineWidth = style.lineWidth || 1;
        } else {
            lineWidth = 0;
        }

        style.__rect = {
            x: Math.round(minX - lineWidth / 2),
            y: Math.round(minY - lineWidth / 2),
            width: maxX - minX + lineWidth,
            height: maxY - minY + lineWidth
        };
        return style.__rect;
    }

}

;// CONCATENATED MODULE: ./src/common/overlay/levelRenderer/SmicBrokenLine.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/




/**
 * @private
 * @class  LevelRenderer.Shape.SmicBrokenLine
 * @category Visualization Theme
 * @classdesc 折线(ic)。
 * @extends LevelRenderer.Shape
 * @example
 *   var shape = new LevelRenderer.Shape.SmicBrokenLine({
 *         style: {
 *             pointList: [[0, 0], [100, 100], [100, 0]],
 *             smooth: 'bezier',
 *             strokeColor: 'purple'
 *         }
 *   });
 *   levelRenderer.addShape(shape);
 * @param {Array} options - shape 的配置（options）项，可以是 shape 的自有属性，也可以是自定义的属性。
 *
 */
class SmicBrokenLine extends Shape_Shape {
    constructor(options) {
        super(options);
        /**
         * @member {string}  LevelRenderer.Shape.SmicBrokenLine.prototype.brushTypeOnly
         * @description 线条只能描边。
         */
        this.brushTypeOnly = 'stroke';

        /**
         * @member {string} LevelRenderer.Shape.SmicBrokenLine.prototype.textPosition
         * @description 文本位置。
         */
        this.textPosition = 'end';

        /**
         * @member {string} LevelRenderer.Shape.SmicBrokenLine.prototype.type
         * @description 图形类型.
         */
        this.type = 'smicbroken-line';
        if (!this.refOriginalPosition || this.refOriginalPosition.length !== 2) {
            this.refOriginalPosition = [0, 0];
        }

        this.CLASS_NAME = "SuperMap.LevelRenderer.Shape.SmicBrokenLine";
    }


    /**
     * @function LevelRenderer.Shape.SmicBrokenLine.prototype.destroy
     * @description 销毁对象，释放资源。调用此函数后所有属性将被置为 null。
     */
    destroy() {
        this.brushTypeOnly = null;
        this.textPosition = null;
        this.type = null;

        super.destroy();
    }


    /**
     * @function LevelRenderer.Shape.SmicBrokenLine.prototype.buildPath
     * @description 创建折线路径。
     *
     * @param {CanvasRenderingContext2D} ctx - Context2D 上下文。
     * @param {Object} style - style。
     *
     */
    buildPath(ctx, style) {
        if (!this.refOriginalPosition || this.refOriginalPosition.length !== 2) {
            this.refOriginalPosition = [0, 0];
        }

        var __OP = this.refOriginalPosition;

        var pointList = style.pointList;
        if (pointList.length < 2) {
            // 少于2个点就不画了~
            return;
        }

        var len = Math.min(style.pointList.length, Math.round(style.pointListLength || style.pointList.length));

        if (style.smooth && style.smooth !== 'spline') {
            var controlPoints = SUtil_SUtil.SUtil_smoothBezier(pointList, style.smooth, false, style.smoothConstraint, __OP);

            ctx.moveTo(pointList[0][0] + __OP[0], pointList[0][1] + __OP[1]);
            var cp1;
            var cp2;
            var p;
            for (let i = 0; i < len - 1; i++) {
                cp1 = controlPoints[i * 2];
                cp2 = controlPoints[i * 2 + 1];
                p = [pointList[i + 1][0] + __OP[0], pointList[i + 1][1] + __OP[1]];
                ctx.bezierCurveTo(
                    cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]
                );
            }
        } else {
            if (style.smooth === 'spline') {
                pointList = SUtil_SUtil.SUtil_smoothSpline(pointList, null, null, __OP);
                len = pointList.length;
            }
            if (!style.lineType || style.lineType === 'solid') {
                // 默认为实线
                ctx.moveTo(pointList[0][0] + __OP[0], pointList[0][1] + __OP[1]);
                for (let i = 1; i < len; i++) {
                    ctx.lineTo(pointList[i][0] + __OP[0], pointList[i][1] + __OP[1]);
                }
            } else if (style.lineType === 'dashed'
                || style.lineType === 'dotted'
                || style.lineType === 'dot'
                || style.lineType === 'dash'
                || style.lineType === 'longdash'
            ) {
                let dashLength = (style.lineWidth || 1);
                let pattern1 = dashLength;
                let pattern2 = dashLength;

                //dashed
                if (style.lineType === 'dashed') {
                    pattern1 *= 5;
                    pattern2 *= 5;
                    if (style.lineCap && style.lineCap !== "butt") {
                        pattern1 -= dashLength;
                        pattern2 += dashLength;
                    }
                }

                //dotted
                if (style.lineType === 'dotted') {
                    if (style.lineCap && style.lineCap !== "butt") {
                        pattern1 = 1;
                        pattern2 += dashLength;
                    }
                }

                //dot
                if (style.lineType === 'dot') {
                    pattern2 *= 4;
                    if (style.lineCap && style.lineCap !== "butt") {
                        pattern1 = 1;
                        pattern2 += dashLength;
                    }
                }

                //dash
                if (style.lineType === 'dash') {
                    pattern1 *= 4;
                    pattern2 *= 4;
                    if (style.lineCap && style.lineCap !== "butt") {
                        pattern1 -= dashLength;
                        pattern2 += dashLength;
                    }
                }

                //longdash
                if (style.lineType === 'longdash') {
                    pattern1 *= 8;
                    pattern2 *= 4;
                    if (style.lineCap && style.lineCap !== "butt") {
                        pattern1 -= dashLength;
                        pattern2 += dashLength;
                    }
                }

                ctx.moveTo(pointList[0][0] + __OP[0], pointList[0][1] + __OP[1]);
                for (var i = 1; i < len; i++) {
                    SUtil_SUtil.SUtil_dashedLineTo(
                        ctx,
                        pointList[i - 1][0] + __OP[0], pointList[i - 1][1] + __OP[1],
                        pointList[i][0] + __OP[0], pointList[i][1] + __OP[1],
                        dashLength,
                        [pattern1, pattern2]
                    );
                }
            } else if (style.lineType === 'dashdot'
                || style.lineType === 'longdashdot'
            ) {
                let dashLength = (style.lineWidth || 1);
                let pattern1 = dashLength;
                let pattern2 = dashLength;
                let pattern3 = dashLength;
                let pattern4 = dashLength;

                //dashdot
                if (style.lineType === 'dashdot') {
                    pattern1 *= 4;
                    pattern2 *= 4;
                    pattern4 *= 4;
                    if (style.lineCap && style.lineCap !== "butt") {
                        pattern1 -= dashLength;
                        pattern2 += dashLength;
                        pattern3 = 1;
                        pattern4 += dashLength;
                    }
                }

                //longdashdot
                if (style.lineType === 'longdashdot') {
                    pattern1 *= 8;
                    pattern2 *= 4;
                    pattern4 *= 4;
                    if (style.lineCap && style.lineCap !== "butt") {
                        pattern1 -= dashLength;
                        pattern2 += dashLength;
                        pattern3 = 1;
                        pattern4 += dashLength;
                    }
                }

                dashLength = (style.lineWidth || 1)
                    * (style.lineType === 'dashed' ? 5 : 1);
                ctx.moveTo(pointList[0][0] + __OP[0], pointList[0][1] + __OP[1]);
                for (let i = 1; i < len; i++) {
                    SUtil_SUtil.SUtil_dashedLineTo(
                        ctx,
                        pointList[i - 1][0] + __OP[0], pointList[i - 1][1] + __OP[1],
                        pointList[i][0] + __OP[0], pointList[i][1] + __OP[1],
                        dashLength,
                        [pattern1, pattern2, pattern3, pattern4]
                    );
                }
            }

        }
        return;
    }


    /**
     * @function LevelRenderer.Shape.SmicBrokenLine.prototype.getRect
     * @description 计算返回折线包围盒矩形。该包围盒是直接从四个控制点计算，并非最小包围盒。
     *
     * @param {Object} style - style
     * @return {Object} 边框对象。包含属性：x，y，width，height。
     */
    getRect(style) {
        if (!this.refOriginalPosition || this.refOriginalPosition.length !== 2) {
            this.refOriginalPosition = [0, 0];
        }
        var __OP = this.refOriginalPosition;
        return SmicPolygon.prototype.getRect.apply(this, [style, __OP]);
    }

}

;// CONCATENATED MODULE: ./src/common/overlay/levelRenderer/SmicRectangle.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


/**
 * @private
 * @class  LevelRenderer.Shape.SmicRectangle
 * @category Visualization Theme
 * @classdesc 矩形。
 * @extends LevelRenderer.Shape
 * @example
 *   var shape = new LevelRenderer.Shape.SmicRectangle({
 *         style: {
 *             x: 0,
 *             y: 0,
 *             width: 100,
 *             height: 100,
 *             radius: 20
 *         }
 *     });
 *   levelRenderer.addShape(shape);
 * @param {Array} options - shape 的配置（options）项，可以是 shape 的自有属性，也可以是自定义的属性。
 */
class SmicRectangle extends Shape_Shape {
    constructor(options) {
        super(options);
        /**
         * @member {string} LevelRenderer.Shape.SmicRectangle.prototype.type
         * @description 图形类型.
         */
        this.type = 'smicrectangle';
        if (!this.refOriginalPosition || this.refOriginalPosition.length !== 2) {
            this.refOriginalPosition = [0, 0];
        }
        this.CLASS_NAME = "SuperMap.LevelRenderer.Shape.SmicRectangle";
    }


    /**
     * @function LevelRenderer.Shape.SmicRectangle.prototype.destroy
     * @description 销毁对象，释放资源。调用此函数后所有属性将被置为 null。
     */
    destroy() {
        this.type = null;
        super.destroy();
    }


    /**
     * APIMethod: _buildRadiusPath
     * 创建矩形的圆角路径。
     *
     * Parameters:
     * ctx - {CanvasRenderingContext2D} Context2D 上下文。
     * style - {Object} style。
     *
     */
    _buildRadiusPath(ctx, style) {
        if (!this.refOriginalPosition || this.refOriginalPosition.length !== 2) {
            this.refOriginalPosition = [0, 0];
        }
        var __OP = this.refOriginalPosition;

        // 左上、右上、右下、左下角的半径依次为r1、r2、r3、r4
        // r缩写为1         相当于 [1, 1, 1, 1]
        // r缩写为[1]       相当于 [1, 1, 1, 1]
        // r缩写为[1, 2]    相当于 [1, 2, 1, 2]
        // r缩写为[1, 2, 3] 相当于 [1, 2, 3, 2]
        var x = style.x + __OP[0];
        var y = style.y + __OP[1];
        var width = style.width;
        var height = style.height;
        var r = style.radius;
        var r1;
        var r2;
        var r3;
        var r4;

        if (typeof r === 'number') {
            r1 = r2 = r3 = r4 = r;
        } else if (r instanceof Array) {
            if (r.length === 1) {
                r1 = r2 = r3 = r4 = r[0];
            } else if (r.length === 2) {
                r1 = r3 = r[0];
                r2 = r4 = r[1];
            } else if (r.length === 3) {
                r1 = r[0];
                r2 = r4 = r[1];
                r3 = r[2];
            } else {
                r1 = r[0];
                r2 = r[1];
                r3 = r[2];
                r4 = r[3];
            }
        } else {
            r1 = r2 = r3 = r4 = 0;
        }

        var total;
        if (r1 + r2 > width) {
            total = r1 + r2;
            r1 *= width / total;
            r2 *= width / total;
        }
        if (r3 + r4 > width) {
            total = r3 + r4;
            r3 *= width / total;
            r4 *= width / total;
        }
        if (r2 + r3 > height) {
            total = r2 + r3;
            r2 *= height / total;
            r3 *= height / total;
        }
        if (r1 + r4 > height) {
            total = r1 + r4;
            r1 *= height / total;
            r4 *= height / total;
        }
        ctx.moveTo(x + r1, y);
        ctx.lineTo(x + width - r2, y);
        r2 !== 0 && ctx.quadraticCurveTo(
            x + width, y, x + width, y + r2
        );
        ctx.lineTo(x + width, y + height - r3);
        r3 !== 0 && ctx.quadraticCurveTo(
            x + width, y + height, x + width - r3, y + height
        );
        ctx.lineTo(x + r4, y + height);
        r4 !== 0 && ctx.quadraticCurveTo(
            x, y + height, x, y + height - r4
        );
        ctx.lineTo(x, y + r1);
        r1 !== 0 && ctx.quadraticCurveTo(x, y, x + r1, y);
    }


    /**
     * @function LevelRenderer.Shape.SmicRectangle.prototype.buildPath
     * @description 创建矩形路径。
     *
     * @param {CanvasRenderingContext2D} ctx - Context2D 上下文。
     * @param {Object} style - style。
     *
     */
    buildPath(ctx, style) {
        if (!this.refOriginalPosition || this.refOriginalPosition.length !== 2) {
            this.refOriginalPosition = [0, 0];
        }
        var __OP = this.refOriginalPosition;

        if (!style.radius) {
            ctx.moveTo(style.x + __OP[0], style.y + __OP[1]);
            ctx.lineTo((style.x + __OP[0]) + style.width, (style.y + __OP[1]));
            ctx.lineTo((style.x + __OP[0]) + style.width, (style.y + __OP[1]) + style.height);
            ctx.lineTo((style.x + __OP[0]), (style.y + __OP[1]) + style.height);
            ctx.lineTo(style.x + __OP[0], style.y + __OP[1]);
            // ctx.rect(style.x, style.y, style.width, style.height);
        } else {
            this._buildRadiusPath(ctx, style);
        }
        ctx.closePath();
        return;
    }


    /**
     * @function LevelRenderer.Shape.SmicRectangle.prototype.getRect
     * @description 计算返回矩形包围盒矩阵。该包围盒是直接从四个控制点计算，并非最小包围盒。
     *
     * @param {Object} style - style
     * @return {Object} 边框对象。包含属性：x，y，width，height。
     */
    getRect(style) {
        if (!this.refOriginalPosition || this.refOriginalPosition.length !== 2) {
            this.refOriginalPosition = [0, 0];
        }
        var __OP = this.refOriginalPosition;

        if (style.__rect) {
            return style.__rect;
        }

        var lineWidth;
        if (style.brushType == 'stroke' || style.brushType == 'fill') {
            lineWidth = style.lineWidth || 1;
        } else {
            lineWidth = 0;
        }
        style.__rect = {
            x: Math.round((style.x + __OP[0]) - lineWidth / 2),
            y: Math.round((style.y + __OP[1]) - lineWidth / 2),
            width: style.width + lineWidth,
            height: style.height + lineWidth
        };

        return style.__rect;
    }

}

;// CONCATENATED MODULE: ./src/common/overlay/levelRenderer/SmicSector.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/



/**
 * @private
 * @class  LevelRenderer.Shape.SmicSector
 * @category Visualization Theme
 * @classdesc 扇形。
 * @extends LevelRenderer.Shape
 * @example
 *   var shape = new LevelRenderer.Shape.SmicSector({
 *         style: {
 *             x: 100,
 *             y: 100,
 *             r: 60,
 *             r0: 30,
 *             startAngle: 0,
 *             endEngle: 180
 *         }
 *   });
 *   levelRenderer.addShape(shape);
 * @param {Array} options - shape 的配置（options）项，可以是 shape 的自有属性，也可以是自定义的属性。
 *
 */
class SmicSector extends Shape_Shape {
    constructor(options) {
        super(options);
        /**
         * @member {string} LevelRenderer.Shape.SmicSector.protptype.type
         * @description 图形类型。
         */
        this.type = 'smicsector';
        if (!this.refOriginalPosition || this.refOriginalPosition.length !== 2) {
            this.refOriginalPosition = [0, 0];
        }
        this.CLASS_NAME = "SuperMap.LevelRenderer.Shape.SmicSector";
    }

    /**
     * @function LevelRenderer.Shape.SmicSector.prototype.destroy
     * @description 销毁对象，释放资源。调用此函数后所有属性将被置为 null。
     */
    destroy() {
        this.type = null;
        super.destroy();
    }

    /**
     * @function LevelRenderer.Shape.SmicSector.prototype.buildPath
     * @description 创建扇形路径。
     *
     * @param {CanvasRenderingContext2D} ctx - Context2D 上下文。
     * @param {Object} style - style。
     *
     */
    buildPath(ctx, style) {
        if (!this.refOriginalPosition || this.refOriginalPosition.length !== 2) {
            this.refOriginalPosition = [0, 0];
        }
        var __OP = this.refOriginalPosition;

        var x = style.x + __OP[0];   // 圆心x
        var y = style.y + __OP[1];   // 圆心y
        var r0 = style.r0 || 0;     // 形内半径[0,r)
        var r = style.r;            // 扇形外半径(0,r]
        var startAngle = style.startAngle;          // 起始角度[0,360)
        var endAngle = style.endAngle;              // 结束角度(0,360]
        var clockWise = style.clockWise || false;

        startAngle = SUtil_SUtil.Util_math.degreeToRadian(startAngle);
        endAngle = SUtil_SUtil.Util_math.degreeToRadian(endAngle);

        if (!clockWise) {
            // 扇形默认是逆时针方向，Y轴向上
            // 这个跟arc的标准不一样，为了兼容echarts
            startAngle = -startAngle;
            endAngle = -endAngle;
        }

        var unitX = SUtil_SUtil.Util_math.cos(startAngle);
        var unitY = SUtil_SUtil.Util_math.sin(startAngle);
        ctx.moveTo(
            unitX * r0 + x,
            unitY * r0 + y
        );

        ctx.lineTo(
            unitX * r + x,
            unitY * r + y
        );

        ctx.arc(x, y, r, startAngle, endAngle, !clockWise);

        ctx.lineTo(
            SUtil_SUtil.Util_math.cos(endAngle) * r0 + x,
            SUtil_SUtil.Util_math.sin(endAngle) * r0 + y
        );

        if (r0 !== 0) {
            ctx.arc(x, y, r0, endAngle, startAngle, clockWise);
        }

        ctx.closePath();

        return;
    }

    /**
     * @function LevelRenderer.Shape.SmicSector.prototype.getRect
     * @description 返回扇形包围盒矩形
     *
     * @param {Object} style - style
     * @return {Object} 边框对象。包含属性：x，y，width，height。
     *
     */
    getRect(style) {
        if (style.__rect) {
            return style.__rect;
        }

        if (!this.refOriginalPosition || this.refOriginalPosition.length !== 2) {
            this.refOriginalPosition = [0, 0];
        }
        var __OP = this.refOriginalPosition;

        var min0 = SUtil_SUtil.Util_vector.create();
        var min1 = SUtil_SUtil.Util_vector.create();
        var max0 = SUtil_SUtil.Util_vector.create();
        var max1 = SUtil_SUtil.Util_vector.create();

        var x = style.x + __OP[0];   // 圆心x
        var y = style.y + __OP[1];   // 圆心y
        var r0 = style.r0 || 0;     // 形内半径[0,r)
        var r = style.r;            // 扇形外半径(0,r]
        var startAngle = SUtil_SUtil.Util_math.degreeToRadian(style.startAngle);
        var endAngle = SUtil_SUtil.Util_math.degreeToRadian(style.endAngle);
        var clockWise = style.clockWise;

        if (!clockWise) {
            startAngle = -startAngle;
            endAngle = -endAngle;
        }

        if (r0 > 1) {
            SUtil_SUtil.Util_computeBoundingBox.arc(
                x, y, r0, startAngle, endAngle, !clockWise, min0, max0
            );
        } else {
            min0[0] = max0[0] = x;
            min0[1] = max0[1] = y;
        }
        SUtil_SUtil.Util_computeBoundingBox.arc(
            x, y, r, startAngle, endAngle, !clockWise, min1, max1
        );

        SUtil_SUtil.Util_vector.min(min0, min0, min1);
        SUtil_SUtil.Util_vector.max(max0, max0, max1);
        style.__rect = {
            x: min0[0],
            y: min0[1],
            width: max0[0] - min0[0],
            height: max0[1] - min0[1]
        };
        return style.__rect;
    }

}

;// CONCATENATED MODULE: ./src/common/overlay/feature/ShapeFactory.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


















/**
 * @class  FeatureShapeFactory
 * @aliasclass Feature.ShapeFactory
 * @deprecatedclass SuperMap.Feature.ShapeFactory
 * @category Visualization Theme
 * @classdesc 图形工厂类。
 * 目前支持创建的图形有：<br>
 * 用于统计专题图：<br>
 * 点 - 参数对象 <{@link ShapeParametersPoint}> <br>
 * 线 - 参数对象 <{@link ShapeParametersLine}> <br>
 * 面 - 参数对象 <{@link ShapeParametersPolygon}> <br>
 * 矩形 - 参数对象 <{@link ShapeParametersPolygon}> <br>
 * 扇形 - 参数对象 <{@link ShapeParametersSector}> <br>
 * 标签 - 参数对象 <{@link ShapeParametersLabel}> <br>
 * 图片 - 参数对象 <{@link ShapeParametersImage}> <br>
 * 用于符号专题图：<br>
 * 圆形 -  参数对象：<{@link ShapeParametersCircle}>
 * @param {Object} [shapeParameters] - 图形参数对象，<{@link ShapeParameters}> 子类对象。
 * @usage
 */
class ShapeFactory {
    constructor(shapeParameters) {
        /**
         * @member {Object} FeatureShapeFactory.prototype.shapeParameters
         * @description  图形参数对象，<{@link ShapeParameters}> 子类对象。必设参数，默认值 null。
         */
        this.shapeParameters = shapeParameters;

        this.CLASS_NAME = "SuperMap.Feature.ShapeFactory";
    }


    /**
     * @function FeatureShapeFactory.prototype.destroy
     * @description 销毁图形工厂类对象。
     */
    destroy() {
        this.shapeParameters = null;
    }


    /**
     * @function FeatureShapeFactory.prototype.createShape
     * @description 创建一个图形。具体图形由 shapeParameters 决定。
     * @param {Object} shapeParameters - 图形参数对象，<{@link ShapeParameters}> 子类对象。
     * 此参数可选，如果使用此参数（不为 null），shapeParameters 属性值将被修改为参数的值，然后再使用 shapeParameters 属性值创建图形；
     * 如果不使用此参数，createShape 方法将直接使用 shapeParameters 属性创建图形。
     * @returns {Object} 图形对象（或 null - 图形创建失败）。
     */
    createShape(shapeParameters) {
        if (shapeParameters) {
            this.shapeParameters = shapeParameters;
        }

        if (!this.shapeParameters) {
            return null;
        }

        var sps = this.shapeParameters;


        if (sps instanceof Point_Point) {        // 点
            //设置style
            let style = new Object();
            style["x"] = sps.x;
            style["y"] = sps.y;
            style["r"] = sps.r;

            style = Util_Util.copyAttributesWithClip(style, sps.style, ['x', 'y']);

            //创建图形
            let shape = new SmicPoint();
            shape.style = ShapeFactory.transformStyle(style);
            shape.highlightStyle = ShapeFactory.transformStyle(sps.highlightStyle);
            Util_Util.copyAttributesWithClip(shape, sps, ['x', 'y', 'style', 'highlightStyle']);

            return shape;
        } else if (sps instanceof Line_Line) {        // 线
            //检查参数 pointList 是否存在
            if (!sps.pointList) {
                return null;
            }

            // 设置style
            let style = new Object();
            style["pointList"] = sps.pointList;
            style = Util_Util.copyAttributesWithClip(style, sps.style, ['pointList']);

            // 创建图形
            let shape = new SmicBrokenLine();
            shape.style = ShapeFactory.transformStyle(style);
            shape.highlightStyle = ShapeFactory.transformStyle(sps.highlightStyle);
            Util_Util.copyAttributesWithClip(shape, sps, ['pointList', 'style', 'highlightStyle']);

            return shape;
        } else if (sps instanceof feature_Polygon_Polygon) {        // 面
            //检查参数 pointList 是否存在
            if (!sps.pointList) {
                return null;
            }

            //设置style
            let style = new Object();
            style["pointList"] = sps.pointList;
            style = Util_Util.copyAttributesWithClip(style, sps.style, ['pointList']);

            //创建图形
            let shape = new SmicPolygon();
            shape.style = ShapeFactory.transformStyle(style);
            shape.highlightStyle = ShapeFactory.transformStyle(sps.highlightStyle);
            Util_Util.copyAttributesWithClip(shape, sps, ['pointList', 'style', "highlightStyle"]);

            return shape;
        } else if (sps instanceof Rectangle_Rectangle) {        // 矩形
            //检查参数 pointList 是否存在
            if (!sps.x && !sps.y & !sps.width & !sps.height) {
                return null;
            }

            //设置style
            let style = new Object();
            style["x"] = sps.x;
            style["y"] = sps.y;
            style["width"] = sps.width;
            style["height"] = sps.height;

            style = Util_Util.copyAttributesWithClip(style, sps.style, ['x', 'y', 'width', 'height']);

            //创建图形
            let shape = new SmicRectangle();
            shape.style = ShapeFactory.transformStyle(style);
            shape.highlightStyle = ShapeFactory.transformStyle(sps.highlightStyle);
            Util_Util.copyAttributesWithClip(shape, sps, ['x', 'y', 'width', 'height', 'style', 'highlightStyle']);

            return shape;
        } else if (sps instanceof Sector) {        // 扇形
            //设置style
            let style = new Object();
            style["x"] = sps.x;
            style["y"] = sps.y;
            style["r"] = sps.r;
            style["startAngle"] = sps.startAngle;
            style["endAngle"] = sps.endAngle;
            if (sps["r0"]) {
                style["r0"] = sps.r0
            }

            if (sps["clockWise"]) {
                style["clockWise"] = sps.clockWise
            }


            style = Util_Util.copyAttributesWithClip(style, sps.style, ['x', 'y', 'r', 'startAngle', 'endAngle', 'r0', 'endAngle']);

            //创建图形
            let shape = new SmicSector();
            shape.style = ShapeFactory.transformStyle(style);
            shape.highlightStyle = ShapeFactory.transformStyle(sps.highlightStyle);
            Util_Util.copyAttributesWithClip(shape, sps, ['x', 'y', 'r', 'startAngle', 'endAngle', 'r0', 'endAngle', 'style', 'highlightStyle']);

            return shape;
        } else if (sps instanceof Label) {        // 标签
            //设置style
            let style = new Object();
            style["x"] = sps.x;
            style["y"] = sps.y;
            style["text"] = sps.text;

            style = Util_Util.copyAttributesWithClip(style, sps.style, ['x', 'y', 'text']);

            //创建图形
            let shape = new SmicText();
            shape.style = ShapeFactory.transformStyle(style);
            shape.highlightStyle = ShapeFactory.transformStyle(sps.highlightStyle);
            Util_Util.copyAttributesWithClip(shape, sps, ['x', 'y', 'text', 'style', 'highlightStyle']);

            return shape;
        } else if (sps instanceof Image_Image) {        // 图片
            //设置style
            let style = new Object();
            style["x"] = sps.x;
            style["y"] = sps.y;
            if (sps["image"]) {
                style["image"] = sps.image;
            }
            if (sps["width"]) {
                style["width"] = sps.width;
            }
            if (sps["height"]) {
                style["height"] = sps.height;
            }
            if (sps["sx"]) {
                style["sx"] = sps.sx;
            }
            if (sps["sy"]) {
                style["sy"] = sps.sy;
            }
            if (sps["sWidth"]) {
                style["sWidth"] = sps.sWidth
            }
            if (sps["sHeight"]) {
                style["sHeight"] = sps.sHeight
            }

            style = Util_Util.copyAttributesWithClip(style, sps.style, ['x', 'y', 'image', 'width', 'height', 'sx', 'sy', 'sWidth', 'sHeight']);

            //创建图形
            let shape = new SmicImage();
            shape.style = ShapeFactory.transformStyle(style);
            shape.highlightStyle = ShapeFactory.transformStyle(sps.highlightStyle);
            Util_Util.copyAttributesWithClip(shape, sps, ['x', 'y', 'image', 'width', 'height', 'style', 'highlightStyle']);

            return shape;
        } else if (sps instanceof Circle_Circle) {       //圆形 用于符号专题图
            //设置stytle
            let style = new Object();
            style["x"] = sps.x;
            style["r"] = sps.r;
            style["y"] = sps.y;

            style = Util_Util.copyAttributesWithClip(style, sps.style, ['x', 'y', 'r']);

            //创建图形
            let shape = new SmicCircle();
            shape.style = ShapeFactory.transformStyle(style);
            shape.highlightStyle = ShapeFactory.transformStyle(sps.highlightStyle);
            Util_Util.copyAttributesWithClip(shape, sps, ['x', 'y', 'r', 'style', 'highlightStyle', 'lineWidth', 'text', 'textPosition']);

            return shape;
        }

        return null
    }


    /**
     * @function FeatureShapeFactory.prototype.transformStyle
     * @description 将用户 feature.style (类 Svg style 标准) 的样式，转换为 levelRenderer 的样式标准（类 CSS-Canvas 样式）
     * @param {Object} style - 用户 style。
     * @returns {Object} 符合 levelRenderer 的 style。
     */
    static transformStyle(style) {
        var newStyle = {};

        //字体 ["font-style", "font-variant", "font-weight", "font-size / line-height", "font-family"];
        var fontStr = ["normal", "normal", "normal", "12", "arial,sans-serif"];

        //画笔类型 ["fill", "stroke"];
        var brushType = [true, false];

        for (var ss in style) {
            switch (ss) {
                case "fill":
                    brushType[0] = style[ss];
                    break;
                case "fillColor":
                    newStyle["color"] = style[ss];
                    break;
                case "stroke":
                    brushType[1] = style[ss];
                    break;
                case "strokeWidth":
                    newStyle["lineWidth"] = style[ss];
                    break;
                case "strokeLinecap":
                    newStyle["lineCap"] = style[ss];
                    break;
                case "strokeLineJoin":
                    newStyle["lineJoin"] = style[ss];
                    break;
                case "strokeDashstyle":
                    newStyle["lineType"] = style[ss];
                    break;
                case "pointRadius":
                    newStyle["r"] = style[ss];
                    break;
                case "label":
                    newStyle["text"] = style[ss];
                    break;
                case "labelRect":
                    newStyle["labelRect"] = style[ss];
                    break;
                case "fontColor":
                    newStyle["textColor"] = style[ss];
                    break;
                case "fontStyle":
                    fontStr[0] = style[ss];
                    break;
                case "fontVariant":
                    fontStr[1] = style[ss];
                    break;
                case "fontWeight":
                    fontStr[2] = style[ss];
                    break;
                case "fontSize":
                    var unit = "";
                    if (style[ss] && style[ss].toString().indexOf("px") < 0) {
                        unit = "px";
                    }
                    fontStr[3] = style[ss] + unit;
                    break;
                case "fontFamily":
                    fontStr[4] = style[ss];
                    break;
                case "fontOpacity":
                    newStyle["opacity"] = style[ss];
                    break;
                case "labelPosition":
                    newStyle["textPosition"] = style[ss];
                    break;
                case "labelAlign":
                    newStyle["textAlign"] = style[ss];
                    break;
                case "labelBaseline":
                    newStyle["textBaseline"] = style[ss];
                    break;
                case "labelRotation":
                    newStyle["textRotation"] = style[ss];
                    break;

                default:
                    newStyle[ss] = style[ss];
                    break;
            }
        }

        //拼接字体字符串
        newStyle["textFont"] = fontStr.join(" ");

        //画笔类型
        if (brushType[0] === true && brushType[1] === false) {
            newStyle["brushType"] = "fill";
        } else if (brushType[0] === false && brushType[1] === true) {
            newStyle["brushType"] = "stroke";
        } else if (brushType[0] === true && brushType[1] === true) {
            newStyle["brushType"] = "both";
        } else {
            newStyle["brushType"] = "fill";
        }

        //默认线宽 1
        if (newStyle["lineWidth"] == null) {
            newStyle["lineWidth"] = 1;
        }

        return newStyle;
    }

    /**
     * @function FeatureShapeFactory.prototype.Background
     * @description 创建一个矩形背景框图形对象。
     * @param {FeatureShapeFactory} shapeFactory - 图形工厂对象。
     * @param {Array.<number>} box - 框区域，长度为 4 的一维数组，像素坐标，[left, bottom, right, top]。
     * @param {Object} setting - 图表配置参数。本函数中图形配置对象 setting 可设属性：
     * @param {Object} setting.backgroundStyle - 背景样式，此样式对象对象可设属性：<ShapeParametersRectangle#style>。
     * @param {Array.<number>} [setting.backgroundRadius=[0,0,0,0]] - 背景框矩形圆角半径，可以用数组分别指定四个角的圆角半径，设：左上、右上、右下、左下角的半径依次为 r1、r2、r3、r4，则 backgroundRadius 为 [r1、r2、r3、r4 ]。
     * @returns {Object} 背景框图形，一个可视化图形（矩形）对象。
     */
    static Background(shapeFactory, box, setting) {
        var sets = setting ? setting : {};

        // 背景框图形参数对象
        var bgSP = new Rectangle_Rectangle(box[0], box[3], Math.abs(box[2] - box[0]), Math.abs(box[3] - box[1]));

        // 默认样式
        bgSP.style = {
            fillColor: "#f3f3f3"
        };

        // 设置用户 style
        if (sets.backgroundStyle) {
            Util_Util.copyAttributesWithClip(bgSP.style, sets.backgroundStyle);
        }

        // 设置背景框圆角参数
        if (sets.backgroundRadius) {
            bgSP.style["radius"] = sets.backgroundRadius;
        }

        // 禁止背景框响应事件
        bgSP.clickable = false;
        bgSP.hoverable = false;

        return shapeFactory.createShape(bgSP);
    }

    /**
     * @function FeatureShapeFactory.prototype.GraphAxis
     * @description 创建一个统计图表坐标轴图形对象组。
     * @param {FeatureShapeFactory} shapeFactory - 图形工厂对象。
     * @param {Array.<number>} dataViewBox - 统计图表模型的数据视图框，长度为 4 的一维数组，像素坐标，[left, bottom, right, top]。
     * @param {Object} setting - 图表配置参数。
     * @param {Object} setting.axisStyle - 坐标轴样式，此样式对象对象可设属性：<ShapeParametersLine#style>。
     * @param {boolean} [setting.axisUseArrow=false] - 坐标轴是否使用箭头。
     * @param {number} [setting.axisYTick=0] - y 轴刻度数量，0表示不使用箭头。
     * @param {Array.<string>} setting.axisYLabels - y 轴上的标签组内容，标签顺序沿着数据视图框左面条边自上而下，等距排布。例如：["1000", "750", "500", "250", "0"]。
     * @param {Object} setting.axisYLabelsStyle - y 轴上的标签组样式，此样式对象对象可设属性：<ShapeParametersLabel#style>。
     * @param {Array.<number>} [setting.axisYLabelsOffset=[0,0]] - y 轴上的标签组偏移量。长度为 2 的数组，数组第一项表示 y 轴标签组横向上的偏移量，向左为正，默认值：0；数组第二项表示 y 轴标签组纵向上的偏移量，向下为正，默认值：0。
     * @param {Array.<string>} setting.axisXLabels - x 轴上的标签组内容，标签顺序沿着数据视图框下面条边自左向右排布，例如：["92年", "95年", "99年"]。
     * 标签排布规则：当标签数量与 xShapeInfo 中的属性 xPositions 数量相同（即标签个数与数据个数相等时）, 按照 xPositions 提供的位置在水平方向上排布标签，否则沿数据视图框下面条边等距排布标签。
     * @param {Object} setting.axisXLabelsStyle - x 轴上的标签组样式，此样式对象对象可设属性：<ShapeParametersLabel#style>。
     * @param {Array.<number>} [setting.axisXLabelsOffset=[0,0]] - x 轴上的标签组偏移量。长度为 2 的数组，数组第一项表示 x 轴标签组横向上的偏移量，向左为正，默认值：0；数组第二项表示 x 轴标签组纵向上的偏移量，向下为正，默认值：0。
     * @param {boolean} setting.useXReferenceLine - 是否使用水平参考线，如果为 true，在 axisYTick 大于 0 时有效，水平参考线是 y 轴刻度在数据视图框里的延伸。
     * @param {Object} setting.xReferenceLineStyle - 水平参考线样式，此样式对象对象可设属性：<ShapeParametersLine#style>。
     * @param {number} [setting.axis3DParameter=0] - 3D 坐标轴参数，此属性值在大于等于 15 时有效。
     * @param {Object} xShapeInfo - X 方向上的图形信息对象，包含两个属性。
     * @param {Array.<number>} xShapeInfo.xPositions - 图形在 x 轴方向上的像素坐标值，是一个一维数组，如果图形在 x 方向上有一定宽度，通常取图形在 x 方向上的中心点为图形在 x 方向上的坐标值。
     * @param {number} xShapeInfo.width - 图形的宽度（特别注意：点的宽度始终为 0，而不是其直径）。
     * @returns {Array.<Object>} 统计图表坐标轴图形对象数组。
     */
    static GraphAxis(shapeFactory, dataViewBox, setting, xShapeInfo) {
        var dvb = dataViewBox;
        var sets = setting ? setting : {};

        // 参考线图形对象组
        var refLines = [];
        //坐标轴箭头对象组
        var arrows = [];
        // 是否使用参水平考线，默认不使用
        var isAddRefLine = sets.useXReferenceLine ? sets.useXReferenceLine : false;
        // y 轴上的刻度
        var axisytick = (sets.axisYTick && !isNaN(sets.axisYTick)) ? sets.axisYTick : 0;
        // 坐标轴节点数组
        var pois = [];
        //z 轴箭头数组
        var zArrowPois = [];
        // x,y 轴主干节点数组
        var xMainPois = [];
        if (axisytick == 0) {
            xMainPois.push([dvb[0], dvb[3] - 5]);
            xMainPois.push([dvb[0], dvb[1]]);

            // 3D 坐标轴  第三象限平分线
            if (sets.axis3DParameter && !isNaN(sets.axis3DParameter) && sets.axis3DParameter >= 15) {
                let axis3DParameter = parseInt(sets.axis3DParameter);
                let axis3DPoi = [dvb[0] - axis3DParameter, dvb[1] + axis3DParameter];

                // 添加 3D 轴节点
                if (sets.axisUseArrow) {      // 添加 3D 轴箭头节点坐标
                    //箭头坐标
                    zArrowPois.push([axis3DPoi[0] + 1.5, axis3DPoi[1] - 7.5]);
                    zArrowPois.push([axis3DPoi[0] - 1, axis3DPoi[1] + 1]);
                    zArrowPois.push([axis3DPoi[0] + 7.5, axis3DPoi[1] - 1.5]);
                    //3D轴
                    xMainPois.push([axis3DPoi[0], axis3DPoi[1]]);
                } else {
                    xMainPois.push([axis3DPoi[0], axis3DPoi[1]]);
                }

                xMainPois.push([dvb[0], dvb[1]]);
            }
            xMainPois.push([dvb[2] + 5, dvb[1]]);
        } else {
            // 单位刻度长度
            var unitTick = Math.abs(dvb[1] - dvb[3]) / axisytick;
            // 刻度 y 坐标
            var thckY = dvb[3];

            xMainPois.push([dvb[0], thckY - 5]);

            for (var i = 0; i < axisytick; i++) {
                xMainPois.push([dvb[0], thckY]);
                xMainPois.push([dvb[0] - 5, thckY]);
                xMainPois.push([dvb[0], thckY]);

                // 参考线
                if (isAddRefLine) {
                    // 参考线参数对象
                    var refLineSP = new Line_Line([
                        [dvb[0], thckY],
                        [dvb[2], thckY]
                    ]);
                    // 参考线默认样式对象
                    refLineSP.style = {
                        strokeColor: "#cfcfcf",
                        strokeLinecap: "butt",
                        strokeLineJoin: "round",
                        strokeWidth: 1
                    };
                    // 禁止事件
                    refLineSP.clickable = false;
                    refLineSP.hoverable = false;
                    // 用户style
                    if (sets.xReferenceLineStyle) {
                        Util_Util.copyAttributesWithClip(refLineSP.style, sets.xReferenceLineStyle);
                    }
                    // 生成参考线图形对象
                    refLines.push(shapeFactory.createShape(refLineSP))
                }

                // y 刻度增量
                thckY += unitTick;
            }

            xMainPois.push([dvb[0], dvb[1]]);

            // 3D 坐标轴  第三象限平分线
            if (sets.axis3DParameter && !isNaN(sets.axis3DParameter) && sets.axis3DParameter >= 15) {
                let axis3DParameter = parseInt(sets.axis3DParameter);
                let axis3DPoi = [dvb[0] - axis3DParameter, dvb[1] + axis3DParameter];

                /*
                 // 箭头计算过程
                 var axis3DPoiRef = [axis3DPoi[0] + 7, axis3DPoi[1] - 7];  // 7 是 10 为斜边 cos（45度）时邻边的值
                 var axis3DPoiLT = [axis3DPoiRef[0] - 4, axis3DPoiRef[1] - 4];
                 var axis3DPoiRB = [axis3DPoiRef[0] + 4, axis3DPoiRef[1] + 4];
                 if(sets.axisUseArrow){
                 xMainPois.push([axis3DPoi[0], axis3DPoi[1]]);
                 xMainPois.push([axis3DPoiLT[0], axis3DPoiLT[1]]);
                 xMainPois.push([axis3DPoi[0], axis3DPoi[1]]);
                 xMainPois.push([axis3DPoiRB[0], axis3DPoiRB[1]]);
                 xMainPois.push([axis3DPoi[0], axis3DPoi[1]]);
                 }
                 else{
                 xMainPois.push([axis3DPoi[0], axis3DPoi[1]]);
                 }
                 */

                // 添加 3D 轴节点
                if (sets.axisUseArrow) {      // 添加 3D 轴和箭头坐标
                    //箭头坐标
                    zArrowPois.push([axis3DPoi[0] + 1.5, axis3DPoi[1] - 7.5]);
                    zArrowPois.push([axis3DPoi[0] - 1, axis3DPoi[1] + 1]);
                    zArrowPois.push([axis3DPoi[0] + 7.5, axis3DPoi[1] - 1.5]);
                    //3D轴
                    xMainPois.push([axis3DPoi[0], axis3DPoi[1]]);
                } else {
                    xMainPois.push([axis3DPoi[0], axis3DPoi[1]]);
                }

                xMainPois.push([dvb[0], dvb[1]]);
            }

            xMainPois.push([dvb[2] + 5, dvb[1]]);
        }
        // 坐标轴箭头
        if (sets.axisUseArrow) {
            // x 轴箭头节点数组
            var xArrowPois = [
                [dvb[2] + 5, dvb[1] + 4],
                [dvb[2] + 13, dvb[1]],
                [dvb[2] + 5, dvb[1] - 4]
            ];

            // y 轴箭头节点数组
            var yArrowPois = [
                [dvb[0] - 4, dvb[3] - 5],
                [dvb[0], dvb[3] - 13],
                [dvb[0] + 4, dvb[3] - 5]
            ];

            //x轴箭头
            var xSP = new feature_Polygon_Polygon(xArrowPois);
            xSP.style = {fillColor: "#008acd"};
            Util_Util.copyAttributesWithClip(xSP.style, sets.axisStyle);
            arrows.push(shapeFactory.createShape(xSP));

            //y轴箭头
            var ySP = new feature_Polygon_Polygon(yArrowPois);
            ySP.style = {fillColor: "#008acd"};
            Util_Util.copyAttributesWithClip(ySP.style, sets.axisStyle);
            arrows.push(shapeFactory.createShape(ySP));

            // z轴箭头 坐标轴箭头是否要使用
            if (sets.axis3DParameter && !isNaN(sets.axis3DParameter) && sets.axis3DParameter >= 15) {
                var zSP = new feature_Polygon_Polygon(zArrowPois);
                zSP.style = {fillColor: "#008acd"};
                Util_Util.copyAttributesWithClip(zSP.style, sets.axisStyle);
                arrows.push(shapeFactory.createShape(zSP));
            }

        }
        //不带箭头的坐标轴
        pois = xMainPois;

        // 坐标轴参数对象
        var axisSP = new Line_Line(pois);
        // 坐标轴默认style
        axisSP.style = {
            strokeLinecap: "butt",
            strokeLineJoin: "round",
            strokeColor: "#008acd",
            strokeWidth: 1
        };
        // 用户 style
        if (sets.axisStyle) {
            Util_Util.copyAttributesWithClip(axisSP.style, sets.axisStyle);
        }
        // 禁止事件
        axisSP.clickable = false;
        axisSP.hoverable = false;
        // 创建坐标轴图形对象
        var axisMain = [shapeFactory.createShape(axisSP)];

        // Y 轴标签
        var yLabels = [];
        if (sets.axisYLabels && sets.axisYLabels.length && sets.axisYLabels.length > 0) {
            var axisYLabels = sets.axisYLabels;
            let len = axisYLabels.length;

            // 标签偏移量
            var ylOffset = [0, 0];
            if (sets.axisYLabelsOffset && sets.axisYLabelsOffset.length) {
                ylOffset = sets.axisYLabelsOffset;
            }

            if (len == 1) {
                // 标签参数对象
                let labelYSP = new Label(dvb[0] - 5 + ylOffset[0], dvb[3] + ylOffset[1], axisYLabels[0]);
                labelYSP.style = {
                    labelAlign: "right"
                };
                // 用户 style
                if (sets.axisYLabelsStyle) {
                    Util_Util.copyAttributesWithClip(labelYSP.style, sets.axisYLabelsStyle);
                }
                // 禁止事件
                labelYSP.clickable = false;
                labelYSP.hoverable = false;
                // 制作标签
                yLabels.push(shapeFactory.createShape(labelYSP));
            } else {
                var labelY = dvb[3];
                // y 轴标签单位距离
                var yUnit = Math.abs(dvb[1] - dvb[3]) / (len - 1);

                for (var j = 0; j < len; j++) {
                    // 标签参数对象
                    let labelYSP = new Label(dvb[0] - 5 + ylOffset[0], labelY + ylOffset[1], axisYLabels[j]);
                    labelYSP.style = {
                        labelAlign: "right"
                    };
                    // 用户 style
                    if (sets.axisYLabelsStyle) {
                        Util_Util.copyAttributesWithClip(labelYSP.style, sets.axisYLabelsStyle);
                    }
                    // 禁止事件
                    labelYSP.clickable = false;
                    labelYSP.hoverable = false;
                    // 制作标签
                    yLabels.push(shapeFactory.createShape(labelYSP));
                    // y 轴标签 y 方向增量
                    labelY += yUnit;
                }
            }
        }

        // X 轴标签
        var xLabels = [];
        if (sets.axisXLabels && sets.axisXLabels.length && sets.axisXLabels.length > 0) {
            let axisXLabels = sets.axisXLabels;
            let len = axisXLabels.length;

            // 标签偏移量
            let xlOffset = [0, 0];
            if (sets.axisXLabelsOffset && sets.axisXLabelsOffset.length) {
                xlOffset = sets.axisXLabelsOffset;
            }

            // 标签个数与数据字段个数相等等时，标签在 x 轴均匀排列
            if (xShapeInfo && xShapeInfo.xPositions && xShapeInfo.xPositions.length && xShapeInfo.xPositions.length == len) {
                let xsCenter = xShapeInfo.xPositions;
                for (let K = 0; K < len; K++) {
                    // 标签参数对象
                    let labelXSP = new Label(xsCenter[K] + xlOffset[0], dvb[1] + xlOffset[1], axisXLabels[K]);
                    // 默认 style
                    labelXSP.style = {
                        labelAlign: "center",
                        labelBaseline: "top"
                    };
                    // 用户 style
                    if (sets.axisXLabelsStyle) {
                        Util_Util.copyAttributesWithClip(labelXSP.style, sets.axisXLabelsStyle);
                    }
                    // 禁止事件
                    labelXSP.clickable = false;
                    labelXSP.hoverable = false;
                    // 创建标签对象
                    xLabels.push(shapeFactory.createShape(labelXSP));
                }
            } else {
                if (len == 1) {
                    // 标签参数对象
                    let labelXSP = new Label(dvb[0] - 5 + xlOffset[0], dvb[1] + xlOffset[0], axisXLabels[0]);
                    // 默认 style
                    labelXSP.style = {
                        labelAlign: "center",
                        labelBaseline: "top"
                    };
                    // 用户 style
                    if (sets.axisXLabelsStyle) {
                        Util_Util.copyAttributesWithClip(labelXSP.style, sets.axisXLabelsStyle);
                    }
                    // 禁止事件
                    labelXSP.clickable = false;
                    labelXSP.hoverable = false;
                    // 创建标签对象
                    xLabels.push(shapeFactory.createShape(labelXSP));
                } else {
                    let labelX = dvb[0];
                    // x 轴标签单位距离
                    let xUnit = Math.abs(dvb[2] - dvb[0]) / (len - 1);

                    for (let m = 0; m < len; m++) {
                        // 标签参数对象
                        let labelXSP = new Label(labelX + xlOffset[0], dvb[1] + xlOffset[1], axisXLabels[m]);
                        // 默认 style
                        labelXSP.style = {
                            labelAlign: "center",
                            labelBaseline: "top"
                        };
                        // 用户 style
                        if (sets.axisXLabelsStyle) {
                            Util_Util.copyAttributesWithClip(labelXSP.style, sets.axisXLabelsStyle);
                        }
                        // 禁止事件
                        labelXSP.clickable = false;
                        labelXSP.hoverable = false;
                        // 创建标签对象
                        xLabels.push(shapeFactory.createShape(labelXSP));
                        // x 轴标签 x 方向增量
                        labelX += xUnit;
                    }
                }
            }
        }

        // 组装并返回构成坐标轴的图形
        return ((refLines.concat(axisMain)).concat(yLabels)).concat(xLabels).concat(arrows);
    }

    /**
     * @function FeatureShapeFactory.prototype.ShapeStyleTool
     * @description 一个图形 style 处理工具。此工具将指定的默认 style，通用 style，按 styleGroup 取得的 style 和按数据值 value 范围取得的 style 进行合并，得到图形最终的 style。
     * @param {Object} defaultStyle - 默认style，此样式对象可设属性根据图形类型参考 <{@link ShapeParameters}> 子类对象的 style 属性。
     * @param {Object} style - 图形对象基础 style，此参数控制图形的基础样式，可设属性根据图形类型参考 <{@link ShapeParameters}> 子类对象的 style 属性。优先级低于 styleGroup，styleByCodomain。
     * @param {Array.<Object>} styleGroup - 一个 style 数组，优先级低于 styleByCodomain，高于 style。此数组每个元素是样式对象，
     * 其可设属性根据图形类型参考 <{@link ShapeParameters}> 子类对象的 style 属性。通过 index 参数从 styleGroup 中取 style。
     * @param {Array.<Object>} styleByCodomain - 按数据（参数 value）所在值域范围控制数据的可视化对象样式。
     * (start code)
     * // styleByCodomain 的每个元素是个包含值域信息和与值域对应样式信息的对象，该对象（必须）有三个属性：
     * // start: 值域值下限（包含）;
     * // end: 值域值上限（不包含）;
     * // style: 数据可视化图形的 style，其可设属性根据图形类型参考 <ShapeParameters> 子类对象的 style 属性。
     * // dataStyleByCodomain 数组形如：
     * [
     *   {
 *     start:0,
 *     end:250,
 *     style:{
 *          fillColor:"#00CD00"
 *      }
 *  },
     *   {
 *     start:250,
 *     end:500,
 *     style:{
 *          fillColor:"#00EE00"
 *      }
 *  },
     *   {
 *     start:500,
 *     end:750,
 *     style:{
 *          fillColor:"#00FF7F"
 *      }
 *  },
     *   {
 *     start:750,
 *     end:1500,
 *     style:{
 *          fillColor:"#00FF00"
 *      }
 *  }
     * ]
     * (end)
     * @param {number} index - styleGroup 的索引值，用于取出 styleGroup 指定的 style。
     * @param {number} value - 数据值，用于取出 styleByCodomain 指定的 style。
     * @returns {Object} 合并后的样式 （style） 对象。
     */
    static ShapeStyleTool(defaultStyle, style, styleGroup, styleByCodomain, index, value) {
        // 用 defaultStyle 初始化 style 对象
        var finalStyle = defaultStyle ? defaultStyle : {};

        // 基础 style
        if (style) {
            Util_Util.copyAttributesWithClip(finalStyle, style);
        }

        // 按索引赋 style
        if (styleGroup && styleGroup.length && typeof(index) !== "undefined" && !isNaN(index) && index >= 0) {
            if (styleGroup[index]) {
                Util_Util.copyAttributesWithClip(finalStyle, styleGroup[index]);
            }
        }

        // 按值域赋 style
        if (styleByCodomain && styleByCodomain.length && typeof(value) !== "undefined") {
            var dsc = styleByCodomain;
            var dscLen = dsc.length;
            var v = parseFloat(value);
            for (var i = 0; i < dscLen; i++) {
                if (dsc[i].start <= v && v < dsc[i].end) {
                    Util_Util.copyAttributesWithClip(finalStyle, dsc[i].style);
                    break;
                }
            }
        }

        return finalStyle;
    }

}

;// CONCATENATED MODULE: ./src/common/overlay/ThemeVector.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/






















/**
 * @class FeatureThemeVector
 * @aliasclass Feature.Theme.ThemeVector
 * @deprecatedclass SuperMap.Feature.Theme.ThemeVector
 * @classdesc 矢量专题要素类。
 * @category Visualization Theme
 * @extends FeatureTheme
 * @param {FeatureVector} data - 用户数据，的类型为矢量数据 feature。
 * @param {SuperMap.Layer} layer - 此专题要素所在图层。
 * @param {Object} style - 样式。
 * @param {Object} options - 创建专题要素时的可选参数。
 * @param {number} [options.nodesClipPixel=2] - 节点抽稀像素距离，单位：像素。
 * @param {boolean} [options.isHoverAble=true] - 图形是否可 hover。
 * @param {boolean} [options.isMultiHover=true] - 是否使用多图形高亮，isHoverAble 为 true 时生效。
 * @param {boolean} [options.isClickAble=true] - 图形是否可点击。
 * @param {Object} [options.highlightStyle] - 高亮样式。
 * @usage
 */
class ThemeVector extends Theme {

    constructor(data, layer, style, options, shapeOptions) {
        super(data, layer);
        //数据的 geometry 属性必须存在且类型是 Geometry 或其子类的类型
        if (!data.geometry) {
            return;
        }
        if (!(data.geometry instanceof Geometry_Geometry)) {
            return;
        }

        /**
         * @member {Bounds} [FeatureThemeVector.prototype.dataBounds]
         * @description 用户数据的（feature.geometry）地理范围。
         */
        this.dataBounds = data.geometry.getBounds();

        /**
         * @member {number} [FeatureThemeVector.prototype.nodesClipPixel=2]
         * @description 节点抽稀像素距离。
         */
        this.nodesClipPixel = 2;

        /**
         * @member {boolean} [FeatureThemeVector.prototype.isHoverAble=true]
         * @description 图形是否可 hover。
         */
        this.isHoverAble = true;

        /**
         * @member {boolean} [FeatureThemeVector.prototype.isMultiHover=true]
         * @description 是否使用多图形高亮，isHoverAble 为 true 时生效。
         */
        this.isMultiHover = true;

        /**
         * @member {boolean} [FeatureThemeVector.prototype.isClickAble=true]
         * @description 图形是否可点击。
         */
        this.isClickAble = true;

        /**
         * @member {Object} [FeatureThemeVector.prototype.highlightStyle]
         * @description 高亮样式。
         */
        this.highlightStyle = null;

        /**
         * @member {Object} [FeatureThemeVector.prototype.shapeOptions]
         * @description 添加到渲染器前修改 shape 的一些属性，非特殊情况通常不允许这么做。
         */
        this.shapeOptions = {};

        /**
         * @member {Object} [FeatureThemeVector.prototype.style]
         * @description 可视化图形的 style。在子类中规定其对象结构和默认属性值。
         */
        this.style = style || {};


        this.CLASS_NAME = "SuperMap.Feature.Theme.Vector";
        this.style = style ? style : {};
        if (options) {
            Util_Util.copyAttributesWithClip(this, options, ["shapeOptions", "dataBounds"])
        }
        if (shapeOptions) {
            Util_Util.copyAttributesWithClip(this.shapeOptions, shapeOptions);
        }

        //设置基础参数 dataBounds、lonlat、location
        var geometry = data.geometry;
        this.lonlat = this.dataBounds.getCenterLonLat();
        this.location = this.getLocalXY(this.lonlat);

        //将地理要素转为专题要素
        if (geometry instanceof LinearRing_LinearRing) {
            this.lineToTF(geometry);
        } else if (geometry instanceof LineString) {
            this.lineToTF(geometry);
        } else if (geometry instanceof Curve) {
            //独立几何体
        } else if (geometry instanceof MultiPoint) {
            this.multiPointToTF(geometry);
        } else if (geometry instanceof MultiLineString) {

            this.multiLineStringToTF(geometry);
        } else if (geometry instanceof MultiPolygon) {
            this.multiPolygonToTF(geometry);
        } else if (geometry instanceof Polygon_Polygon) {
            this.polygonToTF(geometry);
        } else if (geometry instanceof Collection) {
            //独立几何体
        } else if (geometry instanceof Point) {
            this.pointToTF(geometry);
        } else if (geometry instanceof Rectangle) {
            this.rectangleToTF(geometry);
        } else if (geometry instanceof GeoText) {
            this.geoTextToTF(geometry);
        }

    }

    /**
     * @function FeatureThemeVector.prototype.destroy
     * @override
     */
    destroy() {
        this.style = null;
        this.dataBounds = null;
        this.nodesClipPixel = null;
        this.isHoverAble = null;
        this.isMultiHover = null;
        this.isClickAble = null;
        this.highlightStyle = null;
        this.shapeOptions = null;
        super.destroy();
    }


    /**
     * @function FeatureThemeVector.prototype.lineToTF
     * @description 转换线和线环要素。
     * @param {Geometry} geometry - 用户数据几何地理信息，这里必须是 GeometryLineString 或 GeometryLineRing。
     */
    lineToTF(geometry) {
        var components = geometry.components;

        //节点像素坐标
        var localLX = [];
        //参考位置，参考中心为
        var refLocal = [];
        var location = this.location;
        var pointList = [];

        //节点抽稀距离
        var nCPx = this.nodesClipPixel;

        for (var i = 0; i < components.length; i++) {
            var components_i = components[i];
            refLocal = [];
            localLX = this.getLocalXY(components_i);

            refLocal[0] = localLX[0] - location[0];
            refLocal[1] = localLX[1] - location[1];

            //抽稀 - 2 px
            if (pointList.length > 0) {
                var lastLocalXY = pointList[pointList.length - 1];
                if ((Math.abs(lastLocalXY[0] - refLocal[0]) <= nCPx) && (Math.abs(lastLocalXY[1] - refLocal[1]) <= nCPx)) {
                    continue;
                }
            }

            //使用参考点
            pointList.push(refLocal);
        }

        if (pointList.length < 2) {
            return null;
        }

        //赋 style
        var style = new Object();
        style = Util_Util.copyAttributesWithClip(style, this.style, ['pointList']);
        style.pointList = pointList;

        //创建图形
        var shape = new SmicBrokenLine({
            style: style,
            clickable: this.isClickAble,
            hoverable: this.isHoverAble
        });

        //设置高亮样式
        if (this.highlightStyle) {
            shape.highlightStyle = this.highlightStyle;
        }

        //设置参考中心，指定图形位置
        shape.refOriginalPosition = this.location;

        //储存数据 id 属性，用于事件
        shape.refDataID = this.data.id;

        //储存数据 id 属性，用于事件-多图形同时高亮
        shape.isHoverByRefDataID = this.isMultiHover;

        //添加到渲染器前修改 shape 的一些属性，非特殊情况通常不允许这么做
        if (this.shapeOptions) {
            Util_Util.copyAttributesWithClip(shape, this.shapeOptions);
        }

        this.shapes.push(shape);
    }


    /**
     * @function FeatureThemeVector.prototype.multiPointToTF
     * @description 转多点要素。
     * @param {Geometry} geometry - 用户数据几何地理信息，这里必须是 MultiPoint。
     */
    multiPointToTF(geometry) {
        /*   //-- 不抽稀
         var components = geometry.components;

         for(var i = 0; i < components.length; i++){
         var components_i = components[i];
         this.pointToTF(components_i);
         }
         */

        var components = geometry.components;

        //节点像素坐标
        var localLX = [];
        //参考位置，参考中心为
        var refLocal = [];
        var location = this.location;
        var pointList = [];

        //节点抽稀距离
        var nCPx = this.nodesClipPixel;

        for (var i = 0; i < components.length; i++) {
            var components_i = components[i];
            refLocal = [];
            localLX = this.getLocalXY(components_i);

            refLocal[0] = localLX[0] - location[0];
            refLocal[1] = localLX[1] - location[1];

            //抽稀
            if (pointList.length > 0) {
                var lastLocalXY = pointList[pointList.length - 1];
                if ((Math.abs(lastLocalXY[0] - refLocal[0]) <= nCPx) && (Math.abs(lastLocalXY[1] - refLocal[1]) <= nCPx)) {
                    continue;
                }
            }

            //使用参考点
            pointList.push(refLocal);

            //赋 style
            var style = new Object();
            style.r = 6; //防止漏设此参数，默认 6 像素
            style = Util_Util.copyAttributesWithClip(style, this.style);
            style.x = refLocal[0];
            style.y = refLocal[1];

            //创建图形
            var shape = new SmicPoint({
                style: style,
                clickable: this.isClickAble,
                hoverable: this.isHoverAble
            });

            //设置高亮样式
            if (this.highlightStyle) {
                shape.highlightStyle = this.highlightStyle;
            }

            //设置参考中心，指定图形位置
            shape.refOriginalPosition = location;

            //储存数据 id 属性，用于事件
            shape.refDataID = this.data.id;

            //储存数据 id 属性，用于事件-多图形同时高亮
            shape.isHoverByRefDataID = this.isMultiHover;

            //修改一些 shape 可选属性，通常不需要这么做
            if (this.shapeOptions) {
                Util_Util.copyAttributesWithClip(shape, this.shapeOptions);
            }

            this.shapes.push(shape);
        }
    }


    /**
     * @function FeatureThemeVector.prototype.multiLineStringToTF
     * @description 转换多线要素。
     * @param {Geometry} geometry - 用户数据几何地理信息，这里必须是 MultiLineString。
     */
    multiLineStringToTF(geometry) {
        var components = geometry.components;

        for (var i = 0; i < components.length; i++) {
            var components_i = components[i];
            this.lineToTF(components_i);
        }
    }


    /**
     * @function FeatureThemeVector.prototype.multiPolygonToTF
     * @description 转换多面要素。
     * @param {Geometry} geometry - 用户数据几何地理信息，这里必须是 MultiPolygon。
     */
    multiPolygonToTF(geometry) {
        var components = geometry.components;

        for (var i = 0; i < components.length; i++) {
            var components_i = components[i];
            this.polygonToTF(components_i);
        }
    }


    /**
     * @function FeatureThemeVector.prototype.pointToTF
     * @description 转换点要素。
     * @param {Geometry} geometry - 用户数据几何地理信息，这里必须是 Point。
     */
    pointToTF(geometry) {
        //参考位置，参考中心为
        var location = this.location;
        //geometry 像素坐标
        var localLX = this.getLocalXY(geometry);

        //赋 style
        var style = new Object();
        style.r = 6; //防止漏设此参数，默认 6 像素
        style = Util_Util.copyAttributesWithClip(style, this.style);
        style.x = localLX[0] - location[0];
        style.y = localLX[1] - location[1];

        //创建图形
        var shape = new SmicPoint({
            style: style,
            clickable: this.isClickAble,
            hoverable: this.isHoverAble
        });

        //设置高亮样式
        if (this.highlightStyle) {
            shape.highlightStyle = this.highlightStyle;
        }

        //设置参考中心，指定图形位置
        shape.refOriginalPosition = location;

        //储存数据 id 属性，用于事件
        shape.refDataID = this.data.id;

        //储存数据 id 属性，用于事件-多图形同时高亮
        shape.isHoverByRefDataID = this.isMultiHover;

        //修改一些 shape 可选属性，通常不需要这么做
        if (this.shapeOptions) {
            Util_Util.copyAttributesWithClip(shape, this.shapeOptions);
        }

        this.shapes.push(shape);
    }


    /**
     * @function FeatureThemeVector.prototype.polygonToThemeFeature
     * @description 转换面要素。
     * @param {Geometry} geometry - 用户数据几何地理信息，这里必须是 Polygon。
     */
    polygonToTF(geometry) {
        var components = geometry.components;


        //节点像素坐标
        var localLX = [];
        //参考位置，参考中心为
        var refLocal = [];
        var location = this.location;
        var pointList = [];
        //岛洞
        var holePolygonPointList = [];
        var holePolygonPointLists = [];

        //节点抽稀距离
        var nCPx = this.nodesClipPixel;

        for (var i = 0; i < components.length; i++) {
            var components_i = components[i].components;


            if (i === 0) {
                // 第一个 component 正常绘制
                pointList = [];

                for (var j = 0; j < components_i.length; j++) {
                    refLocal = [];
                    localLX = this.getLocalXY(components_i[j]);

                    refLocal[0] = localLX[0] - location[0];
                    refLocal[1] = localLX[1] - location[1];

                    //抽稀 - 2 px
                    if (pointList.length > 0) {
                        var lastLocalXY = pointList[pointList.length - 1];
                        if ((Math.abs(lastLocalXY[0] - refLocal[0]) <= nCPx) && (Math.abs(lastLocalXY[1] - refLocal[1]) <= nCPx)) {
                            continue;
                        }
                    }

                    //使用参考点
                    pointList.push(refLocal);
                }
            } else {
                // 其它 component 作为岛洞
                holePolygonPointList = [];

                for (var k = 0; k < components_i.length; k++) {
                    refLocal = [];
                    localLX = this.getLocalXY(components_i[k]);

                    refLocal[0] = localLX[0] - location[0];
                    refLocal[1] = localLX[1] - location[1];

                    //抽稀 - 2 px
                    if (holePolygonPointList.length > 0) {
                        var lastXY = holePolygonPointList[holePolygonPointList.length - 1];
                        if ((Math.abs(lastXY[0] - refLocal[0]) <= nCPx) && (Math.abs(lastXY[1] - refLocal[1]) <= nCPx)) {
                            continue;
                        }
                    }

                    //使用参考点
                    holePolygonPointList.push(refLocal);
                }
            }

            if (holePolygonPointList.length < 2) {
                continue;
            }

            holePolygonPointLists.push(holePolygonPointList);
        }

        if (pointList.length < 2) {
            return;
        }

        //赋 style
        var style = {};
        style = Util_Util.copyAttributesWithClip(style, this.style, ['pointList']);
        style.pointList = pointList;

        //创建图形
        var shape = new SmicPolygon({
            style: style,
            clickable: this.isClickAble,
            hoverable: this.isHoverAble
        });

        //设置高亮样式
        if (this.highlightStyle) {
            shape.highlightStyle = this.highlightStyle;
        }

        //设置参考中心，指定图形位置
        shape.refOriginalPosition = this.location;

        //储存数据 id 属性，用于事件
        shape.refDataID = this.data.id;

        //储存数据 id 属性，用于事件-多图形同时高亮
        shape.isHoverByRefDataID = this.isMultiHover;

        //岛洞面
        if (holePolygonPointLists.length > 0) {
            shape.holePolygonPointLists = holePolygonPointLists;
        }

        //修改一些 shape 可选属性，通常不需要这么做
        if (this.shapeOptions) {
            Util_Util.copyAttributesWithClip(shape, this.shapeOptions);
        }

        this.shapes.push(shape);
    }


    /**
     * @function FeatureThemeVector.prototype.rectangleToTF
     * @description 转换矩形要素。
     * @param {Geometry} geometry - 用户数据几何地理信息，这里必须是 Rectangle。
     */
    rectangleToTF(geometry) {
        //参考位置，参考中心为
        var location = this.location;
        var ll = new LonLat(geometry.x, geometry.y);

        //地图分辨率
        var res = this.layer.map.getResolution();

        //geometry 像素坐标
        var localLX = this.getLocalXY(ll);

        //赋 style
        var style = new Object();
        style.r = 6; //防止漏设此参数，默认 6 像素
        style = Util_Util.copyAttributesWithClip(style, this.style);
        style.x = localLX[0] - location[0];
        // Rectangle 使用左下角定位， SmicRectangle 使用左上角定位，需要转换
        style.y = (localLX[1] - location[1]) - 2 * geometry.width / res;
        style.width = geometry.width / res;
        style.height = geometry.height / res;

        //创建图形
        var shape = new SmicRectangle({
            style: style,
            clickable: this.isClickAble,
            hoverable: this.isHoverAble
        });

        //设置高亮样式
        if (this.highlightStyle) {
            shape.highlightStyle = this.highlightStyle;
        }

        //设置参考中心，指定图形位置
        shape.refOriginalPosition = location;

        //储存数据 id 属性，用于事件
        shape.refDataID = this.data.id;

        //储存数据 id 属性，用于事件-多图形同时高亮
        shape.isHoverByRefDataID = this.isMultiHover;

        //修改一些 shape 可选属性，通常不需要这么做
        if (this.shapeOptions) {
            Util_Util.copyAttributesWithClip(shape, this.shapeOptions);
        }

        this.shapes.push(shape);
    }


    /**
     * @function FeatureThemeVector.prototype.geoTextToTF
     * @description 转换文本要素。
     * @param {Geometry} geometry - 用户数据几何地理信息，这里必须是 GeoText。
     */
    geoTextToTF(geometry) {
        //参考位置，参考中心为
        var location = this.location;
        //geometry 像素坐标
        var localLX = this.getLocalXY(geometry);

        //赋 style
        var style = new Object();
        style.r = 6; //防止漏设此参数，默认 6 像素
        style = Util_Util.copyAttributesWithClip(style, this.style, ["x", "y", "text"]);
        style.x = localLX[0] - location[0];
        style.y = localLX[1] - location[1];
        style.text = geometry.text;

        //创建图形
        var shape = new SmicText({
            style: style,
            clickable: this.isClickAble,
            hoverable: this.isHoverAble
        });

        //设置高亮样式
        if (this.highlightStyle) {
            shape.highlightStyle = this.highlightStyle;
        }

        //设置参考中心，指定图形位置
        shape.refOriginalPosition = location;

        //储存数据 id 属性，用于事件
        shape.refDataID = this.data.id;

        //储存数据 id 属性，用于事件-多图形同时高亮
        shape.isHoverByRefDataID = this.isMultiHover;

        //修改一些 shape 可选属性，通常不需要这么做
        if (this.shapeOptions) {
            Util_Util.copyAttributesWithClip(shape, this.shapeOptions);
        }

        this.shapes.push(shape);
    }


    /**
     * @function FeatureThemeVector.prototype.updateAndAddShapes
     * @description 修改位置，针对地图平移操作，地图漫游操作后调用此函数。
     */
    updateAndAddShapes() {
        var newLocalLX = this.getLocalXY(this.lonlat);
        this.location = newLocalLX;

        var render = this.layer.renderer;
        for (var i = 0, len = this.shapes.length; i < len; i++) {
            var shape = this.shapes[i];
            //设置参考中心，指定图形位置
            shape.refOriginalPosition = newLocalLX;
            render.addShape(shape);
        }
    }


    /**
     * @function FeatureThemeVector.prototype.getShapesCount
     * @description 获得专题要素中可视化图形的数量。
     * @returns {number} 可视化图形的数量。
     */
    getShapesCount() {
        return this.shapes.length;
    }


    /**
     * @function FeatureThemeVector.prototype.getLocalXY
     * @description 地理坐标转为像素坐标。
     * @param {LonLat} lonlat - 专题要素地理位置。
     */
    getLocalXY(lonlat) {
        return this.layer.getLocalXY(lonlat);
    }

}

;// CONCATENATED MODULE: ./src/mapboxgl/overlay/theme/GeoFeatureThemeLayer.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/







/**
 * @class GeoFeatureThemeLayer
 * @category Visualization Theme
 * @modulecategory Overlay
 * @classdesc 地理几何专题要素型专题图层类。
 * @param {string} name - 图层名。
 * @param {Object} options - 参数。
 * @param {mapboxgl.Map} options.map - MapBoxGL Map 对象。
 * @param {string} [options.id] - 专题图层 ID。默认使用 CommonUtil.createUniqueID("themeLayer_") 创建专题图层 ID。
 * @param {boolean} [options.loadWhileAnimating=true] - 是否实时重绘。
 * @param {number} [options.nodesClipPixel=2] - 节点抽稀像素距离。
 * @param {boolean} [options.isHoverAble=false] - 图形是否在 hover 时高亮。
 * @param {boolean} [options.isMultiHover=false] - 是否多图形同时高亮，用于高亮同一个数据对应的所有图形（如：多面）。
 * @param {boolean} [options.isClickAble=true] - 图形是否可点击。
 * @param {boolean} [options.isAllowFeatureStyle=false] -  是否允许 feature 样式（style） 中的有效属性应用到专题图层。
 *                                        禁止对专题要素使用数据（feature）的 style。
 *                                        此属性可强制将数据 feature 的 style 中有效属性应用到专题要素上，且拥有比图层 style 和 styleGroups 更高的优先级，使专题要素的样式脱离专题图层的控制。可以通过此方式实现对特殊数据（feature） 对应专题要素赋予独立 style。
 * @param {number} [options.opacity=1] - 图层不透明度。
 * @extends {ThemeLayer}
 * @fires GeoFeatureThemeLayer#beforefeaturesadded
 * @usage
 */

class GeoFeature extends ThemeLayer_Theme {

    constructor(name, options) {
        super(name, options);
        /**
         * @member {string} GeoFeatureThemeLayer.prototype.name
         * @description 专题图图层名称。
         */
        this.name = null;
        /**
         * @member {ThemeStyle} GeoFeatureThemeLayer.prototype.style
         * @description 专题图图层全局样式。
         */
        this.style = null;

        /**
         * @member {ThemeStyle} GeoFeatureThemeLayer.prototype.highlightStyle
         * @description 专题图图层高亮样式。
         */
        this.highlightStyle = null;

        /**
         * @member {number} [GeoFeatureThemeLayer.prototype.nodesClipPixel=2]
         * @description 节点抽稀像素距离。
         */
        this.nodesClipPixel = 2;

        /**
         * @member {boolean} [GeoFeatureThemeLayer.prototype.isHoverAble=false]
         * @description 图形是否在 hover 时高亮。
         */
        this.isHoverAble = false;
        /**
         * @member {boolean} [GeoFeatureThemeLayer.prototype.isMultiHover=false]
         * @description 是否多图形同时高亮，用于高亮同一个数据对应的所有图形（如：多面）。
         */
        this.isMultiHover = false;
        /**
         * @member {boolean} [GeoFeatureThemeLayer.prototype.isClickAble=true]
         * @description  图形是否可点击。
         */
        this.isClickAble = true;

        /**
         * @member {boolean} [GeoFeatureThemeLayer.prototype.isAllowFeatureStyle=false]
         * @description  是否允许 feature 样式（style） 中的有效属性应用到专题图层。</br>
         *               禁止对专题要素使用数据（feature）的 style。此属性可强制将数据 feature 的 style 中有效属性应用到专题要素上，且拥有比图层 style 和 styleGroups 更高的优先级，使专题要素的样式脱离专题图层的控制。可以通过此方式实现对特殊数据（feature） 对应专题要素赋予独立 style。
         */
        this.isAllowFeatureStyle = false;
        Util_Util.extend(this, options);
        this.cache = options.cache || {};
        this.cacheFields = options.cacheFields || [];
        this.maxCacheCount = options.maxCacheCount || 0;
        this.isCustomSetMaxCacheCount = options.isCustomSetMaxCacheCount === undefined ? false : options.isCustomSetMaxCacheCount;

    }

    /**
     * @function GeoFeatureThemeLayer.prototype.addFeatures
     * @description 添加要素。
     * @param {ThemeFeature|ServerFeature} features - 要素对象。
     */
    addFeatures(features) {
        /**
         * @event GeoFeatureThemeLayer#beforefeaturesadded
         * @description 要素添加之前触发。
         * @property {ThemeFeature|ServerFeature} features - 被添加的要素。
         */
        external_mapboxgl_default().Evented.prototype.fire('beforefeaturesadded', {features: features});
        //转换 features 形式
        this.features = this.toiClientFeature(features);

        if (!this.isCustomSetMaxCacheCount) {
            this.maxCacheCount = this.features.length * 5;
        }
        //绘制专题要素
        if (this.renderer) {
            this.redrawThematicFeatures(this.map.getBounds());
        }
    }

    /**
     * @function GeoFeatureThemeLayer.prototype.removeFeatures
     * @description 从专题图中删除 feature。这个函数删除所有传递进来的矢量要素。
     * @param {(FeatureVector|Function)} features - 要删除的要素对象或用于过滤的回调函数。
     */
    removeFeatures(features) {
        this.clearCache();
        ThemeLayer_Theme.prototype.removeFeatures.call(this, features);
    }

    /**
     * @function GeoFeatureThemeLayer.prototype.removeAllFeatures
     * @description 清除当前图层所有的矢量要素。
     */
    removeAllFeatures() {
        this.clearCache();
        ThemeLayer_Theme.prototype.removeAllFeatures.apply(this, arguments);
    }

    /**
     * @function GeoFeatureThemeLayer.prototype.redrawThematicFeatures
     * @description 重绘所有专题要素。
     * @param {mapboxgl.LngLatBounds} extent - 重绘的范围。
     */
    redrawThematicFeatures(extent) { // eslint-disable-line no-unused-vars
        this.clearCache();
        //获取高亮专题要素对应的用户 id
        var hoverone = this.renderer.getHoverOne();
        var hoverFid = null;
        if (hoverone && hoverone.refDataID) {
            hoverFid = hoverone.refDataID;
        }
        //清除当前所有可视元素
        this.renderer.clearAll();

        var features = this.features;
        var cache = this.cache;
        var cacheFields = this.cacheFields;
        var cmZoom = this.map.getZoom();

        var maxCC = this.maxCacheCount;

        for (var i = 0, len = features.length; i < len; i++) {
            var feature = features[i];
            // var feaBounds = feature.geometry.getBounds();
            //
            // //剔除当前视图（地理）范围以外的数据
            // if (extent) {
            //     var bounds = new Bounds(extent.getWest(), extent.getSouth(), extent.getEast(), extent.getNorth());
            //     // if (!bounds.intersectsBounds(feaBounds)) continue;
            // }

            //缓存字段
            var fields = feature.id + "_zoom_" + cmZoom.toString();

            var thematicFeature;

            //判断专题要素缓存是否存在
            if (cache[fields]) {
                cache[fields].updateAndAddShapes();
            } else {
                //如果专题要素缓存不存在，创建专题要素
                thematicFeature = this.createThematicFeature(features[i]);

                //检查 thematicFeature 是否有可视化图形
                if (thematicFeature.getShapesCount() < 1) {
                    continue;
                }

                //加入缓存
                cache[fields] = thematicFeature;
                cacheFields.push(fields);

                //缓存数量限制
                if (cacheFields.length > maxCC) {
                    var fieldsTemp = cacheFields[0];
                    cacheFields.splice(0, 1);
                    delete cache[fieldsTemp];
                }
            }

        }
        this.renderer.render();

        //地图漫游后，重新高亮图形
        if (hoverFid && this.isHoverAble && this.isMultiHover) {
            var hShapes = this.getShapesByFeatureID(hoverFid);
            this.renderer.updateHoverShapes(hShapes);
        }
    }

    /**
     * @function GeoFeatureThemeLayer.prototype.createThematicFeature
     * @description 创建专题要素。
     * @param {FeatureVector} feature - 要素对象。
     * @returns {Array.<FeatureVector>} 返回矢量要素。
     */
    createThematicFeature(feature) {
        var style = Util_Util.copyAttributesWithClip(this.style);
        if (feature.style && this.isAllowFeatureStyle === true) {
            style = Util_Util.copyAttributesWithClip(feature.style);
        }
        //创建专题要素时的可选参数
        var options = {};
        options.nodesClipPixel = this.nodesClipPixel;
        options.isHoverAble = this.isHoverAble;
        options.isMultiHover = this.isMultiHover;
        options.isClickAble = this.isClickAble;
        options.highlightStyle = ShapeFactory.transformStyle(this.highlightStyle);
        //将数据转为专题要素（Vector）
        var thematicFeature = new ThemeVector(feature, this, ShapeFactory.transformStyle(style), options);
        //直接添加图形到渲染器
        for (var m = 0; m < thematicFeature.shapes.length; m++) {
            this.renderer.addShape(thematicFeature.shapes[m]);
        }
        return thematicFeature;
    }

    /**
     * @function GeoFeatureThemeLayer.prototype.clearCache
     * @description 清除缓存。
     */
    clearCache() {
        this.cache = {};
        this.cacheFields = [];
    }

    /**
     * @function GeoFeatureThemeLayer.prototype.clear
     * @description  清除的内容包括数据（features）、专题要素和缓存。
     */
    clear() {
        this.renderer.clearAll();
        this.renderer.refresh();
        this.removeAllFeatures();
        this.clearCache();
    }

    /**
     * @function GeoFeatureThemeLayer.prototype.getCacheCount
     * @description 获取当前缓存数量。
     * @returns {number} 当前缓存数量。
     */
    getCacheCount() {
        return this.cacheFields.length;
    }

    /**
     * @function GeoFeatureThemeLayer.prototype.setMaxCacheCount
     * @param {number} [cacheCount] - 缓存总数。
     * @description 设置最大缓存条数。
     */
    setMaxCacheCount(cacheCount) {
        if (!isNaN(cacheCount)) {
            this.maxCacheCount = cacheCount;
            this.isCustomSetMaxCacheCount = true;
        }
    }

    /**
     * @function GeoFeatureThemeLayer.prototype.getShapesByFeatureID
     * @param {number} [featureID=si.refDataID] - 要素 ID。
     * @description 通过 FeatureID 获取 feature 关联的所有图形。如果不传入此参数，函数将返回所有图形。
     * @returns {Array} 返回图形数组。
     */
    getShapesByFeatureID(featureID) {
        var list = [];
        var shapeList = this.renderer.getAllShapes();
        if (!featureID) {
            return shapeList
        }
        for (var i = 0, len = shapeList.length; i < len; i++) {
            var si = shapeList[i];
            if (si.refDataID && featureID === si.refDataID) {
                list.push(si);
            }
        }
        return list;
    }

}

;// CONCATENATED MODULE: ./src/mapboxgl/overlay/LabelThemeLayer.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/










/**
 * @class LabelThemeLayer
 * @category  Visualization Theme
 * @classdesc  标签专题图层类。
 * @modulecategory Overlay
 * @param {string} name - 图层名。
 * @param {Object} options - 参数。
 * @param {mapboxgl.Map} options.map - MapBoxGL Map 对象。
 * @param {string} options.themeField - 指定创建专题图字段。
 * @param {Object} options.style - 专题图样式。
 * @param {Object} options.styleGroups - 各专题类型样式组。
 * @param {Object} [options.highlightStyle] - hover 的高亮样式。
 * @param {string} [options.id] - 专题图层 ID。专题图层 ID。默认使用 CommonUtil.createUniqueID("themeLayer_") 创建专题图层 ID。
 * @param {boolean} [options.loadWhileAnimating=true] - 是否实时重绘。
 * @param {number} [options.opacity=1] - 图层不透明度。
 * @param {boolean} [options.isAvoid=true] - 是否进行地图边缘的避让处理。
 * @param {boolean} [options.isOverLay=true] - 是否进行压盖处理，如果设为 true，图表绘制过程中将隐藏对已在图层中绘制的图表产生压盖的图表。
 * @param {boolean} [options.isHoverAble] - 是否开启 hover 事件。
 * @extends {GeoFeatureThemeLayer}
 * @usage
 */
class LabelThemeLayer_Label extends GeoFeature {

    constructor(name, options) {
        super(name, options);
        /**
         * @member {boolean} [LabelThemeLayer.prototype.isOverLay=true]
         * @description 是否进行压盖处理，如果设为 true，将隐藏被压盖的标签。
         */
        this.isOverLay = true;
        /**
         * @member {boolean} [LabelThemeLayer.prototype.isAvoid=true]
         * @description 是否进行地图边缘的避让处理，如果设为 true，将把与地图边缘相交的标签移到地图范围内，在地图边缘处做避让处理。
         */
        this.isAvoid = true;

        /**
         * @member {string} LabelThemeLayer.prototype.themeField
         * @description  用于指定专题要素样式的属性字段名称。</br>
         *               此属性字段是要用户数据（feature） attributes 中包含的字段，且字段对应的值的类型必须是数值型。</br>
         *               使用标签分组显示还需要设置 styleGroups 属性。
         */
        this.themeField = null;

        /**
         * @member {Array.<Object>} LabelThemeLayer.prototype.styleGroups
         * @description 分组样式。使用此属性需要设置 themeField 属性。</br>
         *              1.没有同时设置 themeField 和 styleGroups，则所有专题要素都使用本图层的 style 进行渲染；</br>
         *              2.同时设置 themeField 和 styleGroups，则按照 themeField 指定的字段名称获取用户数据（feature）attributes 中对应的属性值；</br>
         *               &nbsp;&nbsp;a.如果属性值等于 styleGroups 数组里某个元素定义的 value 值，则此专题要素取 styleGroups 数组中该元素定义的 style 进行渲染。</br>
         *               &nbsp;&nbsp;b.如果属性值不等于 styleGroups 数组里任何元素定义的 value 值，则此专题要素按照本图层的 style 进行渲染。</br>
         *              此数组每个元素对象必须有两个属性：value : 与字段 themeField 相对应的属性值；style：专题要素 style。
         */
        this.styleGroups = null;

        Util_Util.extend(this, options);
        this.defaultStyle = {
            //默认文本样式
            fontColor: "#000000",
            fontOpacity: 1,
            fontSize: "12px",
            fontStyle: "normal",
            fontWeight: "normal",
            labelAlign: "cm",
            labelXOffset: 0,
            labelYOffset: 0,
            labelRotation: 0,

            //默认样式
            fill: false,
            fillColor: "#ee9900",
            fillOpacity: 0.4,
            stroke: false,
            strokeColor: "#ee9900",
            strokeOpacity: 1,
            strokeWidth: 1,
            strokeLinecap: "round",
            strokeDashstyle: "solid",

            //默认显示背景框
            labelRect: true,
            //对用户隐藏但必须保持此值的属性
            //cursor: "pointer",
            labelSelect: true,

            //用  _isGeoTextStrategyStyle 标记此style，携带此类style的要素特指GeoText策略中的标签要素
            _isGeoTextStrategyStyle: true
        };
        //获取标签像素 bounds 的方式。0 - 表示通过文本类容和文本风格计算获取像素范围，现在支持中文、英文; 1 - 表示通过绘制的文本标签获取像素范围，支持各个语种的文字范围获取，但性能消耗较大（尤其是采用SVG渲染）。默认值为0。
        this.getPxBoundsMode = 0;

        this.labelFeatures = [];
    }


    /**
     * @function LabelThemeLayer.prototype.redrawThematicFeatures
     * @description 重绘所有专题要素。</br>
     *              此方法包含绘制专题要素的所有步骤，包含用户数据到专题要素的转换，抽稀，缓存等步骤。</br>
     *              地图漫游时调用此方法进行图层刷新。
     * @param {mapboxgl.LngLatBounds} bounds - 重绘范围。
     */
    redrawThematicFeatures(bounds) {
        if (this.features.length > 0 && this.labelFeatures.length == 0) {
            var feats = this.setLabelsStyle(this.features);
            for (var i = 0, len = feats.length; i < len; i++) {
                this.labelFeatures.push(feats[i]);
            }
        }
        this.features = this.getDrawnLabels(this.labelFeatures);
        super.redrawThematicFeatures.call(this, bounds);
    }
    /**
     * @function LabelThemeLayer.prototype.removeFeatures
     * @description 从专题图中删除 feature。这个函数删除所有传递进来的矢量要素。
     * @param {(Array.<FeatureVector>|FeatureVector|Function)} features - 要删除的要素对象或用于过滤的回调函数。
     */
    removeFeatures(features) {
        this.labelFeatures = [];
        super.removeFeatures.call(this, features);
    }

    /**
     * @function LabelThemeLayer.prototype.removeAllFeatures
     * @description 清除当前图层所有的矢量要素。
     */
    removeAllFeatures() {
        this.labelFeatures = [];
        super.removeAllFeatures.call(this, arguments);
    }

    /**
     * @function LabelThemeLayer.prototype.createThematicFeature
     * @description 创建专题图要素。
     * @param {Object} feature - 要创建的专题图形要素。
     */
    createThematicFeature(feature) {
        //赋 style
        var style = this.getStyleByData(feature);
        //创建专题要素时的可选参数
        var options = {};
        options.nodesClipPixel = this.nodesClipPixel;
        options.isHoverAble = this.isHoverAble;
        options.isMultiHover = this.isMultiHover;
        options.isClickAble = this.isClickAble;
        options.highlightStyle = ShapeFactory.transformStyle(this.highlightStyle);

        //将数据转为专题要素（Vector）
        var thematicFeature = new ThemeVector(feature, this, ShapeFactory.transformStyle(style), options);

        //直接添加图形到渲染器
        for (var m = 0; m < thematicFeature.shapes.length; m++) {
            this.renderer.addShape(thematicFeature.shapes[m]);
        }

        return thematicFeature;
    }


    /**
     * @function LabelThemeLayer.prototype.getDrawnLabels
     * @description 获取经（压盖）处理后将要绘制在图层上的标签要素。
     * @param {Array.<FeatureVector>} labelFeatures - 所有标签要素的数组。
     * @returns {Array.<FeatureVector>} 最终要绘制的标签要素数组。
     */
    getDrawnLabels(labelFeatures) {
        var feas = [], //最终要绘制的标签要素集
            fea, //最终要绘制的标签要素
            fi, //临时标签要素，用户的第i个标签
            labelsB = [], //不产生压盖的标签要素范围集
            styTmp, //用于临时存储要素style的变量
            feaSty, //标签要素最终的style
            // styleTemp用于屏蔽文本style中带有偏移性质style属性，偏移已经在计算bounds的过程中参与了运算，
            // 所以在最终按照bounds来绘制标签时，需屏蔽style中带有偏移性质属性，否则文本的偏移量将扩大一倍。
            styleTemp = {
                labelAlign: "cm",
                labelXOffset: 0,
                labelYOffset: 0
            };

        var map = this.map;
        var zoom = map.getZoom();
        var canvas = map.getCanvas();
        var mapSize = {
            x: parseFloat(canvas.style.width),
            y: parseFloat(canvas.style.height)
        };
        //对用户的每个标签要素进行处理与判断
        for (var i = 0, len = labelFeatures.length; i < len; i++) {
            fi = labelFeatures[i];
            //检查fi的style在避让中是否被改变，如果改变，重新设置要素的style
            if (fi.isStyleChange || fi.isStyleChange === undefined) {
                fi = this.setStyle(fi);
            }

            //标签最终的中心点像素位置 （偏移后）
            var loc = this.getLabelPxLocation(fi);

            //过滤掉地图范围外的标签 （偏移后）
            if ((loc.x >= 0 && loc.x <= mapSize.x) && (loc.y >= 0 && loc.y <= mapSize.y)) {
                //根据当前地图缩放级别过滤标签
                if (fi.style.minZoomLevel > -1) {
                    if (zoom <= fi.style.minZoomLevel) {
                        continue;
                    }
                }
                if (fi.style.maxZoomLevel > -1) {
                    if (zoom > fi.style.maxZoomLevel) {
                        continue;
                    }
                }

                //计算标签bounds
                var boundsQuad = null;
                if (fi.isStyleChange) {
                    fi.isStyleChange = null;
                    boundsQuad = this.calculateLabelBounds(fi, loc);
                } else {
                    if (fi.geometry.bsInfo.w && fi.geometry.bsInfo.h) {
                        //使用calculateLabelBounds2可以提高bounds的计算效率，尤其是在getPxBoundsMode = 1时
                        boundsQuad = this.calculateLabelBounds2(fi, loc);
                    } else {
                        boundsQuad = this.calculateLabelBounds(fi, loc);
                    }
                }

                //避让处理 -start
                var mapViewBounds = new Bounds(0, mapSize.y, mapSize.x, 0), //地图像素范围
                    quadlen = boundsQuad.length;

                if (this.isAvoid) {
                    var avoidInfo = this.getAvoidInfo(mapViewBounds, boundsQuad); //避让信息

                    if (avoidInfo) {
                        //横向（x方向）上的避让
                        if (avoidInfo.aspectW === "left") {
                            fi.style.labelXOffset += avoidInfo.offsetX;

                            for (let j = 0; j < quadlen; j++) {
                                boundsQuad[j].x += avoidInfo.offsetX;
                            }
                        } else if (avoidInfo.aspectW === "right") {
                            fi.style.labelXOffset += (-avoidInfo.offsetX);

                            for (let j = 0; j < quadlen; j++) {
                                boundsQuad[j].x += (-avoidInfo.offsetX);
                            }
                        }

                        //纵向（y方向）上的避让
                        if (avoidInfo.aspectH === "top") {
                            fi.style.labelYOffset += avoidInfo.offsetY;

                            for (let j = 0; j < quadlen; j++) {
                                boundsQuad[j].y += avoidInfo.offsetY;
                            }
                        } else if (avoidInfo.aspectH === "bottom") {
                            fi.style.labelYOffset += (-avoidInfo.offsetY);

                            for (let j = 0; j < quadlen; j++) {
                                boundsQuad[j].y += (-avoidInfo.offsetY);
                            }
                        }

                        //如果style发生变化，记录下来
                        fi.isStyleChange = true;
                    }
                }
                //避让处理 -end

                //压盖处理 -start
                if (this.isOverLay) {
                    //是否压盖
                    var isOL = false;

                    if (i != 0) {
                        for (let j = 0; j < labelsB.length; j++) {
                            //压盖判断
                            if (this.isQuadrilateralOverLap(boundsQuad, labelsB[j])) {
                                isOL = true;
                                break;
                            }
                        }
                    }

                    if (isOL) {
                        continue;
                    } else {
                        labelsB.push(boundsQuad);
                    }
                }
                //压盖处理 -end

                //背景（事件）-start

                //将标签像素范围转为地理范围
                var geoBs = [];
                for (let j = 0; j < quadlen - 1; j++) {
                    geoBs.push(map.unproject(boundsQuad[j]));
                }

                //屏蔽有偏移性质的style属性,偏移量在算bounds时已经加入计算
                var leftBottom = geoBs[3];
                var rightTop = geoBs[1];
                var bounds = new Bounds(leftBottom.lng, leftBottom.lat, rightTop.lng, rightTop.lat);
                var center = bounds.getCenterLonLat();
                var label = new GeoText(center.lon, center.lat, fi.attributes[this.themeField]);
                label.calculateBounds();
                styTmp = Util_Util.cloneObject(fi.style);
                feaSty = Util_Util.cloneObject(Util_Util.copyAttributes(styTmp, styleTemp));
                fea = new Vector(label, fi.attributes, feaSty);
                //赋予id
                fea.id = fi.id;
                fea.fid = fi.fid;
                feas.push(fea);
            }
        }

        //返回最终要绘制的标签要素
        return feas;
    }


    /**
     * @function LabelThemeLayer.prototype.getStyleByData
     * @description 根据用户数据（feature）设置专题要素的 Style。
     * @param {FeatureVector} feat - 矢量要素对象。
     * @returns {Array.<ThemeStyle>} 专题要素的 Style。
     */
    getStyleByData(feat) {
        var feature = feat;
        feature.style = Util_Util.copyAttributes(feature.style, this.defaultStyle);
        //将style赋给标签
        if (this.style && this.style.fontSize && parseFloat(this.style.fontSize) < 12) {
            this.style.fontSize = "12px";
        }
        feature.style = Util_Util.copyAttributes(feature.style, this.style);

        if (this.themeField && this.styleGroups && feature.attributes) {
            var Sf = this.themeField;
            var attributes = feature.attributes;
            var groups = this.styleGroups;
            var isSfInAttrs = false; //指定的 groupField 是否是geotext的属性字段之一
            var attr = null; //属性值

            for (var property in attributes) {
                if (Sf === property) {
                    isSfInAttrs = true;
                    attr = attributes[property];
                    break;
                }
            }

            //判断属性值是否属于styleGroups的某一个范围，以便对标签分组
            if (isSfInAttrs) {
                for (var i = 0, len = groups.length; i < len; i++) {
                    if ((attr >= groups[i].start) && (attr < groups[i].end)) {
                        var sty1 = groups[i].style;
                        if (sty1 && sty1.fontSize && parseFloat(sty1.fontSize) < 12) {
                            sty1.fontSize = "12px";
                        }
                        feature.style = Util_Util.copyAttributes(feature.style, sty1);
                    }
                }
            }
            feature.style.label = feature.attributes[this.themeField]
        }


        return feature.style;
    }

    /**
     * @function LabelThemeLayer.prototype.setLabelsStyle
     * @description 设置标签要素的 Style。
     * @param {Array.<FeatureVector>} labelFeatures - 需要设置 Style 的标签要素数组。
     * @returns {Array.<FeatureVector>} 赋予 Style 后的标签要素数组。
     */
    setLabelsStyle(labelFeatures) {
        var fea, labelFeas = [];
        for (var i = 0, len = labelFeatures.length; i < len; i++) {
            var feature = labelFeatures[i];
            if (feature.geometry.CLASS_NAME === "SuperMap.Geometry.GeoText") {
                //设置标签的Style
                if (feature.geometry.bsInfo.w || feature.geometry.bsInfo.h) {
                    feature.geometry.bsInfo.w = null;
                    feature.geometry.bsInfo.h = null;
                    feature.geometry.labelWTmp = null;
                }
                fea = this.setStyle(feature);
                //为标签要素指定图层
                fea.layer = this.layer;
                labelFeas.push(fea);
            } else {
                return labelFeatures;
            }
        }
        return labelFeas;
    }

    /**
     * @function LabelThemeLayer.prototype.setStyle
     * @description 设置标签要素的Style。
     * @param {FeatureVector} feat - 需要赋予 style 的要素。
     */
    setStyle(feat) {
        var feature = feat;
        feature.style = Util_Util.copyAttributes(feature.style, this.defaultStyle);
        //将style赋给标签
        if (this.style && this.style.fontSize && parseFloat(this.style.fontSize) < 12) {
            this.style.fontSize = "12px";
        }
        feature.style = Util_Util.copyAttributes(feature.style, this.style);

        if (this.groupField && this.styleGroups && feature.attributes) {
            var Sf = this.groupField;
            var Attrs = feature.attributes;
            var Gro = this.styleGroups;
            var isSfInAttrs = false; //指定的 groupField 是否是geotext的属性字段之一
            var attr = null; //属性值

            for (var property in Attrs) {
                if (Sf === property) {
                    isSfInAttrs = true;
                    attr = Attrs[property];
                    break;
                }
            }

            //判断属性值是否属于styleGroups的某一个范围，以便对标签分组
            if (isSfInAttrs) {
                for (var i = 0, len = Gro.length; i < len; i++) {
                    if ((attr >= Gro[i].start) && (attr < Gro[i].end)) {
                        //feature.style = Util.copyAttributes(feature.style, this.defaultStyle);
                        var sty1 = Gro[i].style;
                        if (sty1 && sty1.fontSize && parseFloat(sty1.fontSize) < 12) {
                            sty1.fontSize = "12px";
                        }
                        feature.style = Util_Util.copyAttributes(feature.style, sty1);
                    }
                }
            }
        }

        //将文本内容赋到标签要素的style上
        feature.style.label = feature.geometry.text;

        return feature;
    }

    /**
     * @function LabelThemeLayer.prototype.getLabelPxLocation
     * @description 获取标签要素的像素坐标。
     * @param {FeatureVector} feature - 标签要素。
     * @returns {mapboxgl.Point} 标签位置。
     */
    getLabelPxLocation(feature) {
        var geoText = feature.geometry;
        var styleTmp = feature.style;

        //将标签的地理位置转为像素位置
        var locationTmp = geoText.getCentroid();
        var locTmp = this.map.project(new (external_mapboxgl_default()).LngLat(locationTmp.x, locationTmp.y));
        var loc = new (external_mapboxgl_default()).Point(locTmp.x, locTmp.y);

        //偏移处理
        if (styleTmp.labelXOffset || styleTmp.labelYOffset) {
            var xOffset = isNaN(styleTmp.labelXOffset) ? 0 : styleTmp.labelXOffset;
            var yOffset = isNaN(styleTmp.labelYOffset) ? 0 : styleTmp.labelYOffset;
            var point = loc.add(new (external_mapboxgl_default()).Point(xOffset, -yOffset));
            return new (external_mapboxgl_default()).Point(point.x, point.y);
        } else {
            return new (external_mapboxgl_default()).Point(loc.x, loc.y);
        }
    }


    /**
     * @function LabelThemeLayer.prototype.calculateLabelBounds
     * @description 获得标签要素的最终范围。
     *
     * @param {FeatureVector} feature - 需要计算 bounds 的标签要素数。
     * @param {mapboxgl.Point} loc - 标签位置。
     *
     * @returns {Array.<Object>}  四边形节点数组。例如：[{"x":1,"y":1},{"x":3,"y":1},{"x":6,"y":4},{"x":2,"y":10},{"x":1,"y":1}]。
     */
    calculateLabelBounds(feature, loc) {
        var geoText = feature.geometry;

        //标签范围（未旋转前）
        var labB = null;
        var labelInfo = null;
        //获取bounds的方式
        if (this.getPxBoundsMode == 0) {
            labB = geoText.getLabelPxBoundsByText(loc, feature.style);
        } else if (this.getPxBoundsMode === 1) {
            //canvas
            labelInfo = this.getLabelInfo(feature.geometry.getCentroid(), feature.style);
            labB = geoText.getLabelPxBoundsByLabel(loc, labelInfo.w, labelInfo.h, feature.style);
        } else {
            return null;
        }

        //旋转Bounds
        var boundsQuad = [];
        if ((feature.style.labelRotation % 180) == 0) {
            boundsQuad = [{
                    "x": labB.left,
                    "y": labB.top
                },
                {
                    "x": labB.right,
                    "y": labB.top
                },
                {
                    "x": labB.right,
                    "y": labB.bottom
                },
                {
                    "x": labB.left,
                    "y": labB.bottom
                },
                {
                    "x": labB.left,
                    "y": labB.top
                }
            ];
        } else {
            boundsQuad = this.rotationBounds(labB, loc, feature.style.labelRotation);
        }

        //重置GeoText的bounds
        geoText.bounds = new Bounds(boundsQuad[1].x, boundsQuad[3].y, boundsQuad[2].x, boundsQuad[4].y);
        return boundsQuad;
    }

    /**
     * @function LabelThemeLayer.prototype.calculateLabelBounds2
     * @description 获得标签要素的最终范围的另一种算法（通过记录下的标签宽高），提高计算 bounds 的效率。
     *
     * @param {FeatureVector} feature - 需要计算 bounds 的标签要素数。
     * @param {mapboxgl.Point} loc - 标签位置。
     *
     * @returns {Array.<Object>}  四边形节点数组。例如：[{"x":1,"y":1},{"x":3,"y":1},{"x":6,"y":4},{"x":2,"y":10},{"x":1,"y":1}]。
     */
    calculateLabelBounds2(feature, loc) {
        var labB, left, bottom, top, right;
        var labelSize = feature.geometry.bsInfo;
        var style = feature.style;
        var locationPx = Util_Util.cloneObject(loc);

        //处理文字对齐
        if (style.labelAlign && style.labelAlign !== "cm") {
            switch (style.labelAlign) {
                case "lt":
                    locationPx.x += labelSize.w / 2;
                    locationPx.y += labelSize.h / 2;
                    break;
                case "lm":
                    locationPx.x += labelSize.w / 2;
                    break;
                case "lb":
                    locationPx.x += labelSize.w / 2;
                    locationPx.y -= labelSize.h / 2;
                    break;
                case "ct":
                    locationPx.y += labelSize.h / 2;
                    break;
                case "cb":
                    locationPx.y -= labelSize.h / 2;
                    break;
                case "rt":
                    locationPx.x -= labelSize.w / 2;
                    locationPx.y += labelSize.h / 2;
                    break;
                case "rm":
                    locationPx.x -= labelSize.w / 2;
                    break;
                case "rb":
                    locationPx.x -= labelSize.w / 2;
                    locationPx.y -= labelSize.h / 2;
                    break;
                default:
                    break;
            }
        }

        left = locationPx.x - labelSize.w / 2;
        bottom = locationPx.y + labelSize.h / 2;
        //处理斜体字
        if (style.fontStyle && style.fontStyle === "italic") {
            right = locationPx.x + labelSize.w / 2 + parseInt(parseFloat(style.fontSize) / 2);
        } else {
            right = locationPx.x + labelSize.w / 2;
        }
        top = locationPx.y - labelSize.h / 2;

        labB = new Bounds(left, bottom, right, top);

        //旋转Bounds
        var boundsQuad = [];
        if ((style.labelRotation % 180) == 0) {
            boundsQuad = [{
                    "x": labB.left,
                    "y": labB.top
                },
                {
                    "x": labB.right,
                    "y": labB.top
                },
                {
                    "x": labB.right,
                    "y": labB.bottom
                },
                {
                    "x": labB.left,
                    "y": labB.bottom
                },
                {
                    "x": labB.left,
                    "y": labB.top
                }
            ];
        } else {
            boundsQuad = this.rotationBounds(labB, loc, style.labelRotation);
        }

        //重置GeoText的bounds
        feature.geometry.bounds = new Bounds(boundsQuad[1].x, boundsQuad[3].y, boundsQuad[2].x, boundsQuad[4].y);
        return boundsQuad;
    }

    /**
     * @function LabelThemeLayer.prototype.getLabelInfo
     * @description 根据当前位置获取绘制后的标签信息，包括标签的宽，高和行数等。
     * @returns {Object} 绘制后的标签信息。
     */
    getLabelInfo(location, style) {
        var LABEL_ALIGN = {
                "l": "left",
                "r": "right",
                "t": "top",
                "b": "bottom"
            },
            LABEL_FACTOR = {
                "l": 0,
                "r": -1,
                "t": 0,
                "b": -1
            };

        style = Util_Util.extend({
            fontColor: "#000000",
            labelAlign: "cm"
        }, style);
        var pt = this.getLocalXY(location);
        var labelWidth = 0;

        if (style.labelXOffset || style.labelYOffset) {
            var xOffset = isNaN(style.labelXOffset) ? 0 : style.labelXOffset;
            var yOffset = isNaN(style.labelYOffset) ? 0 : style.labelYOffset;
            pt[0] += xOffset;
            pt[1] -= yOffset;
        }

        var canvas = document.createElement('canvas');
        canvas.globalAlpha = 0;
        canvas.lineWidth = 1;

        var ctx = canvas.getContext("2d");

        ctx.fillStyle = style.fontColor;
        ctx.globalAlpha = style.fontOpacity || 1.0;
        var fontStyle = [style.fontStyle ? style.fontStyle : "normal",
            "normal",
            style.fontWeight ? style.fontWeight : "normal",
            style.fontSize ? style.fontSize : "1em",
            style.fontFamily ? style.fontFamily : "sans-serif"
        ].join(" ");
        var labelRows = style.label.split('\n');
        var numRows = labelRows.length;
        var vfactor, lineHeight, labelWidthTmp;
        if (ctx.fillText) {
            // HTML5
            ctx.font = fontStyle;
            ctx.textAlign = LABEL_ALIGN[style.labelAlign[0]] ||
                "center";
            ctx.textBaseline = LABEL_ALIGN[style.labelAlign[1]] ||
                "middle";
            vfactor = LABEL_FACTOR[style.labelAlign[1]];
            if (vfactor == null) {
                vfactor = -.5;
            }
            lineHeight = ctx.measureText('Mg').height ||
                ctx.measureText('xx').width;
            pt[1] += lineHeight * vfactor * (numRows - 1);
            for (let i = 0; i < numRows; i++) {
                labelWidthTmp = ctx.measureText(labelRows[i]).width;
                if (labelWidth < labelWidthTmp) {
                    labelWidth = labelWidthTmp;
                }
            }
        } else if (ctx.mozDrawText) {
            // Mozilla pre-Gecko1.9.1 (<FF3.1)
            ctx.mozTextStyle = fontStyle;
            vfactor = LABEL_FACTOR[style.labelAlign[1]];
            if (vfactor == null) {
                vfactor = -.5;
            }
            lineHeight = ctx.mozMeasureText('xx');
            pt[1] += lineHeight * (1 + (vfactor * numRows));
            for (let i = 0; i < numRows; i++) {
                labelWidthTmp = ctx.measureText(labelRows[i]).width;
                if (labelWidth < labelWidthTmp) {
                    labelWidth = labelWidthTmp;
                }
            }
        }
        var labelInfo = {}; //标签信息
        if (labelWidth) {
            labelInfo.w = labelWidth; //标签的宽
        } else {
            return null;
        }

        labelInfo.h = style.fontSize; //一行标签的高
        labelInfo.rows = labelRows.length; //标签的行数

        return labelInfo;
    }

    /**
     * @function LabelThemeLayer.prototype.rotationBounds
     * @description 旋转 bounds。
     *
     * @param {Bounds} bounds - 要旋转的 bounds。
     * @param {Object} rotationCenterPoi - 旋转中心点对象，此对象含有属性X（横坐标），属性Y（纵坐标）。
     * @param {number} angle - 旋转角度（顺时针）。
     *
     * @returns {Array.<Object>} bounds 旋转后形成的多边形节点数组。是一个四边形，形如：[{"x":1,"y":1},{"x":3,"y":1},{"x":6,"y":4},{"x":2,"y":10},{"x":1,"y":1}]
     */
    rotationBounds(bounds, rotationCenterPoi, angle) {
        var ltPoi = new (external_mapboxgl_default()).Point(bounds.left, bounds.top);
        var rtPoi = new (external_mapboxgl_default()).Point(bounds.right, bounds.top);
        var rbPoi = new (external_mapboxgl_default()).Point(bounds.right, bounds.bottom);
        var lbPoi = new (external_mapboxgl_default()).Point(bounds.left, bounds.bottom);

        var ver = [];
        ver.push(this.getRotatedLocation(ltPoi.x, ltPoi.y, rotationCenterPoi.x, rotationCenterPoi.y, angle));
        ver.push(this.getRotatedLocation(rtPoi.x, rtPoi.y, rotationCenterPoi.x, rotationCenterPoi.y, angle));
        ver.push(this.getRotatedLocation(rbPoi.x, rbPoi.y, rotationCenterPoi.x, rotationCenterPoi.y, angle));
        ver.push(this.getRotatedLocation(lbPoi.x, lbPoi.y, rotationCenterPoi.x, rotationCenterPoi.y, angle));

        //bounds旋转后形成的多边形节点数组
        var quad = [];

        for (var i = 0; i < ver.length; i++) {
            quad.push({
                "x": ver[i].x,
                "y": ver[i].y
            });
        }
        quad.push({
            "x": ver[0].x,
            "y": ver[0].y
        });
        return quad;
    }

    /**
     * @function LabelThemeLayer.prototype.getRotatedLocation
     * @description 获取一个点绕旋转中心顺时针旋转后的位置（此方法用于屏幕坐标）。
     *
     * @param {number} x - 旋转点横坐标。
     * @param {number} y - 旋转点纵坐标。
     * @param {number} rx - 旋转中心点横坐标。
     * @param {number} ry - 旋转中心点纵坐标。
     * @param {number} angle - 旋转角度。
     *
     * @returns {Object} 旋转后的坐标位置对象，该对象含有属性X（横坐标），属性Y（纵坐标）。
     */
    getRotatedLocation(x, y, rx, ry, angle) {
        var loc = {},
            x0, y0;

        y = -y;
        ry = -ry;
        angle = -angle; //顺时针旋转
        x0 = (x - rx) * Math.cos((angle / 180) * Math.PI) - (y - ry) * Math.sin((angle / 180) * Math.PI) + rx;
        y0 = (x - rx) * Math.sin((angle / 180) * Math.PI) + (y - ry) * Math.cos((angle / 180) * Math.PI) + ry;

        loc.x = x0;
        loc.y = -y0;

        return loc;
    }

    /**
     * @function LabelThemeLayer.prototype.getAvoidInfo
     * @description 获取避让的信息。
     *
     * @param {Bounds} bounds - 地图像素范围。
     * @param {Array.<Object>} quadrilateral - 四边形节点数组。例如：[{"x":1,"y":1},{"x":3,"y":1},{"x":6,"y":4},{"x":2,"y":10},{"x":1,"y":1}]。
     *
     * @returns {Object} 避让的信息。
     */
    getAvoidInfo(bounds, quadrilateral) {
        if (quadrilateral.length !== 5) {
            return null;
        } //不是四边形

        //将bound序列化为点数组形式
        var bounddQuad = [{
                "x": bounds.left,
                "y": bounds.top
            },
            {
                "x": bounds.right,
                "y": bounds.top
            },
            {
                "x": bounds.right,
                "y": bounds.bottom
            },
            {
                "x": bounds.left,
                "y": bounds.bottom
            },
            {
                "x": bounds.left,
                "y": bounds.top
            }
        ];

        var isIntersection = false,
            bqLen = bounddQuad.length,
            quadLen = quadrilateral.length;

        var offsetX = 0,
            offsetY = 0,
            aspectH = "",
            aspectW = "";
        for (var i = 0; i < bqLen - 1; i++) {
            for (var j = 0; j < quadLen - 1; j++) {
                var isLineIn = Util_Util.lineIntersection(bounddQuad[i], bounddQuad[i + 1], quadrilateral[j], quadrilateral[j + 1]);
                if (isLineIn.CLASS_NAME === "SuperMap.Geometry.Point") {
                    //设置避让信息
                    setInfo(quadrilateral[j]);
                    setInfo(quadrilateral[j + 1]);
                    isIntersection = true;
                }
            }
        }

        if (isIntersection) {
            //组织避让操作所需的信息
            return {
                "aspectW": aspectW,
                "aspectH": aspectH,
                "offsetX": offsetX,
                "offsetY": offsetY
            };
        } else {
            return null;
        }

        //内部函数：设置避让信息
        //参数：{Object} vec- quadrilateral四边形单个节点。如：{"x":1,"y":1}。
        function setInfo(vec) {
            //四边形不在bounds内的节点
            if (!bounds.contains(vec.x, vec.y)) {
                //bounds的Top边
                if (vec.y < bounds.top) {
                    let oY = Math.abs(bounds.top - vec.y);
                    if (oY > offsetY) {
                        offsetY = oY;
                        aspectH = "top";
                    }
                }

                //bounds的Bottom边
                if (vec.y > bounds.bottom) {
                    let oY = Math.abs(vec.y - bounds.bottom);
                    if (oY > offsetY) {
                        offsetY = oY;
                        aspectH = "bottom";
                    }
                }

                //bounds的left边
                if (vec.x < bounds.left) {
                    let oX = Math.abs(bounds.left - vec.x);
                    if (oX > offsetX) {
                        offsetX = oX;
                        aspectW = "left";
                    }
                }

                //bounds的right边
                if (vec.x > bounds.right) {
                    let oX = Math.abs(vec.x - bounds.right);
                    if (oX > offsetX) {
                        offsetX = oX;
                        aspectW = "right";
                    }
                }
            }
        }

    }


    /**
     * @function LabelThemeLayer.prototype.isQuadrilateralOverLap
     * @description 判断两个四边形是否有压盖。
     * @param {Array.<Object>} quadrilateral - 四边形节点数组。例如：[{"x":1,"y":1},{"x":3,"y":1},{"x":6,"y":4},{"x":2,"y":10},{"x":1,"y":1}]。
     * @param {Array.<Object>} quadrilateral2 - 第二个四边形节点数组。
     * @returns {boolean} 是否压盖，true 表示压盖。
     */
    isQuadrilateralOverLap(quadrilateral, quadrilateral2) {
        var quadLen = quadrilateral.length,
            quad2Len = quadrilateral2.length;
        if (quadLen !== 5 || quad2Len !== 5) {
            return null;
        } //不是四边形

        var OverLap = false;
        //如果两四边形互不包含对方的节点，则两个四边形不相交
        for (let i = 0; i < quadLen; i++) {
            if (this.isPointInPoly(quadrilateral[i], quadrilateral2)) {
                OverLap = true;
                break;
            }
        }
        for (let i = 0; i < quad2Len; i++) {
            if (this.isPointInPoly(quadrilateral2[i], quadrilateral)) {
                OverLap = true;
                break;
            }
        }
        //加上两矩形十字相交的情况
        for (let i = 0; i < quadLen - 1; i++) {
            if (OverLap) {
                break;
            }
            for (var j = 0; j < quad2Len - 1; j++) {
                var isLineIn = Util_Util.lineIntersection(quadrilateral[i], quadrilateral[i + 1], quadrilateral2[j], quadrilateral2[j + 1]);
                if (isLineIn.CLASS_NAME === "SuperMap.Geometry.Point") {
                    OverLap = true;
                    break;
                }
            }
        }

        return OverLap;
    }

    /**
     * @function LabelThemeLayer.prototype.isPointInPoly
     * @description 判断一个点是否在多边形里面（射线法）。
     *
     * @param {Object} pt - 需要判定的点对象，该对象含有属性x（横坐标），属性y（纵坐标）。
     * @param {Array.<Object>} poly - 多边形节点数组。例如一个四边形：[{"x":1,"y":1},{"x":3,"y":1},{"x":6,"y":4},{"x":2,"y":10},{"x":1,"y":1}]。
     * @returns {boolean} 点是否在多边形内。
     */
    isPointInPoly(pt, poly) {
        for (var isIn = false, i = -1, l = poly.length, j = l - 1; ++i < l; j = i) {
            ((poly[i].y <= pt.y && pt.y < poly[j].y) || (poly[j].y <= pt.y && pt.y < poly[i].y)) &&
            (pt.x < (poly[j].x - poly[i].x) * (pt.y - poly[i].y) / (poly[j].y - poly[i].y) + poly[i].x) &&
            (isIn = !isIn);
        }
        return isIn;
    }

}

;// CONCATENATED MODULE: external "function(){try{return mapv}catch(e){return {}}}()"
const external_function_try_return_mapv_catch_e_return_namespaceObject = function(){try{return mapv}catch(e){return {}}}();
;// CONCATENATED MODULE: ./src/common/overlay/mapv/MapvRenderer.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/
 

var BaseLayer = external_function_try_return_mapv_catch_e_return_namespaceObject.baiduMapLayer ? external_function_try_return_mapv_catch_e_return_namespaceObject.baiduMapLayer.__proto__ : Function;

/**
 * @private
 * @class MapvRenderer
 * @classdesc MapV图层渲染。
 * @param {Object} map - 地图。
 * @param {Object} layer - 图层。
 * @param {Mapv.DataSet} dataSet - 数据集。
 * @param {Object} options - 参数。
 * @param {Object} [functions] - 图层传递给渲染器调用的方法。
 * @param {Object} [mapOptions] - 图层传递给渲染器的地图元素信息。
 * @extends {MapV.BaseLayer}
 *
 */
class MapvRenderer extends BaseLayer {
    constructor(map, dataSet, options, functions, mapOptions) {
        super(map, dataSet, options);
        if (!BaseLayer) {
            return;
        }
        this.options = options || {};
        this.transferCoordinate = functions.transferCoordinate;
        this.getCenterPixel = functions.getCenterPixel;
        this.getResolution = functions.getResolution;
        this.validZoom = functions.validZoom;
        let { mapElement, targetElement, id } = mapOptions;
        this.targetElement = targetElement;
        this.canvas = this._createCanvas(id, mapElement);
        this.canvasLayer = {
          canvas: this.canvas,
          devicePixelRatio: this.devicePixelRatio
        }
        this.init(options);
        this.argCheck(options);
        this.stopAniamation = false;
        this.animation = options.animation;
        this.clickEvent = this.clickEvent.bind(this);
        this.mousemoveEvent = this.mousemoveEvent.bind(this);
        this._canvasUpdate();
        this.targetElement.appendChild(this.canvas);
        this._expectShow = true;
        this.isShow = true;
    }

    /**
     * @function MapvRenderer.prototype.clickEvent
     * @description  点击绑定事件。
     * @param {Object} e - 事件。
     */
    clickEvent(e) {
        var pixel = e.point;
        super.clickEvent(pixel, e);
    }

    /**
     * @function MapvRenderer.prototype.mousemoveEvent
     * @description  鼠标移动事件。
     * @param {Object} e - 事件。
     */
    mousemoveEvent(e) {
        var pixel = e.point;
        super.mousemoveEvent(pixel, e);
    }

    /**
     * @function MapvRenderer.prototype.getContext
     * @description 获取信息。
     */
    getContext() {
        return this.canvas.getContext(this.context);
    }

    /**
     * @function MapvRenderer.prototype.addData
     * @description 添加数据。
     * @param {Object} data - 待添加的数据。
     * @param {Object} options - 待添加的数据信息。
     */
    addData(data, options) {
        var _data = data;
        if (data && data.get) {
            _data = data.get();
        }
        this.dataSet.add(_data);
        this.update({
            options: options
        });
    }

    /**
     * @function MapvRenderer.prototype.update
     * @description 更新图层。
     * @param {Object} opt - 待更新的数据。
     * @param {Object} opt.data - mapv 数据集。
     * @param {Object} opt.options - mapv 绘制参数。
     */
    update(opt) {
        var update = opt || {};
        var _data = update.data;
        if (_data && _data.get) {
            _data = _data.get();
        }
        if (_data != undefined) {
            this.dataSet.set(_data);
        }
        super.update({
            options: update.options
        });
    }

    /**
     * @function MapvRenderer.prototype.getData
     * @description 获取数据。
     */
    getData() {
        return this.dataSet;
    }

    /**
     * @function MapvRenderer.prototype.removeData
     * @description 删除符合过滤条件的数据。
     * @param {function} [filter] - 过滤条件。条件参数为数据项，返回值为true,表示删除该元素；否则表示不删除。
     */
    removeData(filter) {
        if (!this.dataSet) {
            return;
        }
        var newData = this.dataSet.get({
            filter: function (data) {
                return filter != null && typeof filter === 'function' ? !filter(data) : true;
            }
        });
        this.dataSet.set(newData);
        this.update({
            options: null
        });
    }

    /**
     * @function MapVRenderer.prototype.clearData
     * @description 清除数据。
     */
    clearData() {
        this.dataSet && this.dataSet.clear();
        this.update({
            options: null
        });
    }

    /**
     * @function MapVRenderer.prototype.updateData
     * @param {Object} dataSet - 数据集。
     * @param {Object} options - 数据项配置。
     * @description  更新数据。
     */
    updateData(dataSet, options) {
        if (dataSet && dataSet.get) {
            this.dataSet.set(dataSet.get());
        }
        this.update({
            options: options
        });
    }

    _createCanvas(id, mapElement) {
      const { width, height } = mapElement.style;
      var canvas = document.createElement('canvas');
      canvas.style.position = 'absolute';
      canvas.style.top = '0px';
      canvas.style.left = '0px';
      canvas.id = id;
      var global$2 = typeof window === 'undefined' ? {} : window;
      var devicePixelRatio = this.devicePixelRatio = global$2.devicePixelRatio || 1;
      canvas.width = parseInt(width) * devicePixelRatio;
      canvas.height = parseInt(height) * devicePixelRatio;
      if (!this.options.context || this.options.context == '2d') {
        canvas.getContext('2d').scale(devicePixelRatio, devicePixelRatio);
      }
      canvas.style.width = width;
      canvas.style.height = height;
      return canvas;
    }

    _canvasUpdate(time) {
      if (this.stopAniamation) {
          return;
      }
      var self = this;

      var animationOptions = self.options.animation;

      var context = this.getContext();

      if (self.isEnabledTime()) {
          if (time === undefined) {
              this.clear(context);
              return;
          }
          if (this.context === '2d') {
              context.save();
              context.globalCompositeOperation = 'destination-out';
              context.fillStyle = 'rgba(0, 0, 0, .1)';
              context.fillRect(0, 0, context.canvas.width, context.canvas.height);
              context.restore();
          }
      } else {
          this.clear(context);
      }

      if (this.context === '2d') {
          for (var key in self.options) {
              context[key] = self.options[key];
          }
      } else {
          context.clear(context.COLOR_BUFFER_BIT);
      }

      if (!this.validZoom()) {
        return;
      }
      
      var dataGetOptions = {
        transferCoordinate: this.transferCoordinate()
      };
      var zoomUnit = this.getResolution();
      if (time !== undefined) {
          dataGetOptions.filter = function (item) {
              var trails = animationOptions.trails || 10;
              return time && item.time > time - trails && item.time < time;
          };
      }

      var data = self.dataSet.get(dataGetOptions);

      this.processData(data);

      // 兼容unit为'm'的情况
      if (self.options.unit === 'm') {
          if (self.options.size) {
              self.options._size = self.options.size / zoomUnit;
          }
          if (self.options.width) {
              self.options._width = self.options.width / zoomUnit;
          }
          if (self.options.height) {
              self.options._height = self.options.height / zoomUnit;
          }
      } else {
          self.options._size = self.options.size;
          self.options._height = self.options.height;
          self.options._width = self.options.width;
      }

      var worldPoint = this.getCenterPixel();
      this.drawContext(context, data, self.options, worldPoint);

      self.options.updateCallback && self.options.updateCallback(time);
    }

    init(options) {
        var self = this;

        self.options = options;

        this.initDataRange(options);

        this.context = self.options.context || '2d';
        if (self.options.zIndex) {
            this.setZIndex(self.options.zIndex);
        }
        this.initAnimator();
    }
   
    /**
     * @function MapVRenderer.prototype.destroy
     * @description 释放资源。
     */
    destroy() {
        this.targetElement.removeChild(this.canvas);
        this.clearData();
        this.animator && this.animator.stop();
        this.animator = null;
    }


    /**
     * @function MapvRenderer.prototype.addAnimatorEvent
     * @description 添加动画事件。
     */
    addAnimatorEvent() {}

    moveEndEvent() {
        this.stopAniamation = false;
        this._canvasUpdate();
    }

    /**
     * @function MapvRenderer.prototype.draw
     * @description 渲染绘制。
     */
    draw() {
        this._canvasUpdate();
    }

    visible() {
      return this.isShow;
    }

    hide() {
      this.isShow = false;
      this.canvas.style.display = 'none';
    }

    show() {
      this.isShow = true;
      this.canvas.style.display = 'block';
    }

    setZIndex(z) {
      this.canvas.style.zIndex = z;
    }

    /**
     * @function MapvRenderer.prototype.clear
     * @param {Object} context - 当前环境。
     * @description 清除环境。
     */
    clear(context) {
      context &&
          context.clearRect &&
          context.clearRect(
              0,
              0,
              parseInt(this.map.getCanvas().style.width),
              parseInt(this.map.getCanvas().style.height)
          );
    }
}

;// CONCATENATED MODULE: ./src/common/util/MapCalculateUtil.js


/**
 * @function getMeterPerMapUnit
 * @description 单位换算，把米|度|千米|英寸|英尺换成米。
 * @category BaseTypes Util
 * @param {string} mapUnit 地图单位。
 * @returns {number} 返回地图的距离单位。
 * @usage
 * ```
 * // 浏览器
 * <script type="text/javascript" src="{cdn}"></script>
 * <script>
 *   const result = {namespace}.getMeterPerMapUnit(mapUnit);
 *
 * </script>
 *
 * // ES6 Import
 * import { getMeterPerMapUnit } from '{npm}';
 *
 * const result = getMeterPerMapUnit(mapUnit);
 * ```
 */
var getMeterPerMapUnit = function(mapUnit) {
    var earchRadiusInMeters = 6378137;
    var meterPerMapUnit;
    if (mapUnit === Unit.METER) {
        meterPerMapUnit = 1;
    } else if (mapUnit === Unit.DEGREE) {
        // 每度表示多少米。
        meterPerMapUnit = (Math.PI * 2 * earchRadiusInMeters) / 360;
    } else if (mapUnit === Unit.KILOMETER) {
        meterPerMapUnit = 1.0e-3;
    } else if (mapUnit === Unit.INCH) {
        meterPerMapUnit = 1 / 2.5399999918e-2;
    } else if (mapUnit === Unit.FOOT) {
        meterPerMapUnit = 0.3048;
    } else {
        return meterPerMapUnit;
    }
    return meterPerMapUnit;
};

/**
 * @function getWrapNum
 * @description 获取该坐标系的经纬度范围的经度或纬度。
 * @category BaseTypes Util
 * @param {number} x 经度或纬度。
 * @param {boolean} includeMax 是否获取经度或纬度的最大值。
 * @param {boolean} includeMin 是否获取经度或纬度的最小值。
 * @param {number} range 坐标系的经纬度范围。
 * @returns {number} 返回经度或纬度的值。
 * @usage
 * ```
 * // 浏览器
 * <script type="text/javascript" src="{cdn}"></script>
 * <script>
 *   const result = {namespace}.getWrapNum(x, includeMax, includeMin, range);
 *
 * </script>
 *
 * // ES6 Import
 * import { getWrapNum } from '{npm}';
 *
 * const result = getWrapNum(x, includeMax, includeMin, range);
 * ```
 */
function getWrapNum(x, includeMax = true, includeMin = true, range = [-180, 180]) {
    var max = range[1],
        min = range[0],
        d = max - min;
    if (x === max && includeMax) {
        return x;
    }
    if (x === min && includeMin) {
        return x;
    }
    var tmp = (((x - min) % d) + d) % d;
    if (tmp === 0 && includeMax) {
        return max;
    }
    return ((((x - min) % d) + d) % d) + min;
}

/**
 * @function conversionDegree
 * @description 转换经纬度。
 * @category BaseTypes Util
 * @param {number} degrees 经度或纬度。
 * @returns {string} 返回度分秒。
 * @usage
 * ```
 * // 浏览器
 * <script type="text/javascript" src="{cdn}"></script>
 * <script>
 *   const result = {namespace}.conversionDegree(degrees);
 *
 * </script>
 *
 * // ES6 Import
 * import { conversionDegree } from '{npm}';
 *
 * const result = conversionDegree(degrees);
 * ```
 */
function conversionDegree(degrees) {
    const degree = parseInt(degrees);
    let fraction = parseInt((degrees - degree) * 60);
    let second = parseInt(((degrees - degree) * 60 - fraction) * 60);
    fraction = parseInt(fraction / 10) === 0 ? `0${fraction}` : fraction;
    second = parseInt(second / 10) === 0 ? `0${second}` : second;
    return `${degree}°${fraction}'${second}`;
}

/**
  * @function scalesToResolutions
  * @description 通过比例尺数组计算分辨率数组，没有传入比例尺数组时通过地图范围与地图最大级别进行计算。
  * @version 11.0.1
  * @param {Array} scales - 比例尺数组。
  * @param {Object} bounds - 地图范围。
  * @param {number} dpi - 屏幕分辨率。
  * @param {string} mapUnit - 地图单位。
  * @param {number} [level=22] - 地图最大级别。
  * @returns {number} 分辨率。
  * @usage
  * ```
  * // 浏览器
  * <script type="text/javascript" src="{cdn}"></script>
  * <script>
  *   const result = {namespace}.scalesToResolutions(scales, bounds, dpi, mapUnit);
  *
  * </script>
  *
  * // ES6 Import
  * import { scalesToResolutions } from '{npm}';
  *
  * const result = scalesToResolutions(scales, bounds, dpi, mapUnit);
  * ```
 */
 function scalesToResolutions(scales, bounds, dpi, mapUnit, level = 22) {
  var resolutions = [];
  if (scales && scales.length > 0) {
    for (let i = 0; i < scales.length; i++) {
      resolutions.push(scaleToResolution(scales[i], dpi, mapUnit));
    }
  } else {
    const maxReolution = Math.abs(bounds.left - bounds.right) / 256;
    for (let i = 0; i < level; i++) {
      resolutions.push(maxReolution / Math.pow(2, i));
    }
  }
  return resolutions.sort(function (a, b) {
    return b - a;
  });
}
/**
  * @function getZoomByResolution
  * @description 通过分辨率获取地图级别。
  * @version 11.0.1
  * @param {number} resolution - 分辨率。
  * @param {Array} resolutions - 分辨率数组。
  * @returns {number} 地图级别。
  * @usage
  * ```
  * // 浏览器
  * <script type="text/javascript" src="{cdn}"></script>
  * <script>
  *   const result = {namespace}.getZoomByResolution(resolution, resolutions);
  *
  * </script>
  *
  * // ES6 Import
  * import { getZoomByResolution } from '{npm}';
  *
  * const result = getZoomByResolution(resolution, resolutions);
  * ```
 */
function getZoomByResolution(resolution, resolutions) {
  let zoom = 0;
  let minDistance;
  for (let i = 0; i < resolutions.length; i++) {
    if (i === 0) {
      minDistance = Math.abs(resolution - resolutions[i]);
    }
    if (minDistance > Math.abs(resolution - resolutions[i])) {
      minDistance = Math.abs(resolution - resolutions[i]);
      zoom = i;
    }
  }
  return zoom;
}

/**
  * @function scaleToResolution
  * @description 通过比例尺计算分辨率。
  * @version 11.0.1
  * @param {number} scale - 比例尺。
  * @param {number} dpi - 屏幕分辨率。
  * @param {string} mapUnit - 地图单位。
  * @returns {number} 分辨率。
  * @usage
  * ```
  * // 浏览器
  * <script type="text/javascript" src="{cdn}"></script>
  * <script>
  *   const result = {namespace}.scaleToResolution(scale, dpi, mapUnit);
  *
  * </script>
  *
  * // ES6 Import
  * import { scaleToResolution } from '{npm}';
  *
  * const result = scaleToResolution(scale, dpi, mapUnit);
  * ```
 */
function scaleToResolution(scale, dpi, mapUnit) {
  const inchPerMeter = 1 / 0.0254;
  const meterPerMapUnitValue = getMeterPerMapUnit(mapUnit);
  const resolution = 1 / (scale * dpi * inchPerMeter * meterPerMapUnitValue);
  return resolution;
}

/**
 * 范围是否相交
 * @param {Array} extent1 范围1
 * @param {Array} extent2 范围2
 * @return {boolean} 范围是否相交。
 */
 function intersects(extent1, extent2) {
  return (
    extent1[0] <= extent2[2] &&
    extent1[2] >= extent2[0] &&
    extent1[1] <= extent2[3] &&
    extent1[3] >= extent2[1]
  );
}

/**
 * 获取两个范围的交集
 * @param {Array} extent1 Extent 1
 * @param {Array} extent2 Extent 2
 * @return {Array} 相交范围数组.
 * @api
 */
 function getIntersection(extent1, extent2) {
  const intersection = [];
  if (intersects(extent1, extent2)) {
    if (extent1[0] > extent2[0]) {
      intersection[0] = extent1[0];
    } else {
      intersection[0] = extent2[0];
    }
    if (extent1[1] > extent2[1]) {
      intersection[1] = extent1[1];
    } else {
      intersection[1] = extent2[1];
    }
    if (extent1[2] < extent2[2]) {
      intersection[2] = extent1[2];
    } else {
      intersection[2] = extent2[2];
    }
    if (extent1[3] < extent2[3]) {
      intersection[3] = extent1[3];
    } else {
      intersection[3] = extent2[3];
    }
  }
  return intersection;
}
;// CONCATENATED MODULE: ./src/mapboxgl/overlay/MapvLayer.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/






/**
 * @class MapvLayer
 * @category  Visualization MapV
 * @classdesc Mapv 图层类。
 * @modulecategory Overlay
 * @param {mapboxgl.Map} map - MapBoxGL Map 对象，将在下个版本弃用，请用 map.addLayer() 方法添加图层。
 * @param {Mapv.DataSet} dataSet - MapV 图层数据集。
 * @param {Object} mapVOptions - Mapv 参数。
 * @param {string} [mapVOptions.layerID] - 图层 ID。默认使用 CommonUtil.createUniqueID("mapvLayer_") 创建专题图层 ID。
 * @usage
 */
class MapvLayer {
  constructor(map, dataSet, mapVOptions) {
    if (arguments.length === 3) {
      this.map = map;
      delete mapVOptions['layerID'];
      this.mapVOptions = mapVOptions;
      this.dataSet = dataSet;
    } else {
      this.dataSet = map;
      delete dataSet['layerID'];
      this.mapVOptions = dataSet;
    }
    this.id = this.mapVOptions.layerID ? this.mapVOptions.layerID : Util_Util.createUniqueID('mapvLayer_');
    this.type = 'custom';
    this.visibility = true;
    this.renderingMode = '3d';
    this.overlay = true;
    this.context = this.mapVOptions.context || '2d';
    //保留之前的用法
    if (this.map) {
      this.map.addLayer(this);
    }
  }

  /**
   * @function MapvLayer.prototype.onAdd
   * @description 添加图层到地图。
   * @param {Object} map - 地图对象。
   */
  onAdd(map) {
    this.map = map;
    this.mapContainer = map.getCanvasContainer();
    this.renderer = new MapvRenderer(map, this.dataSet, this.mapVOptions, {
      transferCoordinate: this._transferCoordinate,
      getCenterPixel: this._getCenterPixel,
      getResolution: this._getResolution,
      validZoom: this._validZoom.bind(this)
    }, { mapElement: this.map.getCanvas(), targetElement: this.mapContainer, id: this.id });
    this.mapContainer.style.perspective = this.map.transform.cameraToCenterDistance + 'px';
    this.bindEvent();
  }

  /**
     * @function MapvLayer.prototype.onRemove
     * @description 移除图层。
     */
  onRemove() {
    this.renderer.destroy();
    this.unbindEvent();
  }

  /**
     * @function MapvLayer.prototype.render
     * @description 渲染图层。
     */
  render() {
    this.renderer && this.renderer.draw();
  }

  _transferCoordinate() {
    let map = this.map;
    var bounds = map.getBounds(),
      dw = bounds.getEast() - bounds.getWest(),
      dh = bounds.getNorth() - bounds.getSouth();
    let rect = map.getCanvas().getBoundingClientRect();
    var resolutionX = dw / rect.width,
      resolutionY = dh / rect.height;
    var center = map.getCenter();
    var centerPx = map.project(center);
    var self = this;
    return function (coordinate) {
      if (map.transform.rotationMatrix || self.context === '2d') {
        var worldPoint = map.project(new (external_mapboxgl_default()).LngLat(coordinate[0], coordinate[1]));
        return [worldPoint.x, worldPoint.y];
      }
      var pixel = [(coordinate[0] - center.lng) / resolutionX, (center.lat - coordinate[1]) / resolutionY];
      return [pixel[0] + centerPx.x, pixel[1] + centerPx.y];
    }
  }

  _validZoom() {
    if (
      (this.mapVOptions.minZoom && this.map.getZoom() < this.mapVOptions.minZoom) ||
      (this.mapVOptions.maxZoom && this.map.getZoom() > this.mapVOptions.maxZoom)
    ) {
      return false;
    }
    return true;
  }

  _getResolution() {
    var bounds = this.map.getBounds();
    var dw = bounds.getEast() - bounds.getWest();
    var rect = this.map.getCanvas().getBoundingClientRect();
    var resolutionX = dw / rect.width;
    // 一个像素是多少米
    return getMeterPerMapUnit('DEGREE') * resolutionX;
  }

  _getCenterPixel() {
    return this.map.project(new (external_mapboxgl_default()).LngLat(0, 0));
  }

  /**
   * @function MapvLayer.prototype.addData
   * @description 追加数据。
   * @param {Object} data - 要追加的数据。
   * @param {Object} options - 要追加的值。
   */
  addData(data, options) {
    this.renderer.addData(data, options);
  }

  /**
   * @function MapvLayer.prototype.update
   * @description 更新图层。
   * @param {Object} opt - 待更新的数据。
   * @param {Object} opt.data - mapv 数据集。
   * @param {Object} opt.options - mapv 绘制参数。
   */
  update(opt) {
    this.renderer.update(opt);
  }

  /**
   * @function MapvLayer.prototype.getData
   * @description 获取数据。
   * @returns {Mapv.DataSet} mapv 数据集。
   */
  getData() {
    if (this.renderer) {
      this.dataSet = this.renderer.getData();
    }
    return this.dataSet;
  }

  /**
   * @function MapvLayer.prototype.removeData
   * @description 删除符合过滤条件的数据。
   * @param {function} [filter] - 过滤条件。条件参数为数据项，返回值为 true,表示删除该元素；否则表示不删除。
   * @example
   * filter=function(data){
   *    if(data.id=="1"){
   *      return true
   *    }
   *    return false;
   * }
   */
  removeData(filter) {
    this.renderer && this.renderer.removeData(filter);
  }

  /**
   * @function MapvLayer.prototype.clearData
   * @description 清除数据。
   */
  clearData() {
    this.renderer.clearData();
  }
  /**
    * @function MapvLayer.prototype.show
    * @description 显示该图层
    */
  show() {
    if (this.renderer) {
      this.renderer.show();
    }
    return this;
  }
  /**
    * @function MapvLayer.prototype.hide
    * @description 隐藏该图层
    */
  hide() {
    if (this.renderer) {
      this.renderer.hide();
    }
    return this;
  }

   /**
     * @function MapvLayer.prototype.getTopLeft
     * @description 获取左上的坐标。
     */
   getTopLeft() {
    var map = this.map;
    var topLeft;
    if (map) {
        var bounds = map.getBounds();
        topLeft = bounds.getNorthWest();
    }
    return topLeft;
}

  /**
  * @function MapvRenderer.prototype.bindEvent
  * @description 绑定事件。
  */
  bindEvent() {
    var map = this.map;
    if (this.mapVOptions.methods) {
      if (this.mapVOptions.methods.click) {
        map.on('click', this.renderer.clickEvent);
      }
      if (this.mapVOptions.methods.mousemove) {
        map.on('mousemove', this.renderer.mousemoveEvent);
      }
    }
  }

  /**
   * @function MapvRenderer.prototype.unbindEvent
   * @description 解绑事件。
   */
  unbindEvent() {
    var map = this.map;
    if (this.mapvOptions.methods) {
      if (this.mapvOptions.methods.click) {
        map.off('click', this.clickEvent);
      }
      if (this.mapvOptions.methods.mousemove) {
        map.off('mousemove', this.mousemoveEvent);
      }
    }
  }

  /**
    * @function MapvLayer.prototype.setVisibility
    * @description 设置图层可见性。
    * @param {boolean} [visibility] - 是否显示图层（当前地图的 resolution 在最大最小 resolution 之间）。
    */
  setVisibility(visibility) {
    if (visibility !== this.visibility) {
      this.visibility = visibility;
      if (visibility) {
        this.show();
      } else {
        this.hide();
      }
    }
  }

  /**
   * @function MapvLayer.prototype.setZIndex
   * @description 设置 canvas 层级。
   * @param {number} zIndex - canvas 层级。
   */
  setZIndex(z) {
    this.renderer.setZIndex(z);
  }
}


;// CONCATENATED MODULE: ./src/mapboxgl/overlay/theme/Theme3DLayer.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


/**
 * @class Theme3DLayer
 * @category  Visualization Theme
 * @classdesc 三维专题图基类。不能直接实例化。
 * @modulecategory Overlay
 * @param  {string} [id] - 专题图图层 ID。默认使用 CommonUtil.createUniqueID("theme3DLayer") 创建专题图层 ID。
 * @param  {Object} layerOptions -专题图图层配置项。
 * @param  {number} [layerOptions.opacity=1] - 图层不透明度。
 * @param  {boolean} [layerOptions.parseNumber=fasle] - 是否预处理数据，将数据转换为 number。
 * @param  {boolean} [layerOptions.enableHighlight=false] - 是否开启高亮。
 * @param  {string} [layerOptions.highlight="#ADA91E"] - 高亮颜色。
 * @param  {string} [layerOptions.baseHeightField] - 数据中表示基础高度的字段。
 * @param  {number} [layerOptions.height] - 高度。如果数据指定的 heightField (为height)没有可以表示高度的字段，可以为所有数据统一设置一个高度。
 * @param  {string} [layerOptions.heightField] - 数据中表示高度的字段。
 * @param  {string} [layerOptions.themeField] - 专题展示的字段。
 * @param  {boolean} [layerOptions.showLegend=true] - 是否显示图例。
 * @param  {string} [layerOptions.legendTitle] - 图例标题。
 * @param  {string} [layerOptions.legendTheme='light'] - 图例主题，取值：'light','dark'。
 * @param  {string} [layerOptions.legendOrientation='horizontal'] - 图例方向，取值：'horizontal','vertical'。
 * @param  {string} [layerOptions.legendPosition] - 图例位置，取值：'top-right'|'top-left'|'bottom-left'|'bottom-right'。
 * @usage
 */
class Theme3DLayer {


    constructor(id, layerOptions) {
        /**
         * @member {string} Theme3DLayer.prototype.id
         * @description Mapbox GL 图层 ID。
         */
        this.id = id;

        /**
         * @member {Object} Theme3DLayer.prototype.map
         * @description Mapbox GL 地图对象。
         */
        this.map = null;
        /**
         * @member {number} [Theme3DLayer.prototype.opacity=1]
         * @description 图层不透明度。
         */
        this.opacity = 1;
        /**
         * @member {boolean} [Theme3DLayer.prototype.parseNumber=false]
         * @description 是否进行数据预处理，有些字段是 string 类型，需要转换为 number。
         */
        this.parseNumber = false;
        /**
         * @member {boolean} [Theme3DLayer.prototype.enableHighlight=false]
         * @description 是否开启高亮。
         */
        this.enableHighlight = false;

        /**
         * @member {Object} [Theme3DLayer.prototype.highlight={color: "#ADA91E"}]
         * @description 高亮相关配置。
         */
        this.highlight = {color: "#ADA91E"};

        /**
         * @member {string} Theme3DLayer.prototype.baseHeightField
         * @description 数据中表示基础高度的字段。
         */
        this.baseHeightField = null;

        /**
         * @member {number} Theme3DLayer.prototype.height
         * @description 高度。如果数据指定的 heightField (默认 height) 没有可以表示高度的字段，可以为所有数据统一设置一个高度。
         */
        this.height = null;

        /**
         * @member {string} Theme3DLayer.prototype.heightField
         * @description 数据中表示高度的字段。
         */
        this.heightField = 'height';

        /**
         * @member {string} [Theme3DLayer.prototype.themeField]
         * @description 专题展示的字段。
         */
        this.themeField = this.heightField;

        /**
         * @member {boolean} [Theme3DLayer.prototype.showLegend=true]
         * @description 是否显示图例。
         */
        this.showLegend = true;

        /**
         * @member {string} [Theme3DLayer.prototype.legendTitle]
         * @description 图例标题。
         */
        this.legendTitle = null;

        /**
         * @member {string} [Theme3DLayer.prototype.legendTheme='light']
         * @description 图例主题，取值：'light','dark'。
         * @default 'light'
         */
        this.legendTheme = 'light';

        /**
         * @member {string} [Theme3DLayer.prototype.legendOrientation='horizontal']
         * @description 图例方向，取值：'horizontal','vertical'。
         * @default 'horizontal'
         */
        this.legendOrientation = 'horizontal';
        /**
         * @member {string} Theme3DLayer.prototype.legendPosition
         * @description 图例位置，取值：'top-right'|'top-left'|'bottom-left'|'bottom-right'。
         * @default 'bottom-right'
         */
        this.legendPosition = 'bottom-right';
        this._highlightLayerId = `${this.id}-highlightLayer`;
        this._extend(this, layerOptions);
    }

    /**
     * @function Theme3DLayer.prototype.setLayerOptions
     * @description 设置图层相关参数。
     * @param {Object} layerOptions - 该专题图图层相关参数。
     * @param {number} [layerOptions.opacity=1] - 图层不透明度。
     * @param {boolean} [layerOptions.parseNumber=false] - 是否预处理数据，将数据转换为 number。
     * @param {string} [layerOptions.baseHeightField] - 数据中表示基础高度的字段。
     * @param {number} [layerOptions.height] - 高度。如果数据指定的heightField(默认height)没有可以表示高度的字段，可以为所有数据统一设置一个高度。
     * @param {string} [layerOptions.heightField] - 数据中表示高度的字段。
     * @param {string} [layerOptions.themeField] - 专题展示的字段。
     * @param {boolean} [layerOptions.showLegend=true] - 是否显示图例。
     * @param {string} layerOptions.legendTitle - 图例标题。
     * @param {string} [layerOptions.legendTheme='light'] - 图例主题，取值：'light','dark'。
     * @param {string} [layerOptions.legendOrientation='horizontal'] - 图例方向，取值：'horizontal','vertical'。
     * @param {string} [layerOptions.legendPosition] - 图例位置，取值：'top-right'|'top-left'|'bottom-left'|'bottom-right'。
     * @returns {Theme3DLayer} Theme3DLayer的实例对象。
     */
    setLayerOptions(layerOptions) {
        this._extend(this, layerOptions);
        return this;
    }

    /**
     * @function Theme3DLayer.prototype.setHighlightStyleOptions
     * @description 设置图层高亮相关参数。
     * @param {Object} highlightOptions - 该专题图图层高亮相关参数。
     * @param {string} [highlightOptions.color] - 颜色。
     * @param {function} highlightOptions.callback - 回调，返回数据参数（data,event）。
     * @returns {Theme3DLayer} Theme3DLayer的实例对象。
     */
    setHighlightStyleOptions(highlightOptions) {
        this._extend(this.highlight, highlightOptions);
        return this;
    }

    /**
     * @function Theme3DLayer.prototype.setData
     * @description 设置数据，数据格式必须为 GeoJSON 格式。
     * @param {GeoJSONObject} data - GeoJSON 格式数据。
     * @param {boolean} [parseNumber=false] - 是否进行数据预处理，有些字段是 string 类型，需要转换为 number。
     */
    setData(data, parseNumber) {
        var me = this;
        me.data = data;
        if (parseNumber != null) {
            me.parseNumber = parseNumber;
        }
        me.parseNumber && me.data && me.data.features && me.data.features.map(function (val) {
            if (me.baseHeightField && val.properties[me.baseHeightField]) {
                val.properties[me.baseHeightField] = parseFloat(val.properties[me.baseHeightField]);
            }
            if (me.heightField && val.properties[me.heightField]) {
                val.properties[me.heightField] = parseFloat(val.properties[me.heightField]);
            }
            return val;
        });
        return this;
    }

    /**
     * @function Theme3DLayer.prototype.getData
     * @description 获取数据。
     * @returns {GeoJSONObject} 获取的数据。
     */
    getData() {
        return this.data;
    }

    /**
     * @function Theme3DLayer.prototype.addTo
     * @description 添加图层到地图上。
     * @param {mapboxgl.Map} map - MapBoxGL Map 对象。
     * @returns {Theme3DLayer} Theme3DLayer的实例对象。
     */
    addTo(map) {
        this.map = map;
        if (!this.map) {
            return this;
        }

        this.show();
        return this;
    }

    /**
     * @function Theme3DLayer.prototype.show
     * @description 显示图层。
     * @param {Object} options - 图层配置项。
     * @returns {Theme3DLayer} Theme3DLayer的实例对象。
     */
    show(options) {
        this._extend(this, options);
        this._addLayer();
        if (this.enableHighlight) {
            this._addHighLightLayer();
        }
        if (this.showLegend) {
            if (!this.legend) {
                this.legend = this._createLegendControl();
            }
            this.map.addControl(this.legend, this.legendPosition);
        }
        return this;
    }

    /**
     * @function Theme3DLayer.prototype.remove
     * @description 从地图上移除图层。
     * @returns {Theme3DLayer} Theme3DLayer的实例对象。
     */
    remove() {
        if (!this.map) {
            return this;
        }
        //移除图层
        var layerId = this.id ? this.id : "theme3DLayer";
        if (this.map.getLayer(layerId)) {
            this.map.off('mousemove', layerId, this._onMouseMove.bind(this));
            this.map.on('mouseout', layerId, this._onMouseMove.bind(this));
            this.map.removeLayer(layerId);
        }
        //移除高亮图层
        if (this.map.getLayer(this._highlightLayerId)) {
            this._selectFeatureId = null;
            this.map.removeLayer(this._highlightLayerId );
        }

        //移除图例
        if (this.legend) {
            this.map.removeControl(this.legend);
        }
        return this;
    }

    /**
     * @function Theme3DLayer.prototype.getLayerStyleOptions
     * @description 获取图层样式。
     * @returns {Object} Mapbox GL 样式对象。
     */
    getLayerStyleOptions() {
        //子类重写实现
    }

    /**
     * @function Theme3DLayer.prototype.getHighlightStyleOptions
     * @description 获取高亮样式，子类重写实现。
     * @returns {Object} Mapbox GL 样式对象。
     */
    getHighlightStyleOptions() {
        //子类重写实现
    }

    _createLegendControl(html) {
        var me = this;

        function LegendControl() {
        }

        LegendControl.prototype.onAdd = function (map) {
            this._map = map;
            this._container = document.createElement('div');
            var className = 'mapboxgl-ctrl legend ';
            var theme = 'legend-light';
            if (me.legendTheme === 'dark') {
                theme = 'legend-dark';
            }
            var orientation = ' legend-horizontal';
            if (me.legendOrientation === 'vertical') {
                orientation = ' legend-vertical';
            }
            this._container.className = className + theme + orientation;

            if (html) {
                this._container.innerHTML = html;
            } else {
                var legendTitle = me.legendTitle || "";
                var titleElement = " <div class='legend-title'>" + legendTitle + "</div>";
                var content = me._createLegendElement.call(me) || "";
                var contentElement = "<div class='legend-content'>" + content + "</div>";
                this._container.innerHTML = titleElement + contentElement;
            }
            me._appendLegendCSSStyle();
            return this._container;
        };

        LegendControl.prototype.onRemove = function () {
            this._container.parentNode.removeChild(this._container);
            this._map = undefined;
        };

        return new LegendControl();
    }

    _createLegendElement() {
        //子类实现
    }

    _addLayer() {
        var paintOptions = this.getLayerStyleOptions();
        var id = this.id ? this.id : "theme3DLayer";
        var sourceId = this.sourceId = id + 'Source';
        if (!this.map.getSource(sourceId)) {
            this.map.addSource(sourceId, {
                'type': 'geojson',
                'data': this.data
            });
        } else {
            this.map.removeSource(sourceId);
            this.map.addSource(sourceId, {
                'type': 'geojson',
                'data': this.data
            });
        }
        this.map.addLayer({
            'id': id,
            'type': 'fill-extrusion',
            'source': sourceId,
            'paint': paintOptions
        });
        this.map.moveLayer(id);
    }

    //添加高亮图层
    _addHighLightLayer() {
        if (!this.map) {
            return;
        }
        var map = this.map;
        map.addLayer({
            'id': this._highlightLayerId,
            'type': 'fill-extrusion',
            'source': this.sourceId,
            'paint': this.getHighlightStyleOptions(),
            "filter": ["in", "$id", ""]
        });

        this._selectFeatureId = null;
        map.on('mousemove', this.id, this._onMouseMove.bind(this));
        map.on('mouseout', this.id, this._onMouseMove.bind(this));
    }

    _onMouseMove(e) {
        var me = this, map = this.map;
        var features = map.queryRenderedFeatures(e.point, {layers: [me.id]});

        if (me.highlight && me.highlight.callback) {
            me.highlight.callback(features, e);
        }

        if (!features || features.length < 1) {
            me._clearHighlight.call(me);
            me._selectFeatureId = null;
            return;
        }
        var id = features[0].id;
        if (me._selectFeatureId === id) {
            return;
        }
        me._selectFeatureId = id;
        map.setFilter(me._highlightLayerId, ['==', '$id', me._selectFeatureId]);
    }

    _clearHighlight() {
        if (this.map) {
            this.map.setFilter(this._highlightLayerId, ["in", "$id", ""]);
        }
    }

    _appendLegendCSSStyle() {
        var legendStyle = document.createElement('style');
        legendStyle.type = 'text/css';
        var baseStyle = `
        .legend {
            display: inline-block;
            border-radius: 2px;
            -moz-border-radius: 2px;
            -webkit-border-radius: 2px;
            font-size: 12px;
            color: rgba(0, 0, 0, 0.8);
            background-color: rgb(255, 255, 255);
        }
        .legend-light {
            color: rgba(0, 0, 0, 0.8);
            background-color: rgb(255, 255, 255);
            box-shadow: 0px 0px 6px #bbbbbb;
            -moz-box-shadow: 0px 6px 10px #bbbbbb;
            -webkit-box-shadow: 0px 0px 6px #bbbbbb;
        }
        .legend-dark {
            color: rgba(255, 255, 255, 0.8);
            background-color: rgb(64, 64, 64);
        }
        .legend .legend-title {
            min-height: 14px;
            max-width: 500px;
            padding:6px 10px;
        }
        .legend-light .legend-title {
            color: rgba(0, 0, 0, 0.8);
        }
        .legend-dark .legend-title {
            color: rgba(255, 255, 255, 0.8);
        }
        .legend-content{
            padding:6px 10px;
        }
        `;
        legendStyle.innerHTML = baseStyle + this._legendCSSStyle();
        document.getElementsByTagName('head')[0].appendChild(legendStyle);
    }

    //各种图层对应的自己的图例的样式
    _legendCSSStyle() {
        //子类可重写实现
        return `
        .legend ul {
            padding: 0;
            margin: 0 16px;
            height: 100%;
            display: block;
            list-style: none;
        }

        .legend li {
            vertical-align: middle;
        }

        .legend li span:first-child {
            vertical-align: middle;
        }

        .legend li span:last-child {
            line-height: 28px;
            max-width: 200px;
            vertical-align: middle;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            -ms-text-overflow: ellipsis;
        }

        .legend-vertical li {
            height: 28px;
        }

        .legend-vertical li span:first-child {
            display: inline-block;
            width: 60px;
            height: 100%;
        }

        .legend-vertical li span:last-child {
            display: inline-block;
            margin-left: 16px;
            height: 100%;
        }

        .legend-horizontal li {
            height: 56px;
            float: left;
        }

        .legend-horizontal li span:first-child {
            display: block;
            width: 100%;
            height: 50%;
        }

        .legend-horizontal li span:last-child {
            display: block;
            vertical-align: middle;
            width: 60px;
            height: 50%;
            text-align: center;
        }
        `;
    }

    _extend(dest) {
        for (var index = 0; index < Object.getOwnPropertyNames(arguments).length; index++) {
            var arg = Object.getOwnPropertyNames(arguments)[index];
            if (arg == "caller" || arg == "callee" || arg == "length" || arg == "arguments") {
                continue;
            }
            var obj = arguments[arg];
            if (obj) {
                for (var j = 0; j < Object.getOwnPropertyNames(obj).length; j++) {
                    var key = Object.getOwnPropertyNames(obj)[j];
                    if (arg == "caller" || arg == "callee" || arg == "length" || arg == "arguments") {
                        continue;
                    }
                    dest[key] = obj[key];
                }
            }
        }
        return dest;
    }
}

;// CONCATENATED MODULE: ./src/mapboxgl/overlay/RangeTheme3DLayer.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/



/**
 * @class RangeTheme3DLayer
 * @category  Visualization Theme
 * @classdesc 三维分段专题图类。
 * @modulecategory Overlay
 * @param  {string} [id] - 专题图图层 ID。默认使用 CommonUtil.createUniqueID("theme3DLayer") 创建专题图层 ID。
 * @param  {Object} layerOptions - 专题图图层配置项，参数继承自 Theme3DLayer。
 * @param  {Array} [layerOptions.heightStops] - 新增参数，数据高度分段数组。
 * @param  {Array} layerOptions.colorStops - 新增参数，数据颜色分段数组。
 * @param  {number} [layerOptions.base] - 新增参数，数据分段线性增量。
 * @param  {number} [layerOptions.legendRatio=1] - 新增参数，图例数值扩大系数。
 * @example
 * new RangeTheme3DLayer(layerId, map, {
 *      enableHighlight:true,
 *      // 设置分段
 *      heightField: "floor",
 *      heightStops: [[1, 10], [10, 100]],
 *      colorStops: [[0, 'rgba(33, 41, 52, 0.8)'], [20, 'rgba(69,117,180, 0.7)'], [50, 'rgba(116,173,209, 0.7)'], [100, 'rgba(171,217,233, 0.7)']],
 *      // 显示图例
 *      showLegend: true,
 *      legendTheme: 'dark',
 *      legendTitle: "图例"
 * });
 * @usage
 */
class RangeTheme3DLayer extends Theme3DLayer {

    constructor(id, layerOptions) {
        super(id, layerOptions);
        /**
         * @member  {Array} RangeTheme3DLayer.prototype.heightStops
         * @description 数据高度分段数组。
         */
        this.heightStops = null;

        /**
         * @member  {Array} RangeTheme3DLayer.prototype.colorStops
         * @description 数据颜色分段数组。
         */
        this.colorStops = null;
        /**
         * @member  {number} RangeTheme3DLayer.prototype.base
         * @description 数据分段线性增量。
         */
        this.base = null;

        /**
         * @member  {number} [RangeTheme3DLayer.prototype.legendRatio=1]
         * @description 图例数值扩大系数。
         */
        this.legendRatio = 1;

        this._extend(this, layerOptions);
    }

    /**
     * @function RangeTheme3DLayer.prototype.getLayerStyleOptions
     * @description 获取图层样式。
     * @returns {Object} Mapbox GL 样式对象。
     */
    getLayerStyleOptions() {
        var opacity = this.opacity == null ? 1 : this.opacity;
        opacity = isNaN(parseFloat(opacity)) ? 1 : parseFloat(opacity);
        var reg = /^[0-9]+.?[0-9]*$/;
        var options = {
            'fill-extrusion-color': {
                'stops': this.colorStops,
                'property': this.themeField || this.heightField,
                'type': 'interval',
                'base': reg.test(this.base) ? this.base : 1
            },
            'fill-extrusion-opacity': opacity
        };
        if (this.heightStops) {
            options['fill-extrusion-height'] = {
                'stops': this.heightStops,
                'property': this.heightField || 'height',
                'base': reg.test(this.base) ? this.base : 1
            }
        } else if (this.height) {
            options['fill-extrusion-height'] = this.height;
        } else {
            options['fill-extrusion-height'] = {
                'property': this.heightField || 'height',
                'type': 'identity'
            }
        }

        if (this.baseHeightField) {
            options['fill-extrusion-base'] = {
                'property': this.baseHeightField,
                'type': 'identity'
            }
        }
        return options;
    }

    /**
     * @function RangeTheme3DLayer.prototype.getHighlightStyleOptions
     * @description 获取高亮样式。
     * @returns {Object} mapboxgl 样式对象。
     */
    getHighlightStyleOptions() {
        var color = (this.highlight && this.highlight.color != null) ? this.highlight.color : '#ADA91E';
        return {
            'fill-extrusion-color': color,
            'fill-extrusion-height': {
                "stops": this.heightStops,
                "property": this.heightField
            },
            'fill-extrusion-opacity': this.highlight && this.highlight.opacity || 0.6
        }
    }

    _createLegendElement() {
        var len = this.colorStops && this.colorStops.length || 0;
        //颜色分段对应标识
        var legendListElement = "<ul>";
        var i;
        for (i = 0; i < len; i++) {
            var value = this.colorStops[i][0];
            var text = this._getWrapperText(value);
            if (i === len - 1) {
                text = "> " + text;
            } else {
                var next = this._getWrapperText(this.colorStops[i + 1][0]);
                text = text + "-" + next;
            }

            var color = this.colorStops[i][1];

            legendListElement += "<li><span style='background-color:" + color + ";'></span><span>" + text + "</span></li>";
        }
        legendListElement += "</ul>";
        return legendListElement;
    }

    _getWrapperText(number) {
        var value = number * ((this.legendRatio == null) ? 1 : parseFloat(this.legendRatio));

        //单个颜色值宽度为60px,最大只能完全显示1000000，否则就超出宽度，则显示以为k计数单位的值
        var num = parseFloat(value);
        if (num % 1000000 <= 1000000) {
            return num.toString();
        }
        return parseInt(num / 1000) + 'k'
    }

}

;// CONCATENATED MODULE: ./src/mapboxgl/overlay/RangeThemeLayer.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/






/**
 * @class RangeThemeLayer
 * @category  Visualization Theme
 * @classdesc 分段专题图层类。
 * @modulecategory Overlay
 * @param {string} name - 图层名。
 * @param {Object} options - 参数。
 * @param {string} [options.id] - 专题图层 ID。默认使用 CommonUtil.createUniqueID("themeLayer_") 创建专题图层 ID。
 * @param {boolean} [options.loadWhileAnimating=true] - 是否实时重绘。
 * @param {mapboxgl.Map} options.map - MapBoxGL Map 对象。
 * @param {number} [options.opacity=1] - 图层不透明度。
 * @param {string} options.themeField - 指定创建专题图字段。
 * @param {Object} options.style - 专题图样式。
 * @param {Object} options.styleGroups - 各专题类型样式组。
 * @param {boolean} [options.isHoverAble=false] - 是否开启 hover 事件。
 * @param {Object} [options.highlightStyle] - hover 的高亮样式。
 * @extends {GeoFeatureThemeLayer}
 * @usage
 */
class Range extends GeoFeature {

    constructor(name, opt_options) {
        super(name, opt_options);
        this.style = opt_options.style;
        this.isHoverAble = opt_options.isHoverAble;
        this.highlightStyle = opt_options.highlightStyle;
        this.themeField = opt_options.themeField;
        this.styleGroups = opt_options.styleGroups;
    }

    /**
     * @function RangeThemeLayer.prototype.createThematicFeature
     * @description 创建专题图要素。
     * @param {Object} feature - 要创建的专题图形要素。
     */
    createThematicFeature(feature) {
        //赋 style
        var style = this.getStyleByData(feature);
        //创建专题要素时的可选参数
        var options = {};
        options.nodesClipPixel = this.nodesClipPixel;
        options.isHoverAble = this.isHoverAble;
        options.isMultiHover = this.isMultiHover;
        options.isClickAble = this.isClickAble;
        options.highlightStyle = ShapeFactory.transformStyle(this.highlightStyle);

        //将数据转为专题要素（Vector）
        var thematicFeature = new ThemeVector(feature, this, ShapeFactory.transformStyle(style), options);

        //直接添加图形到渲染器
        for (var m = 0; m < thematicFeature.shapes.length; m++) {
            this.renderer.addShape(thematicFeature.shapes[m]);
        }

        return thematicFeature;
    }

    /**
     * @private
     * @function RangeThemeLayer.prototype.getStyleByData
     * @description 通过数据获取 style。
     * @param {Object} fea - 要素数据。
     */
    getStyleByData(fea) {
        var style = {};
        var feature = fea;
        style = Util_Util.copyAttributesWithClip(style, this.style);
        if (this.themeField && this.styleGroups && this.styleGroups.length > 0 && feature.attributes) {
            var Sf = this.themeField;
            var Attrs = feature.attributes;
            var Gro = this.styleGroups;
            var isSfInAttrs = false; //指定的 themeField 是否是 feature 的属性字段之一
            var attr = null; //属性值

            for (var property in Attrs) {
                if (Sf === property) {
                    isSfInAttrs = true;
                    attr = Attrs[property];
                    break;
                }
            }
            //判断属性值是否属于styleGroups的某一个范围，以便对获取分组 style
            if (isSfInAttrs) {
                for (var i = 0, len = Gro.length; i < len; i++) {
                    if ((attr >= Gro[i].start) && (attr < Gro[i].end)) {
                        //feature.style = CommonUtil.copyAttributes(feature.style, this.defaultStyle);
                        var sty1 = Gro[i].style;
                        style = Util_Util.copyAttributesWithClip(style, sty1);
                    }
                }
            }
        }
        if (feature.style && this.isAllowFeatureStyle === true) {
            style = Util_Util.copyAttributesWithClip(feature.style);
        }
        return style;
    }

}

;// CONCATENATED MODULE: ./src/mapboxgl/overlay/RankSymbolThemeLayer.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/




/**
 * @class RankSymbolThemeLayer
 * @category  Visualization Theme
 * @classdesc 等级符号专题图层类。
 * @modulecategory Overlay
 * @param {string} name - 图层名。
 * @param {string} symbolType - 符号类型。
 * @param {Object} opt_options - 参数。
 * @param {string} [opt_options.id] - 专题图层 ID。默认使用 CommonUtil.createUniqueID("themeLayer_") 创建专题图层 ID。
 * @param {boolean} [opt_options.loadWhileAnimating=true] - 是否实时重绘。
 * @param {mapboxgl.Map} opt_options.map - MapBoxGL Map 对象。
 * @param {string} opt_options.themeFields - 指定创建专题图字段。
 * @param {number} [opt_options.opacity=1] - 图层不透明度。
 * @param {boolean} [opt_options.isOverLay=true] - 是否进行压盖处理，如果设为 true，图表绘制过程中将隐藏对已在图层中绘制的图表产生压盖的图表。
 * @param {string} [opt_options.chartsType] - 图表类型。目前可用："Bar", "Line", "Pie"。
 * @param {Object} [opt_options.symbolSetting] - 各类型图表的 symbolSetting 对象可设属性请参考具体图表模型类的注释中对 symbolSetting 对象可设属性的描述。symbolSetting 对象通常都具有以下 5 个基础可设属性:
 * @param {number} [opt_options.symbolSetting.width] - 专题要素（图表）宽度。
 * @param {number} [opt_options.symbolSetting.height] - 专题要素（图表）高度。
 * @param {Array.<number>} opt_options.symbolSetting.codomain - 值域，长度为 2 的一维数组，第一个元素表示值域下限，第二个元素表示值域上限。
 * @param {number} [opt_options.symbolSetting.XOffset] - 专题要素（图表）在 X 方向上的偏移值，单位像素。
 * @param {number} [opt_options.symbolSetting.YOffset] - 专题要素（图表）在 Y 方向上的偏移值，单位像素。
 * @param {Array.<number>} opt_options.symbolSetting.dataViewBoxParameter - 数据视图框 dataViewBox 参数，它是指图表框 chartBox （由图表位置、图表宽度、图表高度构成的图表范围框）在左、下，右，上四个方向上的内偏距值，长度为 4 的一维数组。
 * @param {number} opt_options.symbolSetting.decimalNumber - 数据值数组 dataValues 元素值小数位数，数据的小数位处理参数，取值范围：[0, 16]。如果不设置此参数，在取数据值时不对数据做小数位处理。
 * @extends {GraphThemeLayer}
 * @usage
 */
class RankSymbol extends Graph {

    constructor(name, symbolType, opt_options) {
        super(name, symbolType, opt_options);
        this.symbolType = symbolType;
        this.symbolSetting = opt_options.symbolSetting;
        this.themeField = opt_options.themeField;
    }

    /**
     * @function RankSymbolThemeLayer.prototype.setSymbolType
     * @description 设置标志符号。
     * @param {string} [symbolType] - 符号类型。
     */
    setSymbolType(symbolType) {
        this.symbolType = symbolType;
        this.redraw();
    }

    /**
     * @function RankSymbolThemeLayer.prototype.createThematicFeature
     * @description 创建专题图形要素。
     * @param {Object} feature - 要创建的专题图形要素。
     */
    createThematicFeature(feature) {
        var thematicFeature;
        // 检查图形创建条件并创建图形
        if (Theme[this.symbolType] && this.themeField && this.symbolSetting) {
            thematicFeature = new Theme[this.symbolType](feature, this, [this.themeField], this.symbolSetting);
        }
        // thematicFeature 是否创建成功
        if (!thematicFeature) {
            return false;
        }
        // 对专题要素执行图形装载
        thematicFeature.assembleShapes();
        return thematicFeature;
    }

}

;// CONCATENATED MODULE: ./src/mapboxgl/overlay/UniqueTheme3DLayer.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/



/**
 * @class UniqueTheme3DLayer
 * @category  Visualization Theme
 * @classdesc 三维单值专题图类。
 * @modulecategory Overlay
 * @param {string} [id] - 专题图图层 ID。默认使用 CommonUtil.createUniqueID("theme3DLayer") 创建专题图层 ID。
 * @param {Object} layerOptions - 专题图图层配置项，参数继承自 Theme3DLayer。
 * @param {number} [layerOptions.height] - 新增参数，如果数据指定的 heightField (默认为 height )没有可以表示高度的字段，可以为所有数据统一设置一个高度。
 * @param {Array} layerOptions.colorStops - 新增参数，数据颜色分段数组。
 * @usage
 */
class UniqueTheme3DLayer extends Theme3DLayer {


    constructor(id, layerOptions) {
        super(id, layerOptions);
        /**
         * @member {Array} UniqueTheme3DLayer.prototype.colorStops
         * @description 数据颜色数组，如[["绿地","#CD7054"],["道路","#AD1283"]]。
         */
        this.colorStops = null;
        this._extend(this, layerOptions);
    }

    /**
     * @function UniqueTheme3DLayer.prototype.getLayerStyleOptions
     * @description 获取图层样式。
     * @returns {Object} Mapbox GL 样式对象。
     */
    getLayerStyleOptions() {
        var opacity = this.opacity == null ? 1 : this.opacity;
        opacity = isNaN(parseFloat(opacity)) ? 1 : parseFloat(opacity);
        var options = {
            'fill-extrusion-color': {
                'stops': this.colorStops,
                'property': this.themeField,
                'type': 'categorical'
            },
            'fill-extrusion-opacity': opacity
        };

        if (this.height != null) {
            options['fill-extrusion-height'] = this.height;
        } else {
            options['fill-extrusion-height'] = {
                'property': this.heightField || 'height',
                'type': 'categorical'
            };
        }

        if (this.baseHeightField) {
            options['fill-extrusion-base'] = {
                'property': this.baseHeightField,
                'type': 'identity'
            }
        }
        return options;
    }

    /**
     * @function UniqueTheme3DLayer.prototype.getHighlightStyleOptions
     * @description 获取高亮样式。
     * @returns {Object} Mapbox GL 样式对象。
     */
    getHighlightStyleOptions() {
        var color = (this.highlight && this.highlight.color != null) ? this.highlight.color : '#ADA91E';
        var paint = {
            'fill-extrusion-color': color,
            'fill-extrusion-height': {
                "stops": this.heightStops,
                "property": this.heightField,
                'type': 'categorical'
            },
            'fill-extrusion-opacity': this.highlight && this.highlight.opacity || 0.6
        };
        if (this.height != null) {
            paint['fill-extrusion-height'] = this.height || 0;
        }
        return paint;
    }

    _createLegendElement() {
        var legendListElement = "<ul>";
        var len = this.colorStops && this.colorStops.length || 0;
        for (var i = 0; i < len; i++) {
            var text = this.colorStops[i][0];
            var color = this.colorStops[i][1];
            legendListElement += "<li><span style='background-color:" + color + ";'></span><span>" + text + "</span></li>";
        }
        legendListElement += "</ul>";
        return legendListElement;
    }
}

;// CONCATENATED MODULE: ./src/mapboxgl/overlay/UniqueThemeLayer.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/






/**
 * @class UniqueThemeLayer
 * @category  Visualization Theme
 * @classdesc  单值专题图层类。
 * @modulecategory Overlay
 * @param {string} name - 图层名。
 * @param {Object} opt_options - 参数。
 * @param {string} opt_options.themeField - 指定创建专题图字段。
 * @param {Object} opt_options.style - 专题图样式。
 * @param {Object} opt_options.styleGroups - 各专题类型样式组。
 * @param {mapboxgl.Map} opt_options.map - MapBoxGL Map 对象。
 * @param {string} [opt_options.id] - 专题图层 ID。默认使用 CommonUtil.createUniqueID("themeLayer_") 创建专题图层 ID。
 * @param {boolean} [opt_options.loadWhileAnimating=true] - 是否实时重绘。
 * @param {number} [opt_options.opacity=1] - 图层不透明度。
 * @param {boolean} [opt_options.isHoverAble=false] - 是否开启 hover 事件。
 * @param {Object} [opt_options.highlightStyle] -  hover 的高亮样式。
 * @extends {GeoFeatureThemeLayer}
 * @usage
 */
class Unique extends GeoFeature {

    constructor(name, opt_options) {
        super(name, opt_options);
        this.themeField = opt_options.themeField;
        this.style = opt_options.style;
        this.styleGroups = opt_options.styleGroups;
        this.isHoverAble = opt_options.isHoverAble;
        this.highlightStyle = opt_options.highlightStyle;
    }

    /**
     * @private
     * @function UniqueThemeLayer.prototype.createThematicFeature
     * @description 创建专题图要素。
     * @param {Object} feature - 要创建的专题图形要素。
     */
    createThematicFeature(feature) {
        //赋 style
        var style = this.getStyleByData(feature);
        //创建专题要素时的可选参数
        var options = {};
        options.nodesClipPixel = this.nodesClipPixel;
        options.isHoverAble = this.isHoverAble;
        options.isMultiHover = this.isMultiHover;
        options.isClickAble = this.isClickAble;
        options.highlightStyle = ShapeFactory.transformStyle(this.highlightStyle);

        //将数据转为专题要素（Vector）
        var thematicFeature = new ThemeVector(feature, this, ShapeFactory.transformStyle(style), options);

        //直接添加图形到渲染器
        for (var m = 0; m < thematicFeature.shapes.length; m++) {
            this.renderer.addShape(thematicFeature.shapes[m]);
        }

        return thematicFeature;
    }

    /**
     * @private
     * @function UniqueThemeLayer.prototype.getStyleByData
     * @description 通过数据获取 style。
     * @param {Object} fea - 要素数据。
     */
    getStyleByData(fea) {
        var style = {};
        var feature = fea;
        style = Util_Util.copyAttributesWithClip(style, this.style);
        if (this.themeField && this.styleGroups && this.styleGroups.length > 0 && feature.attributes) {
            var tf = this.themeField;
            var Attrs = feature.attributes;
            var Gro = this.styleGroups;
            var isSfInAttrs = false; //指定的 themeField 是否是 feature 的属性字段之一
            var attr = null; //属性值
            for (var property in Attrs) {
                if (tf === property) {
                    isSfInAttrs = true;
                    attr = Attrs[property];
                    break;
                }
            }
            //判断属性值是否属于styleGroups的某一个范围，以便对获取分组 style
            if (isSfInAttrs) {
                for (var i = 0, len = Gro.length; i < len; i++) {
                    if ((attr).toString() === ( Gro[i].value).toString()) {
                        //feature.style = CommonUtil.copyAttributes(feature.style, this.defaultStyle);
                        var sty1 = Gro[i].style;
                        style = Util_Util.copyAttributesWithClip(style, sty1);
                    }
                }
            }
        }
        if (feature.style && this.isAllowFeatureStyle === true) {
            style = Util_Util.copyAttributesWithClip(feature.style);
        }
        return style;
    }

}

;// CONCATENATED MODULE: ./src/common/overlay/graphic/GraphicLayerRenderer.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/
 

 const defaultProps = {
     color: [0, 0, 0, 255],
     opacity: 0.8,
     radius: 10,
     radiusScale: 1,
     radiusMinPixels: 0,
     radiusMaxPixels: Number.MAX_SAFE_INTEGER,
     strokeWidth: 1,
     outline: false
 };
 
 /**
  * @private
  * @class GraphicLayerRenderer
  * @category  Visualization Graphic
  * @classdesc 高效率点图层。
  * @param {string} [id] - 图层id。
  * @param {Object} options - 参数。
  * @param {Array.<Graphic>} options.graphics - 点要素对象数组 。
  * @param {Array.<number>} [options.color=[0, 0, 0, 255]] - 颜色,目前只支持 rgba 数组。
  * @param {number} [options.radius=10] - 半径。
  * @param {number} [options.opacity=0.8] - 不透明度。
  * @param {Array.<number>} [options.highlightColor=[0, 0, 128, 128]] - 高亮颜色，目前只支持 rgba 数组。
  * @param {number} [options.radiusScale=1] - 点放大倍数。
  * @param {number} [options.radiusMinPixels=0] - 半径最小值(像素)。
  * @param {number} [options.radiusMaxPixels=Number.MAX_SAFE_INTEGER] - 半径最大值(像素)。
  * @param {number} [options.strokeWidth=1] - 边框大小。
  * @param {boolean} [options.outline=false] - 是否显示边框。
  * @param {Object} [functions] - 图层传递给渲染器调用的方法。
  * @param {Object} [mapOptions] - 图层传递给渲染器的地图元素信息。
  * @usage
  */
 class GraphicLayerRenderer {
 
     constructor(id, options, functions, mapOptions) {
         let opt = Util_Util.assign(this,  defaultProps, options);
         /**
          * @member {string} GraphicLayerRenderer.prototype.id
          * @description 高效率点图层 ID。
          */
         this.id = id;
         /**
          * @member {Array.<Graphic>} GraphicLayerRenderer.prototype.graphics
          * @description 点要素对象数组。
          */
         this.graphics = [].concat(opt.graphics);
 
         /**
          * @member {boolean} [GraphicLayerRenderer.prototype.visibility=true]
          * @description 图层显示状态属性。
          */
         this.mapOptions = mapOptions;
         this.functions = functions;
         this.visibility = true;
         this.init();
     }

     init() {
        if (this.canvas) {
            this.mapOptions.targetElement.appendChild(this.canvas);
        }
         this._initContainer();
         let mapState = this.getState();
         let {
             data,
             color,
             radius,
             opacity,
             highlightColor,
             radiusScale,
             radiusMinPixels,
             radiusMaxPixels,
             strokeWidth,
             outline
         } = mapState;
         let me = this;
         let layerOptions = {
             id: 'scatter-plot',
             data,
             pickable: Boolean(this.onClick) || Boolean(this.onHover),
             autoHighlight: true,
             color: color,
             opacity: opacity,
             radius: radius,
             radiusScale: radiusScale,
             highlightColor: highlightColor,
             radiusMinPixels: radiusMinPixels,
             radiusMaxPixels: radiusMaxPixels,
             strokeWidth: strokeWidth,
             outline: outline,
             isGeographicCoordinateSystem: this.isGeographicCoordinateSystem,
             coordinateSystem: this.coordinateSystem,
             getPosition: function (point) {
                 if (!point) {
                     return [0, 0, 0];
                 }
                 let lngLat = point.getLngLat();
                 return lngLat && [lngLat.lng, lngLat.lat, 0];
             },
             getColor: function (point) {
                 let style = point && point.getStyle();
                 let color1 = style && style.color || me.color;
                 return color1;
             },
             getRadius: function (point) {
                 let style = point && point.getStyle();
                 return style && style.radius || me.radius
             },
             updateTriggers: {
                 getColor: [color],
                 getRadius: [radius]
             }
         };
         if (this.onClick) {
             layerOptions.onClick = this.onClick;
         }
         if (this.onHover) {
             layerOptions.onHover = this.onHover;
         }
         this.layer = new window.DeckGL.ScatterplotLayer(layerOptions);
         let deckOptions = {};
         for (let key in mapState) {
             deckOptions[key] = mapState[key];
         }
         let width = parseInt(this.canvas.style.width);
         let height = parseInt(this.canvas.style.height);
         deckOptions.width = width;
         deckOptions.height = height;
         deckOptions.layers = [this.layer];
         deckOptions.canvas = this.canvas;
         this.deckGL = new window.DeckGL.experimental.DeckGLJS(deckOptions);
         this.draw();
     }
 
     /**
      * @function GraphicLayerRenderer.prototype.setStyle
      * @description 设置图层整体样式。
      * @param {Object} styleOptions - 样式对象。
      * @param {Array.<number>} [styleOptions.color=[0, 0, 0, 255]] - 点颜色。
      * @param {number} [styleOptions.radius=10] - 点半径。
      * @param {number} [styleOptions.opacity=0.8] - 不透明度。
      * @param {Array.<number>}  [styleOptions.highlightColor=[0, 0, 128, 128]] - 高亮颜色，目前只支持 rgba 数组。
      * @param {number} [styleOptions.radiusScale=1] - 点放大倍数。
      * @param {number} [styleOptions.radiusMinPixels=0] - 半径最小值(像素)。
      * @param {number} [styleOptions.radiusMaxPixels=Number.MAX_SAFE_INTEGER] - 半径最大值(像素)。
      * @param {number} [styleOptions.strokeWidth=1] - 边框大小。
      * @param {boolean} [styleOptions.outline=false] - 是否显示边框。
      */
     setStyle(styleOptions) {
         let styleOpt = {
             color: this.color,
             radius: this.radius,
             opacity: this.opacity,
             highlightColor: this.highlightColor,
             radiusScale: this.radiusScale,
             radiusMinPixels: this.radiusMinPixels,
             radiusMaxPixels: this.radiusMaxPixels,
             strokeWidth: this.strokeWidth,
             outline: this.outline
         };
 
         Util_Util.assign(this, styleOpt, styleOptions);
         this.update();
     }
 
     /**
      * @function GraphicLayerRenderer.prototype.setGraphics
      * @description 设置绘制的点要素数据，会覆盖之前的所有要素。
      * @param {Array.<Graphic>} graphics - 点要素对象数组。
      */
     setGraphics(graphics) {
         this.graphics = this.graphics || [];
         this.graphics.length = 0;
         let sGraphics = !Util_Util.isArray(graphics) ? [graphics] : [].concat(graphics);
         //this.layer.props.data不能被重新赋值，只能在原数组上进行操作
         if (!this.layer.props.data) {
             this.layer.props.data = [];
         }
         this.layer.props.data.length = 0;
         for (let i = 0; i < sGraphics.length; i++) {
             this.layer.props.data.push(sGraphics[i]);
         }
         this.update();
     }
 
     /**
      * @function GraphicLayerRenderer.prototype.addGraphics
      * @description 添加点要素，不会覆盖之前的要素。
      * @param {Array.<Graphic>} graphics - 点要素对象数组。
      */
     addGraphics(graphics) {
         this.graphics = this.graphics || [];
         let sGraphics = !Util_Util.isArray(graphics) ? [graphics] : [].concat(graphics);
         //this.layer.props.data不能被重新赋值，只能在原数组上进行操作
         if (!this.layer.props.data) {
             this.layer.props.data = [];
         }
         for (let i = 0; i < sGraphics.length; i++) {
             this.layer.props.data.push(sGraphics[i]);
         }
         this.update();
     }
 
     /**
      * @function GraphicLayerRenderer.prototype.getGraphicBy
      * @description 在 Vector 的要素数组 graphics 里面遍历每一个 graphic，当 graphic[property]===value 时，返回此 graphic（并且只返回第一个）。
      * @param {string} property - graphic 的某个属性名称。
      * @param {string} value - property 所对应的值。
      * @returns {Graphic} 一个匹配的 graphic。
      */
     getGraphicBy(property, value) {
         let graphic = null;
         for (let index in this.graphics) {
             if (this.graphics[index][property] === value) {
                 graphic = this.graphics[index];
                 break;
             }
         }
         return graphic;
     }
 
     /**
      * @function GraphicLayerRenderer.prototype.getGraphicById
      * @description 通过给定一个 ID，返回对应的矢量要素。
      * @param {string} graphicId - 矢量要素的属性 ID。
      * @returns {Graphic} 一个匹配的 graphic。
      */
     getGraphicById(graphicId) {
         return this.getGraphicBy("id", graphicId);
     }
 
     /**
      * @function GraphicLayerRenderer.prototype.getGraphicsByAttribute
      * @description 通过给定一个属性的 key 值和 value 值，返回所有匹配的要素数组。
      * @param {string} attrName - graphic 的某个属性名称。
      * @param {string} attrValue - property 所对应的值。
      * @returns {Array.<Graphic>} 一个匹配的 graphic 数组。
      */
     getGraphicsByAttribute(attrName, attrValue) {
         var graphic,
             foundgraphics = [];
         for (let index in this.graphics) {
             graphic = this.graphics[index];
             if (graphic && graphic.attributes) {
                 if (graphic.attributes[attrName] === attrValue) {
                     foundgraphics.push(graphic);
                 }
             }
         }
         return foundgraphics;
     }
 
     /**
      * @function GraphicLayerRenderer.prototype.removeGraphics
      * @description 删除要素数组，默认将删除所有要素
      * @param {Array.<Graphic>} [graphics=null] - 删除的 graphics 数组
      */
     removeGraphics(graphics = null) {
         //当 graphics 为 null 、为空数组，或 === this.graphics，则清除所有要素
         if (!graphics || graphics.length === 0 || graphics === this.graphics) {
             this.graphics.length = 0;
 
             if (this.layer.props.data) {
                 this.layer.props.data.length = 0;
             }
             this.update();
             return;
         }
 
         if (!(Util_Util.isArray(graphics))) {
             graphics = [graphics];
         }
 
         for (let i = graphics.length - 1; i >= 0; i--) {
             let graphic = graphics[i];
 
             //如果我们传入的grapchic在graphics数组中没有的话，则不进行删除，
             //并将其放入未删除的数组中。
             let findex = Util_Util.indexOf(this.graphics, graphic);
 
             if (findex === -1) {
                 continue;
             }
             this.graphics.splice(findex, 1);
         }
 
         //删除完成后重新设置 setGraphics，以更新
         this.update();
     }
 
     /**
      * @function GraphicLayerRenderer.prototype.update
      * @description 更新图层。
      */
     update() {
         if (this.layer.lifecycle !== 'Awaiting state') {
             this.layer.setChangeFlags({
                 dataChanged: true,
                 propsChanged: true,
                 viewportChanged: true,
                 updateTriggersChanged: true
             });
             let state = this.getState();
             let width = parseInt(this.canvas.style.width);
             let height = parseInt(this.canvas.style.height);
             state.width = width;
             state.height = height;
             this.layer.setState(state);
         }
     }
 
     /**
      * @function GraphicLayerRenderer.prototype.clear
      * @description 释放图层资源。
      */
     clear() {
         this.removeGraphics();
         this.deckGL.finalize();
     }
 
     /**
      * @function GraphicLayerRenderer.prototype.remove
      * @description 删除该图层。
      */
     remove() {
        this.mapOptions.targetElement.removeChild(this.canvas);
     }
 
     /**
      * @function GraphicLayerRenderer.prototype.destroy
      * @deprecated
      * @description 删除该图层，并释放图层资源。
      */
     destroy() {
         this.remove();
         this.clear();
     }
 
     /**
      * @function GraphicLayerRenderer.prototype.moveTo
      * @description 将图层移动到某个图层之前。
      * @param {string} layerID - 待插入的图层 ID。
      * @param {boolean} [before=true] - 是否将本图层插入到图层 ID 为 layerID 的图层之前。
      */
     moveTo(layerID, before) {
         var layer = document.getElementById(this.id);
         before = before !== undefined ? before : true;
         if (before) {
             var beforeLayer = document.getElementById(layerID);
             if (layer && beforeLayer) {
                 beforeLayer.parentNode.insertBefore(layer, beforeLayer);
             }
             return;
         }
         var nextLayer = document.getElementById(layerID);
         if (layer) {
             if (nextLayer.nextSibling) {
                 nextLayer.parentNode.insertBefore(layer, nextLayer.nextSibling);
                 return;
             }
             nextLayer.parentNode.appendChild(layer);
         }
     }
 
     /**
      * @function GraphicLayerRenderer.prototype.setVisibility
      * @description 设置图层可见性。
      * @param {boolean} [visibility] - 是否显示图层（当前地图的 resolution 在最大最小 resolution 之间）。
      */
     setVisibility(visibility) {
         if (this.canvas && visibility !== this.visibility) {
             this.visibility = visibility;
             this.canvas.style.display = visibility ? "block" : "none";
         }
     }
 
     /**
      * @function GraphicLayerRenderer.prototype.draw
      * @description 绘制图层。
      */
     draw() {
         let mapState = this.getState();
         let deckOptions = {};
 
         for (let key in mapState) {
             deckOptions[key] = mapState[key];
         }
         let width = parseInt(this.canvas.style.width);
         let height = parseInt(this.canvas.style.height);
         deckOptions.width = width;
         deckOptions.height = height;
         deckOptions.layers = [this.layer];
         deckOptions.canvas = this.canvas;
         this.deckGL.setProps(deckOptions);
     }
 
     _initContainer() {
        this.canvas = this._createCanvas(this.mapOptions.mapElement);
        this.mapOptions.targetElement.appendChild(this.canvas);
     }
 
     _createCanvas(mapElement) {
         let canvas = document.createElement('canvas');
         if (this.id) {
             canvas.id = this.id;
         }
         canvas.style.position = 'absolute';
         canvas.style.top = 0 + "px";
         canvas.style.left = 0 + "px";
         canvas.style.cursor = "";
         canvas.width = parseInt(mapElement.style.width);
         canvas.height = parseInt(mapElement.style.height);
         canvas.style.width = mapElement.style.width;
         canvas.style.height = mapElement.style.height;
         return canvas;
     }

     getState() {
        let mapState = this.functions.getMapState();
        return {
            data: this.graphics,
            color: this.color,
            radius: this.radius,
            opacity: this.opacity,
            highlightColor: this.highlightColor,
            radiusScale: this.radiusScale,
            radiusMinPixels: this.radiusMinPixels,
            radiusMaxPixels: this.radiusMaxPixels,
            strokeWidth: this.strokeWidth,
            outline: this.outline,
            ...mapState
        };
    }
 }
 
;// CONCATENATED MODULE: ./src/mapboxgl/overlay/GraphicLayer.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/
 
 
 

 /**
  * @class GraphicLayer
  * @category  Visualization Graphic
  * @classdesc 高效率点图层类。
  * @modulecategory Overlay
  * @version 11.1.0
  * @param {string} [id] - 图层id。默认使用 CommonUtil.createUniqueID("graphicLayer_") 创建专题图层 ID。
  * @param {Object} options - 参数。
  * @param {Array.<Graphic>} options.graphics - 点要素对象数组 。
  * @param {Array.<number>} [options.color=[0, 0, 0, 255]] - 颜色,目前只支持 rgba 数组。
  * @param {number} [options.radius=10] - 半径。
  * @param {number} [options.opacity=0.8] - 不透明度。
  * @param {Array.<number>} [options.highlightColor=[0, 0, 128, 128]] - 高亮颜色，目前只支持 rgba 数组。
  * @param {number} [options.radiusScale=1] - 点放大倍数。
  * @param {number} [options.radiusMinPixels=0] - 半径最小值(像素)。
  * @param {number} [options.radiusMaxPixels=Number.MAX_SAFE_INTEGER] - 半径最大值(像素)。
  * @param {number} [options.strokeWidth=1] - 边框大小。
  * @param {boolean} [options.outline=false] - 是否显示边框。
  * @usage
  */
 class GraphicLayer {

     constructor(id, options) {
        this.options = options;
         /**
          * @member {string} GraphicLayer.prototype.id
          * @description 高效率点图层 ID。
          */
         this.id = id || Util_Util.createUniqueID("graphicLayer_");
         this.type = 'custom';
         this.renderingMode = '3d';
         this.overlay = true;
     }

     /**
      * @function GraphicLayer.prototype.addTo
      * @deprecated
      * @description 添加该图层，将在下个版本废弃，请使用 onAdd() 代替。
      * @param {mapboxgl.Map} map - mapboxgl Map 对象。
      * @returns this
      */
     addTo(map) {
        this.onAdd(map);
        return this;
     }

     /**
      * @function GraphicLayer.prototype.onAdd
      * @description 添加该图层。
      * @param {mapboxgl.Map} map - mapboxgl Map 对象。
      * @returns {GraphicLayer}
      */
     onAdd(map) {
        this.map = map;
        this.renderer = new GraphicLayerRenderer(this.id, this.options, {
          getMapState: this.getMapState.bind(this)
        }, { targetElement: this.map.getCanvasContainer(), mapElement: this.map.getCanvas() });
     }

     /**
      * @function GraphicLayer.prototype.onRemove
      * @deprecated
      * @description 删除该图层，并释放图层资源。
      */
      onRemove() {
        this.remove();
        this.clear();
      }
    /**
      * @function GraphicLayer.prototype.render
      * @description 渲染图层。
      */
     render() {
        this.renderer.draw();
     }

     /**
      * @function GraphicLayer.prototype.setStyle
      * @description 设置图层整体样式。
      * @param {Object} styleOptions - 样式对象。
      * @param {Array.<number>} [styleOptions.color=[0, 0, 0, 255]] - 点颜色。
      * @param {number} [styleOptions.radius=10] - 点半径。
      * @param {number} [styleOptions.opacity=0.8] - 不透明度。
      * @param {Array.<number>}  [styleOptions.highlightColor=[0, 0, 128, 128]] - 高亮颜色，目前只支持 rgba 数组。
      * @param {number} [styleOptions.radiusScale=1] - 点放大倍数。
      * @param {number} [styleOptions.radiusMinPixels=0] - 半径最小值(像素)。
      * @param {number} [styleOptions.radiusMaxPixels=Number.MAX_SAFE_INTEGER] - 半径最大值(像素)。
      * @param {number} [styleOptions.strokeWidth=1] - 边框大小。
      * @param {boolean} [styleOptions.outline=false] - 是否显示边框。
      */
     setStyle(styleOptions) {
        this.renderer && this.renderer.setStyle(styleOptions);
     }

     /**
      * @function GraphicLayer.prototype.setGraphics
      * @description 设置绘制的点要素数据，会覆盖之前的所有要素。
      * @param {Array.<Graphic>} graphics - 点要素对象数组。
      */
     setGraphics(graphics) {
        this.renderer && this.renderer.setGraphics(graphics);
     }

     /**
      * @function GraphicLayer.prototype.addGraphics
      * @description 添加点要素，不会覆盖之前的要素。
      * @param {Array.<Graphic>} graphics - 点要素对象数组。
      */
     addGraphics(graphics) {
        this.renderer && this.renderer.addGraphics(graphics);
     }

     /**
      * @function GraphicLayer.prototype.getGraphicBy
      * @description 在 Vector 的要素数组 graphics 里面遍历每一个 graphic，当 graphic[property]===value 时，返回此 graphic（并且只返回第一个）。
      * @param {string} property - graphic 的某个属性名称。
      * @param {string} value - property 所对应的值。
      * @returns {Graphic} 一个匹配的 graphic。
      */
     getGraphicBy(property, value) {
        return this.renderer && this.renderer.getGraphicBy(property, value);
     }

     /**
      * @function GraphicLayer.prototype.getGraphicById
      * @description 通过给定一个 ID，返回对应的矢量要素。
      * @param {string} graphicId - 矢量要素的属性 ID。
      * @returns {Graphic} 一个匹配的 graphic。
      */
     getGraphicById(graphicId) {
         return this.getGraphicBy("id", graphicId);
     }

     /**
      * @function GraphicLayer.prototype.getGraphicsByAttribute
      * @description 通过给定一个属性的 key 值和 value 值，返回所有匹配的要素数组。
      * @param {string} attrName - graphic 的某个属性名称。
      * @param {string} attrValue - property 所对应的值。
      * @returns {Array.<Graphic>} 一个匹配的 graphic 数组。
      */
     getGraphicsByAttribute(attrName, attrValue) {
        return this.renderer && this.renderer.getGraphicsByAttribute(attrName, attrValue);
     }

     /**
      * @function GraphicLayer.prototype.removeGraphics
      * @description 删除要素数组，默认将删除所有要素
      * @param {Array.<Graphic>} [graphics=null] - 删除的 graphics 数组
      */
     removeGraphics(graphics = null) {
         this.renderer && this.renderer.removeGraphics(graphics);
     }

     /**
      * @function GraphicLayer.prototype.clear
      * @description 释放图层资源。
      */
     clear() {
         this.renderer && this.renderer.clear();
     }

     /**
      * @function GraphicLayer.prototype.remove
      * @description 删除该图层。
      */
     remove() {
         this.renderer && this.renderer.remove();
     }

     /**
      * @function GraphicLayer.prototype.moveTo
      * @description 将图层移动到某个图层之前。
      * @param {string} layerID - 待插入的图层 ID。
      * @param {boolean} [before=true] - 是否将本图层插入到图层 ID 为 layerID 的图层之前。
      */
     moveTo(layerID, before) {
        this.renderer.moveTo(layerID, before);
     }

     /**
      * @function GraphicLayer.prototype.setVisibility
      * @description 设置图层可见性。
      * @param {boolean} [visibility] - 是否显示图层（当前地图的 resolution 在最大最小 resolution 之间）。
      */
     setVisibility(visibility) {
         this.renderer.setVisibility(visibility);
     }


     /**
      * @function GraphicLayer.prototype.getState
      * @description 获取当前地图及图层状态。
      * @returns {Object} 地图及图层状态，包含地图状态信息和本图层相关状态。
      */
     getState() {
        return this.renderer.getState();
     }

     /**
      * @function GraphicLayer.prototype.getMapState
      * @description 获取当前地图状态。
      * @returns {Object} 地图状态，包含地图状态信息。
      */
     getMapState() {
        let state = {};
        let center = this.map.getCenter();
        let longitude = center.lng;
        let latitude = center.lat;
        let zoom = this.map.getZoom();
        let maxZoom = this.map.getMaxZoom();
        let pitch = this.map.getPitch();
        let bearing = this.map.getBearing();

        let mapViewport = {
            longitude: longitude,
            latitude: latitude,
            zoom: zoom,
            maxZoom: maxZoom,
            pitch: pitch,
            bearing: bearing
        };
        for (let key in mapViewport) {
            state[key] = mapViewport[key];
        }
        //当使用扩展的mapboxgl代码时有效
        if (this.map.getCRS && this.map.getCRS() !== (external_mapboxgl_default()).CRS.EPSG3857) {
            state.coordinateSystem = this.coordinateSystem;
            state.isGeographicCoordinateSystem = this.isGeographicCoordinateSystem;
        }
         return state;
     }
 }

;// CONCATENATED MODULE: external "function(){try{return THREE}catch(e){return {}}}()"
const external_function_try_return_THREE_catch_e_return_namespaceObject = function(){try{return THREE}catch(e){return {}}}();
;// CONCATENATED MODULE: ./src/common/overlay/threejs/Transform.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/
function wrap(source, min, max) {
    if (source === max || source === min) {
        return source;
    }
    let len = max - min;
    return ((source - min) % len + len) % len + min
}

function rad(angle) {
    return angle * Math.PI / 180;
}


var Projection = {

    R: 6378137,
    minZoom: 0,
    maxZoom: 22,
    nativeMaxZoom: 19,

    RAD: Math.PI / 180,
    METERS_PER_DEGREE: 6378137 * Math.PI / 180,
    MAX_LATITUDE: 85.0511287798,

    project: function (lngLat) {
        const rad = this.RAD,
            metersPerDegree = this.METERS_PER_DEGREE,
            max = this.MAX_LATITUDE;

        let ll = (lngLat instanceof Array)
            ? {lng: lngLat[0], lat: lngLat[1]}
            : {lng: lngLat.lng, lat: lngLat.lat};

        let lng = ll.lng, lat = Math.max(Math.min(max, ll.lat), -max);
        let c;
        if (lat === 0) {
            c = 0;
        } else {
            c = Math.log(Math.tan((90 + lat) * rad / 2)) / rad;
        }
        return {x: lng * metersPerDegree, y: c * metersPerDegree};

    },

    unproject: function (point) {
        const x = point.x,
            y = point.y;
        const rad = this.RAD,
            metersPerDegree = this.METERS_PER_DEGREE;
        let c;
        if (y === 0) {
            c = 0;
        } else {
            c = y / metersPerDegree;
            c = (2 * Math.atan(Math.exp(c * rad)) - Math.PI / 2) / rad;
        }
        return {lng: wrap(x / metersPerDegree, -180, 180), lat: wrap(c, -this.MAX_LATITUDE, this.MAX_LATITUDE)};
    },

    locate: function (lngLat, dx, dy) {
        if (!lngLat) {
            return null;
        }
        dx = !dx ? 0 : dx;
        dy = !dy ? 0 : dy;

        if (!dx && !dy) {
            return lngLat;
        }


        let lng = lngLat.lng;
        if (dx !== 0) {
            let ndx = Math.abs(dx), radLng = rad(lngLat.lng);
            let sLng = 2 * Math.sqrt(Math.pow(Math.sin(ndx / (2 * this.R)), 2) / Math.pow(Math.cos(radLng), 2));
            radLng = radLng + sLng * (ndx > 0 ? 1 : -1);
            lng = wrap(radLng * 180 / Math.PI, -180, 180);
        }

        let lat = lngLat.lat;
        if (dy !== 0) {
            let ndy = Math.abs(dy), radLat = rad(lngLat.lat);
            let sLat = Math.sin(ndy / (2 * this.R)) * 2;
            radLat = radLat + sLat * (ndy > 0 ? 1 : -1);
            lat = wrap(radLat * 180 / Math.PI, -90, 90);
        }
        return {lng, lat};
    },

    getResolution: function (zoom) {
        if (!this.resolutions) {
            var resolutions = [];
            var d = 2 * 6378137 * Math.PI;
            for (var i = 0; i <= this.maxZoom; i++) {
                resolutions[i] = d / (256 * Math.pow(2, i));
            }
            this.resolutions = resolutions;
        }
        let z = (zoom | 0), length = this.resolutions.length;
        z = z < 0 ? 0 : z > length - 1 ? length - 1 : z;
        const res = this.resolutions[z];
        if ((zoom | 0) !== zoom && z !== length - 1) {
            const next = this.resolutions[z + 1];
            return res + (next - res) * (zoom - z);
        }
        return res;
    }
};

var Transform = {
    matrix: [1, -1, 0, 0],
    projection: Projection,

    project: function (lngLat) {
        return this.projection.project(lngLat);
    },

    unproject: function (point) {
        return this.projection.unproject(point);
    },

    lngLatToPoint: function (lngLat, zoom) {
        var pt = this.project(lngLat);
        return this.transform(pt, this.projection.getResolution(zoom));
    },

    locate: function (lngLat, dx, dy) {
        return this.projection.locate(lngLat, dx, dy);
    },

    transform: function (point, scale) {
        return {
            x: this.matrix[0] * (point.x - this.matrix[2]) / scale,
            y: this.matrix[1] * (point.y - this.matrix[3]) / scale
        };
    }
};



;// CONCATENATED MODULE: ./src/common/overlay/threejs/ThreeLayerRenderer.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/
/**
 * reference and modification
 * maptalks.three
 * (https://github.com/maptalks/maptalks.three)
 * Apache Licene 2.0
 * thanks maptalks
 */




const projection = Transform.projection;
const {
  Color: ThreeLayerRenderer_Color,
  Scene,
  WebGLRenderer,
  PerspectiveCamera,
  Vector3,
  Shape: ThreeLayerRenderer_Shape,
  Mesh,
  ExtrudeGeometry
} = external_function_try_return_THREE_catch_e_return_namespaceObject;

const RADIAN = Math.PI / 180;


const ThreeLayerRenderer_frame = window.requestAnimationFrame ||
  window.mozRequestAnimationFrame ||
  window.webkitRequestAnimationFrame ||
  window.msRequestAnimationFrame;

const cancel = window.cancelAnimationFrame ||
  window.mozCancelAnimationFrame ||
  window.webkitCancelAnimationFrame ||
  window.msCancelAnimationFrame;

/**
 * @private
 * @class ThreeLayerRenderer
 * @category  Visualization Three
 * @classdesc Three 图层渲染器
 * @param {ThreeLayer} layer - ThreeJs图层。
 * @param {string} [renderer="gl"] - 图层渲染器，仅支持"gl"。'canvas'在v11.1.0后被弃用。
 * @param {Object} options - threejs渲染器初始化参数对象。参数内容详见:
 *          [WebGLRenderer]{@link https://threejs.org/docs/index.html#api/renderers/WebGLRenderer}
 *
 */
class ThreeLayerRenderer {

  constructor(layer, renderer, options) {
    this._layer = layer;
    this.renderer = renderer || "gl";
    this.options = options;
  }

  setMap(map) {
    this.map = map;
  }

  //开始渲染
  render() {
    if (!this._layer) {
      return;
    }
    this.prepare();
    /**
     * @event ThreeLayer#initialized
     * @description three 初始化之后后触发。
     */
    this._layer.fire("initialized");
    this._layer && this._layer.draw(this.context, this.scene, this.camera);
    /**
     * @event ThreeLayer#draw
     * @description draw 绘制事件，调用提供给外部绘制的接口后触发。
     */
    this._layer.fire("draw");
    this.renderScene();
  }

  update() {
    this.remove();
    this.render();
  }

  //渲染场景（模型已经添加到图层）
  renderScene() {
    this.locationCamera();
    this.animationFrame = this.renderFrame((function () {
      this.animationFrame = null;
      this.context && this.context.render(this.scene, this.camera);
    }).bind(this));
  }

  renderFrame(fn) {
    var render = function () {
      fn && typeof fn === "function" && fn();
    };
    return ThreeLayerRenderer_frame(render);
  }

  resize() {
    this._resetElementSize(this.container);
    this._resetElementSize(this.canvas);

    let width = this.canvas.width,
      height = this.canvas.height;

    let size = this.getMapSize();
    this.camera.aspect = width / height;
    this.camera.updateProjectionMatrix();
    this.context.setSize(size.width, size.height);
    this.renderScene();
  }

  //创建画布、初始化渲染器、初始化相机等
  prepare() {
    if (!this.map) {
      return new Error("map object is necessary");
    }
    if (!this.canvas) {
      this._initContainer();
      this._initThreeRenderer();
      /**
       * @event ThreeLayer#rendererinitialized
       * @description rendererinitialized 事件，初始化 three 渲染器后触发。
       */
      this._layer.fire("rendererinitialized");
    } else {
      this.clear(this.context);
    }
  }

  getMapSize() {
    let container = this.map.getContainer();
    return { width: container.clientWidth, height: container.clientHeight };
  }

  cancelFrame() {
    if (this.animationFrame != null) {
      cancel(this.animationFrame);
    }
  }

  remove() {
    if (this.animationFrame != null) {
      cancel(this.animationFrame);
    }
    this.container.removeChild(this.canvas);
    this.container.parentNode.removeChild(this.container);
    this.context = null;
    this.canvas = null;
    this.container = null;
  }

  //清理画布内容
  clear(context) {
    context && context.clear && context.clear();
    context && context.clearRect && context.clearRect(0, 0, context.canvas.width, context.canvas.height);
  }

  //计算缩放比例
  getScale(zoom) {
    let map = this.map;
    let z = zoom == null ? map.getZoom() : zoom;
    let max = projection.getResolution(projection.nativeMaxZoom),
      res = projection.getResolution(z);
    return res / max;
  }

  getCanvasContainer() {
    return this.container;
  }

  getCanvas() {
    return this.canvas;
  }


  //重新设置相机位置
  locationCamera() {
    let map = this.map;

    let size = this.getMapSize();
    let scale = map.transform.zoomScale(projection.nativeMaxZoom - map.getZoom() - 1);
    let fovRatio = Math.tan(map.transform.fov / 2 * RADIAN);

    let camera = this.camera;

    //倾斜时，相机位置低于Z轴
    let pitch = map.getPitch() * RADIAN;
    let pZ = -scale * size.height / 2 / fovRatio;
    camera.position.z = pZ * Math.cos(pitch);

    let centerPoint = Transform.lngLatToPoint(map.getCenter(), projection.nativeMaxZoom);
    let distance = Math.sin(pitch) * pZ;
    let bearing = map.getBearing() * RADIAN;
    camera.position.x = centerPoint.x + distance * Math.sin(bearing);
    camera.position.y = centerPoint.y - distance * Math.cos(bearing);

    camera.up.set(Math.sin(bearing), -Math.cos(bearing), 0);
    camera.lookAt(new external_function_try_return_THREE_catch_e_return_namespaceObject.Vector3(centerPoint.x, centerPoint.y, 0));

    camera.updateProjectionMatrix();
  }

  /**
   * @function ThreeLayerRenderer.prototype.toThreeShape
   * @description  创建 threejs shape 对象。
   * @param {Array} coordinates - 坐标点数组。
   * @returns {THREE.Shape} threejs shape 对象。
   */
  toThreeShape(coordinates) {
    if (!coordinates) {
      return null;
    }
    let center = this.getCoordinatesCenter(coordinates);
    let centerPoint = this.lngLatToPosition(center);
    let outer = coordinates.map(coords => this.lngLatToPosition({
      lng: coords[0],
      lat: coords[1]
    }).sub(centerPoint));

    return new ThreeLayerRenderer_Shape(outer);
  }

  /**
  * @function ThreeLayerRenderer.prototype.toThreeMesh
  * @description 创建 threejs Mesh 对象。将地理坐标转换成 threejs 3D 模型（适用于挤压模型，如城市建筑）。
  * @param {Array.<Object>} coordinates - 坐标点数组。
  * @param {number} amount - 高度。
  * @param {THREE.Material} material - Threejs 材质对象。
  * @param {boolean} [removeDuplicated] - 是否移除重复的坐标点。
  * @returns {THREE.Mesh} threejs Mesh 对象。
  */
  toThreeMesh(coordinates, amount, material, removeDuplicated) {
    if (!coordinates) {
      return null;
    }
    let coords = coordinates;
    if (removeDuplicated) {
      coords = this.removeDuplicatedCoordinates(coordinates)
    }

    let targetAmount = this.distanceToThreeVector3(amount, amount).x;
    let shape = this.toThreeShape(coords);
    let geometry = new ExtrudeGeometry(shape, {
      'amount': targetAmount,
      'bevelEnabled': true
    });
    let mesh = new Mesh(geometry, material);
    let center = this.lngLatToPosition(this.getCoordinatesCenter(coords));
    mesh.position.set(center.x, center.y, -targetAmount);
    return mesh;
  }

  /**
   * @function ThreeLayerRenderer.prototype.addObject
   * @description 设置threejs 3D 对象的坐标（经纬度）。
   * @param {THREE.Object3D} object3D - threejs 3D 对象及子类对象。
   * @param {(Array.<number>|Object)} coordinate - 添加的 three 对象坐标（经纬度）。
   * @returns {ThreeLayer} ThreeLayer的实例对象。
   */
  addObject(object3D, coordinate) {
    if (coordinate && object3D) {
      this.setPosition(object3D, coordinate);
    }
    this.scene.add(object3D);
  }

  /**
    * @function ThreeLayerRenderer.prototype.clearMesh
    * @description 清除所有 threejs mesh 对象。
    * @returns {ThreeLayer} ThreeLayer的实例对象。
    */
  clearMesh() {
    let scene = this.scene;
    if (!scene) {
      return this;
    }
    for (let i = scene.children.length - 1; i >= 0; i--) {
      if (scene.children[i] instanceof external_function_try_return_THREE_catch_e_return_namespaceObject.Mesh) {
        scene.remove(scene.children[i]);
      }
    }
    return this;
  }

  /**
       * @function ThreeLayerRenderer.prototype.clearAll
       * @description 清除所有 threejs 对象。
       * @param {boolean} clearCamera - 是否清除相机。
       * @returns {ThreeLayer} ThreeLayer的实例对象。
       */
  clearAll(clearCamera) {
    let scene = this.scene;
    if (!scene) {
      return this;
    }
    for (let i = scene.children.length - 1; i >= 0; i--) {
      if (!clearCamera && scene.children[i] instanceof external_function_try_return_THREE_catch_e_return_namespaceObject.Camera) {
        continue;
      }
      scene.remove(scene.children[i]);
    }
    return this;
  }

  /**
     * @function ThreeLayerRenderer.prototype.setPosition
     * @description 设置 threejs 3D 对象的坐标（经纬度）。
     * @param {THREE.Object3D} object3D - threejs 3D 对象及子类对象。
     * @param {(Array.<number>|Object)} coordinate - 添加的 three 对象坐标（经纬度）。
     * @returns {ThreeLayer} ThreeLayer的实例对象。
     */
  setPosition(object3D, coordinate) {
    if (!object3D || !coordinate) {
      return this;
    }

    var pos = this.lngLatToPosition(coordinate);
    object3D.position.set(pos.x, pos.y, pos.z);
    return this;
  }


  /**
   * @function ThreeLayerRenderer.prototype.lngLatToPosition
   * @description 经纬度转threejs 3D 矢量对象。
   * @param {(Array.<number>|Object)} lngLat - 经纬度坐标。
   * @returns {THREE.Vector3} threejs 3D 矢量对象。
   */
  lngLatToPosition(lngLat) {
    let zoom = Transform.projection.nativeMaxZoom;
    let point = Transform.lngLatToPoint(lngLat, zoom);
    return new Vector3(point.x, point.y, -0);
  }

  /**
   * @function ThreeLayerRenderer.prototype.distanceToThreeVector3
   * @description 计算距离指定坐标给定距离的新坐标的 threejs 3D 矢量对象。
   * @param {number} x - x 轴距离，单位米。
   * @param {number} y - y 轴距离，单位米。
   * @param {(Array.<number>|Object)} lngLat - 源坐标。
   * @returns {THREE.Vector3} 目标点的 threejs 3D 矢量对象。
   */
  distanceToThreeVector3(x, y, lngLat) {
    let map = this.map;

    let center = lngLat || map.getCenter(),
      maxZoom = Transform.projection.nativeMaxZoom,
      targetLngLat = Transform.locate(center, x, y);

    let point1 = Transform.lngLatToPoint(center, maxZoom),
      point2 = Transform.lngLatToPoint(targetLngLat, maxZoom);

    let targetX = Math.abs(point2.x - point1.x) * Math.sign(x);
    let targetY = Math.abs(point2.y - point1.y) * Math.sign(y);
    return new Vector3(targetX, targetY, 0);
  }

  /**
   * @function ThreeLayerRenderer.prototype.removeDuplicatedCoordinates
   * @description 移除数组中的重复坐标。
   * @param {(Array.<Array.<number>>)} coordinates - 坐标数组。
   * @returns {(Array.<Array.<number>>)} 新的坐标数组。
   */
  removeDuplicatedCoordinates(coordinates) {
    function equals(point1, point2) {
      return point1[0] === point2[0] && point1[1] === point2[1]
    }

    let coords = [].concat(coordinates);
    let length = coords.length;
    for (let i = length - 1; i >= 1; i--) {
      if (equals(coords[i], coords[i - 1])) {
        coords.splice(i, 1);
      }
    }

    let isClose = equals(coords[0], coords[coords.length - 1]);
    isClose && coords.splice(coords.length - 1, 1);
    return coords;
  }

  /**
   * @function ThreeLayerRenderer.prototype.getCoordinatesCenter
   * @description 获取给定坐标数组的中心坐标。
   * @param {(Array.<Array.<number>>)} coordinates - 坐标数组。
   * @returns {Object} 包含经纬度的坐标对象。
   */
  // 提工具
  getCoordinatesCenter(coordinates) {
    let sumX = 0, sumY = 0, count = 0;
    let i = 0, len = coordinates.length;
    for (; i < len; i++) {
      if (coordinates[i]) {
        sumX += coordinates[i][0];
        sumY += coordinates[i][1];
        count++;
      }
    }
    return {
      lng: sumX / count,
      lat: sumY / count
    };
  }

  _initContainer() {
    var canvas = this._createCanvas();
    var container = this.container = document.createElement("div");
    container.id = this._layer.id;
    container.className = "threejs-wrapper";
    container.style.position = "absolute";
    container.style.left = "0px";
    container.style.top = "0px";
    container.style.overflow = "hidden";
    this._resetElementSize(container);
    container.appendChild(canvas);

    var targetElement = this.map.getCanvasContainer();
    targetElement.appendChild(container)
  }

  _createCanvas() {
    if (this.canvas) {
      return;
    }

    const canvas = this.canvas = document.createElement('canvas');
    canvas.className = "threejs-overlay";
    canvas.style.outline = "none";
    this._resetElementSize(canvas);
    return canvas;
  }

  _resetElementSize(element) {
    if (!element) {
      return;
    }
    const size = this.getMapSize();
    const dpr = window.devicePixelRatio ? window.devicePixelRatio : 1;
    const width = dpr * size.width;
    const height = dpr * size.height;

    element.width = width;
    element.height = height;
    element.style.width = size.width + 'px';
    element.style.height = size.height + 'px';
  }

  _initThreeRenderer() {
    let map = this.map;
    let size = this.getMapSize();

    let renderer = this.renderer || 'gl';
    let context;

    if (renderer === 'gl') {
      context = new WebGLRenderer({
        'canvas': this.canvas,
        'alpha': true,
        'antialias': true,
        'preserveDrawingBuffer': true
      }, this.options);
      context.autoClear = true;
      context.clear();
    }
    context.setClearColor(new ThreeLayerRenderer_Color(1, 1, 1), 0);
    context.canvas = this.canvas;
    this.context = context;

    let fov = map.transform.fov;
    let fovRatio = Math.tan(fov / 2 * RADIAN);
    let maxScale = this.getScale(projection.minZoom) / this.getScale(projection.nativeMaxZoom);
    let far = maxScale * size.height / 2 / fovRatio;

    this.camera = new PerspectiveCamera(fov, size.width / size.height, 1, far);
    this.scene = new Scene();
    this.scene.add(this.camera);
  }
}
;// CONCATENATED MODULE: ./src/mapboxgl/overlay/ThreeLayer.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/
/**
 * reference and modification
 * maptalks.three
 * (https://github.com/maptalks/maptalks.three)
 * Apache Licene 2.0
 * thanks maptalks
 */




/**
 * @class ThreeLayer
 * @category  Visualization Three
 * @classdesc Three 图层类。
 * @modulecategory Overlay
 * @param {string} id - 图层 ID。
 * @param {string} [renderer="gl"] - 图层渲染器，仅支持"gl"。'canvas'在v11.1.0后被弃用。
 * @param {Object} options - 初始化参数。
 * @param {Object} options.threeOptions - threejs 渲染器初始化参数对象。参数内容详见:
 *          {@link THREE.WebGLRenderer}
 *
 * @extends {mapboxgl.Evented}
 * @fires ThreeLayer#render
 * @fires ThreeLayer#renderscene
 * @example
 * var threeLayer = new ThreeLayer('three');
 * //模型绘制
 * threeLayer.on("initialized", draw);
 * threeLayer.addTo(map);
 *
 * function draw() {
 *    var scene=threeLayer.getScene();
 *    camera=threeLayer.getCamera();
 *    var light = new THREE.PointLight(0xffffff);
 *    camera.add(light);
 *    var material = new THREE.MeshPhongMaterial({color: 0xff0000});
 *    //根据坐标点转换成模型
 *    var mesh = this.toThreeMesh(feature.geometry.coordinates, 10, material, true);
 *    //模型添加到3D场景
 *    scene.add(mesh);
 * }
 *
 * 叠加模型可以通过两种方式：</br>
 *     1.调用 threeLayer.toThreeMesh 直接将地理坐标转换成 threejs 3D 模型（适用于挤压模型，如城市建筑），然后添加到 3D 场景
 *     2.使用 ThreeJS 的接口创建好 Mesh,然后调用 threeLayer.setPosition 设置地理位置，然后添加到 3D 场景
 *
 * @usage
 */
class ThreeLayer extends (external_mapboxgl_default()).Evented {

  //options.threeOptions是初始化threejs renderer的参数对象
  constructor(id, renderer, options) {
    super();
    this.id = id;
    this.type = 'custom';
    this.renderingMode = '3d';
    this.overlay = true;
    this.options = options;
    let threeOptions = options && options.threeOptions;
    this.renderer = new ThreeLayerRenderer(this, renderer, threeOptions);
  }

  /**
   * @function ThreeLayer.prototype.onAdd
   * @description 添加图层到地图。
   * @param {Object} map - 地图对象。
   */
  onAdd(map) {
    var me = this;
    me._map = map;
    me.renderer.setMap(map);
    me.renderer.render();
    me.on('render', (function () {
      this.context && this.context.render(this.scene, this.camera);
    }).bind(me.renderer));
    return this;
  }

  /**
   * @function ThreeLayer.prototype.addTo
   * @deprecated
   * @description 添加图层到地图。
   * @param {Object} map - 地图对象。
   * @returns {ThreeLayer} ThreeLayer的实例对象。
   */
  addTo(map) {
    map.addLayer(this);
    return this;
  }

  /**
   * @function ThreeLayer.prototype.toThreeShape
   * @description  创建 threejs shape 对象。
   * @param {Array} coordinates - 坐标点数组。
   * @returns {THREE.Shape} threejs shape 对象。
   */
  toThreeShape(coordinates) {
    return this.renderer.toThreeShape(coordinates);
  }

  /**
   * @function ThreeLayer.prototype.toThreeMesh
   * @description 创建 threejs Mesh 对象。将地理坐标转换成 threejs 3D 模型（适用于挤压模型，如城市建筑）。
   * @param {Array.<Object>} coordinates - 坐标点数组。
   * @param {number} amount - 高度。
   * @param {THREE.Material} material - Threejs 材质对象。
   * @param {boolean} [removeDuplicated] - 是否移除重复的坐标点。
   * @returns {THREE.Mesh} threejs Mesh 对象。
   */
  toThreeMesh(coordinates, amount, material, removeDuplicated) {
    return this.renderer.toThreeMesh(coordinates, amount, material, removeDuplicated);
  }

  /**
   * @function ThreeLayer.prototype.addObject
   * @description 设置threejs 3D 对象的坐标（经纬度）。
   * @param {THREE.Object3D} object3D - threejs 3D 对象及子类对象。
   * @param {(Array.<number>|Object)} coordinate - 添加的 three 对象坐标（经纬度）。
   * @returns {ThreeLayer} ThreeLayer的实例对象。
   */
  addObject(object3D, coordinate) {
    this.renderer && this.renderer.addObject(object3D, coordinate);
  }

  /**
   * @function ThreeLayer.prototype.getScene
   * @description 获取 threejs 场景对象。
   * @returns {THREE.Scene} threejs 场景对象。
   */
  getScene() {
    return this.renderer.scene;
  }

  /**
   * @function ThreeLayer.prototype.getCamera
   * @description 获取 threejs 相机。
   * @returns {THREE.Camera} threejs 相机。
   */
  getCamera() {
    return this.renderer.camera;
  }

  /**
   * @function ThreeLayer.prototype.getThreeRenderer
   * @description 获取 threejs renderer。
   * @returns {THREE.WebGLRenderer} threejs renderer。
   */
  getThreeRenderer() {
    return this.renderer.context;
  }

  /**
   * @function ThreeLayer.prototype.clearMesh
   * @description 清除所有 threejs mesh 对象。
   * @returns {ThreeLayer} ThreeLayer的实例对象。
   */
  clearMesh() {
    this.renderer.clearMesh();
    return this;
  }

  /**
   * @function ThreeLayer.prototype.clearAll
   * @description 清除所有 threejs 对象。
   * @param {boolean} clearCamera - 是否清除相机。
   * @returns {ThreeLayer} ThreeLayer的实例对象。
   */
  clearAll(clearCamera) {
    this.renderer.clearAll(clearCamera);
    return this;
  }

  /**
   * @function ThreeLayer.prototype.setPosition
   * @description 设置 threejs 3D 对象的坐标（经纬度）。
   * @param {THREE.Object3D} object3D - threejs 3D 对象及子类对象。
   * @param {(Array.<number>|Object)} coordinate - 添加的 three 对象坐标（经纬度）。
   * @returns {ThreeLayer} ThreeLayer的实例对象。
   */
  setPosition(object3D, coordinate) {
    return this.renderer.setPosition(object3D, coordinate);
  }


  /**
   * @function ThreeLayer.prototype.lngLatToPosition
   * @description 经纬度转threejs 3D 矢量对象。
   * @param {(Array.<number>|Object)} lngLat - 经纬度坐标。
   * @returns {THREE.Vector3} threejs 3D 矢量对象。
   */
  lngLatToPosition(lngLat) {
    return this.renderer.lngLatToPosition(lngLat);
  }

  /**
   * @function ThreeLayer.prototype.distanceToThreeVector3
   * @description 计算距离指定坐标给定距离的新坐标的 threejs 3D 矢量对象。
   * @param {number} x - x 轴距离，单位米。
   * @param {number} y - y 轴距离，单位米。
   * @param {(Array.<number>|Object)} lngLat - 源坐标。
   * @returns {THREE.Vector3} 目标点的 threejs 3D 矢量对象。
   */
  distanceToThreeVector3(x, y, lngLat) {
    let map = this._map;
    let center = lngLat || map.getCenter();
    return this.renderer.distanceToThreeVector3(x, y, center);
  }

  /**
   * @function ThreeLayer.prototype.removeDuplicatedCoordinates
   * @description 移除数组中的重复坐标。
   * @param {(Array.<Array.<number>>)} coordinates - 坐标数组。
   * @returns {(Array.<Array.<number>>)} 新的坐标数组。
   */
  removeDuplicatedCoordinates(coordinates) {
    this.renderer.removeDuplicatedCoordinates(coordinates);
  }

  /**
   * @function ThreeLayer.prototype.getCoordinatesCenter
   * @description 获取给定坐标数组的中心坐标。
   * @param {(Array.<Array.<number>>)} coordinates - 坐标数组。
   * @returns {Object} 包含经纬度的坐标对象。
   */
  getCoordinatesCenter(coordinates) {
    return this.renderer.getCoordinatesCenter(coordinates);
  }

  /**
   * @function ThreeLayer.prototype.render
   */
  render() {
    this._update();
  }

  /**
   * @function ThreeLayer.prototype.getCanvasContainer
   * @description 获取 three 图层容器。
   * @returns {HTMLElement} three 图层的容器。
   */
  getCanvasContainer() {
    return this.renderer.getCanvasContainer();
  }

  /**
   * @function ThreeLayer.prototype.getCanvas
   * @description 获取 three 图层画布。
   * @returns {HTMLCanvasElement} three 图层画布。
   */
  getCanvas() {
    return this.renderer.getCanvas();
  }

  /**
   * @function ThreeLayer.prototype.remove
   * @description 移除图层。
   */
  remove() {
    this.renderer.remove();
    this._map = null;
  }

  /**
   * @function ThreeLayer.prototype.draw
   * @description 提供给外部的 threejs 模型绘制接口。
   * @returns {ThreeLayer} ThreeLayer的实例对象。
   * @example
   * var threeLayer = new ThreeLayer('three');
   * //可以通过重写 draw 实现模型绘制
   * threeLayer.draw = function (gl, scene, camera) {
   *     //TODO 绘制操作
   * }
   * threeLayer.addTo(map);
   */
  draw() {
    return this;
  }


  /**
   * @function ThreeLayer.prototype.renderScene
   * @description 渲染场景。
   * @returns {ThreeLayer} ThreeLayer的实例对象。
   */
  renderScene() {
    this.renderer.renderScene();
    /**
     * @event ThreeLayer#renderscene
     * @description renderScene 事件，场景渲染后触发。
     */
    this.fire("renderscene");
    return this;
  }

  _update() {
    /**
     * @event ThreeLayer#render
     * @description render 事件，地图渲染时(地图状态改变时)触发。
     */
    this.renderScene();
    this.fire('render');
    return this;
  }
}



;// CONCATENATED MODULE: ./src/common/overlay/heatmap/HeatMapLayerRenderer.js








/**
 * @private
 * @class HeatMapLayerRenderer
 * @classdesc 热力图层渲染器类。
 * @category  Visualization HeatMap
 * @param {string} name - 图层名称。
 * @param {Object} options - 构造参数。
 * @param {string} options.featureWeight - 对应 feature 属性中的热点权重字段名称，权重值类型为 float。
 * @param {string} [options.id] - 专题图层ID。默认使用 CommonUtil.createUniqueID("HeatMapLayer_") 创建专题图层 ID。
 * @param {number} [options.radius=50] - 热点渲染的最大半径（热点像素半径），单位为 px,当 useGeoUnit参数 为 true 时，单位使用当前图层地理坐标单位。热点显示的时候以精确点为中心点开始往四周辐射衰减，其衰减半径和权重值成比列。
 * @param {boolean} [options.loadWhileAnimating=true] - 是否实时重绘。(当绘制大数据量要素的情况下会出现卡顿，建议把该参数设为false)。
 * @param {number} [options.opacity=1] - 图层不透明度。
 * @param {Array.<string>} [options.colors=['blue','cyan','lime','yellow','red']] - 颜色线性渐变数组,颜色值必须为canvas所支。
 * @param {boolean} [options.useGeoUnit=false] - 使用地理单位，即默认热点半径默认使用像素单位。当设置为 true 时，热点半径和图层地理坐标保持一致。
 * @usage
 */
class HeatMapLayerRenderer {
  constructor(options) {
    this.options = options;
    /**
     * @member {Object} HeatMapLayerRenderer.prototype.rootCanvas
     * @description 热点图主绘制面板。
     */
    this.rootCanvas = null;

    /**
        * @member {Array.<FeatureVector>} HeatMapLayerRenderer.prototype.features
        * @description 热点信息数组，记录存储图层上添加的所有热点信息。
        */
    this.features = [];
    /**
      * @member {boolean} [HeatMapLayerRenderer.prototype.visibility=true]
      * @description 图层显示状态属性。
      */
    this.visibility = true;
    /**
     * @member {number} [HeatMapLayerRenderer.prototype.opacity=1]
     * @description 图层不透明度，取值范围[0,1]。
     */
    this.opacity = options.opacity ? options.opacity : 1;

    /**
      * @member {Array.<string>} [HeatMapLayerRenderer.prototype.colors=['blue','cyan','lime','yellow','red']]
      * @description 颜色线性渐变数组。
      */
    this.colors = options.colors ? options.colors : ['blue', 'cyan', 'lime', 'yellow', 'red'];

    /**
     * @member {boolean} [HeatMapLayerRenderer.prototype.useGeoUnit=false]
     * @description 使用地理单位，即默认热点半径默认使用像素单位。当设置为 true 时，热点半径和图层地理坐标保持一致。
     */
    this.useGeoUnit = options.useGeoUnit ? options.useGeoUnit : false;

    /**
     * @member {number} [HeatMapLayerRenderer.prototype.radius=50]
     * @description 热点渲染的最大半径（热点像素半径）,
     *              热点显示的时候以精确点为中心点开始往四周辐射衰减，
     *              其衰减半径和权重值成比列。
     */
    this.radius = options.radius ? options.radius : 50;

    /**
     * @member {string} HeatMapLayerRenderer.prototype.featureWeight
     * @description 对应 feature 属性中的热点权重字段名称，权重值类型为 number。
     * @example
     * //feature.attributes中表示权重的字段为 height,则在 HeatMapLayer 的 featureWeight 参数赋值为 "height"。
     * feature1.attributes.height = 7.0;
     * feature2.attributes.height = 6.0;
     * var heatMapLayer = new HeatMapLayer("heatmaplayer",{"featureWeight":"height"});
     * heatMapLayer.addFeatures([feature1,feature2]);
     */
    this.featureWeight = options.featureWeight ? options.featureWeight : null;

    /**
     * @member {number} HeatMapLayerRenderer.prototype.maxWeight
     * @description 设置权重最大值。默认将按照当前屏幕范围内热点所拥有的权重最大值绘制热点图。
     */
    this.maxWeight = null;

    /**
     * @member {number} HeatMapLayerRenderer.prototype.minWeight
     * @description 设置权重最小值。默认将按照当前屏幕范围内热点所拥有的权重最小值绘制热点图。
     */
    this.minWeight = null;

    /**
       * @member {Object} HeatMapLayerRenderer.prototype.canvasContext
       * @description 热点图主绘制对象。
       */
    this.canvasContext = null;

    /**
     * @member {number} HeatMapLayerRenderer.prototype.maxWidth
     * @description 当前绘制面板宽度。默认和当前 map 窗口宽度一致。
     */
    this.maxWidth = null;

    /**
     * @member {number} HeatMapLayerRenderer.prototype.maxHeight
     * @description 当前绘制面板宽度。默认和当前 map 窗口高度一致。
     */
    this.maxHeight = null;

    this.extent = {};
    this.mapElement = options.mapElement;
    this._createCanvasContainer(options.targetElement, options.size);
  }

  /**
   * @function HeatMapLayerRenderer.prototype.addFeatures
   * @description 添加热点信息。
   * @param {GeoJSONObject} features - 待添加的要素数组。
   * @example
   * var geojson = {
   *      "type": "FeatureCollection",
   *      "features": [
   *          {
   *              "type": "feature",
   *              "geometry": {
   *                  "type": "Point",  //只支持point类型
   *                  "coordinates": [0, 0]
   *              },
   *              "properties": {
   *                  "height": Math.random()*9,
   *                  "geoRadius": useGeoRadius?radius:null
   *              }
   *          }
   *      ]
   *   };
   * var HeatMapLayerRenderer = new HeatMapLayerRenderer("HeatMapLayerRenderer",{"featureWeight":"height"});                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   pLayer = new HeatMapLayerRenderer("HeatMapLayerRenderer",{"featureWeight":"height"});
   * HeatMapLayerRenderer.addFeatures(geojson);
   * map.addLayer(HeatMapLayerRenderer);
   */
  addFeatures(features) {
    this.features = this.toiClientFeature(features);
    //支持更新features，刷新底图
    this.refresh();
  }

  /**
   * @function HeatMapLayerRenderer.prototype.refresh
   * @description 强制刷新当前热点显示，在图层热点数组发生变化后调用，更新显示。
   */
  refresh() {
    if (this.features.length === 0) {
      return;
    }
    this.updateHeatPoints(this.extent);
  }

  /**
   * @function HeatMapLayerRenderer.prototype.setOpacity
   * @description 设置图层的不透明度，取值[0-1]之间。
   * @param {number} [opacity] - 不透明度。
   */
  setOpacity(opacity) {
    if (opacity !== this.opacity) {
      this.opacity = opacity;
      Util_Util.modifyDOMElement(this.rootCanvas, null, null, null,
        null, null, null, opacity);
    }
  }

  /**
   * @function HeatMapLayerRenderer.prototype.updateHeatPoints
   * @description 刷新热点图显示。
   * @param {mapboxgl.LngLatBounds} bounds - 当前显示范围。
   */
  updateHeatPoints(bounds) {
    if (this.features && this.features.length > 0) {
      this.convertFastToPixelPoints(bounds);
    } else {
      this.canvasContext.clearRect(0, 0, this.maxWidth, this.maxWidth);
    }
  }

  /**
   * @function HeatMapLayerRenderer.prototype.convertFastToPixelPoints
   * @description 过滤位于当前显示范围内的热点，并转换其为当前分辨率下的像素坐标。
   * @param {mapboxgl.LngLatBounds} bounds - 当前显示范围。
   * @private
   */
  convertFastToPixelPoints(bounds) {
    var data = [], x, y, k, resolution, maxTemp, minTemp, maxWeightTemp;
    //获取当前像素下的地理范围
    var dw = bounds.getEast() - bounds.getWest();
    var dh = bounds.getNorth() - bounds.getSouth();
    var mapElement = this.mapElement;

    if (dw / mapElement.width > dh / mapElement.height) {
      resolution = dw / mapElement.width;
    } else {
      resolution = dh / mapElement.height;
    }

    //热点半径
    this.useRadius = this.useGeoUnit ? parseInt(this.radius / resolution) : this.radius;

    for (var i = 0; i < this.features.length; i++) {
      var feature = this.features[i];
      var point = feature.geometry;

      //可通过bounds过滤需绘制的features以优化性能，但mapboxgl旋转获取得bounds不适

      var pixelPoint = this.getPixelXY(new LonLat(point.x, point.y));
      if (this.featureWeight) {
        pixelPoint.weight = feature.attributes[this.featureWeight];//point.value;
        if (!this.maxWeight) {
          //找出最大最小权重值
          maxTemp = maxTemp ? maxTemp : pixelPoint.weight;
          minTemp = minTemp ? minTemp : pixelPoint.weight;
          maxTemp = Math.max(maxTemp, pixelPoint.weight);
          minTemp = Math.min(minTemp, pixelPoint.weight);
        }
      } else {
        pixelPoint.weight = 1;
      }

      x = Math.floor(pixelPoint.x);
      y = Math.floor(pixelPoint.y);
      k = pixelPoint.weight;

      data.push([x, y, k]);
    }

    //无最大权重设置
    if (!this.maxWeight) {
      if (maxTemp && minTemp) {
        maxWeightTemp = (maxTemp + minTemp) / 2;
      } else {
        maxWeightTemp = 1;
      }
      this.draw(data, maxWeightTemp);
    } else {
      this.draw(data, this.maxWeight);
    }

  }

  /**
   * @function HeatMapLayerRenderer.prototype.draw
   * @description 绘制热点图。
   * @param {Array} data - convertToPixelPoints方法计算出的点。
   * @private
   */
  draw(data, maxWeight) {
    if (this.maxHeight > 0 && this.maxWidth > 0) {
      //清空
      var ctx = this.canvasContext;
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      this.canvasContext.clearRect(0, 0, this.maxWidth, this.maxHeight);
      this.drawCircle(this.useRadius);
      this.createGradient();

      for (var i = 0; i < data.length; i++) {
        var p = data[i];
        this.canvasContext.globalAlpha = Math.max(p[2] / maxWeight, 0.05);
        this.canvasContext.drawImage(this.circle, p[0] - this.useRadius, p[1] - this.useRadius);
      }

      var colored = ctx.getImageData(0, 0, this.maxWidth, this.maxHeight);
      this.colorize(colored.data, this.grad);
      ctx.putImageData(colored, 0, 0);
    } else {
      return false;
    }

  }

  /**
   * @function HeatMapLayerRenderer.prototype.colorize
   * @description 根据渐变色重置热点图rgb值。
   * @param {Array} pixels - 像素 RGBA 值。
   * @param {Array} gradient - 渐变 canvas.getImageData.data。
   * @private
   */
  colorize(pixels, gradient) {
    for (var i = 0, j; i < pixels.length; i += 4) {
      j = pixels[i + 3] * 4;
      if (j) {
        pixels[i] = gradient[j];
        pixels[i + 1] = gradient[j + 1];
        pixels[i + 2] = gradient[j + 2];
      }
    }
  }

  /**
   * @function HeatMapLayerRenderer.drawCircle
   * @description 绘制热点半径圆。
   * @param {number} r - 热点半径。
   * @private
   */
  drawCircle(r) {
    var blur = r / 2;
    var circle = this.circle = document.createElement('canvas'),
      ctx = circle.getContext("2d");
    circle.height = 2 * r;
    circle.width = 2 * r;
    ctx.shadowOffsetX = ctx.shadowOffsetY = 2 * r;
    ctx.shadowBlur = blur;
    ctx.shadowColor = "#000000";

    ctx.beginPath();
    ctx.arc(-r, -r, r / 2, 0, Math.PI * 2, true);
    ctx.closePath();
    ctx.fill();
  }

  /**
   * @function HeatMapLayerRenderer.createGradient
   * @description 根据 options.colors 设置渐变。
   * @private
   */
  createGradient() {
    var colors = this.colors;
    var canvas = document.createElement('canvas'),
      ctx = canvas.getContext("2d"),
      gradient = ctx.createLinearGradient(0, 0, 0, 256);
    canvas.height = 256;
    canvas.width = 1;

    var index = 1;
    for (var i = 0, len = colors.length; i < len; i++) {
      gradient.addColorStop(index / len, colors[i]);
      index++;
    }

    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, 1, 256);

    this.grad = ctx.getImageData(0, 0, 1, 256).data;
  }

  /**
   * @function HeatMapLayerRenderer.prototype.getPixelXY
   * @description 转换地理坐标为相对于当前窗口左上角的像素坐标。
   * @param {number} x - 热点的像素 x 坐标。
   * @param {number} y - 热点的像素 y 坐标。
   */
  getPixelXY(coordinate) {
    let pixelP;
    if (coordinate instanceof Point || coordinate instanceof GeoText) {
      let tempPoint = this.options.convertLatlonToPixel({ lon: coordinate.x, lat: coordinate.y });
      pixelP = { x: parseInt(tempPoint.x), y: parseInt(tempPoint.y) };
    }
    if (coordinate instanceof LonLat) {
      let tempPoint = this.options.convertLatlonToPixel(coordinate);
      pixelP = { x: parseInt(tempPoint.x), y: parseInt(tempPoint.y) };
    }
    return pixelP;
  }

  /**
    * @function HeatMapLayerRenderer.prototype._createCanvasContainer
    * @description 创建热力图绘制容器。
    * @private
    */
  _createCanvasContainer(targetElement) {
    //热点图要求使用canvas绘制，判断是否支持
    this.rootCanvas = document.createElement("canvas");
    this.rootCanvas.id = this.options.id;
    this.rootCanvas.width = this.maxWidth = parseInt(this.mapElement.style.width);
    this.rootCanvas.height = this.maxHeight = parseInt(this.mapElement.style.height);
    this.canvasContext = this.rootCanvas.getContext('2d');
    const devicePixelRatio = window.devicePixelRatio || 1;
    devicePixelRatio !== 1 && this.canvasContext && this.canvasContext.scale(devicePixelRatio, devicePixelRatio);

    Util_Util.modifyDOMElement(this.rootCanvas, null, { x: 0, y: 0 }, { w: this.maxWidth, h: this.maxHeight },
      "absolute", null, null, this.opacity);
    targetElement.appendChild(this.rootCanvas);
  }

  /**
  * @function HeatMapLayerRenderer.prototype.toiClientFeature
  * @description 转为 iClient 要素。
  * @param {GeoJSONObject} features - 待添加的要素数组。
  */
  // 提到 common
  toiClientFeature(features) {
    if (!Util_Util.isArray(features)) {
      features = [features];
    }
    let featuresTemp = [];
    for (let i = 0; i < features.length; i++) {
      if (features[i] instanceof Vector) {
        // 若是 FeatureVector 直接返回
        featuresTemp.push(features[i]);
      } else if (["FeatureCollection", "Feature", "Geometry"].indexOf(features[i].type) != -1) {
        //GeoJSON 规范数据类型
        let format = new GeoJSON();
        featuresTemp = featuresTemp.concat(format.read(features[i]));
      } else if (features[i].geometry && features[i].geometry.parts) {
        //iServer服务器返回数据格式
        featuresTemp.push(ServerFeature.fromJson(features[i]).toFeature());
      } else {
        throw new Error(`Features[${i}]'s type does not match, please check.`);
      }
    }
    return featuresTemp;
  }

  /**
   * @function HeatMapLayerRenderer.prototype.removeFeatures
   * @description 移除指定的热点信息。
   * @param {Array.<FeatureVector>|FeatureVector} features - 热点信息数组。
   */
  removeFeatures(features) {
    if (!features || features.length === 0 || !this.features || this.features.length === 0) {
      return;
    }
    if (features === this.features) {
      return this.removeAllFeatures();
    }
    if (!(Util_Util.isArray(features))) {
      features = [features];
    }
    var heatPoint, index, heatPointsFailedRemoved = [];
    for (var i = 0, len = features.length; i < len; i++) {
      heatPoint = features[i];
      index = Util_Util.indexOf(this.features, heatPoint);
      //找不到视为删除失败
      if (index === -1) {
        heatPointsFailedRemoved.push(heatPoint);
        continue;
      }
      //删除热点
      this.features.splice(index, 1);
    }
    var succeed = heatPointsFailedRemoved.length == 0 ? true : false;
    //派发删除features成功的事件
    /**
     * @event HeatMapLayerRenderer#featuresremoved
     * @description 要素删除之后触发。
     * @property {Array.<FeatureVector>} features - 需要被删除的要素。
     * @property {boolean} succeed - 要素删除成功与否。
     */
    this.refresh();
    return { succeed, heatPointsFailedRemoved }
  }

  /**
   * @function HeatMapLayerRenderer.prototype.removeAllFeatures
   * @description 移除全部的热点信息。
   */
  removeAllFeatures() {
    this.features = [];
    this.refresh();
  }

   /**
     * @function HeatMapLayerRenderer.prototype.removeFromMap
     * @description 删除该图层。
     */
   removeFromMap() {
    this.removeAllFeatures();
    this.options.targetElement.removeChild(this.rootCanvas);
  }

  /**
   * @function HeatMapLayerRenderer.prototype.setVisibility
   * @description 设置图层可见性。
   * @param {boolean} [visibility] - 是否显示图层（当前地图的 resolution 在最大最小 resolution 之间）。
   */
  setVisibility(visibility) {
    if (this.rootCanvas && visibility !== this.visibility) {
      this.visibility = visibility;
      this.rootCanvas.style.display = visibility ? "block" : "none";
    }
  }

  setExtent(extent) {
    this.extent = extent;
  }

  _hide() {
    this.rootCanvas.style.display = 'none';
  }

  _show() {
    this.rootCanvas.style.display = 'block';
  }
}
;// CONCATENATED MODULE: ./src/mapboxgl/overlay/HeatMapLayer.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/




/**
 * @class HeatMapLayer
 * @classdesc 热力图层类。
 * @category  Visualization HeatMap
 * @modulecategory Overlay
 * @param {string} name - 图层名称。
 * @param {Object} options - 构造参数。
 * @param {mapboxgl.Map} options.map - MapBoxGL Map 对象。
 * @param {string} options.featureWeight - 对应 feature 属性中的热点权重字段名称，权重值类型为 float。
 * @param {string} [options.id] - 专题图层ID。默认使用 CommonUtil.createUniqueID("HeatMapLayer_") 创建专题图层 ID。
 * @param {number} [options.radius=50] - 热点渲染的最大半径（热点像素半径），单位为 px,当 useGeoUnit参数 为 true 时，单位使用当前图层地理坐标单位。热点显示的时候以精确点为中心点开始往四周辐射衰减，其衰减半径和权重值成比列。
 * @param {boolean} [options.loadWhileAnimating=true] - 是否实时重绘。(当绘制大数据量要素的情况下会出现卡顿，建议把该参数设为false)。
 * @param {number} [options.opacity=1] - 图层不透明度。
 * @param {Array.<string>} [options.colors=['blue','cyan','lime','yellow','red']] - 颜色线性渐变数组,颜色值必须为canvas所支。
 * @param {boolean} [options.useGeoUnit=false] - 使用地理单位，即默认热点半径默认使用像素单位。当设置为 true 时，热点半径和图层地理坐标保持一致。
 * @extends {mapboxgl.Evented}
 * @fires HeatMapLayer#featuresadded
 * @fires HeatMapLayer#changelayer
 * @fires HeatMapLayer#featuresremoved
 * @usage
 */
class HeatMapLayer extends (external_mapboxgl_default()).Evented {

    constructor(name, options) {
        super();

        var _options = options ? options : {};
        this.options = _options;
        /**
         * @member {string} HeatMapLayer.prototype.name
         * @description 图层名字。
         */
        this.name = name;

        /**
         * @member {string} HeatMapLayer.prototype.id
         * @description 热力图图层 ID。
         */
        this.id = _options.id ? _options.id : Util_Util.createUniqueID("HeatMapLayer_");

        /**
         * @member {boolean} [HeatMapLayer.prototype.loadWhileAnimating=true]
         * @description 是否实时重绘。(当绘制大数据量要素的情况下会出现卡顿，建议把该参数设为false)。
         */
        this.loadWhileAnimating = _options.loadWhileAnimating === undefined ? true : _options.loadWhileAnimating;

        /**
         * @member {GeoJSONObject} HeatMapLayer.prototype.features
         * @description 热点信息数组，记录存储图层上添加的所有热点信息。
         */
        this.features = {};

        /**
         * @member HeatMapLayer.prototype.EVENT_TYPES
         * @description 监听一个自定义事件可用如下方式:
         *              热点图自定义事件信息，事件调用时的属性与具体事件类型相对应。
         *
         * 支持的事件如下 (另外包含 <Layer 中定义的其他事件>):
         * featuresadded - 热点添加完成时触发。回调参数为添加的热点信息数组和操作成功与否信息。
         * 参数类型：{features: features, succeed: succeed}
         * featuresremoved - 热点被删除时触发。回调参数为删除的热点信息数组和操作成功与否信息。
         * 参数类型：{features: features, succeed: succeed}
         * featuresdrawcompleted - 热点图渲染完成时触发。
         */
        this.EVENT_TYPES = ["featuresadded", "featuresremoved", "featuresdrawcompleted"];
        this.type = 'custom';
        this.renderingMode = '3d';
        this.overlay = true;
    }

    /**
     * @function HeatMapLayer.prototype.onAdd
     * @description 添加该图层
     */
    onAdd(map) {
        this.map = map;
        const targetElement = this.map.getCanvasContainer();
        const mapElement = this.map.getCanvas();
        this.renderer = new HeatMapLayerRenderer({ id: this.id, ...this.options, convertLatlonToPixel: this._convertLatlonToPixel.bind(this), targetElement, mapElement });
        if (this.features.features && this.features.features.length) {
            this.renderer.setExtent(this.map.getBounds());
            this.renderer.addFeatures(this.features);
        }
    }

    /**
     * @function HeatMapLayer.prototype.removeFromMap
     * @description 删除该图层。
     */
    onRemove() {
        this.removeAllFeatures();
        this.renderer.removeFromMap();
        this.features = {};
        this.renderer = null;
    }

    render() {
        this.refresh();
    }

    /**
     * @function HeatMapLayer.prototype.addFeatures
     * @description 添加热点信息。
     * @param {GeoJSONObject} features - 待添加的要素数组。
     *
     * @example
     * var geojson = {
     *      "type": "FeatureCollection",
     *      "features": [
     *          {
     *              "type": "feature",
     *              "geometry": {
     *                  "type": "Point",  //只支持point类型
     *                  "coordinates": [0, 0]
     *              },
     *              "properties": {
     *                  "height": Math.random()*9,
     *                  "geoRadius": useGeoRadius?radius:null
     *              }
     *          }
     *      ]
     *   };
     * var heatMapLayer = new HeatMapLayer("heatmaplayer",{"featureWeight":"height"});                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   pLayer = new HeatMapLayer("heatmaplayer",{"featureWeight":"height"});
     * heatMapLayer.addFeatures(geojson);
     * map.addLayer(heatMapLayer);
     */
    addFeatures(features) {
        if (this.renderer) {
            this.renderer.addFeatures(features);
        } else {
            this.features = features;
        }
        /**
         * @event HeatMapLayer#featuresadded
         * @description 要素添加完成之后触发。
         * @property {GeoJSONObject} features - 被添加的要素。
         * @property {boolean} succeed - 要素是否成功添加。
         */
        this.fire(this.EVENT_TYPES[0], { features: features, succeed: true });
    }

    /**
     * @function HeatMapLayer.prototype.refresh
     * @description 强制刷新当前热点显示，在图层热点数组发生变化后调用，更新显示。
     */
    refresh() {
        if (this.map) {
            this.renderer.setExtent(this.map.getBounds());
            this.renderer.refresh();
        }
    }

    /**
     * @function HeatMapLayer.prototype.setOpacity
     * @description 设置图层的不透明度，取值[0-1]之间。
     * @param {number} [opacity] - 不透明度。
     */
    setOpacity(opacity) {
        if (opacity !== this.opacity) {
            this.renderer.setOpacity(opacity);
            if (this.map !== null) {
                /**
                 * @event HeatMapLayer#changelayer
                 * @description 图层属性改变之后触发。
                 * @property {Object} layer - 图层。
                 * @property {string} property - 被改变的图层属性。
                 */
                this.fire('changelayer', {layer: this, property: "opacity"});
            }
        }
    }

    /**
     * @function HeatMapLayer.prototype.updateHeatPoints
     * @description 刷新热点图显示。
     * @param {mapboxgl.LngLatBounds} bounds - 当前显示范围。
     */
    updateHeatPoints(bounds) {
        this.renderer.updateHeatPoints(bounds);
    }

    /**
     * @function HeatMapLayer.prototype.getPixelXY
     * @description 转换地理坐标为相对于当前窗口左上角的像素坐标。
     * @param {number} x - 热点的像素 x 坐标。
     * @param {number} y - 热点的像素 y 坐标。
     */
    getPixelXY(coordinate) {
        return this.renderer.getPixelXY(coordinate);
    }

    /**
     * @function HeatMapLayer.prototype.removeFeatures
     * @description 移除指定的热点信息。
     * @param {Array.<FeatureVector>|FeatureVector} features - 热点信息数组。
     */
    removeFeatures(features) {
        const removeFeaturesRes = this.renderer.removeFeatures(features);
        if(!removeFeaturesRes) {
        return;
        }
        const { heatPointsFailedRemoved, succeed } = removeFeaturesRes;
        //派发删除features成功的事件
        /**
         * @event HeatMapLayer#featuresremoved
         * @description 要素删除之后触发。
         * @property {Array.<FeatureVector>} features - 需要被删除的要素。
         * @property {boolean} succeed - 要素删除成功与否。
         */
        this.fire(this.EVENT_TYPES[1], { features: heatPointsFailedRemoved, succeed });
    }

    /**
     * @function HeatMapLayer.prototype.removeAllFeatures
     * @description 移除全部的热点信息。
     */
    removeAllFeatures() {
        this.renderer.removeAllFeatures();
    }

    /**
     * @function HeatMapLayer.prototype.moveTo
     * @description 将图层移动到某个图层之前。
     * @param {string} layerID - 待插入的图层ID。
     * @param {boolean} [before=true] - 是否将本图层插入到图层 ID 为 layerID 的图层之前(如果为 false 则将本图层插入到图层 ID 为 layerID 的图层之后)。
     */
    moveTo(layerID, before) {
        var layer = document.getElementById(this.renderer.rootCanvas.id);
        before = before !== undefined ? before : true;
        if (before) {
            var beforeLayer = document.getElementById(layerID);
            if (layer && beforeLayer) {
                beforeLayer.parentNode.insertBefore(layer, beforeLayer);
            }
            return;
        }
        var nextLayer = document.getElementById(layerID);
        if (layer) {
            if (nextLayer.nextSibling) {
                nextLayer.parentNode.insertBefore(layer, nextLayer.nextSibling);
                return;
            }
            nextLayer.parentNode.appendChild(layer);
        }
    }

    /**
     * @function HeatMapLayer.prototype.setVisibility
     * @description 设置图层可见性。
     * @param {boolean} [visibility] - 是否显示图层（当前地图的 resolution 在最大最小 resolution 之间）。
     */
    setVisibility(visibility) {
        this.renderer.setVisibility(visibility);
    }

    _convertLatlonToPixel(coordinate) {
        return this.map.project(new (external_mapboxgl_default()).LngLat(coordinate.lon, coordinate.lat));
    }
}

;// CONCATENATED MODULE: ./src/common/overlay/deckgl/DeckglLayerBase.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/
 
 /**
  * @class DeckglLayerBase
  * @category  Visualization DeckGL
  * @classdesc Deckgl 高效率图层，该图图层为综合图层，通过该图层可创建 高效率点图层、路径图层（线图层）、高效率面图层、曲线图层、
  *            正六边形图层（蜂巢图层）、网格图层，只需给定相依配置，因此，在创建图层之前，请仔细阅读参数配置。
  * @param {string} layerTypeID - 高效率图层类型 ID，包括 "scatter-plot" 高效率点图层、"path-layer" 路径图层（线图层）、
  *                 "polygon-layer" 高效率面图层、"arc-layer" 曲线图层、"hexagon-layer" 正六边形图层（蜂巢图层）、"screen-grid-layer" 网格图层。
  *
  * @param {Object} options -  图层配置项，包括以下参数：
  * @param {Object} [options.layerId] - DeckglLayerBase 图层 Dom 元素 ID。默认使用 CommonUtil.createUniqueID("graphicLayer_" + this.layerTypeID + "_") 创建专题图层 ID。
  * @param {Array.<GeoJSONObject>} options.data - 图层数据,支持 GeoJSON 规范数据类型。
  * @param {Object} options.callback - deckgl 图层回调函数配置项。
  * @param {Object} options.props - deckgl 图层配置项, 在该参数下配置图层配置项：
  * @param {boolean} options.props.coverage - "hexagon-layer" 配置项：六边形半径乘数，介于0 - 1之间。六边形的最终半径通过覆盖半径计算。注意：覆盖范围不会影响分数的分配方式。分配方式的半径仅由半径属性确定；
  * @param {boolean} options.props.hexagonAggregator  - "hexagon-layer" 配置项：* @param {boolean}
  * @param {Object} options.props.lightSettings - 光照配置项。
  * @param {Array} options.props.lightSettings.lightsPosition - 光照配置项：指定为`[x，y，z]`的光在平面阵列中的位置`, 在一个平面阵列。长度应该是 `3 x numberOfLights`。
  * @param {Array} options.props.lightSettings.lightsStrength - 光照配置项：平面阵列中指定为“[x，y]`的灯的强度。长度应该是`2 x numberOfLights`。
  * @param {number} [options.props.lightSettings.numberOfLights=1]  - 光照配置项：光照值,最大值为 `5`。
  * @param {number} [options.props.lightSettings.coordinateSystem=COORDINATE_SYSTEM.LNGLAT]  - 光照配置项：指定灯位置的坐标系。
  * @param {number} [options.props.lightSettings.coordinateOrigin=[0, 0, 0]] - 光照配置项：指定灯位置的坐标原点。
  * @param {number} [options.props.lightSettings.modelMatrix] - 光照配置项：光位置的变换矩阵。
  * @param {number} [options.props.lightSettings.ambientRatio=0.4] - 光照配置项：光照的环境比例。
  * @param {number} [options.props.lightSettings.diffuseRatio=0.6] - 光照配置项：光的漫反射率。
  * @param {number} [options.props.lightSettings.specularRatio=0.8] - 光照配置项：光的镜面反射率。
  * @param {number} [options.props.opacity=1] - 公共配置项：图层不透明度度。
  * @param {boolean} [options.props.pickable=false] - 公共配置项：是否响应鼠标事件（鼠标点击，鼠标滑动)。
  * @param {function} [options.props.autoHighlight=false] - 公共配置项：鼠标滑动高亮要素。
  * @param {function} [options.props.highlightColor=[0, 0, 128, 128]] - 公共配置项：鼠标滑动高亮颜色。
  * @param {function} [options.props.onClick] - 公共配置项：鼠标点击事件。
  * @param {function} [options.props.onHover] - 公共配置项：鼠标滑动事件。
  * @param {number} [options.props.radiusScale=1] - "scatter-plot" 配置项：散点半径比例。
  * @param {boolean} [options.props.outline=false] - "scatter-plot" 配置项：是否边线显示。
  * @param {number} [options.props.strokeWidth=1]  - "scatter-plot" 配置项：边线宽度。
  * @param {number} [options.props.radiusMinPixels=0] - "scatter-plot" 配置项：半径最小像素值。
  * @param {number} [options.props.radiusMaxPixels=Number.MAX_SAFE_INTEGER]  - "scatter-plot" 配置项：半径最大像素值。
  * @param {boolean} [options.props.fp64=false] - "scatter-plot" 配置项：否应以高精度64位模式呈现图层。
  * @param {number} [options.props.widthScale=1] - "path-layer" 配置项：线宽比例。
  * @param {number} [options.props.widthMinPixels=0] - "path-layer" 配置项：线宽最小像素值。
  * @param {number} [options.props.widthMaxPixels=Number.MAX_SAFE_INTEGER] - "path-layer" 配置项：线宽最大像素值。
  * @param {boolean} [options.props.rounded=false] - "path-layer" 配置项：节点是否绘制为弧形。
  * @param {number} [options.props.miterLimit=4] - "path-layer" 配置项：节点相对于线宽的最大范围,仅在 rounded 为 false 时有效；
  * @param {boolean} [options.props.fp64=false] - "path-layer" 配置项：否应以高精度64位模式呈现图层。
  * @param {boolean} [options.props.dashJustified=false] - "path-layer" 配置项：是否虚线形式显示，仅在 getDashArray() 回调函数被指定时有效。
  * @param {boolean} [options.props.filled=true] - "polygon-layer" 配置项：是否填充面。
  * @param {boolean} [options.props.stroked=true] - "polygon-layer" 配置项：是否绘制边线。
  * @param {boolean} [options.props.extruded=false] - "polygon-layer" 配置项：是否拉伸建筑。
  * @param {boolean} [options.props.wireframe=false] - "polygon-layer" 配置项：当面被拉伸为建筑时，是否描绘建筑物边线。
  * @param {boolean} [options.props.elevationScale=1] - "polygon-layer" 配置项：海拔比例。
  * @param {boolean} [options.props.lineWidthScale=1] - "polygon-layer" 配置项：线宽比例。
  * @param {boolean} [options.props.lineWidthMinPixels=0] - "polygon-layer" 配置项：线宽最小像素值。
  * @param {boolean} [options.props.lineWidthMaxPixels=Number.MAX_SAFE_INTEGER] - "polygon-layer" 配置项：线宽最大像素值。
  * @param {boolean} [options.props.lineJointRounded=false] - "polygon-layer" 配置项：节点是否绘制为弧形。
  * @param {boolean} [options.props.lineMiterLimit=4] - "polygon-layer" 配置项：节点相对于线宽的最大范围，仅在 lineJointRounded 为 false 时有效。
  * @param {boolean} [options.props.lineDashJustified=false] - "polygon-layer" 配置项：是否虚线形式显示，仅在 getLineDashArray() 回调函数被指定时有效。
  * @param {boolean} [options.props.fp64=false] - "polygon-layer" 配置项：否应以高精度64位模式呈现图层。
  * @param {boolean} [options.props.fp64=false] - "arc-layer" 配置项：否应以高精度64位模式呈现图层。
  * @param {boolean} [options.props.strokeWidth=1] - "arc-layer" 配置项：线宽。
  * @param {boolean} [options.props.radius=1000] - "hexagon-layer" 配置项：六边形半径值。
  * @param {boolean} [options.props.extruded=false] - "hexagon-layer" 配置项：是否拉伸要素。
  * @param {boolean} [options.props.upperPercentile=100] - "hexagon-layer" 配置项：筛选箱并通过upperPercentile重新计算颜色。颜色值大于upperPercentile的六边形将被隐藏。
  * @param {boolean} [options.props.elevationScale=1] - "hexagon-layer" 配置项：高程乘数，实际海拔高度由 elevationScale * getElevation（d）计算。 elevationScale是一个方便的属性，可以在不更新数据的情况下缩放所有六边形。
  * @param {boolean} [options.props.colorDomain=false]  - "hexagon-layer" 配置项：色阶。
  * @param {boolean} [options.props.colorRange=[[255,255,178,255],[254,217,118,255],[254,178,76,255],[253,141,60,255],[240,59,32,255],[189,0,38,255]]]   - "hexagon-layer" 配置项：色带。
  * @usage
  */
 class DeckglLayerBase {
     constructor(layerTypeID, options) {
         /**
          * @member {string} DeckglLayerBase.prototype.id
          * @description 高效率点图层 ID。
          */
         this.layerTypeID = layerTypeID;
         /**
          * @member {Array.<Graphic>} DeckglLayerBase.prototype.graphics
          * @description 点要素对象数组。
          * 
          */
         this.data = [].concat(options.data);
 
         this.props = options.props ? options.props : {};
         this.callback = options.callback ? options.callback : {};
 
         this.id = options.layerId
             ? options.layerId
             : Util_Util.createUniqueID('graphicLayer_' + this.layerTypeID + '_');
     }
 
     /**
      * @function DeckglLayerBase.prototype.onAdd
      */
     onAdd() {
     }

      /**
      * @function DeckglLayerBase.prototype.render
      */
     render() {
     }
 
     /**
      * @function DeckglLayerBase.prototype.setStyle
      * @description 设置图层整体样式。
      * @param {Object} styleOptions - 样式对象。
      * @param {Array.<number>} [styleOptions.color=[0, 0, 0, 255]] - 点颜色。
      * @param {number} [styleOptions.radius=10] - 点半径。
      * @param {number} [styleOptions.opacity=0.8] - 不透明度。
      * @param {Array.<number>}  [styleOptions.highlightColor] - 高亮颜色，目前只支持 rgba 数组。
      * @param {number} [styleOptions.radiusScale=1] - 点放大倍数。
      * @param {number} [styleOptions.radiusMinPixels=0] - 半径最小值（像素）。
      * @param {number} [styleOptions.radiusMaxPixels=Number.MAX_SAFE_INTEGER] - 半径最大值（像素）。
      * @param {number} [styleOptions.strokeWidth=12] - 边框大小。
      * @param {boolean} [styleOptions.outline=false] - 是否显示边框。
      */
     setStyle(styleOptions) {
         Util_Util.extend(this.props, styleOptions);
         this._createLayerByLayerTypeID();
         this.update();
     }
 
     /**
      * @function DeckglLayerBase.prototype.setData
      * @description 设置绘制的点要素数据，会覆盖之前的所有要素。
      * @param {Array.<Object>}  data - 点要素对象数组。
      */
     setData(data) {
         this.data = this.data || [];
         this.data.length = 0;
         let dataTemp = !Util_Util.isArray(data) ? [data] : [].concat(data);
         //this.layer.props.data不能被重新赋值，只能在原数组上进行操作
         if (!this.layer.props.data) {
             this.layer.props.data = [];
         }
         this.layer.props.data.length = 0;
         for (let i = 0; i < dataTemp.length; i++) {
             this.layer.props.data.push(dataTemp[i]);
         }
         this.data = this.layer.props.data;
         this.update();
     }
 
     /**
      * @function DeckglLayerBase.prototype.addData
      * @description 添加点要素，不会覆盖之前的要素。
      * @param {Array.<Object>}  data - 点要素对象数组。
      */
     addData(data) {
         this.data = this.data || [];
         let dataTemp = !Util_Util.isArray(data) ? [data] : [].concat(data);
         //this.layer.props.data不能被重新赋值，只能在原数组上进行操作
         if (!this.layer.props.data) {
             this.layer.props.data = [];
         }
         for (let i = 0; i < dataTemp.length; i++) {
             this.layer.props.data.push(dataTemp[i]);
         }
         this.update();
     }
 
     /**
      * @function DeckglLayerBase.prototype.update
      * @description 更新图层。
      */
     update() {
         if (this.layer.lifecycle !== 'Awaiting state') {
             let changeFlags = {
                 dataChanged: true,
                 propsChanged: true,
                 viewportChanged: true,
                 updateTriggersChanged: true
             };
             this.layer.setChangeFlags(changeFlags);
         }
         this._draw();
     }
 
     /**
      * @function DeckglLayerBase.prototype.clear
      * @description 释放图层资源。
      */
     // todo 还有哪些资源应该被释放？
     clear() {
         this.removeData();
         this.deckGL.finalize();
     }
 
     /**
      * @function DeckglLayerBase.prototype.removeData
      * @description 移除所有要素。
      */
     removeData() {
         this.data.length = 0;
 
         if (this.layer.props.data) {
             this.layer.props.data.length = 0;
         }
         this.update();
     }

    /**
     * @function DeckglLayerBase.prototype.moveTo
     * @description 将图层移动到某个图层之前。
     * @param {string} layerID - 待插入的图层 ID。
     * @param {boolean} [before=true] - 是否将本图层插入到图层 ID 为 layerID 的图层之前。
     */
    moveTo(layerID, before) {
      var layer = document.getElementById(this.id);
      before = before !== undefined ? before : true;
      if (before) {
          var beforeLayer = document.getElementById(layerID);
          if (layer && beforeLayer) {
              beforeLayer.parentNode.insertBefore(layer, beforeLayer);
          }
          return;
      }
      var nextLayer = document.getElementById(layerID);
      if (layer) {
          if (nextLayer.nextSibling) {
              nextLayer.parentNode.insertBefore(layer, nextLayer.nextSibling);
              return;
          }
          nextLayer.parentNode.appendChild(layer);
      }
    }

    /**
     * @function DeckglLayerBase.prototype.setVisibility
     * @description 设置图层可见性。
     * @param {boolean} [visibility] - 是否显示图层（当前地图的 resolution 在最大最小 resolution 之间）。
     */
   setVisibility(visibility) {
      if (this.canvas && visibility !== this.visibility) {
          this.visibility = visibility;
          this.canvas.style.display = visibility ? 'block' : 'none';
      }
    }
 
     _draw() {
         let deckOptions = this._getState();
         deckOptions.layers = [this.layer];
         deckOptions.canvas = this.canvas;
         this.deckGL.setProps(deckOptions);
     }
 
     _getState() {
         //获取地图信息构建state
         let width = parseInt(this.canvas.style.width);
         let height = parseInt(this.canvas.style.height);
        const mapInfo = this.getMapInfo();
 
         let mapViewport = {
             width: width,
             height: height,
             ...mapInfo
         };
 
         let state = {};
 
         //克隆 mapViewport
         for (let key in mapViewport) {
             state[key] = mapViewport[key];
         }
         //克隆 props
         for (let key in this.props) {
             state[key] = this.props[key];
         }
         if (this._isEPSG3857 && this._isEPSG3857()) {
             state.coordinateSystem = this.coordinateSystem;
             state.isGeographicCoordinateSystem = this.isGeographicCoordinateSystem;
         } else {
             state.coordinateSystem = 1;
             state.isGeographicCoordinateSystem = false
         }
 
         //更行数据
         state.data = this.data;
 
         return state;
     }
 
     /**
      * @function DeckglLayerBase.prototype._createLayerByLayerTypeID
      * @description 判别当前创建图层类型。
      * @private
      */
     _createLayerByLayerTypeID() {
         //统一处理公共属性：
         this.props.data = this.data;
         this.props.isGeographicCoordinateSystem = this.isGeographicCoordinateSystem;
         this.props.coordinateSystem = this.coordinateSystem;
         //添加事件监听
         this.props.pickable = Boolean(this.props.onClick) || Boolean(this.props.onHover);
 
         //各类型各自从 defaultProps 取出相形的参数：
         if (this.layerTypeID === 'scatter-plot') {
             this.props.id = 'scatter-plot';
             this._createScatterPlotLayer();
         } else if (this.layerTypeID === 'path-layer') {
             this.props.id = 'path-layer';
             this._createPathLayer();
         } else if (this.layerTypeID === 'polygon-layer') {
             this.props.id = 'polygon-layer';
             this._createPolygonLayer();
         } else if (this.layerTypeID === 'arc-layer') {
             this.props.id = 'arc-layer';
             this._createArcLineLayer();
         } else if (this.layerTypeID === 'hexagon-layer') {
             this.props.id = 'hexagon-layer';
             this._createHexagonLayer();
         } else {
             throw new Error(this.layerTypeID + ' does not support');
         }
     }
 
     /**
      * @description scatter-plot
      * @private
      */
     _createScatterPlotLayer() {
         //处理回调
         /*  this.props.getPosition = this.callback.getPosition ? this.callback.getPosition : function (point) {
               if (!point) {
                   return [0, 0, 0];
               }
               return point.geometry.coordinates;
           };*/
         var me = this;
         this.props.getPosition = this.callback.getPosition
             ? this.callback.getPosition
             : function (point) {
                   if (!point) {
                       return [0, 0, 0];
                   }
                   let lngLat = point.getLngLat();
                   return lngLat && [lngLat.lng, lngLat.lat, 0];
               };
         if (this.callback.getColor) {
             this.props.getColor = this.callback.getColor
                 ? this.callback.getColor
                 : function (point) {
                       let style = point && point.getStyle();
                       return (style && style.color) || me.props.color;
                   };
         }
 
         if (this.callback.getRadius) {
             this.props.getRadius = this.callback.getRadius
                 ? this.callback.getRadius
                 : function (point) {
                       let style = point && point.getStyle();
                       return (style && style.radius) || me.props.radius;
                   };
         }
 
         if (this.props.color || this.props.radius) {
             this.props.updateTriggers = {};
             if (this.props.radius) {
                 this.props.updateTriggers.getRadius = [this.props.radius];
             }
             if (this.props.color) {
                 this.props.updateTriggers.getColor = [this.props.color];
             }
         }
         this.layer = new window.DeckGL.ScatterplotLayer(this.props);
     }
 
     /**
      * @description path-layer
      * @private
      */
     _createPathLayer() {
         this.props.getPath = this.callback.getPath
             ? this.callback.getPath
             : function (feature) {
                   return feature.geometry.coordinates;
               };
         //以下几个函数也可走默认值
         if (this.callback.getColor) {
             this.props.getColor = this.callback.getColor;
         }
         if (this.callback.getWidth) {
             this.props.getWidth = this.callback.getWidth;
         }
         if (this.callback.getDashArray) {
             this.props.getDashArray = this.callback.getDashArray;
         }
 
         this.layer = new window.DeckGL.PathLayer(this.props);
     }
 
     /**
      * @description polygon-layer
      * @private
      */
     _createPolygonLayer() {
         this.props.getPolygon = this.callback.getPolygon
             ? this.callback.getPolygon
             : function (feature) {
                   return feature.geometry.coordinates;
               };
 
         //todo 思考下真的让用户配这么多回调么，或者先判断下数据属性里面有没有配置的属性值？
 
         if (this.callback.getElevation) {
             this.props.getElevation = this.callback.getElevation;
         }
         if (this.callback.getFillColor) {
             this.props.getFillColor = this.callback.getFillColor;
         }
         if (this.callback.getLineColor) {
             this.props.getLineColor = this.callback.getLineColor;
         }
         if (this.callback.getLineWidth) {
             this.props.getLineWidth = this.callback.getLineWidth;
         }
         this.props.updateTriggers = {};
         this.props.updateTriggers.getColor = this.props.color ? this.props.color : [0, 0, 128, 128];
         this.layer = new window.DeckGL.PolygonLayer(this.props);
     }
 
     /**
      * @description arc-layer
      * @private
      */
     _createArcLineLayer() {
         //todo ArcLineLayer geojson coordinates数组中只能有一个线段
         this.props.getSourcePosition = this.callback.getSourcePosition
             ? this.callback.getSourcePosition
             : function (feature) {
                   if (!feature) {
                       return [0, 0, 0];
                   }
 
                   return feature.geometry.coordinates[0];
               };
         this.props.getTargetPosition = this.callback.getTargetPosition
             ? this.callback.getTargetPosition
             : function (feature) {
                   if (!feature) {
                       return [0, 0, 0];
                   }
 
                   return feature.geometry.coordinates[1];
               };
 
         if (this.callback.getStrokeWidth) {
             this.props.getStrokeWidth = this.callback.getStrokeWidth;
         }
         if (this.callback.getSourceColor) {
             this.props.getSourceColor = this.callback.getSourceColor;
         }
         if (this.callback.getTargetColor) {
             this.props.getTargetColor = this.callback.getTargetColor;
         }
 
         this.layer = new window.DeckGL.ArcLayer(this.props);
     }
 
     /**
      * @description hexagon-layer
      * @private
      */
     _createHexagonLayer() {
         this.props.getPosition = this.callback.getPosition
             ? this.callback.getPosition
             : function (feature) {
                   if (!feature) {
                       return [0, 0, 0];
                   }
 
                   return feature.geometry.coordinates;
               };
 
         if (this.callback.getColorValue) {
             this.props.getColorValue = this.callback.getColorValue;
         }
         if (this.callback.getElevationValue) {
             this.props.getElevationValue = this.callback.getElevationValue;
         }
         this.layer = new window.DeckGL.HexagonLayer(this.props);
     }
 
     _initContainer(targetElement, mapElement) {
        const { width, height } = mapElement.style;
        this.canvas = this._createCanvas(width, height);
        targetElement.appendChild(this.canvas);
     }
 
     _createCanvas(width, height) {
         let canvas = document.createElement('canvas');
         canvas.id = this.id;
         canvas.style.position = 'absolute';
         canvas.style.top = 0 + 'px';
         canvas.style.left = 0 + 'px';
         canvas.style.cursor = '';
         canvas.width = parseInt(width);
         canvas.height = parseInt(height);
         canvas.style.width = width;
         canvas.style.height = height;
         return canvas;
     }
 }
 
 
;// CONCATENATED MODULE: ./src/mapboxgl/overlay/DeckglLayer.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/




/**
 * @class DeckglLayer
 * @category  Visualization DeckGL
 * @classdesc Deckgl 高效率图层类。该图图层为综合图层，通过该图层可创建 高效率点图层、路径图层（线图层）、高效率面图层、曲线图层、
 *            正六边形图层（蜂巢图层）、网格图层，只需给定相依配置，因此，在创建图层之前，请仔细阅读参数配置。
 * @modulecategory Overlay
 * @param {string} layerTypeID - 高效率图层类型 ID，包括 "scatter-plot" 高效率点图层、"path-layer" 路径图层（线图层）、
 *                 "polygon-layer" 高效率面图层、"arc-layer" 曲线图层、"hexagon-layer" 正六边形图层（蜂巢图层）、"screen-grid-layer" 网格图层。
 *
 * @param {Object} options -  图层配置项，包括以下参数：
 * @param {Object} [options.layerId] - DeckglLayer 图层 Dom 元素 ID。默认使用 CommonUtil.createUniqueID("graphicLayer_" + this.layerTypeID + "_") 创建专题图层 ID。
 * @param {Array.<GeoJSONObject>} options.data - 图层数据,支持 GeoJSON 规范数据类型。
 * @param {Object} options.callback - deckgl 图层回调函数配置项。
 * @param {Object} options.props - deckgl 图层配置项, 在该参数下配置图层配置项：
 * @param {boolean} options.props.coverage - "hexagon-layer" 配置项：六边形半径乘数，介于0 - 1之间。六边形的最终半径通过覆盖半径计算。注意：覆盖范围不会影响分数的分配方式。分配方式的半径仅由半径属性确定；
 * @param {boolean} options.props.hexagonAggregator  - "hexagon-layer" 配置项：* @param {boolean}
 * @param {Object} options.props.lightSettings - 光照配置项。
 * @param {Array} options.props.lightSettings.lightsPosition - 光照配置项：指定为`[x，y，z]`的光在平面阵列中的位置`, 在一个平面阵列。长度应该是 `3 x numberOfLights`。
 * @param {Array} options.props.lightSettings.lightsStrength - 光照配置项：平面阵列中指定为“[x，y]`的灯的强度。长度应该是`2 x numberOfLights`。
 * @param {number} [options.props.lightSettings.numberOfLights=1]  - 光照配置项：光照值,最大值为 `5`。
 * @param {number} [options.props.lightSettings.coordinateSystem=COORDINATE_SYSTEM.LNGLAT]  - 光照配置项：指定灯位置的坐标系。
 * @param {number} [options.props.lightSettings.coordinateOrigin=[0, 0, 0]] - 光照配置项：指定灯位置的坐标原点。
 * @param {number} [options.props.lightSettings.modelMatrix] - 光照配置项：光位置的变换矩阵。
 * @param {number} [options.props.lightSettings.ambientRatio=0.4] - 光照配置项：光照的环境比例。
 * @param {number} [options.props.lightSettings.diffuseRatio=0.6] - 光照配置项：光的漫反射率。
 * @param {number} [options.props.lightSettings.specularRatio=0.8] - 光照配置项：光的镜面反射率。
 * @param {number} [options.props.opacity=1] - 公共配置项：图层不透明度度。
 * @param {boolean} [options.props.pickable=false] - 公共配置项：是否响应鼠标事件（鼠标点击，鼠标滑动)。
 * @param {function} [options.props.autoHighlight=false] - 公共配置项：鼠标滑动高亮要素。
 * @param {function} [options.props.highlightColor=[0, 0, 128, 128]] - 公共配置项：鼠标滑动高亮颜色。
 * @param {function} [options.props.onClick] - 公共配置项：鼠标点击事件。
 * @param {function} [options.props.onHover] - 公共配置项：鼠标滑动事件。
 * @param {number} [options.props.radiusScale=1] - "scatter-plot" 配置项：散点半径比例。
 * @param {boolean} [options.props.outline=false] - "scatter-plot" 配置项：是否边线显示。
 * @param {number} [options.props.strokeWidth=1]  - "scatter-plot" 配置项：边线宽度。
 * @param {number} [options.props.radiusMinPixels=0] - "scatter-plot" 配置项：半径最小像素值。
 * @param {number} [options.props.radiusMaxPixels=Number.MAX_SAFE_INTEGER]  - "scatter-plot" 配置项：半径最大像素值。
 * @param {boolean} [options.props.fp64=false] - "scatter-plot" 配置项：否应以高精度64位模式呈现图层。
 * @param {number} [options.props.widthScale=1] - "path-layer" 配置项：线宽比例。
 * @param {number} [options.props.widthMinPixels=0] - "path-layer" 配置项：线宽最小像素值。
 * @param {number} [options.props.widthMaxPixels=Number.MAX_SAFE_INTEGER] - "path-layer" 配置项：线宽最大像素值。
 * @param {boolean} [options.props.rounded=false] - "path-layer" 配置项：节点是否绘制为弧形。
 * @param {number} [options.props.miterLimit=4] - "path-layer" 配置项：节点相对于线宽的最大范围,仅在 rounded 为 false 时有效；
 * @param {boolean} [options.props.fp64=false] - "path-layer" 配置项：否应以高精度64位模式呈现图层。
 * @param {boolean} [options.props.dashJustified=false] - "path-layer" 配置项：是否虚线形式显示，仅在 getDashArray() 回调函数被指定时有效。
 * @param {boolean} [options.props.filled=true] - "polygon-layer" 配置项：是否填充面。
 * @param {boolean} [options.props.stroked=true] - "polygon-layer" 配置项：是否绘制边线。
 * @param {boolean} [options.props.extruded=false] - "polygon-layer" 配置项：是否拉伸建筑。
 * @param {boolean} [options.props.wireframe=false] - "polygon-layer" 配置项：当面被拉伸为建筑时，是否描绘建筑物边线。
 * @param {boolean} [options.props.elevationScale=1] - "polygon-layer" 配置项：海拔比例。
 * @param {boolean} [options.props.lineWidthScale=1] - "polygon-layer" 配置项：线宽比例。
 * @param {boolean} [options.props.lineWidthMinPixels=0] - "polygon-layer" 配置项：线宽最小像素值。
 * @param {boolean} [options.props.lineWidthMaxPixels=Number.MAX_SAFE_INTEGER] - "polygon-layer" 配置项：线宽最大像素值。
 * @param {boolean} [options.props.lineJointRounded=false] - "polygon-layer" 配置项：节点是否绘制为弧形。
 * @param {boolean} [options.props.lineMiterLimit=4] - "polygon-layer" 配置项：节点相对于线宽的最大范围，仅在 lineJointRounded 为 false 时有效。
 * @param {boolean} [options.props.lineDashJustified=false] - "polygon-layer" 配置项：是否虚线形式显示，仅在 getLineDashArray() 回调函数被指定时有效。
 * @param {boolean} [options.props.fp64=false] - "polygon-layer" 配置项：否应以高精度64位模式呈现图层。
 * @param {boolean} [options.props.fp64=false] - "arc-layer" 配置项：否应以高精度64位模式呈现图层。
 * @param {boolean} [options.props.strokeWidth=1] - "arc-layer" 配置项：线宽。
 * @param {boolean} [options.props.radius=1000] - "hexagon-layer" 配置项：六边形半径值。
 * @param {boolean} [options.props.extruded=false] - "hexagon-layer" 配置项：是否拉伸要素。
 * @param {boolean} [options.props.upperPercentile=100] - "hexagon-layer" 配置项：筛选箱并通过upperPercentile重新计算颜色。颜色值大于upperPercentile的六边形将被隐藏。
 * @param {boolean} [options.props.elevationScale=1] - "hexagon-layer" 配置项：高程乘数，实际海拔高度由 elevationScale * getElevation（d）计算。 elevationScale是一个方便的属性，可以在不更新数据的情况下缩放所有六边形。
 * @param {boolean} [options.props.colorDomain=false]  - "hexagon-layer" 配置项：色阶。
 * @param {boolean} [options.props.colorRange=[[255,255,178,255],[254,217,118,255],[254,178,76,255],[253,141,60,255],[240,59,32,255],[189,0,38,255]]]   - "hexagon-layer" 配置项：色带。
 * @usage
 * @extends {DeckglLayerBase}
 */
class DeckglLayer extends DeckglLayerBase {
    constructor(layerTypeID, options) {
        super(layerTypeID, options);
        this.type='custom';
        this.renderingMode = '3d';
        this.overlay = true;
    }

    /**
     * @function DeckglLayer.prototype.onAdd
     * @param {mapboxgl.Map} map - MapBoxGL Map 对象。
     * @returns {DeckglLayer}
     */
    onAdd(map) {
        this.map = map;
        if (this.canvas) {
            this.mapContainer = this.map.getCanvasContainer();
            return this;
        }
        //当使用扩展的mapboxgl代码时有效
        if (this._isEPSG3857()) {
            this.coordinateSystem = 3;
            this.isGeographicCoordinateSystem = true;
        } else {
            this.coordinateSystem = 1;
            this.isGeographicCoordinateSystem = false;
        }
        //创建图层容器
        this._initContainer(this.map.getCanvasContainer(), this.map.getCanvas());

        //创建 deckgl 图层
        this._createLayerByLayerTypeID();

        var mapState = this._getState();
        let deckOptions = {};
        for (let key in mapState) {
            deckOptions[key] = mapState[key];
        }
        deckOptions.layers = [this.layer];
        deckOptions.canvas = this.canvas;
        this.deckGL = new window.DeckGL.experimental.DeckGLJS(deckOptions);
        this._draw();
        return this;
    }

    /**
     * @function DeckglLayer.prototype.onRemove
     * @param {maplibregl.Map} map - MapLibreGL Map 对象。
     */
    onRemove() {
      this.map.getCanvasContainer().removeChild(this.canvas);
      this.clear();
    }

    /**
     * @function DeckglLayer.prototype.getMapInfo
     * @param {maplibregl.Map} map - MapLibreGL Map 对象。
     */
    getMapInfo() {
      let center = this.map.getCenter();
      let zoom = this.map.getZoom();
      let maxZoom = this.map.getMaxZoom();
      let pitch = this.map.getPitch();
      let bearing = this.map.getBearing();
      let longitude = center.lng;
      let latitude = center.lat;
      return { center, zoom, maxZoom, pitch, bearing, longitude, latitude };
    }

    /**
     * @function DeckglLayer.prototype.render
     */
    render() {
      this._draw();
    }

    _isEPSG3857() {
      return this.map.getCRS && this.map.getCRS() !== (external_mapboxgl_default()).CRS.EPSG3857
    }
}


;// CONCATENATED MODULE: ./src/common/overlay/graticule/GraticuleLayerRenderer.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/
/**
 * reference and modification
 * dereklieu/cool-grid, cloudybay/leaflet.latlng-graticule
 * (https://github.com/dereklieu/cool-grid, https://github.com/cloudybay/leaflet.latlng-graticule)
 * Apache Licene 2.0
 * thanks dereklieu, cloudybay
 */


/**
 * @private
 * @class GraticuleLayerRenderer
 * @classdesc 经纬网。
 * @version 11.1.1
 * @param {Object} options - 参数。
 * @param {boolean} [options.visible=true] - 是否显示经纬网。
 * @param {boolean} [options.showLabel=true] - 是否显示标签。
 * @param {number} [options.opacity=1] - 画布不透明度。
 * @param {number|function} [options.interval = 10] - 经纬度的间隔（以度为单位），可以是数字，也可以是函数，参数是map。
 * @param {Array.<number>} [options.extent] - 经纬网渲染的边界范围（[minx, miny, maxx, maxy]），不传为整个地图范围。
 * @param {number} [options.minZoom] - 最小视图缩放级别（不包括此级别），在该级别之上，该层将可见。
 * @param {number} [options.maxZoom] - 该图层可见的最大视图缩放级别（含）。
 * @param {function} [options.lngLabelFormatter = null] - 经度标签转换函数。
 * @param {function} [options.latLabelFormatter = null] - 纬度标签转换函数。
 * @param {GraticuleLayerRenderer.LabelStyle} [options.lngLabelStyle] - 经度标签样式。
 * @param {GraticuleLayerRenderer.LabelStyle} [options.latLabelStyle] - 纬度标签样式。
 * @param {GraticuleLayerRenderer.StrokeStyle} [options.strokeStyle] - 绘制经纬线的样式。
 * @param {Object} [functions] - 图层传递给渲染器调用的方法。
 * @param {Object} [mapOptions] - 图层传递给渲染器的地图元素信息。
 * @usage
 */

const defaultTextStyle = {
    textSize: '12px',
    textFont: ['12px Calibri', 'sans-serif'],
    textAnchor: 'bottom',
    textColor: 'rgba(0,0,0,1)',
    textHaloColor: 'rgba(255,255,255,1)',
    textHaloWidth: 1
};
const defaultStrokeStyle = {
    lineColor: 'red',
    lineCap: 'round', // butt, round, square
    lineJoin: 'round', // bevel, round, miter
    lindDasharray: [0.4, 5], // 数组|function
    lineDashOffset: 0,
    lineWidth: 1 // 数字|function
};
const defaultOptions = {
    showLabel: true,
    opacity: 1,
    visible: true,
    interval: 10, // function|number
    extent: null,
    minZoom: 0,
    maxZoom: 50,
    wrapX: true,
    strokeStyle: defaultStrokeStyle,
    lngLabelFormatter: null,
    latLabelFormatter: null,
    lngLabelStyle: defaultTextStyle,
    latLabelStyle: defaultTextStyle
};
class GraticuleLayerRenderer {
    constructor(map, options, functions, mapOptions) {
        this.map = map;
        this.id = mapOptions && mapOptions.id;
        this.sourceId = this.id + '_line';
        this.canvasId = this.id;
        this.options = options;
        this.mapElement = mapOptions.mapElement;
        this.targetElement = mapOptions.targetElement;
        this.getMapStateByKey = functions.getMapStateByKey;
        this.getDefaultExtent = functions.getDefaultExtent;
        this.setVisibility = functions.setVisibility;
        this.updateGraticuleLayer = functions.updateGraticuleLayer;
        this.init();
    }

    init() {
        this._initialize();
        this._createCanvas();
        this._drawCanvas();
        this.setVisibility();
        this._drawLabel();
    }

    onRemove() {
      this.targetElement.removeChild(this.canvas);
      this.canvas = null;
    }

    /**
     * @function GraticuleLayerRenderer.prototype.setMinZoom
     * @description 设置最小视图缩放级别。
     * @param {number} minZoom - 最小视图缩放级别（不包括此级别），在该级别之上，该层将可见。
     */
    setMinZoom(minZoom) {
        this.options.minZoom = minZoom;
        this.setVisibility();
    }

    /**
     * @function GraticuleLayerRenderer.prototype.setMaxZoom
     * @description 该图层可见的最大视图缩放级别。
     * @param {number} maxZoom - 该图层可见的最大视图缩放级别（含）。
     */
    setMaxZoom(maxZoom) {
        this.options.maxZoom = maxZoom;
        this.setVisibility();
    }

    /**
     * @function GraticuleLayerRenderer.prototype.setShowLabel
     * @description 设置显示标签。
     * @param {boolean} showLabel - 是否显示标签。
     */
    setShowLabel(showLabel) {
        this.options.showLabel = showLabel;
        this._drawLabel();
    }

    /**
     * @function GraticuleLayerRenderer.prototype.setExtent
     * @description 设置经纬网渲染的边界范围。
     * @param {Array.<number>} extent - 经纬网渲染的边界范围。
     */
    setExtent(extent) {
        this.options.extent = this.getDefaultExtent(extent);
        this.features = this._getGraticuleFeatures();
        this.updateGraticuleLayer();
        this._drawLabel();
    }

    /**
     * @function GraticuleLayerRenderer.prototype.setLngLabelStyle
     * @description 设置经度标签样式。
     * @param {GraticuleLayerRenderer.LabelStyle} labelStyle - 标签样式。
     */
    setLngLabelStyle(labelStyle) {
        this.options.lngLabelStyle = labelStyle;
        this._drawLabel();
    }

    /**
     * @function GraticuleLayerRenderer.prototype.setLatLabelStyle
     * @description 设置纬度标签样式。
     * @param {GraticuleLayerRenderer.LabelStyle} labelStyle - 标签样式。
     */
    setLatLabelStyle(labelStyle) {
        this.options.latLabelStyle = labelStyle;
        this._drawLabel();
    }

    /**
     * @function GraticuleLayerRenderer.prototype.setIntervals
     * @description 设置经纬度的间隔（以度为单位）。
     * @param {number|function} interval - 经纬度的间隔（以度为单位），可以是数字，也可以是函数，参数是map。
     */
    setIntervals(interval) {
        this.options.interval = interval;
        this._calcInterval();
        this.features = this._getGraticuleFeatures();
        this.updateGraticuleLayer();
        this._drawLabel();
    }

    draw() {
      this._reset();
    }

    _initialize(options = this.options) {
        options = options || {};
        options.strokeStyle = Object.assign({}, defaultStrokeStyle, options.strokeStyle || {});
        options.lngLabelStyle = Object.assign({}, defaultTextStyle, options.lngLabelStyle || {});
        options.latLabelStyle = Object.assign({}, defaultTextStyle, options.latLabelStyle || {});
        this.options = Object.assign({}, defaultOptions, options, {
            extent: this.getDefaultExtent(options.extent),
            // 提出去
            wrapX: options.wrapX
        });
        this.oldExtent = this.options.extent;
        this._calcInterval();
        this.isRotate = false;
        this.visible = true;
        this.features = this._getGraticuleFeatures();
    }

    _createCanvas() {
        if (this.canvas) {
            return;
        }
        const mapElement = this.mapElement;
        this.canvas = document.createElement('canvas');
        this.canvas.id = this.canvasId;
        this.canvas.style.position = 'absolute';
        this.canvas.style.top = 0 + 'px';
        this.canvas.style.left = 0 + 'px';
        var global$2 = typeof window === 'undefined' ? {} : window;
        var devicePixelRatio = global$2.devicePixelRatio || 1;
        this.canvas.width = parseInt(mapElement.style.width) * devicePixelRatio;
        this.canvas.height = parseInt(mapElement.style.height) * devicePixelRatio;
        this.canvas.style.width = mapElement.style.width;
        this.canvas.style.height = mapElement.style.height;
        this.canvas.globalAlpha = this.options.opacity;
        this.targetElement.appendChild(this.canvas);
    }

    _drawCanvas() {
        if (!this.canvas) {
            this._createCanvas();
        }
        this.setVisibility();
        this._reset();
    }

    _resizeCallback() {
        this.targetElement && this.targetElement.removeChild(this.canvas);
        this.canvas = null;
        this._drawCanvas();
    }

    _reset() {
        this._updateRotate();
        this._updateExtent();
        this._calcInterval();
        this._drawLabel();
    }

    _updateRotate() {
        const bearing = this.getMapStateByKey('getBearing');
        this.isRotate = (bearing > -180 && bearing <= -90) || (bearing >= 90 && bearing < 180);
    }

    _updateExtent() {
        if (this.options.wrapX && !this.oldExtent) {
            const { _ne, _sw } = this.getMapStateByKey('getBounds');
            this.options.extent = [_sw.lng, _sw.lat, _ne.lng, _ne.lat];
        }
    }

    _calcInterval(interval = this.options.interval) {
        if (typeof interval === 'function') {
            interval = interval(this.map);
            this._currLngInterval = interval;
            this._currLatInterval = interval;
        } else {
            this._currLngInterval = interval;
            this._currLatInterval = interval;
        }
    }

    _formatLat(lat) {
        if (this.options.latFormatTickLabel) {
            return this.options.latLabelFormatter(lat);
        }
        if (lat < 0) {
            return '' + conversionDegree(lat * -1) + 'S';
        } else if (lat > 0) {
            return '' + conversionDegree(lat) + 'N';
        }
        return '' + conversionDegree(lat);
    }

    _formatLng(lng) {
        if (this.options.lngLabelFormatter) {
            return this.options.lngLabelFormatter(lng);
        }
        lng = getWrapNum(lng);
        if (lng > 0 && lng <= 180) {
            return '' + conversionDegree(lng) + 'E';
        } else if (lng < 0 && lng >= -180) {
            return '' + conversionDegree(lng * -1) + 'W';
        }
        return '' + conversionDegree(lng);
    }

    _parsePxToInt(txt) {
        if (txt.length > 2) {
            if (txt.charAt(txt.length - 2) === 'p') {
                txt = txt.substr(0, txt.length - 2);
            }
        }
        try {
            return parseInt(txt, 10);
        } catch (e) {
            console.log(e);
        }
        return 0;
    }

    _drawLabel(visible = this.visible) {
        const canvas = this.canvas;
        const ctx = canvas.getContext('2d');
        if (!visible || !this.options.showLabel) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            return;
        }
        if (this.mapElement) {
            if (!this._currLngInterval || !this._currLatInterval) {
                this._calcInterval();
            }
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const { lngLabelStyle, latLabelStyle } = this.options;
            const { lngPoints, latPonits } = this._getGridiculePoints();
            lngPoints.forEach(point => {
                this._drawLng(ctx, point[0], point[1], point[2], lngLabelStyle);
            });
            latPonits.forEach(point => {
                this._drawLat(ctx, point[0], point[1], point[2], latLabelStyle);
            });
        }
    }

    _drawLat(ctx, latTick, bb, isIntersect, latLabelStyle) {
        ctx = this._setLabelStyle(ctx, latLabelStyle);
        const ww = this.canvas.width;
        let txtHeight = 12;
        try {
            const fontSize = ctx.font.split(' ')[0];
            txtHeight = this._parsePxToInt(fontSize);
        } catch (e) {
            console.log(e);
        }
        if (!isIntersect) {
            const lngR = latTick;
            latTick = bb;
            bb = this.getMapStateByKey('project', [lngR, latTick]);
        }
        const latstr = this._formatLat(latTick);
        const txtWidth = ctx.measureText(latstr).width;
        ctx.strokeText(latstr, (isIntersect ? ww : bb.x) - txtWidth, (isIntersect ? bb : bb.y) + txtHeight / 2);
        ctx.fillText(latstr, (isIntersect ? ww : bb.x) - txtWidth, (isIntersect ? bb : bb.y) + txtHeight / 2);
    }

    _drawLng(ctx, lngTick, bb, isIntersect, lngLabelStyle) {
        ctx = this._setLabelStyle(ctx, lngLabelStyle);
        const hh = this.canvas.height;
        if (!isIntersect) {
            const latTick = bb;
            bb = this.getMapStateByKey('project', [lngTick, latTick]);
        }
        const lngstr = this._formatLng(lngTick);
        const txtWidth = ctx.measureText(lngstr).width;
        ctx.strokeText(lngstr, (isIntersect ? bb : bb.x) - txtWidth / 2, isIntersect ? hh : bb.y);
        ctx.fillText(lngstr, (isIntersect ? bb : bb.x) - txtWidth / 2, isIntersect ? hh : bb.y);
    }

    _getLatPoints(lngRange = [-180, 180], firstLng, lastLng, features = this.features) {
        if (!features) {
            return;
        }
        if (this.options.wrapX && lngRange[0] === -180 && lngRange[1] === 180) {
            return [];
        }
        let points = [];

        features.forEach(feature => {
            const lat = feature.geometry.coordinates[0][1];
            const isLatFeature = feature.geometry.coordinates[1][1] === lat;
            if (isLatFeature) {
                let lng = typeof lastLng === 'number' ? lastLng : lngRange[1];
                if (this.isRotate) {
                    lng = typeof firstLng === 'number' ? firstLng : lngRange[0];
                }
                if (this.options.wrapX) {
                    points = points.concat(this._getWrapPoints(lng, lat, [lng, lng]));
                }
                points.push([lng, lat]);
            }
        });
        return points;
    }

    _getLngPoints(latRange = [-90, 90], firstLat, lastLat, features = this.features) {
        if (!features) {
            return;
        }

        let lat = typeof firstLat === 'number' ? firstLat : latRange[0];
        if (this.isRotate) {
            lat = typeof lastLat === 'number' ? lastLat : latRange[1];
        }
        let points = [];

        features.forEach(feature => {
            let lng = feature.geometry.coordinates[0][0];
            const isLngFeature = feature.geometry.coordinates[1][0] === lng;
            if (isLngFeature) {
                points.push([lng, lat]);
                if (this.options.wrapX) {
                    points = points.concat(this._getWrapPoints(lng, lat));
                }
            }
        });

        return points;
    }

    _getWrapPoints(lng, lat, extent = this.oldExtent) {
        const points = [];
        const { _ne, _sw } = this.getMapStateByKey('getBounds');
        const lastLng = extent.length > 2 ? extent[2] : extent[1];
        while (lng >= _sw.lng) {
            const wrapNum = getWrapNum(lng, lastLng === 180, extent[0] === -180);
            if (!extent || (wrapNum >= extent[0] && wrapNum <= lastLng)) {
                points.push([lng, lat]);
            }
            lng -= 360;
        }
        while (lng <= _ne.lng) {
            const wrapNum = getWrapNum(lng, lastLng === 180, extent[0] === -180);
            if (!extent || (wrapNum >= extent[0] && wrapNum <= lastLng)) {
                points.push([lng, lat]);
            }
            lng += 360;
        }
        return points;
    }

    _getGridiculePoints() {
        const intersectLatPoints = this._getEdgeLat();
        const intersectLngPoints = this._getEdgeLng();
        const { latRange, lngRange, firstLat, firstLng, lastLat, lastLng } = this._getRange();
        const latPonits = this._getUniquePoint(this._getLatPoints(lngRange, firstLng, lastLng), intersectLatPoints, 1);
        const lngPoints = this._getUniquePoint(this._getLngPoints(latRange, firstLat, lastLat), intersectLngPoints, 0);
        return { latPonits, lngPoints };
    }

    _getEdgeLat(_currLatInterval = this._currLatInterval) {
        let latPoints = [];
        let latCoordinates = [];
        let firstLat;
        const ww = this.canvas.width;
        const hh = this.canvas.height;
        const { extent } = this._getRange();
        const { _ne } = this.getMapStateByKey('getBounds');
        if (this.options.wrapX && getWrapNum(_ne.lng) > extent[2]) {
            return [];
        }
        const countDecimals = this._countDecimals(_currLatInterval);
        for (let i = 0; i <= hh; i++) {
            const point = this.getMapStateByKey('unproject', [ww, i]);
            const wrapNum = getWrapNum(point.lng);
            const lngEdge = this.options.wrapX
                ? wrapNum >= extent[0] && wrapNum <= extent[2]
                : point.lng >= extent[0] && point.lng <= extent[2];
            if (lngEdge && point.lat >= extent[1] && point.lat <= extent[3]) {
                latPoints.push([point.lat, i]);
                latCoordinates.push(point.lat);
                if (firstLat === undefined && point.lat.toFixed(countDecimals) % _currLatInterval === 0) {
                    firstLat = Number(point.lat.toFixed(countDecimals));
                }
            }
        }
        const { first, last, coordinates, points } = this._getIntersectRange(
            firstLat,
            latCoordinates,
            latPoints,
            _currLatInterval
        );

        firstLat = Math.min(Math.max(first, -90), 90);
        const lastLat = Math.max(Math.min(Math.round(last), 90), -90);
        if (firstLat !== -90 || lastLat !== -90) {
            return this._getClosestCoordinate(firstLat, lastLat, coordinates, points, _currLatInterval);
        }
        return [];
    }

    _getEdgeLng(_currLngInterval = this._currLngInterval) {
        let lngPoints = [];
        let lngCoordinates = [];
        let firstLng;
        const ww = this.canvas.width;
        const hh = this.canvas.height;
        const extent = this.options.extent;
        const countDecimals = this._countDecimals(_currLngInterval);
        const { _sw } = this.getMapStateByKey('getBounds');
        if (this.options.wrapX && getWrapNum(_sw.lat) > extent[3]) {
            return [];
        }
        for (let i = 0; i <= ww; i++) {
            const point = this.getMapStateByKey('unproject', [i, hh]);
            const wrapNum = getWrapNum(point.lng);
            const lngEdge = this.options.wrapX
                ? wrapNum >= extent[0] && wrapNum <= extent[2]
                : point.lng >= extent[0] && point.lng <= extent[2];
            if (lngEdge && point.lat >= extent[1] && point.lat <= extent[3]) {
                lngPoints.push([point.lng, i]);
                lngCoordinates.push(point.lng);
                if (firstLng === undefined && point.lng.toFixed(countDecimals) % _currLngInterval === 0) {
                    firstLng = Number(point.lng.toFixed(countDecimals));
                }
            }
        }
        const { first, last: lastLng, coordinates, points } = this._getIntersectRange(
            firstLng,
            lngCoordinates,
            lngPoints,
            _currLngInterval
        );
        firstLng = first;
        return this._getClosestCoordinate(firstLng, lastLng, coordinates, points, _currLngInterval);
    }

    _getIntersectRange(first, coordinates, points, interval) {
        let last = coordinates[coordinates.length - 1];
        if (first > last) {
            last = first;
            coordinates.reverse();
            points.reverse();
            const countDecimals = this._countDecimals(interval);
            for (let i = 0; i <= coordinates.length; i++) {
                const point = coordinates[i];
                if (point.toFixed(countDecimals) % interval === 0) {
                    first = Number(point.toFixed(countDecimals));
                    break;
                }
            }
        }
        return { first, last, coordinates, points };
    }

    _getClosestCoordinate(first, last, coordinates, points, interval) {
        let result = [];
        let graticule = first;
        while (graticule <= last) {
            const index = this._getClosestNumberIndex(graticule, coordinates);
            const point = points[index];
            result.push([Math.round(point[0]), point[1], true]);
            graticule += interval;
            coordinates = coordinates.slice(index);
            points = points.slice(index);
        }
        return result;
    }

    _getClosestNumberIndex(num, arr) {
        var index = 0;
        var diffValue = Number.MAX_VALUE;
        for (var i = 0; i < arr.length; i++) {
            var newDiffValue = Math.abs(arr[i] - num);
            if (newDiffValue <= diffValue) {
                if (newDiffValue === diffValue && arr[i] < arr[index]) {
                    continue;
                }
                index = i;
                diffValue = newDiffValue;
            }
        }
        return index;
    }

    _getUniquePoint(points, intersectPoints, index = 0) {
        if (this.options.wrapX) {
            return points.concat(intersectPoints);
        }
        if (!intersectPoints || intersectPoints.length === 0) {
            return points;
        }
        var tmp = intersectPoints;
        const width = this.canvas.width;
        const height = this.canvas.height;
        for (var i in points) {
            const edgePoint = this.getMapStateByKey('project', points[i]);
            const intersetIndex = tmp.findIndex(item => item[0] === points[i][index]);
            if (intersetIndex <= -1) {
                tmp.push(points[i]);
            } else if (
                edgePoint &&
                edgePoint.x >= 0 &&
                edgePoint.x <= width &&
                edgePoint.y >= 0 &&
                edgePoint.y <= height
            ) {
                tmp[intersetIndex] = points[i];
            }
        }
        return tmp;
    }

    _countDecimals(value) {
        if (Math.floor(value) !== value) {
            return value.toString().split('.')[1].length || 0;
        }
        return 0;
    }

    _getGraticuleFeatures() {
        const _currLngInterval = this._currLngInterval || 10;
        const _currLatInterval = this._currLatInterval || 10;
        const features = [];
        let { latRange, lngRange, firstLat, firstLng, lastLat, lastLng } = this._getRange();

        if (this.options.wrapX && !this.oldExtent) {
            latRange = [-90, 90];
            lngRange = [-180, 180];
            firstLat = firstLng = lastLat = lastLng = null;
        }
        if (typeof firstLng === 'number') {
            features.unshift(this._makeLineFeature(this._makeLineCoords(firstLng, latRange, firstLat, lastLat)));
        }
        if (typeof lastLng === 'number') {
            features.unshift(this._makeLineFeature(this._makeLineCoords(lastLng, latRange, firstLat, lastLat)));
        }
        for (var lng = lngRange[0]; lng <= lngRange[1]; lng += _currLngInterval) {
            features.unshift(this._makeLineFeature(this._makeLineCoords(lng, latRange, firstLat, lastLat)));
        }

        if (typeof firstLat === 'number') {
            features.unshift(this._makeLineFeature(this._makeLineCoords(firstLat, lngRange, firstLng, lastLng, 'lat')));
        }
        if (typeof lastLat === 'number') {
            features.unshift(this._makeLineFeature(this._makeLineCoords(lastLat, lngRange, firstLng, lastLng, 'lat')));
        }

        for (var lat = latRange[0]; lat <= latRange[1]; lat += _currLatInterval) {
            features.unshift(this._makeLineFeature(this._makeLineCoords(lat, lngRange, firstLng, lastLng, 'lat')));
        }
        return features;
    }

    _getRange(extent = this.options.extent && [...this.options.extent]) {
        if (!extent || extent.length === 0) {
            extent = this.getDefaultExtent();
        }
        extent = extent.map(item => {
            return Number(item.toFixed(6));
        });
        const realExtent = {};
        if (extent[1] % this._currLatInterval !== 0) {
            realExtent.firstLat = extent[1];
            const intNumber = Math.ceil(extent[1] / this._currLatInterval);
            extent[1] = intNumber * this._currLatInterval;
        }
        if (extent[3] % this._currLatInterval !== 0) {
            realExtent.lastLat = extent[3];
            const intNumber = Math.floor(extent[3] / this._currLatInterval);
            extent[3] = intNumber * this._currLatInterval;
        }
        if (extent[0] % this._currLngInterval !== 0) {
            realExtent.firstLng = extent[0];
            const intNumber = Math.ceil(extent[0] / this._currLngInterval);
            extent[0] = intNumber * this._currLngInterval;
        }
        if (extent[2] % this._currLngInterval !== 0) {
            realExtent.lastLng = extent[2];
            const intNumber = Math.floor(extent[2] / this._currLngInterval);
            extent[2] = intNumber * this._currLngInterval;
        }
        const result = Object.assign(
            { latRange: [extent[1], extent[3]], lngRange: [extent[0], extent[2]], extent },
            realExtent
        );
        return result;
    }

    _makeLineCoords(fixedDegree, range = [-90, 90], first, last, type = 'lng') {
        fixedDegree = type === 'lng' ? this._lngFix(fixedDegree) : fixedDegree;
        first = typeof first === 'number' ? first : range[0];
        last = typeof last === 'number' ? last : range[1];
        const interval = Math.abs(first - last);
        const coords = [];
        for (var changedDegree = first; changedDegree <= last; changedDegree += interval) {
            if (type === 'lng') {
                coords.push([fixedDegree, changedDegree]);
            } else {
                coords.push([changedDegree, fixedDegree]);
            }
        }
        return coords;
    }

    _makeLineFeature(coordinates, type = 'LineString') {
        return {
            type: 'Feature',
            geometry: {
                type,
                coordinates
            }
        };
    }

    _lngFix(lng) {
        if (lng >= 180) {
            return 180;
        }
        if (lng <= -180) {
            return -180;
        }
        return lng;
    }

    _transformStrokeStyle(strokeStyle = this.options.strokeStyle) {
        if (!strokeStyle || typeof strokeStyle === 'string') {
            return { paint: { 'line-color': strokeStyle || 'rgba(0,0,0,0.2)' } };
        }
        const layout = {
            visibility: this.visible ? 'visible' : 'none',
            'line-join': strokeStyle.lineJoin || 'round',
            'line-cap': strokeStyle.lineCap || 'round'
        };
        const paint = {
            'line-color': strokeStyle.lineColor || 'rgba(0,0,0,0.2)',
            'line-width': strokeStyle.lineWidth || 1,
            'line-offset': strokeStyle.lineDashOffset || 0,
            'line-translate-anchor': 'viewport'
        };

        if (strokeStyle.lineWidth) {
            if (typeof strokeStyle.lineWidth === 'function') {
                paint['line-width'] = strokeStyle.lineWidth(this.map);
            } else {
                paint['line-width'] = strokeStyle.lineWidth;
            }
        }
        if (strokeStyle.lindDasharray) {
            if (typeof strokeStyle.lindDasharray === 'function') {
                paint['line-dasharray'] = strokeStyle.lindDasharray(this.map);
            } else {
                paint['line-dasharray'] = strokeStyle.lindDasharray;
            }
        }
        return { layout, paint };
    }

    _setLabelStyle(ctx, labelStyle) {
        if (labelStyle.textColor) {
            ctx.fillStyle = labelStyle.textColor;
        }
        if (labelStyle.textSize) {
            ctx.font = labelStyle.textSize + ' ' + (labelStyle.textFont || ['Calibri', 'sans-serif']).join(',');
        }
        if (labelStyle.textHaloColor) {
            ctx.strokeStyle = labelStyle.textHaloColor;
            ctx.lineWidth = labelStyle.textHaloWidth || 1;
        }
        if (labelStyle.textAnchor) {
            ctx.textBaseline = this._getTxetBaseline(labelStyle.textAnchor);
            ctx.textAligin = this._getTxetAlign(labelStyle.textAligin);
        }
        return ctx;
    }

    _getTxetBaseline(textAnchor) {
        if (!textAnchor) {
            return 'bottom';
        }
        const textStyle = textAnchor.split('-');
        if (textStyle.includes('bottom')) {
            return 'bottom';
        }
        if (textStyle.includes('top')) {
            return 'top';
        }
        if (textStyle.includes('center')) {
            return 'middle';
        }
    }
    _getTxetAlign(textAnchor) {
        if (!textAnchor) {
            return 'center';
        }
        const textStyle = textAnchor.split('-');
        if (textStyle.includes('left')) {
            return 'left';
        }
        if (textStyle.includes('right')) {
            return 'right';
        }
        if (textStyle.includes('center')) {
            return 'center';
        }
    }
}


;// CONCATENATED MODULE: ./src/mapboxgl/overlay/GraticuleLayer.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/
/**
 * reference and modification
 * dereklieu/cool-grid, cloudybay/leaflet.latlng-graticule
 * (https://github.com/dereklieu/cool-grid, https://github.com/cloudybay/leaflet.latlng-graticule)
 * Apache Licene 2.0
 * thanks dereklieu, cloudybay
 */




/**
 * @class GraticuleLayer
 * @category Visualization GraticuleLayer
 * @classdesc 经纬网类。
 * @modulecategory Overlay
 * @version 10.1.1
 * @param {Object} options - 参数。
 * @param {string} [options.layerID] - 图层 ID。默认使用 CommonUtil.createUniqueID("graticuleLayer_") 创建图层 ID。
 * @param {boolean} [options.visible=true] - 是否显示经纬网。
 * @param {boolean} [options.showLabel=true] - 是否显示标签。
 * @param {number} [options.opacity=1] - 画布不透明度。
 * @param {number|function} [options.interval = 10] - 经纬度的间隔（以度为单位），可以是数字，也可以是函数，参数是map。
 * @param {mapboxgl.LngLatBounds} [options.extent] - 经纬网渲染的边界范围（[minx, miny, maxx, maxy]），不传为整个地图范围。
 * @param {number} [options.minZoom] - 最小视图缩放级别（不包括此级别），在该级别之上，该层将可见。
 * @param {number} [options.maxZoom] - 该图层可见的最大视图缩放级别（含）。
 * @param {function} [options.lngLabelFormatter = null] - 经度标签转换函数。
 * @param {function} [options.latLabelFormatter = null] - 纬度标签转换函数。
 * @param {GraticuleLayer.LabelStyle} [options.lngLabelStyle] - 经度标签样式。
 * @param {GraticuleLayer.LabelStyle} [options.latLabelStyle] - 纬度标签样式。
 * @param {GraticuleLayer.StrokeStyle} [options.strokeStyle] - 绘制经纬线的样式。
 * @usage
 */

/**
 * @typedef {Object} GraticuleLayer.LabelStyle - 标签样式。
 * @property {Array.<string>} [textFont = ['Calibri','sans-serif']] - 字体样式。
 * @property {string} [textSize = '12px'] - 字体大小。
 * @property {string} [textColor ='rgba(0,0,0,1)'] - 字体颜色。
 * @property {string} [textHaloColor ='rgba(255,255,255,1)'] - 描边颜色。
 * @property {number} [textHaloWidth = 1] - 描边宽度。
 * @property {string} [textAnchor = 'bottom'] - 字体基线: "center", "left", "right", "top", "bottom", "top-left", "top-right", "bottom-left", "bottom-right"。
 */

/**
 * @typedef {Object} GraticuleLayer.StrokeStyle - 线样式。
 * @property {string} [lineColor = 'red'] - 线颜色。
 * @property {string} [lineCap = 'round'] - 线端点风格：butt, round, square。
 * @property {string} [lineJoin = round] - 线连接样式：bevel, round, miter。
 * @property {Array.<number>} [lindDasharray = [0.5,4]] - 虚线样式。
 * @property {number} [lineWidth = 1] - 线宽。
 */

const GraticuleLayer_defaultTextStyle = {
  textSize: '12px',
  textFont: ['12px Calibri', 'sans-serif'],
  textAnchor: 'bottom',
  textColor: 'rgba(0,0,0,1)',
  textHaloColor: 'rgba(255,255,255,1)',
  textHaloWidth: 1
};
const GraticuleLayer_defaultStrokeStyle = {
  lineColor: 'red',
  lineCap: 'round', // butt, round, square
  lineJoin: 'round', // bevel, round, miter
  lindDasharray: [0.4, 5], // 数组|function
  lineDashOffset: 0,
  lineWidth: 1 // 数字|function
};
const GraticuleLayer_defaultOptions = {
  showLabel: true,
  opacity: 1,
  visible: true,
  interval: 10, // function|number
  extent: null,
  minZoom: 0,
  maxZoom: 50,
  wrapX: true,
  strokeStyle: GraticuleLayer_defaultStrokeStyle,
  lngLabelFormatter: null,
  latLabelFormatter: null,
  lngLabelStyle: GraticuleLayer_defaultTextStyle,
  latLabelStyle: GraticuleLayer_defaultTextStyle
};

class GraticuleLayer {
  constructor(options) {
    this.id = options && options.layerID ? options.layerID : Util_Util.createUniqueID('graticuleLayer_');
    this.sourceId = this.id + '_line';
    options = options || {};
    options.strokeStyle = Object.assign({}, GraticuleLayer_defaultStrokeStyle, options.strokeStyle || {});
    options.lngLabelStyle = Object.assign({}, GraticuleLayer_defaultTextStyle, options.lngLabelStyle || {});
    options.latLabelStyle = Object.assign({}, GraticuleLayer_defaultTextStyle, options.latLabelStyle || {});
    this.options = Object.assign({}, GraticuleLayer_defaultOptions, options);
    this.type = 'custom';
    this.renderingMode = '3d';
    this.overlay = true;
    this.styleDataEevent = this._setLayerTop.bind(this);
  }

  onAdd(map) {
    this.map = map;
    this.renderer = new GraticuleLayerRenderer(this.map, this.options, {
      getMapStateByKey: this.getMapStateByKey,
      getDefaultExtent: this.getDefaultExtent,
      updateGraticuleLayer: this.updateGraticuleLayer.bind(this),
      setVisibility: this.setVisibility.bind(this)
    }, {
      mapElement: this.map.getCanvas(),
      targetElement: this.map.getCanvasContainer(),
      id: this.id
    });
    this.addGraticuleLayer();
    this.resizeEvent = this.renderer._resizeCallback.bind(this.renderer);
    this.zoomendEvent = this.setVisibility.bind(this);
    this._bindEvent()
  }

  onRemove() {
    this.renderer.onRemove();
    this._unbindEvent();
  }

  render() {
    this.renderer.draw();
  }

  getMapStateByKey(key, params) {
    if (key === 'getBearing') {
      return this.map.getBearing();
    } else if (key === 'getBounds') {
      return this.map.getBounds();
    } else if (key === 'project') {
      return this.map.project(params);
    } else if(key === 'unproject') {
      return this.map.unproject(params);
    }
  }

  /**
   * @function GraticuleLayer.prototype.setVisibility
   * @description 设置可见性。
   * @param {boolean} visible - 是否可见。
   */
  setVisibility(visible) {
    const zoom = this.map && this.map.getZoom();
    this.options.visible = typeof visible === 'boolean' ? visible : this.options.visible;
    this.visible =
      typeof visible === 'boolean'
        ? visible
        : this.options.visible && zoom >= this.options.minZoom && zoom <= this.options.maxZoom;
    if (this.renderer) {
      this.renderer.visible = this.visible;
    }
    if (this.map.getLayer(this.sourceId)) {
      this.map.setLayoutProperty(this.sourceId, 'visibility', this.visible ? 'visible' : 'none');
    }
    this.renderer && this.renderer._drawLabel();
  }

  /**
   * @function GraticuleLayer.prototype.setMinZoom
   * @description 设置最小视图缩放级别。
   * @param {number} minZoom - 最小视图缩放级别（不包括此级别），在该级别之上，该层将可见。
   */
  setMinZoom(minZoom) {
    this.options.minZoom = minZoom;
    this.setVisibility();
  }

  /**
   * @function GraticuleLayer.prototype.setMaxZoom
   * @description 该图层可见的最大视图缩放级别。
   * @param {number} maxZoom - 该图层可见的最大视图缩放级别（含）。
   */
  setMaxZoom(maxZoom) {
    this.options.maxZoom = maxZoom;
    this.setVisibility();
  }

  /**
   * @function GraticuleLayer.prototype.setShowLabel
   * @description 设置显示标签。
   * @param {boolean} showLabel - 是否显示标签。
   */
  setShowLabel(showLabel) {
    this.options.showLabel = showLabel;
    this.renderer._drawLabel();
  }

  /**
   * @function GraticuleLayer.prototype.setExtent
   * @description 设置经纬网渲染的边界范围。
   * @param {mapboxgl.LngLatBounds} extent - 经纬网渲染的边界范围。
   */
  setExtent(extent) {
    this.options.extent = this.getDefaultExtent(extent, this.map);
    // this.features = this._getGraticuleFeatures();
    this.updateGraticuleLayer();
    this.renderer._drawLabel();
  }

  /**
   * @function GraticuleLayer.prototype.setStrokeStyle
   * @description 设置经纬线样式。
   * @param {GraticuleLayer.StrokeStyle} strokeStyle - 经纬线样式。
   */
  setStrokeStyle(strokeStyle) {
    if (!this.map || !this.map.getLayer(this.sourceId)) {
      return;
    }
    this.options.strokeStyle = strokeStyle;
    const { layout, paint } = this.renderer._transformStrokeStyle(strokeStyle);
    for (let key in layout) {
      this.map.setLayoutProperty(this.sourceId, key, layout[key]);
    }
    for (let key in paint) {
      this.map.setPaintProperty(this.sourceId, key, paint[key]);
    }
  }

  /**
   * @function GraticuleLayer.prototype.setLngLabelStyle
   * @description 设置经度标签样式。
   * @param {GraticuleLayer.LabelStyle} labelStyle - 标签样式。
   */
  setLngLabelStyle(labelStyle) {
    this.options.lngLabelStyle = labelStyle;
    this.renderer._drawLabel();
  }

  /**
   * @function GraticuleLayer.prototype.setLatLabelStyle
   * @description 设置纬度标签样式。
   * @param {GraticuleLayer.LabelStyle} labelStyle - 标签样式。
   */
  setLatLabelStyle(labelStyle) {
    this.options.latLabelStyle = labelStyle;
    this.renderer._drawLabel();
  }

  /**
   * @function GraticuleLayer.prototype.setIntervals
   * @description 设置经纬度的间隔（以度为单位）。
   * @param {number|function} interval - 经纬度的间隔（以度为单位），可以是数字，也可以是函数，参数是map。
   */
  setIntervals(interval) {
    if (this.renderer) {
      this.renderer.setIntervals(interval);
    }
  }

  getDefaultExtent(extent, map = this.map) {
    const crs = (map.getCRS && map.getCRS()) || {};
    let { extent: crsExtent } = crs;
    if (!crsExtent) {
      crsExtent = [-180, -85.05119, 180, 85.05119];
    }
    if (!extent || extent.length === 0) {
      return crsExtent;
    }
    const { _sw, _ne } = external_mapboxgl_default().LngLatBounds.convert(extent);
    extent = [_sw.lng, _sw.lat, _ne.lng, _ne.lat];
    extent = [
      Math.max(crsExtent[0], extent[0]),
      Math.max(crsExtent[1], extent[1]),
      Math.min(crsExtent[2], extent[2]),
      Math.min(crsExtent[3], extent[3])
    ];
    return extent;
  }

  addGraticuleLayer() {
    if (!this.map.getSource(this.sourceId)) {
      const source = {
        type: 'geojson',
        data: {
          type: 'FeatureCollection',
          features: this.renderer.features
        }
      };
      this.map.addSource(this.sourceId, source);
    }

    if (!this.map.getLayer(this.sourceId)) {
      const layer = Object.assign(
        { id: this.sourceId, type: 'line', source: this.sourceId },
        this.renderer._transformStrokeStyle()
      );
      this.map.addLayer(layer);
    }
  }

  _getLatPoints(lngRange, firstLng, lastLng, features) {
     return this.renderer._getLatPoints(lngRange, firstLng, lastLng, features);
  }

  _bindEvent() {
    this.map.on('styledata', this.styleDataEevent);
    this.map.on('resize', this.resizeEvent);
    this.map.on('zoomend', this.zoomendEvent);
  }

  _unbindEvent() {
    this.map.off('styledata', this.styleDataEevent);
    this.map.off('resize', this.resizeEvent);
    this.map.off('zoomend', this.zoomendEvent);
  }

  _setLayerTop() {
    const map = this.map;
    if (!map) {
      return;
    }
    const layersOnMap = map.getStyle && map.getStyle().layers;
    if (
      layersOnMap &&
      layersOnMap.length &&
      layersOnMap.findIndex(item => item.id === this.sourceId) !== layersOnMap.length - 1
    ) {
      if (map.getLayer(this.sourceId)) {
        map.removeLayer(this.sourceId);
        this.addGraticuleLayer();
      }
    }
  }

  updateGraticuleLayer(features = this.features) {
    if (this.map.getSource(this.sourceId)) {
      const geoJSONData = {
        type: 'FeatureCollection',
        features
      };
      this.map.getSource(this.sourceId).setData(geoJSONData);
    }
    this.addGraticuleLayer();
  }
}


// EXTERNAL MODULE: ./node_modules/promise-polyfill/dist/polyfill.js
var polyfill = __webpack_require__(107);
// EXTERNAL MODULE: ./node_modules/fetch-ie8/fetch.js
var fetch_ie8_fetch = __webpack_require__(693);
// EXTERNAL MODULE: ./node_modules/fetch-jsonp/build/fetch-jsonp.js
var fetch_jsonp = __webpack_require__(144);
var fetch_jsonp_default = /*#__PURE__*/__webpack_require__.n(fetch_jsonp);
;// CONCATENATED MODULE: ./src/common/util/FetchRequest.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/





let FetchRequest_fetch = window.fetch;
var setFetch = function (newFetch) {
    FetchRequest_fetch = newFetch;
}
var RequestJSONPPromise = {
  limitLength: 1500,
  queryKeys: [],
  queryValues: [],
  supermap_callbacks: {},
  addQueryStrings: function (values) {
      var me = this;
      for (var key in values) {
          me.queryKeys.push(key);
          if (typeof values[key] !== 'string') {
              values[key] = Util_Util.toJSON(values[key]);
          }
          var tempValue = encodeURIComponent(values[key]);
          me.queryValues.push(tempValue);
      }
  },
  issue: function (config) {
      var me = this,
          uid = me.getUid(),
          url = config.url,
          splitQuestUrl = [];

      // me.addQueryStrings({
      //     callback: "RequestJSONPPromise.supermap_callbacks[" + uid + "]"
      // });
      var sectionURL = url,
          keysCount = 0; //此次sectionURL中有多少个key
      var length = me.queryKeys ? me.queryKeys.length : 0;
      for (var i = 0; i < length; i++) {
          if (sectionURL.length + me.queryKeys[i].length + 2 >= me.limitLength) {
              //+2 for ("&"or"?")and"="
              if (keysCount == 0) {
                  return false;
              }
              splitQuestUrl.push(sectionURL);
              sectionURL = url;
              keysCount = 0;
              i--;
          } else {
              if (sectionURL.length + me.queryKeys[i].length + 2 + me.queryValues[i].length > me.limitLength) {
                  var leftValue = me.queryValues[i];
                  while (leftValue.length > 0) {
                      var leftLength = me.limitLength - sectionURL.length - me.queryKeys[i].length - 2; //+2 for ("&"or"?")and"="
                      if (sectionURL.indexOf('?') > -1) {
                          sectionURL += '&';
                      } else {
                          sectionURL += '?';
                      }
                      var tempLeftValue = leftValue.substring(0, leftLength);
                      //避免 截断sectionURL时，将类似于%22这样的符号截成两半，从而导致服务端组装sectionURL时发生错误
                      if (tempLeftValue.substring(leftLength - 1, leftLength) === '%') {
                          leftLength -= 1;
                          tempLeftValue = leftValue.substring(0, leftLength);
                      } else if (tempLeftValue.substring(leftLength - 2, leftLength - 1) === '%') {
                          leftLength -= 2;
                          tempLeftValue = leftValue.substring(0, leftLength);
                      }

                      sectionURL += me.queryKeys[i] + '=' + tempLeftValue;
                      leftValue = leftValue.substring(leftLength);
                      if (tempLeftValue.length > 0) {
                          splitQuestUrl.push(sectionURL);
                          sectionURL = url;
                          keysCount = 0;
                      }
                  }
              } else {
                  keysCount++;
                  if (sectionURL.indexOf('?') > -1) {
                      sectionURL += '&';
                  } else {
                      sectionURL += '?';
                  }
                  sectionURL += me.queryKeys[i] + '=' + me.queryValues[i];
              }
          }
      }
      splitQuestUrl.push(sectionURL);
      return me.send(
          splitQuestUrl,
          'SuperMapJSONPCallbacks_' + uid,
          config && config.proxy
      );
  },

  getUid: function () {
      var uid = new Date().getTime(),
          random = Math.floor(Math.random() * 1e17);
      return uid * 1000 + random;
  },

  send: function (splitQuestUrl, callback, proxy) {
      var len = splitQuestUrl.length;
      if (len > 0) {
         return new Promise((resolve) => {
          var jsonpUserID = new Date().getTime();
          for (var i = 0; i < len; i++) {
              var url = splitQuestUrl[i];
              if (url.indexOf('?') > -1) {
                  url += '&';
              } else {
                  url += '?';
              }
              url += 'sectionCount=' + len;
              url += '&sectionIndex=' + i;
              url += '&jsonpUserID=' + jsonpUserID;
              if (proxy) {
                  url = decodeURIComponent(url);
                  url = proxy + encodeURIComponent(url);
              }
              fetch_jsonp_default()(url, {
                  jsonpCallbackFunction: callback,
                  timeout: 30000
              }).then((result) => {
                resolve(result.json());
              });
          }
         })
      }
  },

  GET: function (config) {
      var me = this;
      me.queryKeys.length = 0;
      me.queryValues.length = 0;
      me.addQueryStrings(config.params);
      return me.issue(config);
  },

  POST: function (config) {
      var me = this;
      me.queryKeys.length = 0;
      me.queryValues.length = 0;
      me.addQueryStrings({
          requestEntity: config.data
      });
      return me.issue(config);
  },

  PUT: function (config) {
      var me = this;
      me.queryKeys.length = 0;
      me.queryValues.length = 0;
      me.addQueryStrings({
          requestEntity: config.data
      });
      return me.issue(config);
  },
  DELETE: function (config) {
      var me = this;
      me.queryKeys.length = 0;
      me.queryValues.length = 0;
      me.addQueryStrings({
          requestEntity: config.data
      });
      return me.issue(config);
  }
};

var CORS;
var RequestTimeout;
/**
 * @function setCORS
 * @description 设置是否允许跨域请求，全局配置，优先级低于 service 下的 crossOring 参数。
 * @category BaseTypes Util
 * @param {boolean} cors - 是否允许跨域请求。
 * @usage
 * ```
 * // 浏览器
 * <script type="text/javascript" src="{cdn}"></script>
 * <script>
 *   {namespace}.setCORS(cors);
 *
 *   // 弃用的写法
 *   SuperMap.setCORS(cors);
 *
 * </script>
 *
 * // ES6 Import
 * import { setCORS } from '{npm}';
 *
 * setCORS(cors);
 * ```
 */
var setCORS = function (cors) {
    CORS = cors;
}
/**
 * @function isCORS
 * @description 是是否允许跨域请求。
 * @category BaseTypes Util
 * @returns {boolean} 是否允许跨域请求。
 * @usage
 * ```
 * // 浏览器
 * <script type="text/javascript" src="{cdn}"></script>
 * <script>
 *   const result = {namespace}.isCORS();
 *
 *   // 弃用的写法
 *   const result = SuperMap.isCORS();
 *
 * </script>
 *
 * // ES6 Import
 * import { isCORS } from '{npm}';
 *
 * const result = isCORS();
 * ```
 */
var isCORS = function () {
    if (CORS != undefined) {
        return CORS;
    }
    return window.XMLHttpRequest && 'withCredentials' in new window.XMLHttpRequest();
}
/**
 * @function setRequestTimeout
 * @category BaseTypes Util
 * @description 设置请求超时时间。
 * @param {number} [timeout=45] - 请求超时时间，单位秒。
 * @usage
 * ```
 * // 浏览器
  <script type="text/javascript" src="{cdn}"></script>
  <script>
    {namespace}.setRequestTimeout(timeout);

    // 弃用的写法
    SuperMap.setRequestTimeout(timeout);

  </script>

  // ES6 Import
  import { setRequestTimeout } from '{npm}';

  setRequestTimeout(timeout);
 * ```
 */
var setRequestTimeout = function (timeout) {
    return RequestTimeout = timeout;
}
/**
 * @function getRequestTimeout
 * @category BaseTypes Util
 * @description 获取请求超时时间。
 * @returns {number} 请求超时时间。
 * @usage
 * ```
 * // 浏览器
  <script type="text/javascript" src="{cdn}"></script>
  <script>
    {namespace}.getRequestTimeout();

    // 弃用的写法
    SuperMap.getRequestTimeout();

  </script>

  // ES6 Import
  import { getRequestTimeout } from '{npm}';

  getRequestTimeout();
 * ```
 */
var getRequestTimeout = function () {
    return RequestTimeout || 45000;
}

/**
 * @name FetchRequest
 * @namespace
 * @category BaseTypes Util
 * @description 获取请求。
 * @usage
 * ```
 * // 浏览器
 * <script type="text/javascript" src="{cdn}"></script>
 * <script>
 *   const result = {namespace}.FetchRequest.commit(method, url, params, options);
 *
 * </script>
 *
 * // ES6 Import
 * import { FetchRequest } from '{npm}';
 *
 * const result = FetchRequest.commit(method, url, params, options);
 *
 * ```
 */
var FetchRequest = {
    /**
     * @function FetchRequest.commit
     * @description commit 请求。
     * @param {string} method - 请求方法。
     * @param {string} url - 请求地址。
     * @param {string} params - 请求参数。
     * @param {Object} options - 请求的配置属性。
     * @returns {Promise} Promise 对象。
     */
    commit: function (method, url, params, options) {
        method = method ? method.toUpperCase() : method;
        switch (method) {
            case 'GET':
                return this.get(url, params, options);
            case 'POST':
                return this.post(url, params, options);
            case 'PUT':
                return this.put(url, params, options);
            case 'DELETE':
                return this.delete(url, params, options);
            default:
                return this.get(url, params, options);
        }
    },
    /**
     * @function FetchRequest.supportDirectRequest
     * @description supportDirectRequest 请求。
     * @param {string} url - 请求地址。
     * @param {Object} options - 请求的配置属性。
     * @returns {boolean} 是否允许跨域请求。
     */
    supportDirectRequest: function (url, options) {
        if (Util_Util.isInTheSameDomain(url)) {
            return true;
        }
        if (options.crossOrigin != undefined) {
            return options.crossOrigin;
        } else {
            return isCORS() || options.proxy;
        }
    },
    /**
     * @function FetchRequest.get
     * @description get 请求。
     * @param {string} url - 请求地址。
     * @param {string} params - 请求参数。
     * @param {Object} options - 请求的配置属性。
     * @returns {Promise} Promise 对象。
     */
    get: function (url, params, options) {
        options = options || {};
        var type = 'GET';
        url = Util_Util.urlAppend(url, this._getParameterString(params || {}));
        url = this._processUrl(url, options);
        if (!this.supportDirectRequest(url, options)) {
            url = url.replace('.json', '.jsonp');
            var config = {
                url: url,
                data: params
            };
            return RequestJSONPPromise.GET(config);
        }
        if (!this.urlIsLong(url)) {
            return this._fetch(url, params, options, type);
        } else {
            return this._postSimulatie(type, url.substring(0, url.indexOf('?')), params, options);
        }
    },
    /**
     * @function FetchRequest.delete
     * @description delete 请求。
     * @param {string} url - 请求地址。
     * @param {string} params - 请求参数。
     * @param {Object} options -请求的配置属性。
     * @returns {Promise} Promise 对象。
     */
    delete: function (url, params, options) {
        options = options || {};
        var type = 'DELETE';
        url = Util_Util.urlAppend(url, this._getParameterString(params || {}));
        url = this._processUrl(url, options);
        if (!this.supportDirectRequest(url, options)) {
            url = url.replace('.json', '.jsonp');
            var config = {
                url: url += "&_method=DELETE",
                data: params
            };
            return RequestJSONPPromise.DELETE(config);
        }
        if (this.urlIsLong(url)) {
            return this._postSimulatie(type, url.substring(0, url.indexOf('?')), params, options);
        }
        return this._fetch(url, params, options, type);
    },
    /**
     * @function FetchRequest.post
     * @description post 请求。
     * @param {string} url - 请求地址。
     * @param {string} params - 请求参数。
     * @param {Object} options - 请求的配置属性。
     * @returns {Promise} Promise 对象。
     */
    post: function (url, params, options) {
        options = options || {};
        url = this._processUrl(url, options);
        if (!this.supportDirectRequest(url, options)) {
            url = url.replace('.json', '.jsonp');
            var config = {
                url: Util_Util.urlAppend(url, "_method=POST"),
                data: params
            };
            return RequestJSONPPromise.POST(config);
        }
        return this._fetch(url, params, options, 'POST');
    },
    /**
     * @function FetchRequest.put
     * @description put 请求。
     * @param {string} url - 请求地址。
     * @param {string} params - 请求参数。
     * @param {Object} options - 请求的配置属性。
     * @returns {Promise} Promise 对象。
     */
    put: function (url, params, options) {
        options = options || {};
        url = this._processUrl(url, options);
        if (!this.supportDirectRequest(url, options)) {
            url = url.replace('.json', '.jsonp');
            var config = {
                url: url += "&_method=PUT",
                data: params
            };
            return RequestJSONPPromise.PUT(config);
        }
        return this._fetch(url, params, options, 'PUT');
    },
    /**
     * @function FetchRequest.urlIsLong
     * @description URL 的字节长度是否太长。
     * @param {string} url - 请求地址。
     * @returns {boolean} URL 的字节长度是否太长。
     */
    urlIsLong: function (url) {
        //当前url的字节长度。
        var totalLength = 0,
            charCode = null;
        for (var i = 0, len = url.length; i < len; i++) {
            //转化为Unicode编码
            charCode = url.charCodeAt(i);
            if (charCode < 0x007f) {
                totalLength++;
            } else if ((0x0080 <= charCode) && (charCode <= 0x07ff)) {
                totalLength += 2;
            } else if ((0x0800 <= charCode) && (charCode <= 0xffff)) {
                totalLength += 3;
            }
        }
        return totalLength < 2000 ? false : true;
    },
    _postSimulatie: function (type, url, params, options) {
        var separator = url.indexOf('?') > -1 ? '&' : '?';
        url += separator + '_method=' + type;
        if (typeof params !== 'string') {
            params = JSON.stringify(params);
        }
        return this.post(url, params, options);
    },

    _processUrl: function (url, options) {
        if (this._isMVTRequest(url)) {
            return url;
        }

        if (url.indexOf('.json') === -1 && !options.withoutFormatSuffix) {
            if (url.indexOf('?') < 0) {
                url += '.json';
            } else {
                var urlArrays = url.split('?');
                if (urlArrays.length === 2) {
                    url = urlArrays[0] + '.json?' + urlArrays[1];
                }
            }
        }
        if (options && options.proxy) {
            if (typeof options.proxy === 'function') {
                url = options.proxy(url);
            } else {
                url = decodeURIComponent(url);
                url = options.proxy + encodeURIComponent(url);
            }
        }
        return url;
    },

    _fetch: function (url, params, options, type) {
        options = options || {};
        options.headers = options.headers || {};
        if (!options.headers['Content-Type'] && !FormData.prototype.isPrototypeOf(params)) {
            options.headers['Content-Type'] = 'application/x-www-form-urlencoded;charset=UTF-8';
        }
        if (options.timeout) {
            return this._timeout(
                options.timeout,
                FetchRequest_fetch(url, {
                    method: type,
                    headers: options.headers,
                    body: type === 'PUT' || type === 'POST' ? params : undefined,
                    credentials: this._getWithCredentials(options),
                    mode: 'cors',
                    timeout: getRequestTimeout()
                }).then(function (response) {
                    return response;
                })
            );
        }
        return FetchRequest_fetch(url, {
            method: type,
            body: type === 'PUT' || type === 'POST' ? params : undefined,
            headers: options.headers,
            credentials: this._getWithCredentials(options),
            mode: 'cors',
            timeout: getRequestTimeout()
        }).then(function (response) {
            return response;
        });
    },

    _getWithCredentials: function (options) {
        if (options.withCredentials === true) {
            return 'include';
        }
        if (options.withCredentials === false) {
            return 'omit';
        }
        return 'same-origin';
    },

    _fetchJsonp: function (url, options) {
        options = options || {};
        return fetch_jsonp_default()(url, {
            method: 'GET',
            timeout: options.timeout
        }).then(function (response) {
            return response;
        });
    },

    _timeout: function (seconds, promise) {
        return new Promise(function (resolve, reject) {
            setTimeout(function () {
                reject(new Error('timeout'));
            }, seconds);
            promise.then(resolve, reject);
        });
    },

    _getParameterString: function (params) {
        var paramsArray = [];
        for (var key in params) {
            var value = params[key];
            if (value != null && typeof value !== 'function') {
                var encodedValue;
                if (Array.isArray(value) || value.toString() === '[object Object]') {
                    encodedValue = encodeURIComponent(JSON.stringify(value));
                } else {
                    encodedValue = encodeURIComponent(value);
                }
                paramsArray.push(encodeURIComponent(key) + '=' + encodedValue);
            }
        }
        return paramsArray.join('&');
    },

    _isMVTRequest: function (url) {
        return url.indexOf('.mvt') > -1 || url.indexOf('.pbf') > -1;
    }
}

;// CONCATENATED MODULE: ./node_modules/flatgeobuf/lib/mjs/flat-geobuf/geometry-type.js
var geometry_type_GeometryType;
(function (GeometryType) {
  GeometryType[GeometryType["Unknown"] = 0] = "Unknown";
  GeometryType[GeometryType["Point"] = 1] = "Point";
  GeometryType[GeometryType["LineString"] = 2] = "LineString";
  GeometryType[GeometryType["Polygon"] = 3] = "Polygon";
  GeometryType[GeometryType["MultiPoint"] = 4] = "MultiPoint";
  GeometryType[GeometryType["MultiLineString"] = 5] = "MultiLineString";
  GeometryType[GeometryType["MultiPolygon"] = 6] = "MultiPolygon";
  GeometryType[GeometryType["GeometryCollection"] = 7] = "GeometryCollection";
  GeometryType[GeometryType["CircularString"] = 8] = "CircularString";
  GeometryType[GeometryType["CompoundCurve"] = 9] = "CompoundCurve";
  GeometryType[GeometryType["CurvePolygon"] = 10] = "CurvePolygon";
  GeometryType[GeometryType["MultiCurve"] = 11] = "MultiCurve";
  GeometryType[GeometryType["MultiSurface"] = 12] = "MultiSurface";
  GeometryType[GeometryType["Curve"] = 13] = "Curve";
  GeometryType[GeometryType["Surface"] = 14] = "Surface";
  GeometryType[GeometryType["PolyhedralSurface"] = 15] = "PolyhedralSurface";
  GeometryType[GeometryType["TIN"] = 16] = "TIN";
  GeometryType[GeometryType["Triangle"] = 17] = "Triangle";
})(geometry_type_GeometryType || (geometry_type_GeometryType = {}));
;// CONCATENATED MODULE: ./node_modules/flatbuffers/mjs/constants.js
const constants_SIZEOF_SHORT = 2;
const constants_SIZEOF_INT = 4;
const constants_FILE_IDENTIFIER_LENGTH = 4;
const constants_SIZE_PREFIX_LENGTH = 4;

;// CONCATENATED MODULE: ./node_modules/flatbuffers/mjs/utils.js
const int32 = new Int32Array(2);
const float32 = new Float32Array(int32.buffer);
const float64 = new Float64Array(int32.buffer);
const isLittleEndian = new Uint16Array(new Uint8Array([1, 0]).buffer)[0] === 1;

;// CONCATENATED MODULE: ./node_modules/flatbuffers/mjs/encoding.js
var Encoding;
(function (Encoding) {
    Encoding[Encoding["UTF8_BYTES"] = 1] = "UTF8_BYTES";
    Encoding[Encoding["UTF16_STRING"] = 2] = "UTF16_STRING";
})(Encoding || (Encoding = {}));

;// CONCATENATED MODULE: ./node_modules/flatbuffers/mjs/byte-buffer.js



class byte_buffer_ByteBuffer {
    /**
     * Create a new ByteBuffer with a given array of bytes (`Uint8Array`)
     */
    constructor(bytes_) {
        this.bytes_ = bytes_;
        this.position_ = 0;
    }
    /**
     * Create and allocate a new ByteBuffer with a given size.
     */
    static allocate(byte_size) {
        return new byte_buffer_ByteBuffer(new Uint8Array(byte_size));
    }
    clear() {
        this.position_ = 0;
    }
    /**
     * Get the underlying `Uint8Array`.
     */
    bytes() {
        return this.bytes_;
    }
    /**
     * Get the buffer's position.
     */
    position() {
        return this.position_;
    }
    /**
     * Set the buffer's position.
     */
    setPosition(position) {
        this.position_ = position;
    }
    /**
     * Get the buffer's capacity.
     */
    capacity() {
        return this.bytes_.length;
    }
    readInt8(offset) {
        return this.readUint8(offset) << 24 >> 24;
    }
    readUint8(offset) {
        return this.bytes_[offset];
    }
    readInt16(offset) {
        return this.readUint16(offset) << 16 >> 16;
    }
    readUint16(offset) {
        return this.bytes_[offset] | this.bytes_[offset + 1] << 8;
    }
    readInt32(offset) {
        return this.bytes_[offset] | this.bytes_[offset + 1] << 8 | this.bytes_[offset + 2] << 16 | this.bytes_[offset + 3] << 24;
    }
    readUint32(offset) {
        return this.readInt32(offset) >>> 0;
    }
    readInt64(offset) {
        return BigInt.asIntN(64, BigInt(this.readUint32(offset)) + (BigInt(this.readUint32(offset + 4)) << BigInt(32)));
    }
    readUint64(offset) {
        return BigInt.asUintN(64, BigInt(this.readUint32(offset)) + (BigInt(this.readUint32(offset + 4)) << BigInt(32)));
    }
    readFloat32(offset) {
        int32[0] = this.readInt32(offset);
        return float32[0];
    }
    readFloat64(offset) {
        int32[isLittleEndian ? 0 : 1] = this.readInt32(offset);
        int32[isLittleEndian ? 1 : 0] = this.readInt32(offset + 4);
        return float64[0];
    }
    writeInt8(offset, value) {
        this.bytes_[offset] = value;
    }
    writeUint8(offset, value) {
        this.bytes_[offset] = value;
    }
    writeInt16(offset, value) {
        this.bytes_[offset] = value;
        this.bytes_[offset + 1] = value >> 8;
    }
    writeUint16(offset, value) {
        this.bytes_[offset] = value;
        this.bytes_[offset + 1] = value >> 8;
    }
    writeInt32(offset, value) {
        this.bytes_[offset] = value;
        this.bytes_[offset + 1] = value >> 8;
        this.bytes_[offset + 2] = value >> 16;
        this.bytes_[offset + 3] = value >> 24;
    }
    writeUint32(offset, value) {
        this.bytes_[offset] = value;
        this.bytes_[offset + 1] = value >> 8;
        this.bytes_[offset + 2] = value >> 16;
        this.bytes_[offset + 3] = value >> 24;
    }
    writeInt64(offset, value) {
        this.writeInt32(offset, Number(BigInt.asIntN(32, value)));
        this.writeInt32(offset + 4, Number(BigInt.asIntN(32, value >> BigInt(32))));
    }
    writeUint64(offset, value) {
        this.writeUint32(offset, Number(BigInt.asUintN(32, value)));
        this.writeUint32(offset + 4, Number(BigInt.asUintN(32, value >> BigInt(32))));
    }
    writeFloat32(offset, value) {
        float32[0] = value;
        this.writeInt32(offset, int32[0]);
    }
    writeFloat64(offset, value) {
        float64[0] = value;
        this.writeInt32(offset, int32[isLittleEndian ? 0 : 1]);
        this.writeInt32(offset + 4, int32[isLittleEndian ? 1 : 0]);
    }
    /**
     * Return the file identifier.   Behavior is undefined for FlatBuffers whose
     * schema does not include a file_identifier (likely points at padding or the
     * start of a the root vtable).
     */
    getBufferIdentifier() {
        if (this.bytes_.length < this.position_ + constants_SIZEOF_INT +
            constants_FILE_IDENTIFIER_LENGTH) {
            throw new Error('FlatBuffers: ByteBuffer is too short to contain an identifier.');
        }
        let result = "";
        for (let i = 0; i < constants_FILE_IDENTIFIER_LENGTH; i++) {
            result += String.fromCharCode(this.readInt8(this.position_ + constants_SIZEOF_INT + i));
        }
        return result;
    }
    /**
     * Look up a field in the vtable, return an offset into the object, or 0 if the
     * field is not present.
     */
    __offset(bb_pos, vtable_offset) {
        const vtable = bb_pos - this.readInt32(bb_pos);
        return vtable_offset < this.readInt16(vtable) ? this.readInt16(vtable + vtable_offset) : 0;
    }
    /**
     * Initialize any Table-derived type to point to the union at the given offset.
     */
    __union(t, offset) {
        t.bb_pos = offset + this.readInt32(offset);
        t.bb = this;
        return t;
    }
    /**
     * Create a JavaScript string from UTF-8 data stored inside the FlatBuffer.
     * This allocates a new string and converts to wide chars upon each access.
     *
     * To avoid the conversion to UTF-16, pass Encoding.UTF8_BYTES as
     * the "optionalEncoding" argument. This is useful for avoiding conversion to
     * and from UTF-16 when the data will just be packaged back up in another
     * FlatBuffer later on.
     *
     * @param offset
     * @param opt_encoding Defaults to UTF16_STRING
     */
    __string(offset, opt_encoding) {
        offset += this.readInt32(offset);
        const length = this.readInt32(offset);
        let result = '';
        let i = 0;
        offset += constants_SIZEOF_INT;
        if (opt_encoding === Encoding.UTF8_BYTES) {
            return this.bytes_.subarray(offset, offset + length);
        }
        while (i < length) {
            let codePoint;
            // Decode UTF-8
            const a = this.readUint8(offset + i++);
            if (a < 0xC0) {
                codePoint = a;
            }
            else {
                const b = this.readUint8(offset + i++);
                if (a < 0xE0) {
                    codePoint =
                        ((a & 0x1F) << 6) |
                            (b & 0x3F);
                }
                else {
                    const c = this.readUint8(offset + i++);
                    if (a < 0xF0) {
                        codePoint =
                            ((a & 0x0F) << 12) |
                                ((b & 0x3F) << 6) |
                                (c & 0x3F);
                    }
                    else {
                        const d = this.readUint8(offset + i++);
                        codePoint =
                            ((a & 0x07) << 18) |
                                ((b & 0x3F) << 12) |
                                ((c & 0x3F) << 6) |
                                (d & 0x3F);
                    }
                }
            }
            // Encode UTF-16
            if (codePoint < 0x10000) {
                result += String.fromCharCode(codePoint);
            }
            else {
                codePoint -= 0x10000;
                result += String.fromCharCode((codePoint >> 10) + 0xD800, (codePoint & ((1 << 10) - 1)) + 0xDC00);
            }
        }
        return result;
    }
    /**
     * Handle unions that can contain string as its member, if a Table-derived type then initialize it,
     * if a string then return a new one
     *
     * WARNING: strings are immutable in JS so we can't change the string that the user gave us, this
     * makes the behaviour of __union_with_string different compared to __union
     */
    __union_with_string(o, offset) {
        if (typeof o === 'string') {
            return this.__string(offset);
        }
        return this.__union(o, offset);
    }
    /**
     * Retrieve the relative offset stored at "offset"
     */
    __indirect(offset) {
        return offset + this.readInt32(offset);
    }
    /**
     * Get the start of data of a vector whose offset is stored at "offset" in this object.
     */
    __vector(offset) {
        return offset + this.readInt32(offset) + constants_SIZEOF_INT; // data starts after the length
    }
    /**
     * Get the length of a vector whose offset is stored at "offset" in this object.
     */
    __vector_len(offset) {
        return this.readInt32(offset + this.readInt32(offset));
    }
    __has_identifier(ident) {
        if (ident.length != constants_FILE_IDENTIFIER_LENGTH) {
            throw new Error('FlatBuffers: file identifier must be length ' +
                constants_FILE_IDENTIFIER_LENGTH);
        }
        for (let i = 0; i < constants_FILE_IDENTIFIER_LENGTH; i++) {
            if (ident.charCodeAt(i) != this.readInt8(this.position() + constants_SIZEOF_INT + i)) {
                return false;
            }
        }
        return true;
    }
    /**
     * A helper function for generating list for obj api
     */
    createScalarList(listAccessor, listLength) {
        const ret = [];
        for (let i = 0; i < listLength; ++i) {
            if (listAccessor(i) !== null) {
                ret.push(listAccessor(i));
            }
        }
        return ret;
    }
    /**
     * A helper function for generating list for obj api
     * @param listAccessor function that accepts an index and return data at that index
     * @param listLength listLength
     * @param res result list
     */
    createObjList(listAccessor, listLength) {
        const ret = [];
        for (let i = 0; i < listLength; ++i) {
            const val = listAccessor(i);
            if (val !== null) {
                ret.push(val.unpack());
            }
        }
        return ret;
    }
}

;// CONCATENATED MODULE: ./node_modules/flatbuffers/mjs/builder.js


class Builder {
    /**
     * Create a FlatBufferBuilder.
     */
    constructor(opt_initial_size) {
        /** Minimum alignment encountered so far. */
        this.minalign = 1;
        /** The vtable for the current table. */
        this.vtable = null;
        /** The amount of fields we're actually using. */
        this.vtable_in_use = 0;
        /** Whether we are currently serializing a table. */
        this.isNested = false;
        /** Starting offset of the current struct/table. */
        this.object_start = 0;
        /** List of offsets of all vtables. */
        this.vtables = [];
        /** For the current vector being built. */
        this.vector_num_elems = 0;
        /** False omits default values from the serialized data */
        this.force_defaults = false;
        this.string_maps = null;
        let initial_size;
        if (!opt_initial_size) {
            initial_size = 1024;
        }
        else {
            initial_size = opt_initial_size;
        }
        /**
         * @type {ByteBuffer}
         * @private
         */
        this.bb = ByteBuffer.allocate(initial_size);
        this.space = initial_size;
    }
    clear() {
        this.bb.clear();
        this.space = this.bb.capacity();
        this.minalign = 1;
        this.vtable = null;
        this.vtable_in_use = 0;
        this.isNested = false;
        this.object_start = 0;
        this.vtables = [];
        this.vector_num_elems = 0;
        this.force_defaults = false;
        this.string_maps = null;
    }
    /**
     * In order to save space, fields that are set to their default value
     * don't get serialized into the buffer. Forcing defaults provides a
     * way to manually disable this optimization.
     *
     * @param forceDefaults true always serializes default values
     */
    forceDefaults(forceDefaults) {
        this.force_defaults = forceDefaults;
    }
    /**
     * Get the ByteBuffer representing the FlatBuffer. Only call this after you've
     * called finish(). The actual data starts at the ByteBuffer's current position,
     * not necessarily at 0.
     */
    dataBuffer() {
        return this.bb;
    }
    /**
     * Get the bytes representing the FlatBuffer. Only call this after you've
     * called finish().
     */
    asUint8Array() {
        return this.bb.bytes().subarray(this.bb.position(), this.bb.position() + this.offset());
    }
    /**
     * Prepare to write an element of `size` after `additional_bytes` have been
     * written, e.g. if you write a string, you need to align such the int length
     * field is aligned to 4 bytes, and the string data follows it directly. If all
     * you need to do is alignment, `additional_bytes` will be 0.
     *
     * @param size This is the of the new element to write
     * @param additional_bytes The padding size
     */
    prep(size, additional_bytes) {
        // Track the biggest thing we've ever aligned to.
        if (size > this.minalign) {
            this.minalign = size;
        }
        // Find the amount of alignment needed such that `size` is properly
        // aligned after `additional_bytes`
        const align_size = ((~(this.bb.capacity() - this.space + additional_bytes)) + 1) & (size - 1);
        // Reallocate the buffer if needed.
        while (this.space < align_size + size + additional_bytes) {
            const old_buf_size = this.bb.capacity();
            this.bb = Builder.growByteBuffer(this.bb);
            this.space += this.bb.capacity() - old_buf_size;
        }
        this.pad(align_size);
    }
    pad(byte_size) {
        for (let i = 0; i < byte_size; i++) {
            this.bb.writeInt8(--this.space, 0);
        }
    }
    writeInt8(value) {
        this.bb.writeInt8(this.space -= 1, value);
    }
    writeInt16(value) {
        this.bb.writeInt16(this.space -= 2, value);
    }
    writeInt32(value) {
        this.bb.writeInt32(this.space -= 4, value);
    }
    writeInt64(value) {
        this.bb.writeInt64(this.space -= 8, value);
    }
    writeFloat32(value) {
        this.bb.writeFloat32(this.space -= 4, value);
    }
    writeFloat64(value) {
        this.bb.writeFloat64(this.space -= 8, value);
    }
    /**
     * Add an `int8` to the buffer, properly aligned, and grows the buffer (if necessary).
     * @param value The `int8` to add the the buffer.
     */
    addInt8(value) {
        this.prep(1, 0);
        this.writeInt8(value);
    }
    /**
     * Add an `int16` to the buffer, properly aligned, and grows the buffer (if necessary).
     * @param value The `int16` to add the the buffer.
     */
    addInt16(value) {
        this.prep(2, 0);
        this.writeInt16(value);
    }
    /**
     * Add an `int32` to the buffer, properly aligned, and grows the buffer (if necessary).
     * @param value The `int32` to add the the buffer.
     */
    addInt32(value) {
        this.prep(4, 0);
        this.writeInt32(value);
    }
    /**
     * Add an `int64` to the buffer, properly aligned, and grows the buffer (if necessary).
     * @param value The `int64` to add the the buffer.
     */
    addInt64(value) {
        this.prep(8, 0);
        this.writeInt64(value);
    }
    /**
     * Add a `float32` to the buffer, properly aligned, and grows the buffer (if necessary).
     * @param value The `float32` to add the the buffer.
     */
    addFloat32(value) {
        this.prep(4, 0);
        this.writeFloat32(value);
    }
    /**
     * Add a `float64` to the buffer, properly aligned, and grows the buffer (if necessary).
     * @param value The `float64` to add the the buffer.
     */
    addFloat64(value) {
        this.prep(8, 0);
        this.writeFloat64(value);
    }
    addFieldInt8(voffset, value, defaultValue) {
        if (this.force_defaults || value != defaultValue) {
            this.addInt8(value);
            this.slot(voffset);
        }
    }
    addFieldInt16(voffset, value, defaultValue) {
        if (this.force_defaults || value != defaultValue) {
            this.addInt16(value);
            this.slot(voffset);
        }
    }
    addFieldInt32(voffset, value, defaultValue) {
        if (this.force_defaults || value != defaultValue) {
            this.addInt32(value);
            this.slot(voffset);
        }
    }
    addFieldInt64(voffset, value, defaultValue) {
        if (this.force_defaults || value !== defaultValue) {
            this.addInt64(value);
            this.slot(voffset);
        }
    }
    addFieldFloat32(voffset, value, defaultValue) {
        if (this.force_defaults || value != defaultValue) {
            this.addFloat32(value);
            this.slot(voffset);
        }
    }
    addFieldFloat64(voffset, value, defaultValue) {
        if (this.force_defaults || value != defaultValue) {
            this.addFloat64(value);
            this.slot(voffset);
        }
    }
    addFieldOffset(voffset, value, defaultValue) {
        if (this.force_defaults || value != defaultValue) {
            this.addOffset(value);
            this.slot(voffset);
        }
    }
    /**
     * Structs are stored inline, so nothing additional is being added. `d` is always 0.
     */
    addFieldStruct(voffset, value, defaultValue) {
        if (value != defaultValue) {
            this.nested(value);
            this.slot(voffset);
        }
    }
    /**
     * Structures are always stored inline, they need to be created right
     * where they're used.  You'll get this assertion failure if you
     * created it elsewhere.
     */
    nested(obj) {
        if (obj != this.offset()) {
            throw new Error('FlatBuffers: struct must be serialized inline.');
        }
    }
    /**
     * Should not be creating any other object, string or vector
     * while an object is being constructed
     */
    notNested() {
        if (this.isNested) {
            throw new Error('FlatBuffers: object serialization must not be nested.');
        }
    }
    /**
     * Set the current vtable at `voffset` to the current location in the buffer.
     */
    slot(voffset) {
        if (this.vtable !== null)
            this.vtable[voffset] = this.offset();
    }
    /**
     * @returns Offset relative to the end of the buffer.
     */
    offset() {
        return this.bb.capacity() - this.space;
    }
    /**
     * Doubles the size of the backing ByteBuffer and copies the old data towards
     * the end of the new buffer (since we build the buffer backwards).
     *
     * @param bb The current buffer with the existing data
     * @returns A new byte buffer with the old data copied
     * to it. The data is located at the end of the buffer.
     *
     * uint8Array.set() formally takes {Array<number>|ArrayBufferView}, so to pass
     * it a uint8Array we need to suppress the type check:
     * @suppress {checkTypes}
     */
    static growByteBuffer(bb) {
        const old_buf_size = bb.capacity();
        // Ensure we don't grow beyond what fits in an int.
        if (old_buf_size & 0xC0000000) {
            throw new Error('FlatBuffers: cannot grow buffer beyond 2 gigabytes.');
        }
        const new_buf_size = old_buf_size << 1;
        const nbb = ByteBuffer.allocate(new_buf_size);
        nbb.setPosition(new_buf_size - old_buf_size);
        nbb.bytes().set(bb.bytes(), new_buf_size - old_buf_size);
        return nbb;
    }
    /**
     * Adds on offset, relative to where it will be written.
     *
     * @param offset The offset to add.
     */
    addOffset(offset) {
        this.prep(SIZEOF_INT, 0); // Ensure alignment is already done.
        this.writeInt32(this.offset() - offset + SIZEOF_INT);
    }
    /**
     * Start encoding a new object in the buffer.  Users will not usually need to
     * call this directly. The FlatBuffers compiler will generate helper methods
     * that call this method internally.
     */
    startObject(numfields) {
        this.notNested();
        if (this.vtable == null) {
            this.vtable = [];
        }
        this.vtable_in_use = numfields;
        for (let i = 0; i < numfields; i++) {
            this.vtable[i] = 0; // This will push additional elements as needed
        }
        this.isNested = true;
        this.object_start = this.offset();
    }
    /**
     * Finish off writing the object that is under construction.
     *
     * @returns The offset to the object inside `dataBuffer`
     */
    endObject() {
        if (this.vtable == null || !this.isNested) {
            throw new Error('FlatBuffers: endObject called without startObject');
        }
        this.addInt32(0);
        const vtableloc = this.offset();
        // Trim trailing zeroes.
        let i = this.vtable_in_use - 1;
        // eslint-disable-next-line no-empty
        for (; i >= 0 && this.vtable[i] == 0; i--) { }
        const trimmed_size = i + 1;
        // Write out the current vtable.
        for (; i >= 0; i--) {
            // Offset relative to the start of the table.
            this.addInt16(this.vtable[i] != 0 ? vtableloc - this.vtable[i] : 0);
        }
        const standard_fields = 2; // The fields below:
        this.addInt16(vtableloc - this.object_start);
        const len = (trimmed_size + standard_fields) * SIZEOF_SHORT;
        this.addInt16(len);
        // Search for an existing vtable that matches the current one.
        let existing_vtable = 0;
        const vt1 = this.space;
        outer_loop: for (i = 0; i < this.vtables.length; i++) {
            const vt2 = this.bb.capacity() - this.vtables[i];
            if (len == this.bb.readInt16(vt2)) {
                for (let j = SIZEOF_SHORT; j < len; j += SIZEOF_SHORT) {
                    if (this.bb.readInt16(vt1 + j) != this.bb.readInt16(vt2 + j)) {
                        continue outer_loop;
                    }
                }
                existing_vtable = this.vtables[i];
                break;
            }
        }
        if (existing_vtable) {
            // Found a match:
            // Remove the current vtable.
            this.space = this.bb.capacity() - vtableloc;
            // Point table to existing vtable.
            this.bb.writeInt32(this.space, existing_vtable - vtableloc);
        }
        else {
            // No match:
            // Add the location of the current vtable to the list of vtables.
            this.vtables.push(this.offset());
            // Point table to current vtable.
            this.bb.writeInt32(this.bb.capacity() - vtableloc, this.offset() - vtableloc);
        }
        this.isNested = false;
        return vtableloc;
    }
    /**
     * Finalize a buffer, poiting to the given `root_table`.
     */
    finish(root_table, opt_file_identifier, opt_size_prefix) {
        const size_prefix = opt_size_prefix ? SIZE_PREFIX_LENGTH : 0;
        if (opt_file_identifier) {
            const file_identifier = opt_file_identifier;
            this.prep(this.minalign, SIZEOF_INT +
                FILE_IDENTIFIER_LENGTH + size_prefix);
            if (file_identifier.length != FILE_IDENTIFIER_LENGTH) {
                throw new Error('FlatBuffers: file identifier must be length ' +
                    FILE_IDENTIFIER_LENGTH);
            }
            for (let i = FILE_IDENTIFIER_LENGTH - 1; i >= 0; i--) {
                this.writeInt8(file_identifier.charCodeAt(i));
            }
        }
        this.prep(this.minalign, SIZEOF_INT + size_prefix);
        this.addOffset(root_table);
        if (size_prefix) {
            this.addInt32(this.bb.capacity() - this.space);
        }
        this.bb.setPosition(this.space);
    }
    /**
     * Finalize a size prefixed buffer, pointing to the given `root_table`.
     */
    finishSizePrefixed(root_table, opt_file_identifier) {
        this.finish(root_table, opt_file_identifier, true);
    }
    /**
     * This checks a required field has been set in a given table that has
     * just been constructed.
     */
    requiredField(table, field) {
        const table_start = this.bb.capacity() - table;
        const vtable_start = table_start - this.bb.readInt32(table_start);
        const ok = this.bb.readInt16(vtable_start + field) != 0;
        // If this fails, the caller will show what field needs to be set.
        if (!ok) {
            throw new Error('FlatBuffers: field ' + field + ' must be set');
        }
    }
    /**
     * Start a new array/vector of objects.  Users usually will not call
     * this directly. The FlatBuffers compiler will create a start/end
     * method for vector types in generated code.
     *
     * @param elem_size The size of each element in the array
     * @param num_elems The number of elements in the array
     * @param alignment The alignment of the array
     */
    startVector(elem_size, num_elems, alignment) {
        this.notNested();
        this.vector_num_elems = num_elems;
        this.prep(SIZEOF_INT, elem_size * num_elems);
        this.prep(alignment, elem_size * num_elems); // Just in case alignment > int.
    }
    /**
     * Finish off the creation of an array and all its elements. The array must be
     * created with `startVector`.
     *
     * @returns The offset at which the newly created array
     * starts.
     */
    endVector() {
        this.writeInt32(this.vector_num_elems);
        return this.offset();
    }
    /**
     * Encode the string `s` in the buffer using UTF-8. If the string passed has
     * already been seen, we return the offset of the already written string
     *
     * @param s The string to encode
     * @return The offset in the buffer where the encoded string starts
     */
    createSharedString(s) {
        if (!s) {
            return 0;
        }
        if (!this.string_maps) {
            this.string_maps = new Map();
        }
        if (this.string_maps.has(s)) {
            return this.string_maps.get(s);
        }
        const offset = this.createString(s);
        this.string_maps.set(s, offset);
        return offset;
    }
    /**
     * Encode the string `s` in the buffer using UTF-8. If a Uint8Array is passed
     * instead of a string, it is assumed to contain valid UTF-8 encoded data.
     *
     * @param s The string to encode
     * @return The offset in the buffer where the encoded string starts
     */
    createString(s) {
        if (s === null || s === undefined) {
            return 0;
        }
        let utf8;
        if (s instanceof Uint8Array) {
            utf8 = s;
        }
        else {
            utf8 = [];
            let i = 0;
            while (i < s.length) {
                let codePoint;
                // Decode UTF-16
                const a = s.charCodeAt(i++);
                if (a < 0xD800 || a >= 0xDC00) {
                    codePoint = a;
                }
                else {
                    const b = s.charCodeAt(i++);
                    codePoint = (a << 10) + b + (0x10000 - (0xD800 << 10) - 0xDC00);
                }
                // Encode UTF-8
                if (codePoint < 0x80) {
                    utf8.push(codePoint);
                }
                else {
                    if (codePoint < 0x800) {
                        utf8.push(((codePoint >> 6) & 0x1F) | 0xC0);
                    }
                    else {
                        if (codePoint < 0x10000) {
                            utf8.push(((codePoint >> 12) & 0x0F) | 0xE0);
                        }
                        else {
                            utf8.push(((codePoint >> 18) & 0x07) | 0xF0, ((codePoint >> 12) & 0x3F) | 0x80);
                        }
                        utf8.push(((codePoint >> 6) & 0x3F) | 0x80);
                    }
                    utf8.push((codePoint & 0x3F) | 0x80);
                }
            }
        }
        this.addInt8(0);
        this.startVector(1, utf8.length, 1);
        this.bb.setPosition(this.space -= utf8.length);
        for (let i = 0, offset = this.space, bytes = this.bb.bytes(); i < utf8.length; i++) {
            bytes[offset++] = utf8[i];
        }
        return this.endVector();
    }
    /**
     * A helper function to pack an object
     *
     * @returns offset of obj
     */
    createObjectOffset(obj) {
        if (obj === null) {
            return 0;
        }
        if (typeof obj === 'string') {
            return this.createString(obj);
        }
        else {
            return obj.pack(this);
        }
    }
    /**
     * A helper function to pack a list of object
     *
     * @returns list of offsets of each non null object
     */
    createObjectOffsetList(list) {
        const ret = [];
        for (let i = 0; i < list.length; ++i) {
            const val = list[i];
            if (val !== null) {
                ret.push(this.createObjectOffset(val));
            }
            else {
                throw new Error('FlatBuffers: Argument for createObjectOffsetList cannot contain null.');
            }
        }
        return ret;
    }
    createStructOffsetList(list, startFunc) {
        startFunc(this, list.length);
        this.createObjectOffsetList(list);
        return this.endVector();
    }
}

;// CONCATENATED MODULE: ./node_modules/flatbuffers/mjs/flatbuffers.js









;// CONCATENATED MODULE: ./node_modules/flatgeobuf/lib/mjs/flat-geobuf/geometry.js
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }


var geometry_Geometry = /*#__PURE__*/function () {
  function Geometry() {
    _classCallCheck(this, Geometry);
    this.bb = null;
    this.bb_pos = 0;
  }
  _createClass(Geometry, [{
    key: "__init",
    value: function __init(i, bb) {
      this.bb_pos = i;
      this.bb = bb;
      return this;
    }
  }, {
    key: "ends",
    value: function ends(index) {
      var offset = this.bb.__offset(this.bb_pos, 4);
      return offset ? this.bb.readUint32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
    }
  }, {
    key: "endsLength",
    value: function endsLength() {
      var offset = this.bb.__offset(this.bb_pos, 4);
      return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
  }, {
    key: "endsArray",
    value: function endsArray() {
      var offset = this.bb.__offset(this.bb_pos, 4);
      return offset ? new Uint32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    }
  }, {
    key: "xy",
    value: function xy(index) {
      var offset = this.bb.__offset(this.bb_pos, 6);
      return offset ? this.bb.readFloat64(this.bb.__vector(this.bb_pos + offset) + index * 8) : 0;
    }
  }, {
    key: "xyLength",
    value: function xyLength() {
      var offset = this.bb.__offset(this.bb_pos, 6);
      return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
  }, {
    key: "xyArray",
    value: function xyArray() {
      var offset = this.bb.__offset(this.bb_pos, 6);
      return offset ? new Float64Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    }
  }, {
    key: "z",
    value: function z(index) {
      var offset = this.bb.__offset(this.bb_pos, 8);
      return offset ? this.bb.readFloat64(this.bb.__vector(this.bb_pos + offset) + index * 8) : 0;
    }
  }, {
    key: "zLength",
    value: function zLength() {
      var offset = this.bb.__offset(this.bb_pos, 8);
      return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
  }, {
    key: "zArray",
    value: function zArray() {
      var offset = this.bb.__offset(this.bb_pos, 8);
      return offset ? new Float64Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    }
  }, {
    key: "m",
    value: function m(index) {
      var offset = this.bb.__offset(this.bb_pos, 10);
      return offset ? this.bb.readFloat64(this.bb.__vector(this.bb_pos + offset) + index * 8) : 0;
    }
  }, {
    key: "mLength",
    value: function mLength() {
      var offset = this.bb.__offset(this.bb_pos, 10);
      return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
  }, {
    key: "mArray",
    value: function mArray() {
      var offset = this.bb.__offset(this.bb_pos, 10);
      return offset ? new Float64Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    }
  }, {
    key: "t",
    value: function t(index) {
      var offset = this.bb.__offset(this.bb_pos, 12);
      return offset ? this.bb.readFloat64(this.bb.__vector(this.bb_pos + offset) + index * 8) : 0;
    }
  }, {
    key: "tLength",
    value: function tLength() {
      var offset = this.bb.__offset(this.bb_pos, 12);
      return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
  }, {
    key: "tArray",
    value: function tArray() {
      var offset = this.bb.__offset(this.bb_pos, 12);
      return offset ? new Float64Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    }
  }, {
    key: "tm",
    value: function tm(index) {
      var offset = this.bb.__offset(this.bb_pos, 14);
      return offset ? this.bb.readUint64(this.bb.__vector(this.bb_pos + offset) + index * 8) : BigInt(0);
    }
  }, {
    key: "tmLength",
    value: function tmLength() {
      var offset = this.bb.__offset(this.bb_pos, 14);
      return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
  }, {
    key: "type",
    value: function type() {
      var offset = this.bb.__offset(this.bb_pos, 16);
      return offset ? this.bb.readUint8(this.bb_pos + offset) : geometry_type_GeometryType.Unknown;
    }
  }, {
    key: "parts",
    value: function parts(index, obj) {
      var offset = this.bb.__offset(this.bb_pos, 18);
      return offset ? (obj || new Geometry()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
  }, {
    key: "partsLength",
    value: function partsLength() {
      var offset = this.bb.__offset(this.bb_pos, 18);
      return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
  }], [{
    key: "getRootAsGeometry",
    value: function getRootAsGeometry(bb, obj) {
      return (obj || new Geometry()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
  }, {
    key: "getSizePrefixedRootAsGeometry",
    value: function getSizePrefixedRootAsGeometry(bb, obj) {
      bb.setPosition(bb.position() + constants_SIZE_PREFIX_LENGTH);
      return (obj || new Geometry()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
  }, {
    key: "startGeometry",
    value: function startGeometry(builder) {
      builder.startObject(8);
    }
  }, {
    key: "addEnds",
    value: function addEnds(builder, endsOffset) {
      builder.addFieldOffset(0, endsOffset, 0);
    }
  }, {
    key: "createEndsVector",
    value: function createEndsVector(builder, data) {
      builder.startVector(4, data.length, 4);
      for (var i = data.length - 1; i >= 0; i--) {
        builder.addInt32(data[i]);
      }
      return builder.endVector();
    }
  }, {
    key: "startEndsVector",
    value: function startEndsVector(builder, numElems) {
      builder.startVector(4, numElems, 4);
    }
  }, {
    key: "addXy",
    value: function addXy(builder, xyOffset) {
      builder.addFieldOffset(1, xyOffset, 0);
    }
  }, {
    key: "createXyVector",
    value: function createXyVector(builder, data) {
      builder.startVector(8, data.length, 8);
      for (var i = data.length - 1; i >= 0; i--) {
        builder.addFloat64(data[i]);
      }
      return builder.endVector();
    }
  }, {
    key: "startXyVector",
    value: function startXyVector(builder, numElems) {
      builder.startVector(8, numElems, 8);
    }
  }, {
    key: "addZ",
    value: function addZ(builder, zOffset) {
      builder.addFieldOffset(2, zOffset, 0);
    }
  }, {
    key: "createZVector",
    value: function createZVector(builder, data) {
      builder.startVector(8, data.length, 8);
      for (var i = data.length - 1; i >= 0; i--) {
        builder.addFloat64(data[i]);
      }
      return builder.endVector();
    }
  }, {
    key: "startZVector",
    value: function startZVector(builder, numElems) {
      builder.startVector(8, numElems, 8);
    }
  }, {
    key: "addM",
    value: function addM(builder, mOffset) {
      builder.addFieldOffset(3, mOffset, 0);
    }
  }, {
    key: "createMVector",
    value: function createMVector(builder, data) {
      builder.startVector(8, data.length, 8);
      for (var i = data.length - 1; i >= 0; i--) {
        builder.addFloat64(data[i]);
      }
      return builder.endVector();
    }
  }, {
    key: "startMVector",
    value: function startMVector(builder, numElems) {
      builder.startVector(8, numElems, 8);
    }
  }, {
    key: "addT",
    value: function addT(builder, tOffset) {
      builder.addFieldOffset(4, tOffset, 0);
    }
  }, {
    key: "createTVector",
    value: function createTVector(builder, data) {
      builder.startVector(8, data.length, 8);
      for (var i = data.length - 1; i >= 0; i--) {
        builder.addFloat64(data[i]);
      }
      return builder.endVector();
    }
  }, {
    key: "startTVector",
    value: function startTVector(builder, numElems) {
      builder.startVector(8, numElems, 8);
    }
  }, {
    key: "addTm",
    value: function addTm(builder, tmOffset) {
      builder.addFieldOffset(5, tmOffset, 0);
    }
  }, {
    key: "createTmVector",
    value: function createTmVector(builder, data) {
      builder.startVector(8, data.length, 8);
      for (var i = data.length - 1; i >= 0; i--) {
        builder.addInt64(data[i]);
      }
      return builder.endVector();
    }
  }, {
    key: "startTmVector",
    value: function startTmVector(builder, numElems) {
      builder.startVector(8, numElems, 8);
    }
  }, {
    key: "addType",
    value: function addType(builder, type) {
      builder.addFieldInt8(6, type, geometry_type_GeometryType.Unknown);
    }
  }, {
    key: "addParts",
    value: function addParts(builder, partsOffset) {
      builder.addFieldOffset(7, partsOffset, 0);
    }
  }, {
    key: "createPartsVector",
    value: function createPartsVector(builder, data) {
      builder.startVector(4, data.length, 4);
      for (var i = data.length - 1; i >= 0; i--) {
        builder.addOffset(data[i]);
      }
      return builder.endVector();
    }
  }, {
    key: "startPartsVector",
    value: function startPartsVector(builder, numElems) {
      builder.startVector(4, numElems, 4);
    }
  }, {
    key: "endGeometry",
    value: function endGeometry(builder) {
      var offset = builder.endObject();
      return offset;
    }
  }, {
    key: "createGeometry",
    value: function createGeometry(builder, endsOffset, xyOffset, zOffset, mOffset, tOffset, tmOffset, type, partsOffset) {
      Geometry.startGeometry(builder);
      Geometry.addEnds(builder, endsOffset);
      Geometry.addXy(builder, xyOffset);
      Geometry.addZ(builder, zOffset);
      Geometry.addM(builder, mOffset);
      Geometry.addT(builder, tOffset);
      Geometry.addTm(builder, tmOffset);
      Geometry.addType(builder, type);
      Geometry.addParts(builder, partsOffset);
      return Geometry.endGeometry(builder);
    }
  }]);
  return Geometry;
}();
;// CONCATENATED MODULE: ./node_modules/flatgeobuf/lib/mjs/generic/geometry.js
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }


function geometry_buildGeometry(builder, parsedGeometry) {
  var xy = parsedGeometry.xy,
    z = parsedGeometry.z,
    ends = parsedGeometry.ends,
    parts = parsedGeometry.parts,
    type = parsedGeometry.type;
  if (parts) {
    var partOffsets = parts.map(function (part) {
      return geometry_buildGeometry(builder, part);
    });
    var partsOffset = Geometry.createPartsVector(builder, partOffsets);
    Geometry.startGeometry(builder);
    Geometry.addParts(builder, partsOffset);
    Geometry.addType(builder, type);
    return Geometry.endGeometry(builder);
  }
  var xyOffset = Geometry.createXyVector(builder, xy);
  var zOffset;
  if (z) zOffset = Geometry.createZVector(builder, z);
  var endsOffset;
  if (ends) endsOffset = Geometry.createEndsVector(builder, ends);
  Geometry.startGeometry(builder);
  if (endsOffset) Geometry.addEnds(builder, endsOffset);
  Geometry.addXy(builder, xyOffset);
  if (zOffset) Geometry.addZ(builder, zOffset);
  Geometry.addType(builder, type);
  return Geometry.endGeometry(builder);
}
function geometry_flat(a, xy, z) {
  if (a.length === 0) return;
  if (Array.isArray(a[0])) {
    var _iterator = _createForOfIteratorHelper(a),
      _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var sa = _step.value;
        geometry_flat(sa, xy, z);
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  } else {
    if (a.length === 2) xy.push.apply(xy, _toConsumableArray(a));else {
      xy.push(a[0], a[1]);
      z.push(a[2]);
    }
  }
}
function geometry_parseGeometry(geometry, headerGeomType) {
  var xy;
  var ends;
  var parts;
  var type = headerGeomType;
  if (type === GeometryType.Unknown) {
    type = geometry_toGeometryType(geometry.getType());
  }
  if (type === GeometryType.MultiLineString) {
    if (geometry.getFlatCoordinates) xy = geometry.getFlatCoordinates();
    var mlsEnds = geometry.getEnds();
    if (mlsEnds.length > 1) ends = mlsEnds.map(function (e) {
      return e >> 1;
    });
  } else if (type === GeometryType.Polygon) {
    if (geometry.getFlatCoordinates) xy = geometry.getFlatCoordinates();
    var pEnds = geometry.getEnds();
    if (pEnds.length > 1) ends = pEnds.map(function (e) {
      return e >> 1;
    });
  } else if (type === GeometryType.MultiPolygon) {
    var mp = geometry;
    parts = mp.getPolygons().map(function (p) {
      return geometry_parseGeometry(p, GeometryType.Polygon);
    });
  } else {
    if (geometry.getFlatCoordinates) xy = geometry.getFlatCoordinates();
  }
  return {
    xy: xy,
    ends: ends,
    type: type,
    parts: parts
  };
}
function pairFlatCoordinates(xy, z) {
  var newArray = [];
  for (var i = 0; i < xy.length; i += 2) {
    var a = [xy[i], xy[i + 1]];
    if (z) a.push(z[i >> 1]);
    newArray.push(a);
  }
  return newArray;
}
function geometry_toGeometryType(name) {
  if (!name) return GeometryType.Unknown;
  var type = GeometryType[name];
  return type;
}
;// CONCATENATED MODULE: ./node_modules/flatgeobuf/lib/mjs/geojson/geometry.js


function geojson_geometry_parseGeometry(geometry) {
  var cs = geometry.coordinates;
  var xy = [];
  var z = [];
  var ends;
  var parts;
  var type = toGeometryType(geometry.type);
  var end = 0;
  switch (geometry.type) {
    case 'Point':
      flat(cs, xy, z);
      break;
    case 'MultiPoint':
    case 'LineString':
      flat(cs, xy, z);
      break;
    case 'MultiLineString':
    case 'Polygon':
      {
        var css = cs;
        flat(css, xy, z);
        if (css.length > 1) ends = css.map(function (c) {
          return end += c.length;
        });
        break;
      }
    case 'MultiPolygon':
      {
        var csss = cs;
        var geometries = csss.map(function (coordinates) {
          return {
            type: 'Polygon',
            coordinates: coordinates
          };
        });
        parts = geometries.map(geojson_geometry_parseGeometry);
        break;
      }
  }
  return {
    xy: xy,
    z: z.length > 0 ? z : undefined,
    ends: ends,
    type: type,
    parts: parts
  };
}
function geometry_parseGC(geometry) {
  var type = toGeometryType(geometry.type);
  var parts = [];
  for (var i = 0; i < geometry.geometries.length; i++) {
    var g = geometry.geometries[i];
    if (g.type === 'GeometryCollection') parts.push(geometry_parseGC(g));else parts.push(geojson_geometry_parseGeometry(g));
  }
  return {
    type: type,
    parts: parts
  };
}
function extractParts(xy, z, ends) {
  if (!ends || ends.length === 0) return [pairFlatCoordinates(xy, z)];
  var s = 0;
  var xySlices = Array.from(ends).map(function (e) {
    return xy.slice(s, s = e << 1);
  });
  var zSlices;
  if (z) {
    s = 0;
    zSlices = Array.from(ends).map(function (e) {
      return z.slice(s, s = e);
    });
  }
  return xySlices.map(function (xy, i) {
    return pairFlatCoordinates(xy, zSlices ? zSlices[i] : undefined);
  });
}
function toGeoJsonCoordinates(geometry, type) {
  var xy = geometry.xyArray();
  var z = geometry.zArray();
  switch (type) {
    case geometry_type_GeometryType.Point:
      {
        var a = Array.from(xy);
        if (z) a.push(z[0]);
        return a;
      }
    case geometry_type_GeometryType.MultiPoint:
    case geometry_type_GeometryType.LineString:
      return pairFlatCoordinates(xy, z);
    case geometry_type_GeometryType.MultiLineString:
      return extractParts(xy, z, geometry.endsArray());
    case geometry_type_GeometryType.Polygon:
      return extractParts(xy, z, geometry.endsArray());
  }
}
function fromGeometry(geometry, headerType) {
  var type = headerType;
  if (type === geometry_type_GeometryType.Unknown) {
    type = geometry.type();
  }
  if (type === geometry_type_GeometryType.GeometryCollection) {
    var geometries = [];
    for (var i = 0; i < geometry.partsLength(); i++) {
      var part = geometry.parts(i);
      var partType = part.type();
      geometries.push(fromGeometry(part, partType));
    }
    return {
      type: geometry_type_GeometryType[type],
      geometries: geometries
    };
  } else if (type === geometry_type_GeometryType.MultiPolygon) {
    var _geometries = [];
    for (var _i2 = 0; _i2 < geometry.partsLength(); _i2++) _geometries.push(fromGeometry(geometry.parts(_i2), geometry_type_GeometryType.Polygon));
    return {
      type: geometry_type_GeometryType[type],
      coordinates: _geometries.map(function (g) {
        return g.coordinates;
      })
    };
  }
  var coordinates = toGeoJsonCoordinates(geometry, type);
  return {
    type: geometry_type_GeometryType[type],
    coordinates: coordinates
  };
}
;// CONCATENATED MODULE: ./node_modules/flatgeobuf/lib/mjs/flat-geobuf/column-type.js
var column_type_ColumnType;
(function (ColumnType) {
  ColumnType[ColumnType["Byte"] = 0] = "Byte";
  ColumnType[ColumnType["UByte"] = 1] = "UByte";
  ColumnType[ColumnType["Bool"] = 2] = "Bool";
  ColumnType[ColumnType["Short"] = 3] = "Short";
  ColumnType[ColumnType["UShort"] = 4] = "UShort";
  ColumnType[ColumnType["Int"] = 5] = "Int";
  ColumnType[ColumnType["UInt"] = 6] = "UInt";
  ColumnType[ColumnType["Long"] = 7] = "Long";
  ColumnType[ColumnType["ULong"] = 8] = "ULong";
  ColumnType[ColumnType["Float"] = 9] = "Float";
  ColumnType[ColumnType["Double"] = 10] = "Double";
  ColumnType[ColumnType["String"] = 11] = "String";
  ColumnType[ColumnType["Json"] = 12] = "Json";
  ColumnType[ColumnType["DateTime"] = 13] = "DateTime";
  ColumnType[ColumnType["Binary"] = 14] = "Binary";
})(column_type_ColumnType || (column_type_ColumnType = {}));
;// CONCATENATED MODULE: ./node_modules/flatgeobuf/lib/mjs/flat-geobuf/column.js
function column_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function column_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
function column_createClass(Constructor, protoProps, staticProps) { if (protoProps) column_defineProperties(Constructor.prototype, protoProps); if (staticProps) column_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }


var column_Column = /*#__PURE__*/function () {
  function Column() {
    column_classCallCheck(this, Column);
    this.bb = null;
    this.bb_pos = 0;
  }
  column_createClass(Column, [{
    key: "__init",
    value: function __init(i, bb) {
      this.bb_pos = i;
      this.bb = bb;
      return this;
    }
  }, {
    key: "name",
    value: function name(optionalEncoding) {
      var offset = this.bb.__offset(this.bb_pos, 4);
      return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
  }, {
    key: "type",
    value: function type() {
      var offset = this.bb.__offset(this.bb_pos, 6);
      return offset ? this.bb.readUint8(this.bb_pos + offset) : column_type_ColumnType.Byte;
    }
  }, {
    key: "title",
    value: function title(optionalEncoding) {
      var offset = this.bb.__offset(this.bb_pos, 8);
      return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
  }, {
    key: "description",
    value: function description(optionalEncoding) {
      var offset = this.bb.__offset(this.bb_pos, 10);
      return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
  }, {
    key: "width",
    value: function width() {
      var offset = this.bb.__offset(this.bb_pos, 12);
      return offset ? this.bb.readInt32(this.bb_pos + offset) : -1;
    }
  }, {
    key: "precision",
    value: function precision() {
      var offset = this.bb.__offset(this.bb_pos, 14);
      return offset ? this.bb.readInt32(this.bb_pos + offset) : -1;
    }
  }, {
    key: "scale",
    value: function scale() {
      var offset = this.bb.__offset(this.bb_pos, 16);
      return offset ? this.bb.readInt32(this.bb_pos + offset) : -1;
    }
  }, {
    key: "nullable",
    value: function nullable() {
      var offset = this.bb.__offset(this.bb_pos, 18);
      return offset ? !!this.bb.readInt8(this.bb_pos + offset) : true;
    }
  }, {
    key: "unique",
    value: function unique() {
      var offset = this.bb.__offset(this.bb_pos, 20);
      return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
  }, {
    key: "primaryKey",
    value: function primaryKey() {
      var offset = this.bb.__offset(this.bb_pos, 22);
      return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
  }, {
    key: "metadata",
    value: function metadata(optionalEncoding) {
      var offset = this.bb.__offset(this.bb_pos, 24);
      return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
  }], [{
    key: "getRootAsColumn",
    value: function getRootAsColumn(bb, obj) {
      return (obj || new Column()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
  }, {
    key: "getSizePrefixedRootAsColumn",
    value: function getSizePrefixedRootAsColumn(bb, obj) {
      bb.setPosition(bb.position() + constants_SIZE_PREFIX_LENGTH);
      return (obj || new Column()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
  }, {
    key: "startColumn",
    value: function startColumn(builder) {
      builder.startObject(11);
    }
  }, {
    key: "addName",
    value: function addName(builder, nameOffset) {
      builder.addFieldOffset(0, nameOffset, 0);
    }
  }, {
    key: "addType",
    value: function addType(builder, type) {
      builder.addFieldInt8(1, type, column_type_ColumnType.Byte);
    }
  }, {
    key: "addTitle",
    value: function addTitle(builder, titleOffset) {
      builder.addFieldOffset(2, titleOffset, 0);
    }
  }, {
    key: "addDescription",
    value: function addDescription(builder, descriptionOffset) {
      builder.addFieldOffset(3, descriptionOffset, 0);
    }
  }, {
    key: "addWidth",
    value: function addWidth(builder, width) {
      builder.addFieldInt32(4, width, -1);
    }
  }, {
    key: "addPrecision",
    value: function addPrecision(builder, precision) {
      builder.addFieldInt32(5, precision, -1);
    }
  }, {
    key: "addScale",
    value: function addScale(builder, scale) {
      builder.addFieldInt32(6, scale, -1);
    }
  }, {
    key: "addNullable",
    value: function addNullable(builder, nullable) {
      builder.addFieldInt8(7, +nullable, +true);
    }
  }, {
    key: "addUnique",
    value: function addUnique(builder, unique) {
      builder.addFieldInt8(8, +unique, +false);
    }
  }, {
    key: "addPrimaryKey",
    value: function addPrimaryKey(builder, primaryKey) {
      builder.addFieldInt8(9, +primaryKey, +false);
    }
  }, {
    key: "addMetadata",
    value: function addMetadata(builder, metadataOffset) {
      builder.addFieldOffset(10, metadataOffset, 0);
    }
  }, {
    key: "endColumn",
    value: function endColumn(builder) {
      var offset = builder.endObject();
      builder.requiredField(offset, 4);
      return offset;
    }
  }, {
    key: "createColumn",
    value: function createColumn(builder, nameOffset, type, titleOffset, descriptionOffset, width, precision, scale, nullable, unique, primaryKey, metadataOffset) {
      Column.startColumn(builder);
      Column.addName(builder, nameOffset);
      Column.addType(builder, type);
      Column.addTitle(builder, titleOffset);
      Column.addDescription(builder, descriptionOffset);
      Column.addWidth(builder, width);
      Column.addPrecision(builder, precision);
      Column.addScale(builder, scale);
      Column.addNullable(builder, nullable);
      Column.addUnique(builder, unique);
      Column.addPrimaryKey(builder, primaryKey);
      Column.addMetadata(builder, metadataOffset);
      return Column.endColumn(builder);
    }
  }]);
  return Column;
}();
;// CONCATENATED MODULE: ./node_modules/flatgeobuf/lib/mjs/flat-geobuf/feature.js
function feature_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function feature_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
function feature_createClass(Constructor, protoProps, staticProps) { if (protoProps) feature_defineProperties(Constructor.prototype, protoProps); if (staticProps) feature_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }



var feature_Feature = /*#__PURE__*/function () {
  function Feature() {
    feature_classCallCheck(this, Feature);
    this.bb = null;
    this.bb_pos = 0;
  }
  feature_createClass(Feature, [{
    key: "__init",
    value: function __init(i, bb) {
      this.bb_pos = i;
      this.bb = bb;
      return this;
    }
  }, {
    key: "geometry",
    value: function geometry(obj) {
      var offset = this.bb.__offset(this.bb_pos, 4);
      return offset ? (obj || new geometry_Geometry()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
  }, {
    key: "properties",
    value: function properties(index) {
      var offset = this.bb.__offset(this.bb_pos, 6);
      return offset ? this.bb.readUint8(this.bb.__vector(this.bb_pos + offset) + index) : 0;
    }
  }, {
    key: "propertiesLength",
    value: function propertiesLength() {
      var offset = this.bb.__offset(this.bb_pos, 6);
      return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
  }, {
    key: "propertiesArray",
    value: function propertiesArray() {
      var offset = this.bb.__offset(this.bb_pos, 6);
      return offset ? new Uint8Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    }
  }, {
    key: "columns",
    value: function columns(index, obj) {
      var offset = this.bb.__offset(this.bb_pos, 8);
      return offset ? (obj || new column_Column()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
  }, {
    key: "columnsLength",
    value: function columnsLength() {
      var offset = this.bb.__offset(this.bb_pos, 8);
      return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
  }], [{
    key: "getRootAsFeature",
    value: function getRootAsFeature(bb, obj) {
      return (obj || new Feature()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
  }, {
    key: "getSizePrefixedRootAsFeature",
    value: function getSizePrefixedRootAsFeature(bb, obj) {
      bb.setPosition(bb.position() + constants_SIZE_PREFIX_LENGTH);
      return (obj || new Feature()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
  }, {
    key: "startFeature",
    value: function startFeature(builder) {
      builder.startObject(3);
    }
  }, {
    key: "addGeometry",
    value: function addGeometry(builder, geometryOffset) {
      builder.addFieldOffset(0, geometryOffset, 0);
    }
  }, {
    key: "addProperties",
    value: function addProperties(builder, propertiesOffset) {
      builder.addFieldOffset(1, propertiesOffset, 0);
    }
  }, {
    key: "createPropertiesVector",
    value: function createPropertiesVector(builder, data) {
      builder.startVector(1, data.length, 1);
      for (var i = data.length - 1; i >= 0; i--) {
        builder.addInt8(data[i]);
      }
      return builder.endVector();
    }
  }, {
    key: "startPropertiesVector",
    value: function startPropertiesVector(builder, numElems) {
      builder.startVector(1, numElems, 1);
    }
  }, {
    key: "addColumns",
    value: function addColumns(builder, columnsOffset) {
      builder.addFieldOffset(2, columnsOffset, 0);
    }
  }, {
    key: "createColumnsVector",
    value: function createColumnsVector(builder, data) {
      builder.startVector(4, data.length, 4);
      for (var i = data.length - 1; i >= 0; i--) {
        builder.addOffset(data[i]);
      }
      return builder.endVector();
    }
  }, {
    key: "startColumnsVector",
    value: function startColumnsVector(builder, numElems) {
      builder.startVector(4, numElems, 4);
    }
  }, {
    key: "endFeature",
    value: function endFeature(builder) {
      var offset = builder.endObject();
      return offset;
    }
  }, {
    key: "finishFeatureBuffer",
    value: function finishFeatureBuffer(builder, offset) {
      builder.finish(offset);
    }
  }, {
    key: "finishSizePrefixedFeatureBuffer",
    value: function finishSizePrefixedFeatureBuffer(builder, offset) {
      builder.finish(offset, undefined, true);
    }
  }, {
    key: "createFeature",
    value: function createFeature(builder, geometryOffset, propertiesOffset, columnsOffset) {
      Feature.startFeature(builder);
      Feature.addGeometry(builder, geometryOffset);
      Feature.addProperties(builder, propertiesOffset);
      Feature.addColumns(builder, columnsOffset);
      return Feature.endFeature(builder);
    }
  }]);
  return Feature;
}();
;// CONCATENATED MODULE: ./node_modules/flatgeobuf/lib/mjs/generic/feature.js




var textEncoder = new TextEncoder();
var textDecoder = new TextDecoder();
function fromFeature(feature, header, createGeometry, createFeature) {
  var columns = header.columns;
  var geometry = feature.geometry();
  var simpleGeometry = createGeometry(geometry, header.geometryType);
  var properties = parseProperties(feature, columns);
  return createFeature(simpleGeometry, properties);
}
function feature_buildFeature(geometry, properties, header) {
  var columns = header.columns;
  var builder = new flatbuffers.Builder();
  var offset = 0;
  var capacity = 1024;
  var bytes = new Uint8Array(capacity);
  var view = new DataView(bytes.buffer);
  var prep = function prep(size) {
    if (offset + size < capacity) return;
    capacity = Math.max(capacity + size, capacity * 2);
    var newBytes = new Uint8Array(capacity);
    newBytes.set(bytes);
    bytes = newBytes;
    view = new DataView(bytes.buffer);
  };
  if (columns) {
    for (var i = 0; i < columns.length; i++) {
      var column = columns[i];
      var value = properties[column.name];
      if (value === null) continue;
      prep(2);
      view.setUint16(offset, i, true);
      offset += 2;
      switch (column.type) {
        case ColumnType.Bool:
          prep(1);
          view.setUint8(offset, value);
          offset += 1;
          break;
        case ColumnType.Short:
          prep(2);
          view.setInt16(offset, value, true);
          offset += 2;
          break;
        case ColumnType.UShort:
          prep(2);
          view.setUint16(offset, value, true);
          offset += 2;
          break;
        case ColumnType.Int:
          prep(4);
          view.setInt32(offset, value, true);
          offset += 4;
          break;
        case ColumnType.UInt:
          prep(4);
          view.setUint32(offset, value, true);
          offset += 4;
          break;
        case ColumnType.Long:
          prep(8);
          view.setBigInt64(offset, BigInt(value), true);
          offset += 8;
          break;
        case ColumnType.Float:
          prep(4);
          view.setFloat32(offset, value, true);
          offset += 4;
          break;
        case ColumnType.Double:
          prep(8);
          view.setFloat64(offset, value, true);
          offset += 8;
          break;
        case ColumnType.DateTime:
        case ColumnType.String:
          {
            var str = textEncoder.encode(value);
            prep(4);
            view.setUint32(offset, str.length, true);
            offset += 4;
            prep(str.length);
            bytes.set(str, offset);
            offset += str.length;
            break;
          }
        case ColumnType.Json:
          {
            var _str = textEncoder.encode(JSON.stringify(value));
            prep(4);
            view.setUint32(offset, _str.length, true);
            offset += 4;
            prep(_str.length);
            bytes.set(_str, offset);
            offset += _str.length;
            break;
          }
        default:
          throw new Error('Unknown type ' + column.type);
      }
    }
  }
  var propertiesOffset = null;
  if (offset > 0) propertiesOffset = Feature.createPropertiesVector(builder, bytes.slice(0, offset));
  var geometryOffset = buildGeometry(builder, geometry);
  Feature.startFeature(builder);
  Feature.addGeometry(builder, geometryOffset);
  if (propertiesOffset) Feature.addProperties(builder, propertiesOffset);
  var featureOffset = Feature.endFeature(builder);
  builder.finishSizePrefixed(featureOffset);
  return builder.asUint8Array();
}
function parseProperties(feature, columns) {
  var properties = {};
  if (!columns || columns.length === 0) return properties;
  var array = feature.propertiesArray();
  if (!array) return properties;
  var view = new DataView(array.buffer, array.byteOffset);
  var length = feature.propertiesLength();
  var offset = 0;
  while (offset < length) {
    var i = view.getUint16(offset, true);
    offset += 2;
    var column = columns[i];
    var name = column.name;
    switch (column.type) {
      case column_type_ColumnType.Bool:
        {
          properties[name] = !!view.getUint8(offset);
          offset += 1;
          break;
        }
      case column_type_ColumnType.Byte:
        {
          properties[name] = view.getInt8(offset);
          offset += 1;
          break;
        }
      case column_type_ColumnType.UByte:
        {
          properties[name] = view.getUint8(offset);
          offset += 1;
          break;
        }
      case column_type_ColumnType.Short:
        {
          properties[name] = view.getInt16(offset, true);
          offset += 2;
          break;
        }
      case column_type_ColumnType.UShort:
        {
          properties[name] = view.getUint16(offset, true);
          offset += 2;
          break;
        }
      case column_type_ColumnType.Int:
        {
          properties[name] = view.getInt32(offset, true);
          offset += 4;
          break;
        }
      case column_type_ColumnType.UInt:
        {
          properties[name] = view.getUint32(offset, true);
          offset += 4;
          break;
        }
      case column_type_ColumnType.Long:
        {
          properties[name] = Number(view.getBigInt64(offset, true));
          offset += 8;
          break;
        }
      case column_type_ColumnType.ULong:
        {
          properties[name] = Number(view.getBigUint64(offset, true));
          offset += 8;
          break;
        }
      case column_type_ColumnType.Float:
        {
          properties[name] = view.getFloat32(offset, true);
          offset += 4;
          break;
        }
      case column_type_ColumnType.Double:
        {
          properties[name] = view.getFloat64(offset, true);
          offset += 8;
          break;
        }
      case column_type_ColumnType.DateTime:
      case column_type_ColumnType.String:
        {
          var _length = view.getUint32(offset, true);
          offset += 4;
          properties[name] = textDecoder.decode(array.subarray(offset, offset + _length));
          offset += _length;
          break;
        }
      case column_type_ColumnType.Json:
        {
          var _length2 = view.getUint32(offset, true);
          offset += 4;
          var str = textDecoder.decode(array.subarray(offset, offset + _length2));
          properties[name] = JSON.parse(str);
          offset += _length2;
          break;
        }
      default:
        throw new Error('Unknown type ' + column.type);
    }
  }
  return properties;
}
;// CONCATENATED MODULE: ./node_modules/flatgeobuf/lib/mjs/geojson/feature.js


function feature_fromFeature(feature, header) {
  var columns = header.columns;
  var geometry = fromGeometry(feature.geometry(), header.geometryType);
  var geoJsonfeature = {
    type: 'Feature',
    geometry: geometry,
    properties: parseProperties(feature, columns)
  };
  return geoJsonfeature;
}
;// CONCATENATED MODULE: ./node_modules/slice-source/empty.js
/* harmony default export */ const empty = (new Uint8Array(0));

;// CONCATENATED MODULE: ./node_modules/slice-source/cancel.js
/* harmony default export */ function slice_source_cancel() {
  return this._source.cancel();
}

;// CONCATENATED MODULE: ./node_modules/slice-source/concat.js
function concat(a, b) {
  if (!a.length) return b;
  if (!b.length) return a;
  var c = new Uint8Array(a.length + b.length);
  c.set(a);
  c.set(b, a.length);
  return c;
}

;// CONCATENATED MODULE: ./node_modules/slice-source/read.js



/* harmony default export */ function read() {
  var that = this, array = that._array.subarray(that._index);
  return that._source.read().then(function(result) {
    that._array = empty;
    that._index = 0;
    return result.done ? (array.length > 0
        ? {done: false, value: array}
        : {done: true, value: undefined})
        : {done: false, value: concat(array, result.value)};
  });
}

;// CONCATENATED MODULE: ./node_modules/slice-source/slice.js


/* harmony default export */ function slice(length) {
  if ((length |= 0) < 0) throw new Error("invalid length");
  var that = this, index = this._array.length - this._index;

  // If the request fits within the remaining buffer, resolve it immediately.
  if (this._index + length <= this._array.length) {
    return Promise.resolve(this._array.subarray(this._index, this._index += length));
  }

  // Otherwise, read chunks repeatedly until the request is fulfilled.
  var array = new Uint8Array(length);
  array.set(this._array.subarray(this._index));
  return (function read() {
    return that._source.read().then(function(result) {

      // When done, it’s possible the request wasn’t fully fullfilled!
      // If so, the pre-allocated array is too big and needs slicing.
      if (result.done) {
        that._array = empty;
        that._index = 0;
        return index > 0 ? array.subarray(0, index) : null;
      }

      // If this chunk fulfills the request, return the resulting array.
      if (index + result.value.length >= length) {
        that._array = result.value;
        that._index = length - index;
        array.set(result.value.subarray(0, length - index), index);
        return array;
      }

      // Otherwise copy this chunk into the array, then read the next chunk.
      array.set(result.value, index);
      index += result.value.length;
      return read();
    });
  })();
}

;// CONCATENATED MODULE: ./node_modules/slice-source/index.js





function slice_source_slice(source) {
  return typeof source.slice === "function" ? source :
      new SliceSource(typeof source.read === "function" ? source
          : source.getReader());
}

function SliceSource(source) {
  this._source = source;
  this._array = empty;
  this._index = 0;
}

SliceSource.prototype.read = read;
SliceSource.prototype.slice = slice;
SliceSource.prototype.cancel = slice_source_cancel;

;// CONCATENATED MODULE: ./node_modules/flatgeobuf/lib/mjs/flat-geobuf/crs.js
function crs_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function crs_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
function crs_createClass(Constructor, protoProps, staticProps) { if (protoProps) crs_defineProperties(Constructor.prototype, protoProps); if (staticProps) crs_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

var Crs = /*#__PURE__*/function () {
  function Crs() {
    crs_classCallCheck(this, Crs);
    this.bb = null;
    this.bb_pos = 0;
  }
  crs_createClass(Crs, [{
    key: "__init",
    value: function __init(i, bb) {
      this.bb_pos = i;
      this.bb = bb;
      return this;
    }
  }, {
    key: "org",
    value: function org(optionalEncoding) {
      var offset = this.bb.__offset(this.bb_pos, 4);
      return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
  }, {
    key: "code",
    value: function code() {
      var offset = this.bb.__offset(this.bb_pos, 6);
      return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
    }
  }, {
    key: "name",
    value: function name(optionalEncoding) {
      var offset = this.bb.__offset(this.bb_pos, 8);
      return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
  }, {
    key: "description",
    value: function description(optionalEncoding) {
      var offset = this.bb.__offset(this.bb_pos, 10);
      return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
  }, {
    key: "wkt",
    value: function wkt(optionalEncoding) {
      var offset = this.bb.__offset(this.bb_pos, 12);
      return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
  }, {
    key: "codeString",
    value: function codeString(optionalEncoding) {
      var offset = this.bb.__offset(this.bb_pos, 14);
      return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
  }], [{
    key: "getRootAsCrs",
    value: function getRootAsCrs(bb, obj) {
      return (obj || new Crs()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
  }, {
    key: "getSizePrefixedRootAsCrs",
    value: function getSizePrefixedRootAsCrs(bb, obj) {
      bb.setPosition(bb.position() + constants_SIZE_PREFIX_LENGTH);
      return (obj || new Crs()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
  }, {
    key: "startCrs",
    value: function startCrs(builder) {
      builder.startObject(6);
    }
  }, {
    key: "addOrg",
    value: function addOrg(builder, orgOffset) {
      builder.addFieldOffset(0, orgOffset, 0);
    }
  }, {
    key: "addCode",
    value: function addCode(builder, code) {
      builder.addFieldInt32(1, code, 0);
    }
  }, {
    key: "addName",
    value: function addName(builder, nameOffset) {
      builder.addFieldOffset(2, nameOffset, 0);
    }
  }, {
    key: "addDescription",
    value: function addDescription(builder, descriptionOffset) {
      builder.addFieldOffset(3, descriptionOffset, 0);
    }
  }, {
    key: "addWkt",
    value: function addWkt(builder, wktOffset) {
      builder.addFieldOffset(4, wktOffset, 0);
    }
  }, {
    key: "addCodeString",
    value: function addCodeString(builder, codeStringOffset) {
      builder.addFieldOffset(5, codeStringOffset, 0);
    }
  }, {
    key: "endCrs",
    value: function endCrs(builder) {
      var offset = builder.endObject();
      return offset;
    }
  }, {
    key: "createCrs",
    value: function createCrs(builder, orgOffset, code, nameOffset, descriptionOffset, wktOffset, codeStringOffset) {
      Crs.startCrs(builder);
      Crs.addOrg(builder, orgOffset);
      Crs.addCode(builder, code);
      Crs.addName(builder, nameOffset);
      Crs.addDescription(builder, descriptionOffset);
      Crs.addWkt(builder, wktOffset);
      Crs.addCodeString(builder, codeStringOffset);
      return Crs.endCrs(builder);
    }
  }]);
  return Crs;
}();
;// CONCATENATED MODULE: ./node_modules/flatgeobuf/lib/mjs/flat-geobuf/header.js
function header_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function header_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
function header_createClass(Constructor, protoProps, staticProps) { if (protoProps) header_defineProperties(Constructor.prototype, protoProps); if (staticProps) header_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }




var header_Header = /*#__PURE__*/function () {
  function Header() {
    header_classCallCheck(this, Header);
    this.bb = null;
    this.bb_pos = 0;
  }
  header_createClass(Header, [{
    key: "__init",
    value: function __init(i, bb) {
      this.bb_pos = i;
      this.bb = bb;
      return this;
    }
  }, {
    key: "name",
    value: function name(optionalEncoding) {
      var offset = this.bb.__offset(this.bb_pos, 4);
      return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
  }, {
    key: "envelope",
    value: function envelope(index) {
      var offset = this.bb.__offset(this.bb_pos, 6);
      return offset ? this.bb.readFloat64(this.bb.__vector(this.bb_pos + offset) + index * 8) : 0;
    }
  }, {
    key: "envelopeLength",
    value: function envelopeLength() {
      var offset = this.bb.__offset(this.bb_pos, 6);
      return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
  }, {
    key: "envelopeArray",
    value: function envelopeArray() {
      var offset = this.bb.__offset(this.bb_pos, 6);
      return offset ? new Float64Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    }
  }, {
    key: "geometryType",
    value: function geometryType() {
      var offset = this.bb.__offset(this.bb_pos, 8);
      return offset ? this.bb.readUint8(this.bb_pos + offset) : geometry_type_GeometryType.Unknown;
    }
  }, {
    key: "hasZ",
    value: function hasZ() {
      var offset = this.bb.__offset(this.bb_pos, 10);
      return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
  }, {
    key: "hasM",
    value: function hasM() {
      var offset = this.bb.__offset(this.bb_pos, 12);
      return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
  }, {
    key: "hasT",
    value: function hasT() {
      var offset = this.bb.__offset(this.bb_pos, 14);
      return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
  }, {
    key: "hasTm",
    value: function hasTm() {
      var offset = this.bb.__offset(this.bb_pos, 16);
      return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    }
  }, {
    key: "columns",
    value: function columns(index, obj) {
      var offset = this.bb.__offset(this.bb_pos, 18);
      return offset ? (obj || new column_Column()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    }
  }, {
    key: "columnsLength",
    value: function columnsLength() {
      var offset = this.bb.__offset(this.bb_pos, 18);
      return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    }
  }, {
    key: "featuresCount",
    value: function featuresCount() {
      var offset = this.bb.__offset(this.bb_pos, 20);
      return offset ? this.bb.readUint64(this.bb_pos + offset) : BigInt('0');
    }
  }, {
    key: "indexNodeSize",
    value: function indexNodeSize() {
      var offset = this.bb.__offset(this.bb_pos, 22);
      return offset ? this.bb.readUint16(this.bb_pos + offset) : 16;
    }
  }, {
    key: "crs",
    value: function crs(obj) {
      var offset = this.bb.__offset(this.bb_pos, 24);
      return offset ? (obj || new Crs()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    }
  }, {
    key: "title",
    value: function title(optionalEncoding) {
      var offset = this.bb.__offset(this.bb_pos, 26);
      return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
  }, {
    key: "description",
    value: function description(optionalEncoding) {
      var offset = this.bb.__offset(this.bb_pos, 28);
      return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
  }, {
    key: "metadata",
    value: function metadata(optionalEncoding) {
      var offset = this.bb.__offset(this.bb_pos, 30);
      return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    }
  }], [{
    key: "getRootAsHeader",
    value: function getRootAsHeader(bb, obj) {
      return (obj || new Header()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
  }, {
    key: "getSizePrefixedRootAsHeader",
    value: function getSizePrefixedRootAsHeader(bb, obj) {
      bb.setPosition(bb.position() + constants_SIZE_PREFIX_LENGTH);
      return (obj || new Header()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    }
  }, {
    key: "startHeader",
    value: function startHeader(builder) {
      builder.startObject(14);
    }
  }, {
    key: "addName",
    value: function addName(builder, nameOffset) {
      builder.addFieldOffset(0, nameOffset, 0);
    }
  }, {
    key: "addEnvelope",
    value: function addEnvelope(builder, envelopeOffset) {
      builder.addFieldOffset(1, envelopeOffset, 0);
    }
  }, {
    key: "createEnvelopeVector",
    value: function createEnvelopeVector(builder, data) {
      builder.startVector(8, data.length, 8);
      for (var i = data.length - 1; i >= 0; i--) {
        builder.addFloat64(data[i]);
      }
      return builder.endVector();
    }
  }, {
    key: "startEnvelopeVector",
    value: function startEnvelopeVector(builder, numElems) {
      builder.startVector(8, numElems, 8);
    }
  }, {
    key: "addGeometryType",
    value: function addGeometryType(builder, geometryType) {
      builder.addFieldInt8(2, geometryType, geometry_type_GeometryType.Unknown);
    }
  }, {
    key: "addHasZ",
    value: function addHasZ(builder, hasZ) {
      builder.addFieldInt8(3, +hasZ, +false);
    }
  }, {
    key: "addHasM",
    value: function addHasM(builder, hasM) {
      builder.addFieldInt8(4, +hasM, +false);
    }
  }, {
    key: "addHasT",
    value: function addHasT(builder, hasT) {
      builder.addFieldInt8(5, +hasT, +false);
    }
  }, {
    key: "addHasTm",
    value: function addHasTm(builder, hasTm) {
      builder.addFieldInt8(6, +hasTm, +false);
    }
  }, {
    key: "addColumns",
    value: function addColumns(builder, columnsOffset) {
      builder.addFieldOffset(7, columnsOffset, 0);
    }
  }, {
    key: "createColumnsVector",
    value: function createColumnsVector(builder, data) {
      builder.startVector(4, data.length, 4);
      for (var i = data.length - 1; i >= 0; i--) {
        builder.addOffset(data[i]);
      }
      return builder.endVector();
    }
  }, {
    key: "startColumnsVector",
    value: function startColumnsVector(builder, numElems) {
      builder.startVector(4, numElems, 4);
    }
  }, {
    key: "addFeaturesCount",
    value: function addFeaturesCount(builder, featuresCount) {
      builder.addFieldInt64(8, featuresCount, BigInt('0'));
    }
  }, {
    key: "addIndexNodeSize",
    value: function addIndexNodeSize(builder, indexNodeSize) {
      builder.addFieldInt16(9, indexNodeSize, 16);
    }
  }, {
    key: "addCrs",
    value: function addCrs(builder, crsOffset) {
      builder.addFieldOffset(10, crsOffset, 0);
    }
  }, {
    key: "addTitle",
    value: function addTitle(builder, titleOffset) {
      builder.addFieldOffset(11, titleOffset, 0);
    }
  }, {
    key: "addDescription",
    value: function addDescription(builder, descriptionOffset) {
      builder.addFieldOffset(12, descriptionOffset, 0);
    }
  }, {
    key: "addMetadata",
    value: function addMetadata(builder, metadataOffset) {
      builder.addFieldOffset(13, metadataOffset, 0);
    }
  }, {
    key: "endHeader",
    value: function endHeader(builder) {
      var offset = builder.endObject();
      return offset;
    }
  }, {
    key: "finishHeaderBuffer",
    value: function finishHeaderBuffer(builder, offset) {
      builder.finish(offset);
    }
  }, {
    key: "finishSizePrefixedHeaderBuffer",
    value: function finishSizePrefixedHeaderBuffer(builder, offset) {
      builder.finish(offset, undefined, true);
    }
  }]);
  return Header;
}();
;// CONCATENATED MODULE: ./node_modules/flatgeobuf/lib/mjs/header-meta.js

function fromByteBuffer(bb) {
  var header = header_Header.getRootAsHeader(bb);
  var featuresCount = header.featuresCount();
  var indexNodeSize = header.indexNodeSize();
  var columns = [];
  for (var j = 0; j < header.columnsLength(); j++) {
    var column = header.columns(j);
    if (!column) throw new Error('Column unexpectedly missing');
    if (!column.name()) throw new Error('Column name unexpectedly missing');
    columns.push({
      name: column.name(),
      type: column.type(),
      title: column.title(),
      description: column.description(),
      width: column.width(),
      precision: column.precision(),
      scale: column.scale(),
      nullable: column.nullable(),
      unique: column.unique(),
      primary_key: column.primaryKey()
    });
  }
  var crs = header.crs();
  var crsMeta = crs ? {
    org: crs.org(),
    code: crs.code(),
    name: crs.name(),
    description: crs.description(),
    wkt: crs.wkt(),
    code_string: crs.codeString()
  } : null;
  var headerMeta = {
    geometryType: header.geometryType(),
    columns: columns,
    envelope: null,
    featuresCount: Number(featuresCount),
    indexNodeSize: indexNodeSize,
    crs: crsMeta,
    title: header.title(),
    description: header.description(),
    metadata: header.metadata()
  };
  return headerMeta;
}
;// CONCATENATED MODULE: ./node_modules/@repeaterjs/repeater/repeater.js
/// <reference types="./repeater.d.ts" />
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

/** An error subclass which is thrown when there are too many pending push or next operations on a single repeater. */
var RepeaterOverflowError = /** @class */ (function (_super) {
    __extends(RepeaterOverflowError, _super);
    function RepeaterOverflowError(message) {
        var _this = _super.call(this, message) || this;
        Object.defineProperty(_this, "name", {
            value: "RepeaterOverflowError",
            enumerable: false,
        });
        if (typeof Object.setPrototypeOf === "function") {
            Object.setPrototypeOf(_this, _this.constructor.prototype);
        }
        else {
            _this.__proto__ = _this.constructor.prototype;
        }
        if (typeof Error.captureStackTrace === "function") {
            Error.captureStackTrace(_this, _this.constructor);
        }
        return _this;
    }
    return RepeaterOverflowError;
}(Error));
/** A buffer which allows you to push a set amount of values to the repeater without pushes waiting or throwing errors. */
var FixedBuffer = /** @class */ (function () {
    function FixedBuffer(capacity) {
        if (capacity < 0) {
            throw new RangeError("Capacity may not be less than 0");
        }
        this._c = capacity;
        this._q = [];
    }
    Object.defineProperty(FixedBuffer.prototype, "empty", {
        get: function () {
            return this._q.length === 0;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(FixedBuffer.prototype, "full", {
        get: function () {
            return this._q.length >= this._c;
        },
        enumerable: false,
        configurable: true
    });
    FixedBuffer.prototype.add = function (value) {
        if (this.full) {
            throw new Error("Buffer full");
        }
        else {
            this._q.push(value);
        }
    };
    FixedBuffer.prototype.remove = function () {
        if (this.empty) {
            throw new Error("Buffer empty");
        }
        return this._q.shift();
    };
    return FixedBuffer;
}());
// TODO: Use a circular buffer here.
/** Sliding buffers allow you to push a set amount of values to the repeater without pushes waiting or throwing errors. If the number of values exceeds the capacity set in the constructor, the buffer will discard the earliest values added. */
var SlidingBuffer = /** @class */ (function () {
    function SlidingBuffer(capacity) {
        if (capacity < 1) {
            throw new RangeError("Capacity may not be less than 1");
        }
        this._c = capacity;
        this._q = [];
    }
    Object.defineProperty(SlidingBuffer.prototype, "empty", {
        get: function () {
            return this._q.length === 0;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SlidingBuffer.prototype, "full", {
        get: function () {
            return false;
        },
        enumerable: false,
        configurable: true
    });
    SlidingBuffer.prototype.add = function (value) {
        while (this._q.length >= this._c) {
            this._q.shift();
        }
        this._q.push(value);
    };
    SlidingBuffer.prototype.remove = function () {
        if (this.empty) {
            throw new Error("Buffer empty");
        }
        return this._q.shift();
    };
    return SlidingBuffer;
}());
/** Dropping buffers allow you to push a set amount of values to the repeater without the push function waiting or throwing errors. If the number of values exceeds the capacity set in the constructor, the buffer will discard the latest values added. */
var DroppingBuffer = /** @class */ (function () {
    function DroppingBuffer(capacity) {
        if (capacity < 1) {
            throw new RangeError("Capacity may not be less than 1");
        }
        this._c = capacity;
        this._q = [];
    }
    Object.defineProperty(DroppingBuffer.prototype, "empty", {
        get: function () {
            return this._q.length === 0;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(DroppingBuffer.prototype, "full", {
        get: function () {
            return false;
        },
        enumerable: false,
        configurable: true
    });
    DroppingBuffer.prototype.add = function (value) {
        if (this._q.length < this._c) {
            this._q.push(value);
        }
    };
    DroppingBuffer.prototype.remove = function () {
        if (this.empty) {
            throw new Error("Buffer empty");
        }
        return this._q.shift();
    };
    return DroppingBuffer;
}());
/** Makes sure promise-likes don’t cause unhandled rejections. */
function swallow(value) {
    if (value != null && typeof value.then === "function") {
        value.then(NOOP, NOOP);
    }
}
/*** REPEATER STATES ***/
/** The following is an enumeration of all possible repeater states. These states are ordered, and a repeater may only advance to higher states. */
/** The initial state of the repeater. */
var Initial = 0;
/** Repeaters advance to this state the first time the next method is called on the repeater. */
var Started = 1;
/** Repeaters advance to this state when the stop function is called. */
var Stopped = 2;
/** Repeaters advance to this state when there are no values left to be pulled from the repeater. */
var Done = 3;
/** Repeaters advance to this state if an error is thrown into the repeater. */
var Rejected = 4;
/** The maximum number of push or next operations which may exist on a single repeater. */
var MAX_QUEUE_LENGTH = 1024;
var NOOP = function () { };
/** A helper function used to mimic the behavior of async generators where the final iteration is consumed. */
function consumeExecution(r) {
    var err = r.err;
    var execution = Promise.resolve(r.execution).then(function (value) {
        if (err != null) {
            throw err;
        }
        return value;
    });
    r.err = undefined;
    r.execution = execution.then(function () { return undefined; }, function () { return undefined; });
    return r.pending === undefined ? execution : r.pending.then(function () { return execution; });
}
/** A helper function for building iterations from values. Promises are unwrapped, so that iterations never have their value property set to a promise. */
function createIteration(r, value) {
    var done = r.state >= Done;
    return Promise.resolve(value).then(function (value) {
        if (!done && r.state >= Rejected) {
            return consumeExecution(r).then(function (value) { return ({
                value: value,
                done: true,
            }); });
        }
        return { value: value, done: done };
    });
}
/**
 * This function is bound and passed to the executor as the stop argument.
 *
 * Advances state to Stopped.
 */
function stop(r, err) {
    var e_1, _a;
    if (r.state >= Stopped) {
        return;
    }
    r.state = Stopped;
    r.onnext();
    r.onstop();
    if (r.err == null) {
        r.err = err;
    }
    if (r.pushes.length === 0 &&
        (typeof r.buffer === "undefined" || r.buffer.empty)) {
        finish(r);
    }
    else {
        try {
            for (var _b = __values(r.pushes), _d = _b.next(); !_d.done; _d = _b.next()) {
                var push_1 = _d.value;
                push_1.resolve();
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
    }
}
/**
 * The difference between stopping a repeater vs finishing a repeater is that stopping a repeater allows next to continue to drain values from the push queue and buffer, while finishing a repeater will clear all pending values and end iteration immediately. Once, a repeater is finished, all iterations will have the done property set to true.
 *
 * Advances state to Done.
 */
function finish(r) {
    var e_2, _a;
    if (r.state >= Done) {
        return;
    }
    if (r.state < Stopped) {
        stop(r);
    }
    r.state = Done;
    r.buffer = undefined;
    try {
        for (var _b = __values(r.nexts), _d = _b.next(); !_d.done; _d = _b.next()) {
            var next = _d.value;
            var execution = r.pending === undefined
                ? consumeExecution(r)
                : r.pending.then(function () { return consumeExecution(r); });
            next.resolve(createIteration(r, execution));
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (_d && !_d.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_2) throw e_2.error; }
    }
    r.pushes = [];
    r.nexts = [];
}
/**
 * Called when a promise passed to push rejects, or when a push call is unhandled.
 *
 * Advances state to Rejected.
 */
function reject(r) {
    if (r.state >= Rejected) {
        return;
    }
    if (r.state < Done) {
        finish(r);
    }
    r.state = Rejected;
}
/** This function is bound and passed to the executor as the push argument. */
function push(r, value) {
    swallow(value);
    if (r.pushes.length >= MAX_QUEUE_LENGTH) {
        throw new RepeaterOverflowError("No more than " + MAX_QUEUE_LENGTH + " pending calls to push are allowed on a single repeater.");
    }
    else if (r.state >= Stopped) {
        return Promise.resolve(undefined);
    }
    var valueP = r.pending === undefined
        ? Promise.resolve(value)
        : r.pending.then(function () { return value; });
    valueP = valueP.catch(function (err) {
        if (r.state < Stopped) {
            r.err = err;
        }
        reject(r);
        return undefined; // void :(
    });
    var nextP;
    if (r.nexts.length) {
        var next_1 = r.nexts.shift();
        next_1.resolve(createIteration(r, valueP));
        if (r.nexts.length) {
            nextP = Promise.resolve(r.nexts[0].value);
        }
        else {
            nextP = new Promise(function (resolve) { return (r.onnext = resolve); });
        }
    }
    else if (typeof r.buffer !== "undefined" && !r.buffer.full) {
        r.buffer.add(valueP);
        nextP = Promise.resolve(undefined);
    }
    else {
        nextP = new Promise(function (resolve) { return r.pushes.push({ resolve: resolve, value: valueP }); });
    }
    // If an error is thrown into the repeater via the next or throw methods, we give the repeater a chance to handle this by rejecting the promise returned from push. If the push call is not immediately handled we throw the next iteration of the repeater.
    // To check that the promise returned from push is floating, we modify the then and catch methods of the returned promise so that they flip the floating flag. The push function actually does not return a promise, because modern engines do not call the then and catch methods on native promises. By making next a plain old javascript object, we ensure that the then and catch methods will be called.
    var floating = true;
    var next = {};
    var unhandled = nextP.catch(function (err) {
        if (floating) {
            throw err;
        }
        return undefined; // void :(
    });
    next.then = function (onfulfilled, onrejected) {
        floating = false;
        return Promise.prototype.then.call(nextP, onfulfilled, onrejected);
    };
    next.catch = function (onrejected) {
        floating = false;
        return Promise.prototype.catch.call(nextP, onrejected);
    };
    next.finally = nextP.finally.bind(nextP);
    r.pending = valueP
        .then(function () { return unhandled; })
        .catch(function (err) {
        r.err = err;
        reject(r);
    });
    return next;
}
/**
 * Creates the stop callable promise which is passed to the executor
 */
function createStop(r) {
    var stop1 = stop.bind(null, r);
    var stopP = new Promise(function (resolve) { return (r.onstop = resolve); });
    stop1.then = stopP.then.bind(stopP);
    stop1.catch = stopP.catch.bind(stopP);
    stop1.finally = stopP.finally.bind(stopP);
    return stop1;
}
/**
 * Calls the executor passed into the constructor. This function is called the first time the next method is called on the repeater.
 *
 * Advances state to Started.
 */
function execute(r) {
    if (r.state >= Started) {
        return;
    }
    r.state = Started;
    var push1 = push.bind(null, r);
    var stop1 = createStop(r);
    r.execution = new Promise(function (resolve) { return resolve(r.executor(push1, stop1)); });
    // TODO: We should consider stopping all repeaters when the executor settles.
    r.execution.catch(function () { return stop(r); });
}
var records = new WeakMap();
// NOTE: While repeaters implement and are assignable to the AsyncGenerator interface, and you can use the types interchangeably, we don’t use typescript’s implements syntax here because this would make supporting earlier versions of typescript trickier. This is because TypeScript version 3.6 changed the iterator types by adding the TReturn and TNext type parameters.
var Repeater = /** @class */ (function () {
    function Repeater(executor, buffer) {
        records.set(this, {
            executor: executor,
            buffer: buffer,
            err: undefined,
            state: Initial,
            pushes: [],
            nexts: [],
            pending: undefined,
            execution: undefined,
            onnext: NOOP,
            onstop: NOOP,
        });
    }
    Repeater.prototype.next = function (value) {
        swallow(value);
        var r = records.get(this);
        if (r === undefined) {
            throw new Error("WeakMap error");
        }
        if (r.nexts.length >= MAX_QUEUE_LENGTH) {
            throw new RepeaterOverflowError("No more than " + MAX_QUEUE_LENGTH + " pending calls to next are allowed on a single repeater.");
        }
        if (r.state <= Initial) {
            execute(r);
        }
        r.onnext(value);
        if (typeof r.buffer !== "undefined" && !r.buffer.empty) {
            var result = createIteration(r, r.buffer.remove());
            if (r.pushes.length) {
                var push_2 = r.pushes.shift();
                r.buffer.add(push_2.value);
                r.onnext = push_2.resolve;
            }
            return result;
        }
        else if (r.pushes.length) {
            var push_3 = r.pushes.shift();
            r.onnext = push_3.resolve;
            return createIteration(r, push_3.value);
        }
        else if (r.state >= Stopped) {
            finish(r);
            return createIteration(r, consumeExecution(r));
        }
        return new Promise(function (resolve) { return r.nexts.push({ resolve: resolve, value: value }); });
    };
    Repeater.prototype.return = function (value) {
        swallow(value);
        var r = records.get(this);
        if (r === undefined) {
            throw new Error("WeakMap error");
        }
        finish(r);
        // We override the execution because return should always return the value passed in.
        r.execution = Promise.resolve(r.execution).then(function () { return value; });
        return createIteration(r, consumeExecution(r));
    };
    Repeater.prototype.throw = function (err) {
        var r = records.get(this);
        if (r === undefined) {
            throw new Error("WeakMap error");
        }
        if (r.state <= Initial ||
            r.state >= Stopped ||
            (typeof r.buffer !== "undefined" && !r.buffer.empty)) {
            finish(r);
            // If r.err is already set, that mean the repeater has already produced an error, so we throw that error rather than the error passed in, because doing so might be more informative for the caller.
            if (r.err == null) {
                r.err = err;
            }
            return createIteration(r, consumeExecution(r));
        }
        return this.next(Promise.reject(err));
    };
    Repeater.prototype[Symbol.asyncIterator] = function () {
        return this;
    };
    // TODO: Remove these static methods from the class.
    Repeater.race = race;
    Repeater.merge = merge;
    Repeater.zip = zip;
    Repeater.latest = latest;
    return Repeater;
}());
/*** COMBINATOR FUNCTIONS ***/
// TODO: move these combinators to their own file.
function getIterators(values, options) {
    var e_3, _a;
    var iters = [];
    var _loop_1 = function (value) {
        if (value != null && typeof value[Symbol.asyncIterator] === "function") {
            iters.push(value[Symbol.asyncIterator]());
        }
        else if (value != null && typeof value[Symbol.iterator] === "function") {
            iters.push(value[Symbol.iterator]());
        }
        else {
            iters.push((function valueToAsyncIterator() {
                return __asyncGenerator(this, arguments, function valueToAsyncIterator_1() {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                if (!options.yieldValues) return [3 /*break*/, 3];
                                return [4 /*yield*/, __await(value)];
                            case 1: return [4 /*yield*/, _a.sent()];
                            case 2:
                                _a.sent();
                                _a.label = 3;
                            case 3:
                                if (!options.returnValues) return [3 /*break*/, 5];
                                return [4 /*yield*/, __await(value)];
                            case 4: return [2 /*return*/, _a.sent()];
                            case 5: return [2 /*return*/];
                        }
                    });
                });
            })());
        }
    };
    try {
        for (var values_1 = __values(values), values_1_1 = values_1.next(); !values_1_1.done; values_1_1 = values_1.next()) {
            var value = values_1_1.value;
            _loop_1(value);
        }
    }
    catch (e_3_1) { e_3 = { error: e_3_1 }; }
    finally {
        try {
            if (values_1_1 && !values_1_1.done && (_a = values_1.return)) _a.call(values_1);
        }
        finally { if (e_3) throw e_3.error; }
    }
    return iters;
}
// NOTE: whenever you see any variables called `advance` or `advances`, know that it is a hack to get around the fact that `Promise.race` leaks memory. These variables are intended to be set to the resolve function of a promise which is constructed and awaited as an alternative to Promise.race. For more information, see this comment in the Node.js issue tracker: https://github.com/nodejs/node/issues/17469#issuecomment-685216777.
function race(contenders) {
    var _this = this;
    var iters = getIterators(contenders, { returnValues: true });
    return new Repeater(function (push, stop) { return __awaiter(_this, void 0, void 0, function () {
        var advance, stopped, finalIteration, iteration, i_1, _loop_2;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (!iters.length) {
                        stop();
                        return [2 /*return*/];
                    }
                    stopped = false;
                    stop.then(function () {
                        advance();
                        stopped = true;
                    });
                    _a.label = 1;
                case 1:
                    _a.trys.push([1, , 5, 7]);
                    iteration = void 0;
                    i_1 = 0;
                    _loop_2 = function () {
                        var j, iters_1, iters_1_1, iter;
                        var e_4, _a;
                        return __generator(this, function (_b) {
                            switch (_b.label) {
                                case 0:
                                    j = i_1;
                                    try {
                                        for (iters_1 = (e_4 = void 0, __values(iters)), iters_1_1 = iters_1.next(); !iters_1_1.done; iters_1_1 = iters_1.next()) {
                                            iter = iters_1_1.value;
                                            Promise.resolve(iter.next()).then(function (iteration) {
                                                if (iteration.done) {
                                                    stop();
                                                    if (finalIteration === undefined) {
                                                        finalIteration = iteration;
                                                    }
                                                }
                                                else if (i_1 === j) {
                                                    // This iterator has won, advance i and resolve the promise.
                                                    i_1++;
                                                    advance(iteration);
                                                }
                                            }, function (err) { return stop(err); });
                                        }
                                    }
                                    catch (e_4_1) { e_4 = { error: e_4_1 }; }
                                    finally {
                                        try {
                                            if (iters_1_1 && !iters_1_1.done && (_a = iters_1.return)) _a.call(iters_1);
                                        }
                                        finally { if (e_4) throw e_4.error; }
                                    }
                                    return [4 /*yield*/, new Promise(function (resolve) { return (advance = resolve); })];
                                case 1:
                                    iteration = _b.sent();
                                    if (!(iteration !== undefined)) return [3 /*break*/, 3];
                                    return [4 /*yield*/, push(iteration.value)];
                                case 2:
                                    _b.sent();
                                    _b.label = 3;
                                case 3: return [2 /*return*/];
                            }
                        });
                    };
                    _a.label = 2;
                case 2:
                    if (!!stopped) return [3 /*break*/, 4];
                    return [5 /*yield**/, _loop_2()];
                case 3:
                    _a.sent();
                    return [3 /*break*/, 2];
                case 4: return [2 /*return*/, finalIteration && finalIteration.value];
                case 5:
                    stop();
                    return [4 /*yield*/, Promise.race(iters.map(function (iter) { return iter.return && iter.return(); }))];
                case 6:
                    _a.sent();
                    return [7 /*endfinally*/];
                case 7: return [2 /*return*/];
            }
        });
    }); });
}
function merge(contenders) {
    var _this = this;
    var iters = getIterators(contenders, { yieldValues: true });
    return new Repeater(function (push, stop) { return __awaiter(_this, void 0, void 0, function () {
        var advances, stopped, finalIteration;
        var _this = this;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (!iters.length) {
                        stop();
                        return [2 /*return*/];
                    }
                    advances = [];
                    stopped = false;
                    stop.then(function () {
                        var e_5, _a;
                        stopped = true;
                        try {
                            for (var advances_1 = __values(advances), advances_1_1 = advances_1.next(); !advances_1_1.done; advances_1_1 = advances_1.next()) {
                                var advance = advances_1_1.value;
                                advance();
                            }
                        }
                        catch (e_5_1) { e_5 = { error: e_5_1 }; }
                        finally {
                            try {
                                if (advances_1_1 && !advances_1_1.done && (_a = advances_1.return)) _a.call(advances_1);
                            }
                            finally { if (e_5) throw e_5.error; }
                        }
                    });
                    _a.label = 1;
                case 1:
                    _a.trys.push([1, , 3, 4]);
                    return [4 /*yield*/, Promise.all(iters.map(function (iter, i) { return __awaiter(_this, void 0, void 0, function () {
                            var iteration, _a;
                            return __generator(this, function (_b) {
                                switch (_b.label) {
                                    case 0:
                                        _b.trys.push([0, , 6, 9]);
                                        _b.label = 1;
                                    case 1:
                                        if (!!stopped) return [3 /*break*/, 5];
                                        Promise.resolve(iter.next()).then(function (iteration) { return advances[i](iteration); }, function (err) { return stop(err); });
                                        return [4 /*yield*/, new Promise(function (resolve) {
                                                advances[i] = resolve;
                                            })];
                                    case 2:
                                        iteration = _b.sent();
                                        if (!(iteration !== undefined)) return [3 /*break*/, 4];
                                        if (iteration.done) {
                                            finalIteration = iteration;
                                            return [2 /*return*/];
                                        }
                                        return [4 /*yield*/, push(iteration.value)];
                                    case 3:
                                        _b.sent();
                                        _b.label = 4;
                                    case 4: return [3 /*break*/, 1];
                                    case 5: return [3 /*break*/, 9];
                                    case 6:
                                        _a = iter.return;
                                        if (!_a) return [3 /*break*/, 8];
                                        return [4 /*yield*/, iter.return()];
                                    case 7:
                                        _a = (_b.sent());
                                        _b.label = 8;
                                    case 8:
                                        return [7 /*endfinally*/];
                                    case 9: return [2 /*return*/];
                                }
                            });
                        }); }))];
                case 2:
                    _a.sent();
                    return [2 /*return*/, finalIteration && finalIteration.value];
                case 3:
                    stop();
                    return [7 /*endfinally*/];
                case 4: return [2 /*return*/];
            }
        });
    }); });
}
function zip(contenders) {
    var _this = this;
    var iters = getIterators(contenders, { returnValues: true });
    return new Repeater(function (push, stop) { return __awaiter(_this, void 0, void 0, function () {
        var advance, stopped, iterations, values;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (!iters.length) {
                        stop();
                        return [2 /*return*/, []];
                    }
                    stopped = false;
                    stop.then(function () {
                        advance();
                        stopped = true;
                    });
                    _a.label = 1;
                case 1:
                    _a.trys.push([1, , 6, 8]);
                    _a.label = 2;
                case 2:
                    if (!!stopped) return [3 /*break*/, 5];
                    Promise.all(iters.map(function (iter) { return iter.next(); })).then(function (iterations) { return advance(iterations); }, function (err) { return stop(err); });
                    return [4 /*yield*/, new Promise(function (resolve) { return (advance = resolve); })];
                case 3:
                    iterations = _a.sent();
                    if (iterations === undefined) {
                        return [2 /*return*/];
                    }
                    values = iterations.map(function (iteration) { return iteration.value; });
                    if (iterations.some(function (iteration) { return iteration.done; })) {
                        return [2 /*return*/, values];
                    }
                    return [4 /*yield*/, push(values)];
                case 4:
                    _a.sent();
                    return [3 /*break*/, 2];
                case 5: return [3 /*break*/, 8];
                case 6:
                    stop();
                    return [4 /*yield*/, Promise.all(iters.map(function (iter) { return iter.return && iter.return(); }))];
                case 7:
                    _a.sent();
                    return [7 /*endfinally*/];
                case 8: return [2 /*return*/];
            }
        });
    }); });
}
function latest(contenders) {
    var _this = this;
    var iters = getIterators(contenders, {
        yieldValues: true,
        returnValues: true,
    });
    return new Repeater(function (push, stop) { return __awaiter(_this, void 0, void 0, function () {
        var advance, advances, stopped, iterations_1, values_2;
        var _this = this;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (!iters.length) {
                        stop();
                        return [2 /*return*/, []];
                    }
                    advances = [];
                    stopped = false;
                    stop.then(function () {
                        var e_6, _a;
                        advance();
                        try {
                            for (var advances_2 = __values(advances), advances_2_1 = advances_2.next(); !advances_2_1.done; advances_2_1 = advances_2.next()) {
                                var advance1 = advances_2_1.value;
                                advance1();
                            }
                        }
                        catch (e_6_1) { e_6 = { error: e_6_1 }; }
                        finally {
                            try {
                                if (advances_2_1 && !advances_2_1.done && (_a = advances_2.return)) _a.call(advances_2);
                            }
                            finally { if (e_6) throw e_6.error; }
                        }
                        stopped = true;
                    });
                    _a.label = 1;
                case 1:
                    _a.trys.push([1, , 5, 7]);
                    Promise.all(iters.map(function (iter) { return iter.next(); })).then(function (iterations) { return advance(iterations); }, function (err) { return stop(err); });
                    return [4 /*yield*/, new Promise(function (resolve) { return (advance = resolve); })];
                case 2:
                    iterations_1 = _a.sent();
                    if (iterations_1 === undefined) {
                        return [2 /*return*/];
                    }
                    values_2 = iterations_1.map(function (iteration) { return iteration.value; });
                    if (iterations_1.every(function (iteration) { return iteration.done; })) {
                        return [2 /*return*/, values_2];
                    }
                    // We continuously yield and mutate the same values array so we shallow copy it each time it is pushed.
                    return [4 /*yield*/, push(values_2.slice())];
                case 3:
                    // We continuously yield and mutate the same values array so we shallow copy it each time it is pushed.
                    _a.sent();
                    return [4 /*yield*/, Promise.all(iters.map(function (iter, i) { return __awaiter(_this, void 0, void 0, function () {
                            var iteration;
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0:
                                        if (iterations_1[i].done) {
                                            return [2 /*return*/, iterations_1[i].value];
                                        }
                                        _a.label = 1;
                                    case 1:
                                        if (!!stopped) return [3 /*break*/, 4];
                                        Promise.resolve(iter.next()).then(function (iteration) { return advances[i](iteration); }, function (err) { return stop(err); });
                                        return [4 /*yield*/, new Promise(function (resolve) { return (advances[i] = resolve); })];
                                    case 2:
                                        iteration = _a.sent();
                                        if (iteration === undefined) {
                                            return [2 /*return*/, iterations_1[i].value];
                                        }
                                        else if (iteration.done) {
                                            return [2 /*return*/, iteration.value];
                                        }
                                        values_2[i] = iteration.value;
                                        return [4 /*yield*/, push(values_2.slice())];
                                    case 3:
                                        _a.sent();
                                        return [3 /*break*/, 1];
                                    case 4: return [2 /*return*/];
                                }
                            });
                        }); }))];
                case 4: return [2 /*return*/, _a.sent()];
                case 5:
                    stop();
                    return [4 /*yield*/, Promise.all(iters.map(function (iter) { return iter.return && iter.return(); }))];
                case 6:
                    _a.sent();
                    return [7 /*endfinally*/];
                case 7: return [2 /*return*/];
            }
        });
    }); });
}


//# sourceMappingURL=repeater.js.map

;// CONCATENATED MODULE: ./node_modules/flatgeobuf/lib/mjs/config.js
function config_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function config_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
function config_createClass(Constructor, protoProps, staticProps) { if (protoProps) config_defineProperties(Constructor.prototype, protoProps); if (staticProps) config_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
var config_Config = /*#__PURE__*/function () {
  function Config() {
    config_classCallCheck(this, Config);
    this._extraRequestThreshold = 256 * 1024;
  }
  config_createClass(Config, [{
    key: "extraRequestThreshold",
    value: function extraRequestThreshold() {
      return this._extraRequestThreshold;
    }
  }, {
    key: "setExtraRequestThreshold",
    value: function setExtraRequestThreshold(bytes) {
      if (bytes < 0) {
        throw new Error('extraRequestThreshold cannot be negative');
      }
      this._extraRequestThreshold = bytes;
    }
  }]);
  return Config;
}();

config_Config.global = new config_Config();
;// CONCATENATED MODULE: ./node_modules/flatgeobuf/lib/mjs/logger.js
function logger_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function logger_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
function logger_createClass(Constructor, protoProps, staticProps) { if (protoProps) logger_defineProperties(Constructor.prototype, protoProps); if (staticProps) logger_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
var LogLevel;
(function (LogLevel) {
  LogLevel[LogLevel["Debug"] = 0] = "Debug";
  LogLevel[LogLevel["Info"] = 1] = "Info";
  LogLevel[LogLevel["Warn"] = 2] = "Warn";
  LogLevel[LogLevel["Error"] = 3] = "Error";
})(LogLevel || (LogLevel = {}));
var Logger = /*#__PURE__*/function () {
  function Logger() {
    logger_classCallCheck(this, Logger);
  }
  logger_createClass(Logger, null, [{
    key: "debug",
    value: function debug() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      this.log.apply(this, [LogLevel.Debug].concat(args));
    }
  }, {
    key: "info",
    value: function info() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      this.log.apply(this, [LogLevel.Info].concat(args));
    }
  }, {
    key: "warn",
    value: function warn() {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }
      this.log.apply(this, [LogLevel.Warn].concat(args));
    }
  }, {
    key: "error",
    value: function error() {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }
      this.log.apply(this, [LogLevel.Error].concat(args));
    }
  }, {
    key: "log",
    value: function log(level) {
      if (this.logLevel > level) {
        return;
      }
      for (var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
        args[_key5 - 1] = arguments[_key5];
      }
      switch (level) {
        case LogLevel.Debug:
          {
            var _console;
            (_console = console).debug.apply(_console, args);
            break;
          }
        case LogLevel.Info:
          {
            var _console2;
            (_console2 = console).info.apply(_console2, args);
            break;
          }
        case LogLevel.Warn:
          {
            var _console3;
            (_console3 = console).warn.apply(_console3, args);
            break;
          }
        case LogLevel.Error:
          {
            var _console4;
            (_console4 = console).error.apply(_console4, args);
            break;
          }
      }
    }
  }]);
  return Logger;
}();

Logger.logLevel = LogLevel.Info;
;// CONCATENATED MODULE: ./node_modules/flatgeobuf/lib/mjs/packedrtree.js
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || packedrtree_unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function packedrtree_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return packedrtree_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return packedrtree_arrayLikeToArray(o, minLen); }
function packedrtree_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function packedrtree_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function packedrtree_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
function packedrtree_createClass(Constructor, protoProps, staticProps) { if (protoProps) packedrtree_defineProperties(Constructor.prototype, protoProps); if (staticProps) packedrtree_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _awaitAsyncGenerator(value) { return new _OverloadYield(value, 0); }
function _wrapAsyncGenerator(fn) { return function () { return new _AsyncGenerator(fn.apply(this, arguments)); }; }
function _AsyncGenerator(gen) { var front, back; function resume(key, arg) { try { var result = gen[key](arg), value = result.value, overloaded = value instanceof _OverloadYield; Promise.resolve(overloaded ? value.v : value).then(function (arg) { if (overloaded) { var nextKey = "return" === key ? "return" : "next"; if (!value.k || arg.done) return resume(nextKey, arg); arg = gen[nextKey](arg).value; } settle(result.done ? "return" : "normal", arg); }, function (err) { resume("throw", err); }); } catch (err) { settle("throw", err); } } function settle(type, value) { switch (type) { case "return": front.resolve({ value: value, done: !0 }); break; case "throw": front.reject(value); break; default: front.resolve({ value: value, done: !1 }); } (front = front.next) ? resume(front.key, front.arg) : back = null; } this._invoke = function (key, arg) { return new Promise(function (resolve, reject) { var request = { key: key, arg: arg, resolve: resolve, reject: reject, next: null }; back ? back = back.next = request : (front = back = request, resume(key, arg)); }); }, "function" != typeof gen["return"] && (this["return"] = void 0); }
_AsyncGenerator.prototype["function" == typeof Symbol && Symbol.asyncIterator || "@@asyncIterator"] = function () { return this; }, _AsyncGenerator.prototype.next = function (arg) { return this._invoke("next", arg); }, _AsyncGenerator.prototype["throw"] = function (arg) { return this._invoke("throw", arg); }, _AsyncGenerator.prototype["return"] = function (arg) { return this._invoke("return", arg); };
function _OverloadYield(value, kind) { this.v = value, this.k = kind; }


var NODE_ITEM_LEN = 8 * 4 + 8;
var DEFAULT_NODE_SIZE = 16;
function calcTreeSize(numItems, nodeSize) {
  nodeSize = Math.min(Math.max(+nodeSize, 2), 65535);
  var n = numItems;
  var numNodes = n;
  do {
    n = Math.ceil(n / nodeSize);
    numNodes += n;
  } while (n !== 1);
  return numNodes * NODE_ITEM_LEN;
}
function generateLevelBounds(numItems, nodeSize) {
  if (nodeSize < 2) throw new Error('Node size must be at least 2');
  if (numItems === 0) throw new Error('Number of items must be greater than 0');
  var n = numItems;
  var numNodes = n;
  var levelNumNodes = [n];
  do {
    n = Math.ceil(n / nodeSize);
    numNodes += n;
    levelNumNodes.push(n);
  } while (n !== 1);
  var levelOffsets = [];
  n = numNodes;
  for (var _i = 0, _levelNumNodes = levelNumNodes; _i < _levelNumNodes.length; _i++) {
    var size = _levelNumNodes[_i];
    levelOffsets.push(n - size);
    n -= size;
  }
  levelOffsets.reverse();
  levelNumNodes.reverse();
  var levelBounds = [];
  for (var i = 0; i < levelNumNodes.length; i++) levelBounds.push([levelOffsets[i], levelOffsets[i] + levelNumNodes[i]]);
  levelBounds.reverse();
  return levelBounds;
}
function streamSearch(_x, _x2, _x3, _x4) {
  return _streamSearch.apply(this, arguments);
}
function _streamSearch() {
  _streamSearch = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(numItems, nodeSize, rect, readNode) {
    var NodeRange, minX, minY, maxX, maxY, levelBounds, leafNodesOffset, rootNodeRange, queue, _loop;
    return _regeneratorRuntime().wrap(function _callee$(_context3) {
      while (1) switch (_context3.prev = _context3.next) {
        case 0:
          NodeRange = /*#__PURE__*/function () {
            function NodeRange(nodes, level) {
              packedrtree_classCallCheck(this, NodeRange);
              this._level = level;
              this.nodes = nodes;
            }
            packedrtree_createClass(NodeRange, [{
              key: "level",
              value: function level() {
                return this._level;
              }
            }, {
              key: "startNode",
              value: function startNode() {
                return this.nodes[0];
              }
            }, {
              key: "endNode",
              value: function endNode() {
                return this.nodes[1];
              }
            }, {
              key: "extendEndNodeToNewOffset",
              value: function extendEndNodeToNewOffset(newOffset) {
                console.assert(newOffset > this.nodes[1]);
                this.nodes[1] = newOffset;
              }
            }, {
              key: "toString",
              value: function toString() {
                return "[NodeRange level: ".concat(this._level, ", nodes: ").concat(this.nodes[0], "-").concat(this.nodes[1], "]");
              }
            }]);
            return NodeRange;
          }();
          minX = rect.minX, minY = rect.minY, maxX = rect.maxX, maxY = rect.maxY;
          Logger.info("tree items: ".concat(numItems, ", nodeSize: ").concat(nodeSize));
          levelBounds = generateLevelBounds(numItems, nodeSize);
          leafNodesOffset = levelBounds[0][0];
          rootNodeRange = function () {
            var range = [0, 1];
            var level = levelBounds.length - 1;
            return new NodeRange(range, level);
          }();
          queue = [rootNodeRange];
          Logger.debug("starting stream search with queue: ".concat(queue, ", numItems: ").concat(numItems, ", nodeSize: ").concat(nodeSize, ", levelBounds: ").concat(levelBounds));
          _loop = /*#__PURE__*/_regeneratorRuntime().mark(function _loop() {
            var nodeRange, nodeIndex, isLeafNode, _levelBounds$nodeRang, levelBound, end, length, buffer, float64Array, uint32Array, _loop2, _ret, pos;
            return _regeneratorRuntime().wrap(function _loop$(_context2) {
              while (1) switch (_context2.prev = _context2.next) {
                case 0:
                  nodeRange = queue.shift();
                  Logger.debug("popped node: ".concat(nodeRange, ", queueLength: ").concat(queue.length));
                  nodeIndex = nodeRange.startNode();
                  isLeafNode = nodeIndex >= leafNodesOffset;
                  _levelBounds$nodeRang = _slicedToArray(levelBounds[nodeRange.level()], 2), levelBound = _levelBounds$nodeRang[1];
                  end = Math.min(nodeRange.endNode() + nodeSize, levelBound);
                  length = end - nodeIndex;
                  _context2.next = 9;
                  return _awaitAsyncGenerator(readNode(nodeIndex * NODE_ITEM_LEN, length * NODE_ITEM_LEN));
                case 9:
                  buffer = _context2.sent;
                  float64Array = new Float64Array(buffer);
                  uint32Array = new Uint32Array(buffer);
                  _loop2 = /*#__PURE__*/_regeneratorRuntime().mark(function _loop2(pos) {
                    var nodePos, low32Offset, high32Offset, offset, featureLength, extraRequestThresholdNodes, nearestNodeRange, newNodeRange;
                    return _regeneratorRuntime().wrap(function _loop2$(_context) {
                      while (1) switch (_context.prev = _context.next) {
                        case 0:
                          nodePos = (pos - nodeIndex) * 5;
                          if (!(maxX < float64Array[nodePos + 0])) {
                            _context.next = 3;
                            break;
                          }
                          return _context.abrupt("return", 0);
                        case 3:
                          if (!(maxY < float64Array[nodePos + 1])) {
                            _context.next = 5;
                            break;
                          }
                          return _context.abrupt("return", 0);
                        case 5:
                          if (!(minX > float64Array[nodePos + 2])) {
                            _context.next = 7;
                            break;
                          }
                          return _context.abrupt("return", 0);
                        case 7:
                          if (!(minY > float64Array[nodePos + 3])) {
                            _context.next = 9;
                            break;
                          }
                          return _context.abrupt("return", 0);
                        case 9:
                          low32Offset = uint32Array[(nodePos << 1) + 8];
                          high32Offset = uint32Array[(nodePos << 1) + 9];
                          offset = readUint52(high32Offset, low32Offset);
                          if (!isLeafNode) {
                            _context.next = 17;
                            break;
                          }
                          featureLength = function () {
                            if (pos < numItems - 1) {
                              var nextPos = (pos - nodeIndex + 1) * 5;
                              var _low32Offset = uint32Array[(nextPos << 1) + 8];
                              var _high32Offset = uint32Array[(nextPos << 1) + 9];
                              var nextOffset = readUint52(_high32Offset, _low32Offset);
                              return nextOffset - offset;
                            } else {
                              return null;
                            }
                          }();
                          _context.next = 16;
                          return [offset, pos - leafNodesOffset, featureLength];
                        case 16:
                          return _context.abrupt("return", 0);
                        case 17:
                          extraRequestThresholdNodes = config_Config.global.extraRequestThreshold() / NODE_ITEM_LEN;
                          nearestNodeRange = queue[queue.length - 1];
                          if (!(nearestNodeRange !== undefined && nearestNodeRange.level() == nodeRange.level() - 1 && offset < nearestNodeRange.endNode() + extraRequestThresholdNodes)) {
                            _context.next = 23;
                            break;
                          }
                          Logger.debug("Merging \"nodeRange\" request into existing range: ".concat(nearestNodeRange, ", newOffset: ").concat(nearestNodeRange.endNode(), " -> ").concat(offset));
                          nearestNodeRange.extendEndNodeToNewOffset(offset);
                          return _context.abrupt("return", 0);
                        case 23:
                          newNodeRange = function () {
                            var level = nodeRange.level() - 1;
                            var range = [offset, offset + 1];
                            return new NodeRange(range, level);
                          }();
                          if (nearestNodeRange !== undefined && nearestNodeRange.level() == newNodeRange.level()) {
                            Logger.info("Same level, but too far away. Pushing new request at offset: ".concat(offset, " rather than merging with distant ").concat(nearestNodeRange));
                          } else {
                            Logger.info("Pushing new level for ".concat(newNodeRange, " onto queue with nearestNodeRange: ").concat(nearestNodeRange, " since there's not already a range for this level."));
                          }
                          queue.push(newNodeRange);
                        case 26:
                        case "end":
                          return _context.stop();
                      }
                    }, _loop2);
                  });
                  pos = nodeIndex;
                case 14:
                  if (!(pos < end)) {
                    _context2.next = 22;
                    break;
                  }
                  return _context2.delegateYield(_loop2(pos), "t0", 16);
                case 16:
                  _ret = _context2.t0;
                  if (!(_ret === 0)) {
                    _context2.next = 19;
                    break;
                  }
                  return _context2.abrupt("continue", 19);
                case 19:
                  pos++;
                  _context2.next = 14;
                  break;
                case 22:
                case "end":
                  return _context2.stop();
              }
            }, _loop);
          });
        case 9:
          if (!(queue.length != 0)) {
            _context3.next = 13;
            break;
          }
          return _context3.delegateYield(_loop(), "t0", 11);
        case 11:
          _context3.next = 9;
          break;
        case 13:
        case "end":
          return _context3.stop();
      }
    }, _callee);
  }));
  return _streamSearch.apply(this, arguments);
}
function readUint52(high32Bits, low32Bits) {
  if ((high32Bits & 0xfff00000) != 0) {
    throw Error('integer is too large to be safely represented');
  }
  var result = low32Bits + high32Bits * Math.pow(2, 32);
  return result;
}
;// CONCATENATED MODULE: ./node_modules/flatgeobuf/lib/mjs/constants.js
var constants_magicbytes = new Uint8Array([0x66, 0x67, 0x62, 0x03, 0x66, 0x67, 0x62, 0x00]);
var SIZE_PREFIX_LEN = 4;
;// CONCATENATED MODULE: ./node_modules/flatgeobuf/lib/mjs/http-reader.js
function http_reader_typeof(obj) { "@babel/helpers - typeof"; return http_reader_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, http_reader_typeof(obj); }
function http_reader_createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = http_reader_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function http_reader_slicedToArray(arr, i) { return http_reader_arrayWithHoles(arr) || http_reader_iterableToArrayLimit(arr, i) || http_reader_unsupportedIterableToArray(arr, i) || http_reader_nonIterableRest(); }
function http_reader_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function http_reader_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return http_reader_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return http_reader_arrayLikeToArray(o, minLen); }
function http_reader_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function http_reader_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }
function http_reader_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function http_reader_regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ http_reader_regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == http_reader_typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function http_reader_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function http_reader_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
function http_reader_createClass(Constructor, protoProps, staticProps) { if (protoProps) http_reader_defineProperties(Constructor.prototype, protoProps); if (staticProps) http_reader_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function http_reader_wrapAsyncGenerator(fn) { return function () { return new http_reader_AsyncGenerator(fn.apply(this, arguments)); }; }
function http_reader_AsyncGenerator(gen) { var front, back; function resume(key, arg) { try { var result = gen[key](arg), value = result.value, overloaded = value instanceof http_reader_OverloadYield; Promise.resolve(overloaded ? value.v : value).then(function (arg) { if (overloaded) { var nextKey = "return" === key ? "return" : "next"; if (!value.k || arg.done) return resume(nextKey, arg); arg = gen[nextKey](arg).value; } settle(result.done ? "return" : "normal", arg); }, function (err) { resume("throw", err); }); } catch (err) { settle("throw", err); } } function settle(type, value) { switch (type) { case "return": front.resolve({ value: value, done: !0 }); break; case "throw": front.reject(value); break; default: front.resolve({ value: value, done: !1 }); } (front = front.next) ? resume(front.key, front.arg) : back = null; } this._invoke = function (key, arg) { return new Promise(function (resolve, reject) { var request = { key: key, arg: arg, resolve: resolve, reject: reject, next: null }; back ? back = back.next = request : (front = back = request, resume(key, arg)); }); }, "function" != typeof gen["return"] && (this["return"] = void 0); }
http_reader_AsyncGenerator.prototype["function" == typeof Symbol && Symbol.asyncIterator || "@@asyncIterator"] = function () { return this; }, http_reader_AsyncGenerator.prototype.next = function (arg) { return this._invoke("next", arg); }, http_reader_AsyncGenerator.prototype["throw"] = function (arg) { return this._invoke("throw", arg); }, http_reader_AsyncGenerator.prototype["return"] = function (arg) { return this._invoke("return", arg); };
function http_reader_awaitAsyncGenerator(value) { return new http_reader_OverloadYield(value, 0); }
function _asyncGeneratorDelegate(inner) { var iter = {}, waiting = !1; function pump(key, value) { return waiting = !0, value = new Promise(function (resolve) { resolve(inner[key](value)); }), { done: !1, value: new http_reader_OverloadYield(value, 1) }; } return iter["undefined" != typeof Symbol && Symbol.iterator || "@@iterator"] = function () { return this; }, iter.next = function (value) { return waiting ? (waiting = !1, value) : pump("next", value); }, "function" == typeof inner["throw"] && (iter["throw"] = function (value) { if (waiting) throw waiting = !1, value; return pump("throw", value); }), "function" == typeof inner["return"] && (iter["return"] = function (value) { return waiting ? (waiting = !1, value) : pump("return", value); }), iter; }
function http_reader_OverloadYield(value, kind) { this.v = value, this.k = kind; }
function _asyncIterator(iterable) { var method, async, sync, retry = 2; for ("undefined" != typeof Symbol && (async = Symbol.asyncIterator, sync = Symbol.iterator); retry--;) { if (async && null != (method = iterable[async])) return method.call(iterable); if (sync && null != (method = iterable[sync])) return new AsyncFromSyncIterator(method.call(iterable)); async = "@@asyncIterator", sync = "@@iterator"; } throw new TypeError("Object is not async iterable"); }
function AsyncFromSyncIterator(s) { function AsyncFromSyncIteratorContinuation(r) { if (Object(r) !== r) return Promise.reject(new TypeError(r + " is not an object.")); var done = r.done; return Promise.resolve(r.value).then(function (value) { return { value: value, done: done }; }); } return AsyncFromSyncIterator = function AsyncFromSyncIterator(s) { this.s = s, this.n = s.next; }, AsyncFromSyncIterator.prototype = { s: null, n: null, next: function next() { return AsyncFromSyncIteratorContinuation(this.n.apply(this.s, arguments)); }, "return": function _return(value) { var ret = this.s["return"]; return void 0 === ret ? Promise.resolve({ value: value, done: !0 }) : AsyncFromSyncIteratorContinuation(ret.apply(this.s, arguments)); }, "throw": function _throw(value) { var thr = this.s["return"]; return void 0 === thr ? Promise.reject(value) : AsyncFromSyncIteratorContinuation(thr.apply(this.s, arguments)); } }, new AsyncFromSyncIterator(s); }








var HttpReader = /*#__PURE__*/function () {
  function HttpReader(headerClient, header, headerLength, indexLength) {
    http_reader_classCallCheck(this, HttpReader);
    this.headerClient = headerClient;
    this.header = header;
    this.headerLength = headerLength;
    this.indexLength = indexLength;
  }
  http_reader_createClass(HttpReader, [{
    key: "selectBbox",
    value: function selectBbox(rect) {
      var _this = this;
      return http_reader_wrapAsyncGenerator( /*#__PURE__*/http_reader_regeneratorRuntime().mark(function _callee2() {
        var lengthBeforeTree, bufferedClient, readNode, batches, currentBatch, _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step, searchResult, _searchResult2, featureOffset, _searchResult4, featureLength, guessLength, prevFeature, gap, promises;
        return http_reader_regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              lengthBeforeTree = _this.lengthBeforeTree();
              bufferedClient = _this.headerClient;
              readNode = /*#__PURE__*/function () {
                var _ref = _asyncToGenerator( /*#__PURE__*/http_reader_regeneratorRuntime().mark(function _callee(offsetIntoTree, size) {
                  var minReqLength;
                  return http_reader_regeneratorRuntime().wrap(function _callee$(_context) {
                    while (1) switch (_context.prev = _context.next) {
                      case 0:
                        minReqLength = 0;
                        return _context.abrupt("return", bufferedClient.getRange(lengthBeforeTree + offsetIntoTree, size, minReqLength, 'index'));
                      case 2:
                      case "end":
                        return _context.stop();
                    }
                  }, _callee);
                }));
                return function readNode(_x, _x2) {
                  return _ref.apply(this, arguments);
                };
              }();
              batches = [];
              currentBatch = [];
              _iteratorAbruptCompletion = false;
              _didIteratorError = false;
              _context2.prev = 7;
              _iterator = _asyncIterator(streamSearch(_this.header.featuresCount, _this.header.indexNodeSize, rect, readNode));
            case 9:
              _context2.next = 11;
              return http_reader_awaitAsyncGenerator(_iterator.next());
            case 11:
              if (!(_iteratorAbruptCompletion = !(_step = _context2.sent).done)) {
                _context2.next = 26;
                break;
              }
              searchResult = _step.value;
              _searchResult2 = http_reader_slicedToArray(searchResult, 2), featureOffset = _searchResult2[0];
              _searchResult4 = http_reader_slicedToArray(searchResult, 3), featureLength = _searchResult4[2];
              if (!featureLength) {
                Logger.info('final feature');
                guessLength = config_Config.global.extraRequestThreshold();
                featureLength = guessLength;
              }
              if (!(currentBatch.length == 0)) {
                _context2.next = 19;
                break;
              }
              currentBatch.push([featureOffset, featureLength]);
              return _context2.abrupt("continue", 23);
            case 19:
              prevFeature = currentBatch[currentBatch.length - 1];
              gap = featureOffset - (prevFeature[0] + prevFeature[1]);
              if (gap > config_Config.global.extraRequestThreshold()) {
                Logger.info("Pushing new feature batch, since gap ".concat(gap, " was too large"));
                batches.push(currentBatch);
                currentBatch = [];
              }
              currentBatch.push([featureOffset, featureLength]);
            case 23:
              _iteratorAbruptCompletion = false;
              _context2.next = 9;
              break;
            case 26:
              _context2.next = 32;
              break;
            case 28:
              _context2.prev = 28;
              _context2.t0 = _context2["catch"](7);
              _didIteratorError = true;
              _iteratorError = _context2.t0;
            case 32:
              _context2.prev = 32;
              _context2.prev = 33;
              if (!(_iteratorAbruptCompletion && _iterator["return"] != null)) {
                _context2.next = 37;
                break;
              }
              _context2.next = 37;
              return http_reader_awaitAsyncGenerator(_iterator["return"]());
            case 37:
              _context2.prev = 37;
              if (!_didIteratorError) {
                _context2.next = 40;
                break;
              }
              throw _iteratorError;
            case 40:
              return _context2.finish(37);
            case 41:
              return _context2.finish(32);
            case 42:
              _this.headerClient.logUsage('header+index');
              if (currentBatch.length > 0) {
                batches.push(currentBatch);
              }
              promises = batches.flatMap(function (batch) {
                return _this.readFeatureBatch(batch);
              });
              return _context2.delegateYield(_asyncGeneratorDelegate(_asyncIterator(Repeater.merge(promises)), http_reader_awaitAsyncGenerator), "t1", 46);
            case 46:
            case "end":
              return _context2.stop();
          }
        }, _callee2, null, [[7, 28, 32, 42], [33,, 37, 41]]);
      }))();
    }
  }, {
    key: "lengthBeforeTree",
    value: function lengthBeforeTree() {
      return constants_magicbytes.length + SIZE_PREFIX_LEN + this.headerLength;
    }
  }, {
    key: "lengthBeforeFeatures",
    value: function lengthBeforeFeatures() {
      return this.lengthBeforeTree() + this.indexLength;
    }
  }, {
    key: "buildFeatureClient",
    value: function buildFeatureClient() {
      return new BufferedHttpRangeClient(this.headerClient.httpClient);
    }
  }, {
    key: "readFeatureBatch",
    value: function readFeatureBatch(batch) {
      var _this2 = this;
      return http_reader_wrapAsyncGenerator( /*#__PURE__*/http_reader_regeneratorRuntime().mark(function _callee3() {
        var _batch$, firstFeatureOffset, _batch, lastFeatureOffset, lastFeatureLength, batchStart, batchEnd, batchSize, featureClient, _iterator2, _step2, _step2$value2, featureOffset;
        return http_reader_regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              _batch$ = http_reader_slicedToArray(batch[0], 1), firstFeatureOffset = _batch$[0];
              _batch = http_reader_slicedToArray(batch[batch.length - 1], 2), lastFeatureOffset = _batch[0], lastFeatureLength = _batch[1];
              batchStart = firstFeatureOffset;
              batchEnd = lastFeatureOffset + lastFeatureLength;
              batchSize = batchEnd - batchStart;
              featureClient = _this2.buildFeatureClient();
              _iterator2 = http_reader_createForOfIteratorHelper(batch);
              _context3.prev = 7;
              _iterator2.s();
            case 9:
              if ((_step2 = _iterator2.n()).done) {
                _context3.next = 17;
                break;
              }
              _step2$value2 = http_reader_slicedToArray(_step2.value, 1), featureOffset = _step2$value2[0];
              _context3.next = 13;
              return http_reader_awaitAsyncGenerator(_this2.readFeature(featureClient, featureOffset, batchSize));
            case 13:
              _context3.next = 15;
              return _context3.sent;
            case 15:
              _context3.next = 9;
              break;
            case 17:
              _context3.next = 22;
              break;
            case 19:
              _context3.prev = 19;
              _context3.t0 = _context3["catch"](7);
              _iterator2.e(_context3.t0);
            case 22:
              _context3.prev = 22;
              _iterator2.f();
              return _context3.finish(22);
            case 25:
              featureClient.logUsage('feature');
            case 26:
            case "end":
              return _context3.stop();
          }
        }, _callee3, null, [[7, 19, 22, 25]]);
      }))();
    }
  }, {
    key: "readFeature",
    value: function () {
      var _readFeature = _asyncToGenerator( /*#__PURE__*/http_reader_regeneratorRuntime().mark(function _callee4(featureClient, featureOffset, minFeatureReqLength) {
        var offset, featureLength, _bytes, byteBuffer, bytes, bytesAligned, bb;
        return http_reader_regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              offset = featureOffset + this.lengthBeforeFeatures();
              _context4.next = 3;
              return featureClient.getRange(offset, 4, minFeatureReqLength, 'feature length');
            case 3:
              _bytes = _context4.sent;
              featureLength = new DataView(_bytes).getUint32(0, true);
              _context4.next = 7;
              return featureClient.getRange(offset + 4, featureLength, minFeatureReqLength, 'feature data');
            case 7:
              byteBuffer = _context4.sent;
              bytes = new Uint8Array(byteBuffer);
              bytesAligned = new Uint8Array(featureLength + SIZE_PREFIX_LEN);
              bytesAligned.set(bytes, SIZE_PREFIX_LEN);
              bb = new byte_buffer_ByteBuffer(bytesAligned);
              bb.setPosition(SIZE_PREFIX_LEN);
              return _context4.abrupt("return", feature_Feature.getRootAsFeature(bb));
            case 14:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this);
      }));
      function readFeature(_x3, _x4, _x5) {
        return _readFeature.apply(this, arguments);
      }
      return readFeature;
    }()
  }], [{
    key: "open",
    value: function () {
      var _open = _asyncToGenerator( /*#__PURE__*/http_reader_regeneratorRuntime().mark(function _callee5(url) {
        var assumedHeaderLength, headerClient, assumedIndexLength, minReqLength, _bytes2, headerLength, _bytes3, HEADER_MAX_BUFFER_SIZE, bytes, bb, header, indexLength;
        return http_reader_regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              assumedHeaderLength = 2024;
              headerClient = new BufferedHttpRangeClient(url);
              assumedIndexLength = function () {
                var assumedBranchingFactor = DEFAULT_NODE_SIZE;
                var prefetchedLayers = 3;
                var result = 0;
                var i;
                for (i = 0; i < prefetchedLayers; i++) {
                  var layer_width = Math.pow(assumedBranchingFactor, i) * NODE_ITEM_LEN;
                  result += layer_width;
                }
                return result;
              }();
              minReqLength = assumedHeaderLength + assumedIndexLength;
              Logger.debug("fetching header. minReqLength: ".concat(minReqLength, " (assumedHeaderLength: ").concat(assumedHeaderLength, ", assumedIndexLength: ").concat(assumedIndexLength, ")"));
              _context5.t0 = Uint8Array;
              _context5.next = 8;
              return headerClient.getRange(0, 8, minReqLength, 'header');
            case 8:
              _context5.t1 = _context5.sent;
              _bytes2 = new _context5.t0(_context5.t1);
              if (_bytes2.subarray(0, 3).every(function (v, i) {
                return constants_magicbytes[i] === v;
              })) {
                _context5.next = 13;
                break;
              }
              Logger.error("bytes: ".concat(_bytes2, " != ").concat(constants_magicbytes));
              throw new Error('Not a FlatGeobuf file');
            case 13:
              Logger.debug('magic bytes look good');
              _context5.next = 16;
              return headerClient.getRange(8, 4, minReqLength, 'header');
            case 16:
              _bytes3 = _context5.sent;
              headerLength = new DataView(_bytes3).getUint32(0, true);
              HEADER_MAX_BUFFER_SIZE = 1048576 * 10;
              if (!(headerLength > HEADER_MAX_BUFFER_SIZE || headerLength < 8)) {
                _context5.next = 21;
                break;
              }
              throw new Error('Invalid header size');
            case 21:
              Logger.debug("headerLength: ".concat(headerLength));
              _context5.next = 24;
              return headerClient.getRange(12, headerLength, minReqLength, 'header');
            case 24:
              bytes = _context5.sent;
              bb = new byte_buffer_ByteBuffer(new Uint8Array(bytes));
              header = fromByteBuffer(bb);
              indexLength = calcTreeSize(header.featuresCount, header.indexNodeSize);
              Logger.debug('completed: opening http reader');
              return _context5.abrupt("return", new HttpReader(headerClient, header, headerLength, indexLength));
            case 30:
            case "end":
              return _context5.stop();
          }
        }, _callee5);
      }));
      function open(_x6) {
        return _open.apply(this, arguments);
      }
      return open;
    }()
  }]);
  return HttpReader;
}();
var BufferedHttpRangeClient = /*#__PURE__*/function () {
  function BufferedHttpRangeClient(source) {
    http_reader_classCallCheck(this, BufferedHttpRangeClient);
    this.bytesEverUsed = 0;
    this.bytesEverFetched = 0;
    this.buffer = new ArrayBuffer(0);
    this.head = 0;
    if (typeof source === 'string') {
      this.httpClient = new HttpRangeClient(source);
    } else {
      this.httpClient = source;
    }
  }
  http_reader_createClass(BufferedHttpRangeClient, [{
    key: "getRange",
    value: function () {
      var _getRange = _asyncToGenerator( /*#__PURE__*/http_reader_regeneratorRuntime().mark(function _callee6(start, length, minReqLength, purpose) {
        var start_i, end_i, lengthToFetch;
        return http_reader_regeneratorRuntime().wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              this.bytesEverUsed += length;
              start_i = start - this.head;
              end_i = start_i + length;
              if (!(start_i >= 0 && end_i <= this.buffer.byteLength)) {
                _context6.next = 5;
                break;
              }
              return _context6.abrupt("return", this.buffer.slice(start_i, end_i));
            case 5:
              lengthToFetch = Math.max(length, minReqLength);
              this.bytesEverFetched += lengthToFetch;
              Logger.debug("requesting for new Range: ".concat(start, "-").concat(start + length - 1));
              _context6.next = 10;
              return this.httpClient.getRange(start, lengthToFetch, purpose);
            case 10:
              this.buffer = _context6.sent;
              this.head = start;
              return _context6.abrupt("return", this.buffer.slice(0, length));
            case 13:
            case "end":
              return _context6.stop();
          }
        }, _callee6, this);
      }));
      function getRange(_x7, _x8, _x9, _x10) {
        return _getRange.apply(this, arguments);
      }
      return getRange;
    }()
  }, {
    key: "logUsage",
    value: function logUsage(purpose) {
      var category = purpose.split(' ')[0];
      var used = this.bytesEverUsed;
      var requested = this.bytesEverFetched;
      var efficiency = (100.0 * used / requested).toFixed(2);
      Logger.info("".concat(category, " bytes used/requested: ").concat(used, " / ").concat(requested, " = ").concat(efficiency, "%"));
    }
  }]);
  return BufferedHttpRangeClient;
}();
var HttpRangeClient = /*#__PURE__*/function () {
  function HttpRangeClient(url) {
    http_reader_classCallCheck(this, HttpRangeClient);
    this.requestsEverMade = 0;
    this.bytesEverRequested = 0;
    this.url = url;
  }
  http_reader_createClass(HttpRangeClient, [{
    key: "getRange",
    value: function () {
      var _getRange2 = _asyncToGenerator( /*#__PURE__*/http_reader_regeneratorRuntime().mark(function _callee7(begin, length, purpose) {
        var range, response;
        return http_reader_regeneratorRuntime().wrap(function _callee7$(_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              this.requestsEverMade += 1;
              this.bytesEverRequested += length;
              range = "bytes=".concat(begin, "-").concat(begin + length - 1);
              Logger.info("request: #".concat(this.requestsEverMade, ", purpose: ").concat(purpose, "), bytes: (this_request: ").concat(length, ", ever: ").concat(this.bytesEverRequested, "), Range: ").concat(range));
              _context7.next = 6;
              return fetch(this.url, {
                headers: {
                  Range: range
                }
              });
            case 6:
              response = _context7.sent;
              return _context7.abrupt("return", response.arrayBuffer());
            case 8:
            case "end":
              return _context7.stop();
          }
        }, _callee7, this);
      }));
      function getRange(_x11, _x12, _x13) {
        return _getRange2.apply(this, arguments);
      }
      return getRange;
    }()
  }]);
  return HttpRangeClient;
}();
;// CONCATENATED MODULE: ./node_modules/flatgeobuf/lib/mjs/generic/header.js
function header_createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = header_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function header_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return header_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return header_arrayLikeToArray(o, minLen); }
function header_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }


function featureGeomType(feature) {
  if (feature.getGeometry) {
    return toGeometryType(feature.getGeometry().getType());
  } else {
    return toGeometryType(feature.geometry.type);
  }
}
function header_inferGeometryType(features) {
  var geometryType = undefined;
  var _iterator = header_createForOfIteratorHelper(features),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var f = _step.value;
      if (geometryType === GeometryType.Unknown) {
        break;
      }
      var gtype = featureGeomType(f);
      if (geometryType === undefined) {
        geometryType = gtype;
      } else if (geometryType !== gtype) {
        geometryType = GeometryType.Unknown;
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  if (geometryType === undefined) {
    throw new Error('Could not infer geometry type for collection of features.');
  }
  return geometryType;
}
;// CONCATENATED MODULE: ./node_modules/flatgeobuf/lib/mjs/generic/featurecollection.js
function featurecollection_typeof(obj) { "@babel/helpers - typeof"; return featurecollection_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, featurecollection_typeof(obj); }
function featurecollection_regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ featurecollection_regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == featurecollection_typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function featurecollection_asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function featurecollection_asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { featurecollection_asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { featurecollection_asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function featurecollection_createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = featurecollection_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function featurecollection_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return featurecollection_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return featurecollection_arrayLikeToArray(o, minLen); }
function featurecollection_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function featurecollection_asyncIterator(iterable) { var method, async, sync, retry = 2; for ("undefined" != typeof Symbol && (async = Symbol.asyncIterator, sync = Symbol.iterator); retry--;) { if (async && null != (method = iterable[async])) return method.call(iterable); if (sync && null != (method = iterable[sync])) return new featurecollection_AsyncFromSyncIterator(method.call(iterable)); async = "@@asyncIterator", sync = "@@iterator"; } throw new TypeError("Object is not async iterable"); }
function featurecollection_AsyncFromSyncIterator(s) { function AsyncFromSyncIteratorContinuation(r) { if (Object(r) !== r) return Promise.reject(new TypeError(r + " is not an object.")); var done = r.done; return Promise.resolve(r.value).then(function (value) { return { value: value, done: done }; }); } return featurecollection_AsyncFromSyncIterator = function AsyncFromSyncIterator(s) { this.s = s, this.n = s.next; }, featurecollection_AsyncFromSyncIterator.prototype = { s: null, n: null, next: function next() { return AsyncFromSyncIteratorContinuation(this.n.apply(this.s, arguments)); }, "return": function _return(value) { var ret = this.s["return"]; return void 0 === ret ? Promise.resolve({ value: value, done: !0 }) : AsyncFromSyncIteratorContinuation(ret.apply(this.s, arguments)); }, "throw": function _throw(value) { var thr = this.s["return"]; return void 0 === thr ? Promise.reject(value) : AsyncFromSyncIteratorContinuation(thr.apply(this.s, arguments)); } }, new featurecollection_AsyncFromSyncIterator(s); }
function featurecollection_awaitAsyncGenerator(value) { return new featurecollection_OverloadYield(value, 0); }
function featurecollection_wrapAsyncGenerator(fn) { return function () { return new featurecollection_AsyncGenerator(fn.apply(this, arguments)); }; }
function featurecollection_AsyncGenerator(gen) { var front, back; function resume(key, arg) { try { var result = gen[key](arg), value = result.value, overloaded = value instanceof featurecollection_OverloadYield; Promise.resolve(overloaded ? value.v : value).then(function (arg) { if (overloaded) { var nextKey = "return" === key ? "return" : "next"; if (!value.k || arg.done) return resume(nextKey, arg); arg = gen[nextKey](arg).value; } settle(result.done ? "return" : "normal", arg); }, function (err) { resume("throw", err); }); } catch (err) { settle("throw", err); } } function settle(type, value) { switch (type) { case "return": front.resolve({ value: value, done: !0 }); break; case "throw": front.reject(value); break; default: front.resolve({ value: value, done: !1 }); } (front = front.next) ? resume(front.key, front.arg) : back = null; } this._invoke = function (key, arg) { return new Promise(function (resolve, reject) { var request = { key: key, arg: arg, resolve: resolve, reject: reject, next: null }; back ? back = back.next = request : (front = back = request, resume(key, arg)); }); }, "function" != typeof gen["return"] && (this["return"] = void 0); }
featurecollection_AsyncGenerator.prototype["function" == typeof Symbol && Symbol.asyncIterator || "@@asyncIterator"] = function () { return this; }, featurecollection_AsyncGenerator.prototype.next = function (arg) { return this._invoke("next", arg); }, featurecollection_AsyncGenerator.prototype["throw"] = function (arg) { return this._invoke("throw", arg); }, featurecollection_AsyncGenerator.prototype["return"] = function (arg) { return this._invoke("return", arg); };
function featurecollection_OverloadYield(value, kind) { this.v = value, this.k = kind; }














function serialize(features) {
  var headerMeta = introspectHeaderMeta(features);
  var header = featurecollection_buildHeader(headerMeta);
  var featureBuffers = features.map(function (f) {
    if (!f.getGeometry) throw new Error('Missing getGeometry implementation');
    if (!f.getProperties) throw new Error('Missing getProperties implementation');
    return buildFeature(parseGeometry(f.getGeometry(), headerMeta.geometryType), f.getProperties(), headerMeta);
  });
  var featuresLength = featureBuffers.map(function (f) {
    return f.length;
  }).reduce(function (a, b) {
    return a + b;
  });
  var uint8 = new Uint8Array(magicbytes.length + header.length + featuresLength);
  uint8.set(header, magicbytes.length);
  var offset = magicbytes.length + header.length;
  var _iterator2 = featurecollection_createForOfIteratorHelper(featureBuffers),
    _step2;
  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var feature = _step2.value;
      uint8.set(feature, offset);
      offset += feature.length;
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }
  uint8.set(magicbytes);
  return uint8;
}
function deserialize(bytes, fromFeature, headerMetaFn) {
  if (!bytes.subarray(0, 3).every(function (v, i) {
    return constants_magicbytes[i] === v;
  })) throw new Error('Not a FlatGeobuf file');
  var bb = new byte_buffer_ByteBuffer(bytes);
  var headerLength = bb.readUint32(constants_magicbytes.length);
  bb.setPosition(constants_magicbytes.length + SIZE_PREFIX_LEN);
  var headerMeta = fromByteBuffer(bb);
  if (headerMetaFn) headerMetaFn(headerMeta);
  var offset = constants_magicbytes.length + SIZE_PREFIX_LEN + headerLength;
  var indexNodeSize = headerMeta.indexNodeSize,
    featuresCount = headerMeta.featuresCount;
  if (indexNodeSize > 0) offset += calcTreeSize(featuresCount, indexNodeSize);
  var features = [];
  while (offset < bb.capacity()) {
    var featureLength = bb.readUint32(offset);
    bb.setPosition(offset + SIZE_PREFIX_LEN);
    var feature = feature_Feature.getRootAsFeature(bb);
    features.push(fromFeature(feature, headerMeta));
    offset += SIZE_PREFIX_LEN + featureLength;
  }
  return features;
}
function deserializeStream(_x, _x2, _x3) {
  return _deserializeStream.apply(this, arguments);
}
function _deserializeStream() {
  _deserializeStream = featurecollection_wrapAsyncGenerator( /*#__PURE__*/featurecollection_regeneratorRuntime().mark(function _callee2(stream, fromFeature, headerMetaFn) {
    var reader, read, bytes, bb, headerLength, headerMeta, indexNodeSize, featuresCount, treeSize, feature;
    return featurecollection_regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          reader = slice_source_slice(stream);
          read = /*#__PURE__*/function () {
            var _ref = featurecollection_asyncToGenerator( /*#__PURE__*/featurecollection_regeneratorRuntime().mark(function _callee(size) {
              return featurecollection_regeneratorRuntime().wrap(function _callee$(_context) {
                while (1) switch (_context.prev = _context.next) {
                  case 0:
                    _context.next = 2;
                    return reader.slice(size);
                  case 2:
                    return _context.abrupt("return", _context.sent);
                  case 3:
                  case "end":
                    return _context.stop();
                }
              }, _callee);
            }));
            return function read(_x8) {
              return _ref.apply(this, arguments);
            };
          }();
          _context2.t0 = Uint8Array;
          _context2.next = 5;
          return featurecollection_awaitAsyncGenerator(read(8, 'magic bytes'));
        case 5:
          _context2.t1 = _context2.sent;
          bytes = new _context2.t0(_context2.t1);
          if (bytes.subarray(0, 3).every(function (v, i) {
            return constants_magicbytes[i] === v;
          })) {
            _context2.next = 9;
            break;
          }
          throw new Error('Not a FlatGeobuf file');
        case 9:
          _context2.t2 = Uint8Array;
          _context2.next = 12;
          return featurecollection_awaitAsyncGenerator(read(4, 'header length'));
        case 12:
          _context2.t3 = _context2.sent;
          bytes = new _context2.t2(_context2.t3);
          bb = new byte_buffer_ByteBuffer(bytes);
          headerLength = bb.readUint32(0);
          _context2.t4 = Uint8Array;
          _context2.next = 19;
          return featurecollection_awaitAsyncGenerator(read(headerLength, 'header data'));
        case 19:
          _context2.t5 = _context2.sent;
          bytes = new _context2.t4(_context2.t5);
          bb = new byte_buffer_ByteBuffer(bytes);
          headerMeta = fromByteBuffer(bb);
          if (headerMetaFn) headerMetaFn(headerMeta);
          indexNodeSize = headerMeta.indexNodeSize, featuresCount = headerMeta.featuresCount;
          if (!(indexNodeSize > 0)) {
            _context2.next = 29;
            break;
          }
          treeSize = calcTreeSize(featuresCount, indexNodeSize);
          _context2.next = 29;
          return featurecollection_awaitAsyncGenerator(read(treeSize, 'entire index, w/o rect'));
        case 29:
          _context2.next = 31;
          return featurecollection_awaitAsyncGenerator(readFeature(read, headerMeta, fromFeature));
        case 31:
          if (!(feature = _context2.sent)) {
            _context2.next = 36;
            break;
          }
          _context2.next = 34;
          return feature;
        case 34:
          _context2.next = 29;
          break;
        case 36:
        case "end":
          return _context2.stop();
      }
    }, _callee2);
  }));
  return _deserializeStream.apply(this, arguments);
}
function deserializeFiltered(_x4, _x5, _x6, _x7) {
  return _deserializeFiltered.apply(this, arguments);
}
function _deserializeFiltered() {
  _deserializeFiltered = featurecollection_wrapAsyncGenerator( /*#__PURE__*/featurecollection_regeneratorRuntime().mark(function _callee3(url, rect, fromFeature, headerMetaFn) {
    var reader, _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step, feature;
    return featurecollection_regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) switch (_context3.prev = _context3.next) {
        case 0:
          _context3.next = 2;
          return featurecollection_awaitAsyncGenerator(HttpReader.open(url));
        case 2:
          reader = _context3.sent;
          Logger.debug('opened reader');
          if (headerMetaFn) headerMetaFn(reader.header);
          _iteratorAbruptCompletion = false;
          _didIteratorError = false;
          _context3.prev = 7;
          _iterator = featurecollection_asyncIterator(reader.selectBbox(rect));
        case 9:
          _context3.next = 11;
          return featurecollection_awaitAsyncGenerator(_iterator.next());
        case 11:
          if (!(_iteratorAbruptCompletion = !(_step = _context3.sent).done)) {
            _context3.next = 18;
            break;
          }
          feature = _step.value;
          _context3.next = 15;
          return fromFeature(feature, reader.header);
        case 15:
          _iteratorAbruptCompletion = false;
          _context3.next = 9;
          break;
        case 18:
          _context3.next = 24;
          break;
        case 20:
          _context3.prev = 20;
          _context3.t0 = _context3["catch"](7);
          _didIteratorError = true;
          _iteratorError = _context3.t0;
        case 24:
          _context3.prev = 24;
          _context3.prev = 25;
          if (!(_iteratorAbruptCompletion && _iterator["return"] != null)) {
            _context3.next = 29;
            break;
          }
          _context3.next = 29;
          return featurecollection_awaitAsyncGenerator(_iterator["return"]());
        case 29:
          _context3.prev = 29;
          if (!_didIteratorError) {
            _context3.next = 32;
            break;
          }
          throw _iteratorError;
        case 32:
          return _context3.finish(29);
        case 33:
          return _context3.finish(24);
        case 34:
        case "end":
          return _context3.stop();
      }
    }, _callee3, null, [[7, 20, 24, 34], [25,, 29, 33]]);
  }));
  return _deserializeFiltered.apply(this, arguments);
}
function readFeature(_x9, _x10, _x11) {
  return _readFeature.apply(this, arguments);
}
function _readFeature() {
  _readFeature = featurecollection_asyncToGenerator( /*#__PURE__*/featurecollection_regeneratorRuntime().mark(function _callee4(read, headerMeta, fromFeature) {
    var bytes, bb, featureLength, bytesAligned, feature;
    return featurecollection_regeneratorRuntime().wrap(function _callee4$(_context4) {
      while (1) switch (_context4.prev = _context4.next) {
        case 0:
          _context4.t0 = Uint8Array;
          _context4.next = 3;
          return read(4, 'feature length');
        case 3:
          _context4.t1 = _context4.sent;
          bytes = new _context4.t0(_context4.t1);
          if (!(bytes.byteLength === 0)) {
            _context4.next = 7;
            break;
          }
          return _context4.abrupt("return");
        case 7:
          bb = new byte_buffer_ByteBuffer(bytes);
          featureLength = bb.readUint32(0);
          _context4.t2 = Uint8Array;
          _context4.next = 12;
          return read(featureLength, 'feature data');
        case 12:
          _context4.t3 = _context4.sent;
          bytes = new _context4.t2(_context4.t3);
          bytesAligned = new Uint8Array(featureLength + 4);
          bytesAligned.set(bytes, 4);
          bb = new byte_buffer_ByteBuffer(bytesAligned);
          bb.setPosition(SIZE_PREFIX_LEN);
          feature = feature_Feature.getRootAsFeature(bb);
          return _context4.abrupt("return", fromFeature(feature, headerMeta));
        case 20:
        case "end":
          return _context4.stop();
      }
    }, _callee4);
  }));
  return _readFeature.apply(this, arguments);
}
function buildColumn(builder, column) {
  var nameOffset = builder.createString(column.name);
  Column.startColumn(builder);
  Column.addName(builder, nameOffset);
  Column.addType(builder, column.type);
  return Column.endColumn(builder);
}
function featurecollection_buildHeader(header) {
  var builder = new flatbuffers.Builder();
  var columnOffsets = null;
  if (header.columns) columnOffsets = Header.createColumnsVector(builder, header.columns.map(function (c) {
    return buildColumn(builder, c);
  }));
  var nameOffset = builder.createString('L1');
  Header.startHeader(builder);
  Header.addFeaturesCount(builder, BigInt(header.featuresCount));
  Header.addGeometryType(builder, header.geometryType);
  Header.addIndexNodeSize(builder, 0);
  if (columnOffsets) Header.addColumns(builder, columnOffsets);
  Header.addName(builder, nameOffset);
  var offset = Header.endHeader(builder);
  builder.finishSizePrefixed(offset);
  return builder.asUint8Array();
}
function valueToType(value) {
  if (typeof value === 'boolean') return ColumnType.Bool;else if (typeof value === 'number') {
    if (value % 1 === 0) return ColumnType.Int;else return ColumnType.Double;
  } else if (typeof value === 'string') return ColumnType.String;else if (value === null) return ColumnType.String;else if (featurecollection_typeof(value) === 'object') return ColumnType.Json;else throw new Error("Unknown type (value '".concat(value, "')"));
}
function featurecollection_mapColumn(properties, k) {
  return {
    name: k,
    type: valueToType(properties[k]),
    title: null,
    description: null,
    width: -1,
    precision: -1,
    scale: -1,
    nullable: true,
    unique: false,
    primary_key: false
  };
}
function introspectHeaderMeta(features) {
  var sampleFeature = features[0];
  var properties = sampleFeature.getProperties ? sampleFeature.getProperties() : {};
  var columns = null;
  if (properties) columns = Object.keys(properties).filter(function (key) {
    return key !== 'geometry';
  }).map(function (k) {
    return featurecollection_mapColumn(properties, k);
  });
  var geometryType = inferGeometryType(features);
  var headerMeta = {
    geometryType: geometryType,
    columns: columns,
    envelope: null,
    featuresCount: features.length,
    indexNodeSize: 0,
    crs: null,
    title: null,
    description: null,
    metadata: null
  };
  return headerMeta;
}
;// CONCATENATED MODULE: ./node_modules/flatgeobuf/lib/mjs/geojson/featurecollection.js
function geojson_featurecollection_createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = geojson_featurecollection_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function geojson_featurecollection_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return geojson_featurecollection_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return geojson_featurecollection_arrayLikeToArray(o, minLen); }
function geojson_featurecollection_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }






function featurecollection_serialize(featurecollection) {
  var headerMeta = featurecollection_introspectHeaderMeta(featurecollection);
  var header = buildHeader(headerMeta);
  var features = featurecollection.features.map(function (f) {
    return buildFeature(f.geometry.type === 'GeometryCollection' ? parseGC(f.geometry) : parseGeometry(f.geometry), f.properties, headerMeta);
  });
  var featuresLength = features.map(function (f) {
    return f.length;
  }).reduce(function (a, b) {
    return a + b;
  });
  var uint8 = new Uint8Array(magicbytes.length + header.length + featuresLength);
  uint8.set(header, magicbytes.length);
  var offset = magicbytes.length + header.length;
  var _iterator = geojson_featurecollection_createForOfIteratorHelper(features),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var feature = _step.value;
      uint8.set(feature, offset);
      offset += feature.length;
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  uint8.set(magicbytes);
  return uint8;
}
function featurecollection_deserialize(bytes, headerMetaFn) {
  var features = deserialize(bytes, feature_fromFeature, headerMetaFn);
  return {
    type: 'FeatureCollection',
    features: features
  };
}
function featurecollection_deserializeStream(stream, headerMetaFn) {
  return deserializeStream(stream, feature_fromFeature, headerMetaFn);
}
function featurecollection_deserializeFiltered(url, rect, headerMetaFn) {
  return deserializeFiltered(url, rect, feature_fromFeature, headerMetaFn);
}
function featurecollection_introspectHeaderMeta(featurecollection) {
  var feature = featurecollection.features[0];
  var properties = feature.properties;
  var columns = null;
  if (properties) columns = Object.keys(properties).map(function (k) {
    return mapColumn(properties, k);
  });
  var geometryType = inferGeometryType(featurecollection.features);
  var headerMeta = {
    geometryType: geometryType,
    columns: columns,
    envelope: null,
    featuresCount: featurecollection.features.length,
    indexNodeSize: 0,
    crs: null,
    title: null,
    description: null,
    metadata: null
  };
  return headerMeta;
}
;// CONCATENATED MODULE: ./node_modules/flatgeobuf/lib/mjs/geojson.js

function geojson_serialize(geojson) {
  var bytes = fcSerialize(geojson);
  return bytes;
}
function geojson_deserialize(input, rect, headerMetaFn) {
  if (input instanceof Uint8Array) return featurecollection_deserialize(input, headerMetaFn);else if (input instanceof ReadableStream) return featurecollection_deserializeStream(input, headerMetaFn);else return featurecollection_deserializeFiltered(input, rect, headerMetaFn);
}
// EXTERNAL MODULE: ./node_modules/rbush/index.js
var rbush = __webpack_require__(510);
var rbush_default = /*#__PURE__*/__webpack_require__.n(rbush);
;// CONCATENATED MODULE: ./src/common/overlay/fgb/FGBLayerRenderer.js
function FGBLayerRenderer_typeof(obj) { "@babel/helpers - typeof"; return FGBLayerRenderer_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, FGBLayerRenderer_typeof(obj); }
function FGBLayerRenderer_regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ FGBLayerRenderer_regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == FGBLayerRenderer_typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function FGBLayerRenderer_asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function FGBLayerRenderer_asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { FGBLayerRenderer_asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { FGBLayerRenderer_asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function FGBLayerRenderer_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function FGBLayerRenderer_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
function FGBLayerRenderer_createClass(Constructor, protoProps, staticProps) { if (protoProps) FGBLayerRenderer_defineProperties(Constructor.prototype, protoProps); if (staticProps) FGBLayerRenderer_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function FGBLayerRenderer_asyncIterator(iterable) { var method, async, sync, retry = 2; for ("undefined" != typeof Symbol && (async = Symbol.asyncIterator, sync = Symbol.iterator); retry--;) { if (async && null != (method = iterable[async])) return method.call(iterable); if (sync && null != (method = iterable[sync])) return new FGBLayerRenderer_AsyncFromSyncIterator(method.call(iterable)); async = "@@asyncIterator", sync = "@@iterator"; } throw new TypeError("Object is not async iterable"); }
function FGBLayerRenderer_AsyncFromSyncIterator(s) { function AsyncFromSyncIteratorContinuation(r) { if (Object(r) !== r) return Promise.reject(new TypeError(r + " is not an object.")); var done = r.done; return Promise.resolve(r.value).then(function (value) { return { value: value, done: done }; }); } return FGBLayerRenderer_AsyncFromSyncIterator = function AsyncFromSyncIterator(s) { this.s = s, this.n = s.next; }, FGBLayerRenderer_AsyncFromSyncIterator.prototype = { s: null, n: null, next: function next() { return AsyncFromSyncIteratorContinuation(this.n.apply(this.s, arguments)); }, "return": function _return(value) { var ret = this.s["return"]; return void 0 === ret ? Promise.resolve({ value: value, done: !0 }) : AsyncFromSyncIteratorContinuation(ret.apply(this.s, arguments)); }, "throw": function _throw(value) { var thr = this.s["return"]; return void 0 === thr ? Promise.reject(value) : AsyncFromSyncIteratorContinuation(thr.apply(this.s, arguments)); } }, new FGBLayerRenderer_AsyncFromSyncIterator(s); }
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/






/**
 * @private
 * @class FGBLayerRenderer
 * @classdesc FGB。
 * @version 11.1.0
 * @param {Object} options - 参数。
 * @param {string} [options.layerID] - 图层 ID。默认使用 CommonUtil.createUniqueID("FGBlayer_") 创建图层 ID。
 * @param {boolean} [options.strategy='bbox'] - 指定加载策略，可选值为 all，bbox。 all为全量加载， bbox为当前可见范围加载。
 * @param {Array} [options.extent] - 加载范围, 参数规范为: [minX, minY, maxX, maxY], 传递此参数后, 图层将使用局部加载。
 * @param {function} [options.featureLoader] - 要素自定义方法，接收要素作为参数，需返回要素。
 * @usage
 */

var GEOMETRY_TYPE_MAP = {
  1: 'circle',
  2: 'line',
  3: 'fill',
  5: 'line',
  4: 'circle',
  6: 'fill',
  'MultiPolygon': 'fill',
  'Point': 'circle',
  'MultiLineString': 'line',
  'MultiPoint': 'circle',
  'LineString': 'line',
  'Polygon': 'fill'
};
var FGBLayerRenderer = /*#__PURE__*/function () {
  function FGBLayerRenderer() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    FGBLayerRenderer_classCallCheck(this, FGBLayerRenderer);
    this.id = options.layerID ? options.layerID : Util_Util.createUniqueID('FGBLayer_');
    this.layerId = this.id + 'outer';
    this.sourceId = this.layerId;
    this.options = options;
    this.strategy = options.strategy || 'bbox';
    this.url = options.url;
    this.layerType = '';
    this.extent = options.extent;
    this.init();
  }
  FGBLayerRenderer_createClass(FGBLayerRenderer, [{
    key: "init",
    value: function init() {
      if (this.strategy === 'bbox') {
        this.loadedExtentsRtree_ = new (rbush_default())();
      }
    }
  }, {
    key: "iterateFeatures",
    value: function () {
      var _iterateFeatures = FGBLayerRenderer_asyncToGenerator( /*#__PURE__*/FGBLayerRenderer_regeneratorRuntime().mark(function _callee(iterator) {
        var features, _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step, feature;
        return FGBLayerRenderer_regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              features = {
                type: 'FeatureCollection',
                features: []
              };
              _iteratorAbruptCompletion = false;
              _didIteratorError = false;
              _context.prev = 3;
              _iterator = FGBLayerRenderer_asyncIterator(iterator);
            case 5:
              _context.next = 7;
              return _iterator.next();
            case 7:
              if (!(_iteratorAbruptCompletion = !(_step = _context.sent).done)) {
                _context.next = 15;
                break;
              }
              feature = _step.value;
              if (this.options.featureLoader && typeof this.options.featureLoader === 'function') {
                feature = this.options.featureLoader(feature);
              }
              if (!this.layerType) {
                this.layerType = GEOMETRY_TYPE_MAP[feature.geometry.type];
              }
              features.features.push(feature);
            case 12:
              _iteratorAbruptCompletion = false;
              _context.next = 5;
              break;
            case 15:
              _context.next = 21;
              break;
            case 17:
              _context.prev = 17;
              _context.t0 = _context["catch"](3);
              _didIteratorError = true;
              _iteratorError = _context.t0;
            case 21:
              _context.prev = 21;
              _context.prev = 22;
              if (!(_iteratorAbruptCompletion && _iterator["return"] != null)) {
                _context.next = 26;
                break;
              }
              _context.next = 26;
              return _iterator["return"]();
            case 26:
              _context.prev = 26;
              if (!_didIteratorError) {
                _context.next = 29;
                break;
              }
              throw _iteratorError;
            case 29:
              return _context.finish(26);
            case 30:
              return _context.finish(21);
            case 31:
              return _context.abrupt("return", features);
            case 32:
            case "end":
              return _context.stop();
          }
        }, _callee, this, [[3, 17, 21, 31], [22,, 26, 30]]);
      }));
      function iterateFeatures(_x) {
        return _iterateFeatures.apply(this, arguments);
      }
      return iterateFeatures;
    }()
  }, {
    key: "_loadData",
    value: function () {
      var _loadData2 = FGBLayerRenderer_asyncToGenerator( /*#__PURE__*/FGBLayerRenderer_regeneratorRuntime().mark(function _callee2(bounds) {
        var _this = this;
        var fgbStream, rect;
        return FGBLayerRenderer_regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              rect = {
                minX: bounds[0],
                minY: bounds[1],
                maxX: bounds[2],
                maxY: bounds[3]
              };
              if (bounds.length) {
                _context2.next = 7;
                break;
              }
              _context2.next = 4;
              return this._getStream(this.url);
            case 4:
              fgbStream = _context2.sent;
              _context2.next = 9;
              break;
            case 7:
              rect.value = {
                extent: bounds.slice()
              };
              this.loadedExtentsRtree_.insert(rect);
            case 9:
              _context2.next = 11;
              return geojson_deserialize(fgbStream && fgbStream.body || this.url, rect, function (headerMeta) {
                _this.layerType = GEOMETRY_TYPE_MAP[headerMeta.geometryType];
              });
            case 11:
              return _context2.abrupt("return", _context2.sent);
            case 12:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function _loadData(_x2) {
        return _loadData2.apply(this, arguments);
      }
      return _loadData;
    }()
  }, {
    key: "_getStream",
    value: function () {
      var _getStream2 = FGBLayerRenderer_asyncToGenerator( /*#__PURE__*/FGBLayerRenderer_regeneratorRuntime().mark(function _callee3(url) {
        return FGBLayerRenderer_regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              _context3.next = 2;
              return FetchRequest.get(url, {}, {
                withoutFormatSuffix: true
              }).then(function (response) {
                return response;
              });
            case 2:
              return _context3.abrupt("return", _context3.sent);
            case 3:
            case "end":
              return _context3.stop();
          }
        }, _callee3);
      }));
      function _getStream(_x3) {
        return _getStream2.apply(this, arguments);
      }
      return _getStream;
    }()
  }, {
    key: "_containsExtent",
    value: function _containsExtent(extent1, extent2) {
      return extent1[0] <= extent2[0] && extent2[2] <= extent1[2] && extent1[1] <= extent2[1] && extent2[3] <= extent1[3];
    }
  }, {
    key: "_getInExtent",
    value: function _getInExtent(extent) {
      var bbox = {
        minX: extent[0],
        minY: extent[1],
        maxX: extent[2],
        maxY: extent[3]
      };
      var items = this.loadedExtentsRtree_.search(bbox);
      return items.map(function (item) {
        return item.value;
      });
    }
  }, {
    key: "_forEachInExtent",
    value: function _forEachInExtent(extent, callback) {
      return this._forEach(this._getInExtent(extent), callback);
    }
  }, {
    key: "_forEach",
    value: function _forEach(values, callback) {
      var result;
      for (var i = 0, l = values.length; i < l; i++) {
        result = callback(values[i]);
        if (result) {
          return result;
        }
      }
      return result;
    }
  }]);
  return FGBLayerRenderer;
}();
;// CONCATENATED MODULE: ./src/mapboxgl/overlay/FGBLayer.js
function FGBLayer_typeof(obj) { "@babel/helpers - typeof"; return FGBLayer_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, FGBLayer_typeof(obj); }
function FGBLayer_regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ FGBLayer_regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == FGBLayer_typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }
function FGBLayer_asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function FGBLayer_asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { FGBLayer_asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { FGBLayer_asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function FGBLayer_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function FGBLayer_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
function FGBLayer_createClass(Constructor, protoProps, staticProps) { if (protoProps) FGBLayer_defineProperties(Constructor.prototype, protoProps); if (staticProps) FGBLayer_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/
/**
 * reference and modification
 * dereklieu/cool-grid, cloudybay/leaflet.latlng-graticule
 * (https://github.com/dereklieu/cool-grid, https://github.com/cloudybay/leaflet.latlng-graticule)
 * Apache Licene 2.0
 * thanks dereklieu, cloudybay
 */





/**
 * @class FGBLayer
 * @category Visualization FGB
 * @classdesc FGB 图层类。该图层把 {@link FlatGeobuf} 格式解析为点线面要素。
 * @modulecategory Overlay
 * @version 11.1.0
 * @param {Object} options - 参数。
 * @param {string} [options.layerID] - 图层 ID。默认使用 CommonUtil.createUniqueID("FGBlayer_") 创建图层 ID。
 * @param {string} [options.strategy='bbox'] - 指定加载策略，可选值为 all，bbox。 all为全量加载， bbox为当前可见范围加载。
 * @param {Array} [options.extent] - 加载范围, 参数规范为: [minX, minY, maxX, maxY], 传递此参数后, 图层将使用局部加载。
 * @param {function} [options.featureLoader] - 要素自定义方法，接收要素作为参数，需返回要素。
 * @param {Object} [options.paint] - 参数内容详见: {@link https://docs.mapbox.com/mapbox-gl-js/style-spec/layers/#paint-property}
 * @param {Object} [options.layout] - 参数内容详见: {@link https://docs.mapbox.com/mapbox-gl-js/style-spec/layers/#layout-property}
 * @param {Object} [options.sourceOptions] - 参数内容详见: {@link mapboxgl.source}
 * @usage
 */

var PAINT_MAP = {
  circle: {
    'circle-radius': 6,
    'circle-color': '#3fb1e3',
    'circle-opacity': 1,
    'circle-blur': 0,
    'circle-translate': [0, 0],
    'circle-stroke-width': 0,
    'circle-stroke-color': '#000',
    'circle-stroke-opacity': 1
  },
  line: {
    'line-opacity': 1,
    'line-color': '#3fb1e3',
    'line-width': 3,
    'line-blur': 1
  },
  fill: {
    'fill-opacity': 0.8,
    'fill-color': '#3fb1e3',
    'fill-translate': [0, 0],
    'fill-antialias': true,
    'fill-outline-color': '#3fb1e3'
  }
};
var FGBLayer = /*#__PURE__*/function () {
  function FGBLayer() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    FGBLayer_classCallCheck(this, FGBLayer);
    this.id = options.layerID ? options.layerID : Util_Util.createUniqueID('FGBLayer_');
    this.layerId = this.id + 'outer';
    this.sourceId = this.layerId;
    this.options = options;
    this.strategy = options.strategy || 'bbox';
    this.url = options.url;
    this.layerType = '';
    this.extent = options.extent;
    this.overlay = true;
    this.type = 'custom';
    this.renderingMode = '3d';
    this._updateFeaturesFn = this._updateFeatures.bind(this);
  }

  /**
   * @function DeckglLayer.prototype.onAdd
   * @param {mapboxgl.Map} map - MapBoxGL Map 对象。
   */
  FGBLayer_createClass(FGBLayer, [{
    key: "onAdd",
    value: function onAdd(map) {
      this.map = map;
      var extent = [];
      if (this.strategy === 'bbox') {
        var bounds = this.map.getBounds().toArray();
        extent = [bounds[0][0], bounds[0][1], bounds[1][0], bounds[1][1]];
        this.map.on('moveend', this._updateFeaturesFn);
      }
      if (this.extent) {
        var intersectExtent = getIntersection(this.extent, extent);
        if (intersectExtent && intersectExtent.length) {
          extent = intersectExtent;
        } else {
          extent = this.extent;
        }
      }
      this.renderer = new FGBLayerRenderer(this.options);
      this._handleFeatures(extent);
    }
    /**
     * @function DeckglLayer.prototype.onRemove
     */
  }, {
    key: "onRemove",
    value: function onRemove() {
      this.map.off('moveend', this._updateFeaturesFn);
    }
    /**
       * @function DeckglLayer.prototype.moveLayer
       */
  }, {
    key: "moveLayer",
    value: function moveLayer(beforeId) {
      this.map.moveLayer(this.layerId, beforeId);
    }
    /**
      * @function FGBLayer.prototype.render
    */
  }, {
    key: "render",
    value: function render() {}
    /**
      * @function FGBLayer.prototype.setVisibility
      * @description 设置图层的显隐
    */
  }, {
    key: "setVisibility",
    value: function setVisibility(visibility) {
      var visible = visibility ? 'visible' : 'none';
      this.map.setLayoutProperty(this.layerId, 'visibility', visible);
    }
  }, {
    key: "_handleFeatures",
    value: function () {
      var _handleFeatures2 = FGBLayer_asyncToGenerator( /*#__PURE__*/FGBLayer_regeneratorRuntime().mark(function _callee(bounds) {
        var iter, features, layer;
        return FGBLayer_regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return this.renderer._loadData(bounds);
            case 2:
              iter = _context.sent;
              _context.next = 5;
              return this.renderer.iterateFeatures(iter);
            case 5:
              features = _context.sent;
              if (!this.map.getSource(this.sourceId)) {
                this.map.addSource(this.sourceId, {
                  type: 'geojson',
                  data: features
                });
              } else {
                this.map.getSource(this.sourceId).setData(features);
              }
              if (!this.map.getLayer(this.layerId)) {
                this.layerType = this.renderer.layerType;
                layer = Object.assign({
                  id: this.layerId,
                  type: this.layerType,
                  source: this.sourceId,
                  paint: Object.assign(PAINT_MAP[this.layerType], this.options.paint) || {},
                  layout: this.options.layout || {}
                });
                this.map.addLayer(layer);
              }
            case 8:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function _handleFeatures(_x) {
        return _handleFeatures2.apply(this, arguments);
      }
      return _handleFeatures;
    }()
  }, {
    key: "_updateFeatures",
    value: function () {
      var _updateFeatures2 = FGBLayer_asyncToGenerator( /*#__PURE__*/FGBLayer_regeneratorRuntime().mark(function _callee2() {
        var _this = this;
        var bounds, extentToLoad, alreadyLoaded, iter, features;
        return FGBLayer_regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              bounds = this.map.getBounds().toArray();
              extentToLoad = [bounds[0][0], bounds[0][1], bounds[1][0], bounds[1][1]];
              alreadyLoaded = this.renderer._forEachInExtent(extentToLoad, function (object) {
                return _this.renderer._containsExtent(object.extent, extentToLoad);
              });
              if (alreadyLoaded) {
                _context2.next = 11;
                break;
              }
              _context2.next = 6;
              return this.renderer._loadData(extentToLoad);
            case 6:
              iter = _context2.sent;
              _context2.next = 9;
              return this.renderer.iterateFeatures(iter);
            case 9:
              features = _context2.sent;
              this.map.getSource(this.sourceId).setData(features);
            case 11:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function _updateFeatures() {
        return _updateFeatures2.apply(this, arguments);
      }
      return _updateFeatures;
    }()
  }]);
  return FGBLayer;
}();
;// CONCATENATED MODULE: ./src/mapboxgl/services/ServiceBase.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/



/**
 * @class ServiceBase
 * @category  iServer Core
 * @classdesc mapboxgl.supermap 服务基类。
 * @param {string} url - 服务地址。 
 * @param {Object} options - 参数。
 * @param {string} [options.proxy] - 服务代理地址。
 * @param {boolean} [options.withCredentials=false] - 请求是否携带 cookie。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @fires ServiceBase#initialized
 * @usage
 */
class ServiceBase extends (external_mapboxgl_default()).Evented {

    constructor(url, options) {
        super();
        this.options = options || {};
        this.url = url;
        /**
         * @event ServiceBase#initialized
         * @description 构造函数构造成功之后触发。
         * @property {Object} this - this 对象。
         */
        this.fire('initialized', this);
    }
}

;// CONCATENATED MODULE: ./src/common/security/SecurityManager.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/




/**
 * @class SecurityManager
 * @deprecatedclass SuperMap.SecurityManager
 * @category Security
 * @classdesc 安全管理中心，提供 iServer,iPortal,Online 统一权限认证管理。
 *  > 使用说明：
 *  > 创建任何一个服务之前调用 {@link SecurityManager.registerToken}或
 *  > {@link SecurityManager.registerKey}注册凭据。
 *  > 发送请求时根据 URL 或者服务 ID 获取相应的 key 或者 token 并自动添加到服务地址中。
 * @usage
 */
class SecurityManager {
    /**
     * @description 从服务器获取一个token,在此之前要注册服务器信息。
     * @function SecurityManager.generateToken
     * @param {string} url - 服务器域名+端口，如：http://localhost:8092。
     * @param {TokenServiceParameter} tokenParam - token 申请参数。
     * @returns {Promise} 包含 token 信息的 Promise 对象。
     */

    static generateToken(url, tokenParam) {
        var serverInfo = this.servers[url];
        if (!serverInfo) {
            return;
        }
        return FetchRequest.post(serverInfo.tokenServiceUrl, JSON.stringify(tokenParam.toJSON())).then(function(
            response
        ) {
            return response.text();
        });
    }

    /**
     * @description 注册安全服务器相关信息。
     * @function SecurityManager.registerServers
     * @param {ServerInfo} serverInfos - 服务器信息。
     */
    static registerServers(serverInfos) {
        this.servers = this.servers || {};
        if (!Util_Util.isArray(serverInfos)) {
            serverInfos = [serverInfos];
        }
        for (var i = 0; i < serverInfos.length; i++) {
            var serverInfo = serverInfos[i];
            this.servers[serverInfo.server] = serverInfo;
        }
    }

    /**
     * @description 服务请求都会自动带上这个 token。
     * @function SecurityManager.registerToken
     * @param {string} url -服务器域名+端口：如http://localhost:8090。
     * @param {string} token - token。
     */
    static registerToken(url, token) {
        this.tokens = this.tokens || {};
        if (!url || !token) {
            return;
        }
        var domain = this._getTokenStorageKey(url);
        this.tokens[domain] = token;
    }

    /**
     * @description 注册 key,ids 为数组(存在一个 key 对应多个服务)。
     * @function SecurityManager.registerKey
     * @param {Array} ids - 可以是服务 ID 数组或者 URL 地址数组或者 webAPI 类型数组。
     * @param {string} key - key。
     */
    static registerKey(ids, key) {
        this.keys = this.keys || {};
        if (!ids || ids.length < 1 || !key) {
            return;
        }

        ids = Util_Util.isArray(ids) ? ids : [ids];
        for (var i = 0; i < ids.length; i++) {
            var id = this._getUrlRestString(ids[0]) || ids[0];
            this.keys[id] = key;
        }
    }

    /**
     * @description 获取服务器信息。
     * @function SecurityManager.getServerInfo
     * @param {string} url - 服务器域名+端口，如：http://localhost:8092。
     * @returns {ServerInfo} 服务器信息。
     */
    static getServerInfo(url) {
        this.servers = this.servers || {};
        return this.servers[url];
    }

    /**
     * @description 根据 URL 获取token。
     * @function SecurityManager.getToken
     * @param {string} url - 服务器域名+端口，如：http://localhost:8092。
     * @returns {string} token。
     */
    static getToken(url) {
        if (!url) {
            return;
        }
        this.tokens = this.tokens || {};
        var domain = this._getTokenStorageKey(url);
        return this.tokens[domain];
    }

    /**
     * @description 根据 URL 获取 key。
     * @function SecurityManager.getKey
     * @param {string} id - ID。
     * @returns {string} key。
     */
    static getKey(id) {
        this.keys = this.keys || {};
        var key = this._getUrlRestString(id) || id;
        return this.keys[key];
    }

    /**
     * @description iServer 登录验证。
     * @function SecurityManager.loginiServer
     * @param {string} url - iServer 首页地址，如：http://localhost:8090/iserver。
     * @param {string} username - 用户名。
     * @param {string} password - 密码。
     * @param {boolean} [rememberme=false] - 是否记住。
     * @returns {Promise} 包含 iServer 登录请求结果的 Promise 对象。
     */
    static loginiServer(url, username, password, rememberme) {
        url = Util_Util.urlPathAppend(url, 'services/security/login');
        var loginInfo = {
            username: username && username.toString(),
            password: password && password.toString(),
            rememberme: rememberme
        };
        loginInfo = JSON.stringify(loginInfo);
        var requestOptions = {
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8'
            }
        };
        return FetchRequest.post(url, loginInfo, requestOptions).then(function(response) {
            return response.json();
        });
    }

    /**
     * @description iServer登出。
     * @function SecurityManager.logoutiServer
     * @param {string} url - iServer 首页地址,如：http://localhost:8090/iserver。
     * @returns {Promise} 是否登出成功。
     */
    static logoutiServer(url) {
        url = Util_Util.urlPathAppend(url, 'services/security/logout');
        var requestOptions = {
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8'
            },
            withoutFormatSuffix: true
        };
        return FetchRequest.get(url, '', requestOptions)
            .then(function() {
                return true;
            })
            .catch(function() {
                return false;
            });
    }

    /**
     * @description Online 登录验证。
     * @function SecurityManager.loginOnline
     * @param {string} callbackLocation - 跳转位置。
     * @param {boolean} [newTab=true] - 是否新窗口打开。
     */
    static loginOnline(callbackLocation, newTab) {
        var loginUrl = SecurityManager.SSO + '/login?service=' + callbackLocation;
        this._open(loginUrl, newTab);
    }

    /**
     * @description iPortal登录验证。
     * @function SecurityManager.loginiPortal
     * @param {string} url - iportal 首页地址,如：http://localhost:8092/iportal。
     * @param {string} username - 用户名。
     * @param {string} password - 密码。
     * @returns {Promise} 包含 iPortal 登录请求结果的 Promise 对象。
     */
    static loginiPortal(url, username, password) {
        url = Util_Util.urlPathAppend(url, 'web/login');
        var loginInfo = {
            username: username && username.toString(),
            password: password && password.toString()
        };
        loginInfo = JSON.stringify(loginInfo);
        var requestOptions = {
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8'
            },
            withCredentials: false
        };
        return FetchRequest.post(url, loginInfo, requestOptions).then(function(response) {
            return response.json();
        });
    }

    /**
     * @description iPortal 登出。
     * @function SecurityManager.logoutiPortal
     * @param {string} url - iportal 首页地址，如：http://localhost:8092/iportal。
     * @returns {Promise} 如果登出成功，返回 true;否则返回 false。
     */
    static logoutiPortal(url) {
        url = Util_Util.urlPathAppend(url, 'services/security/logout');
        var requestOptions = {
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8'
            },
            withCredentials: true,
            withoutFormatSuffix: true
        };
        return FetchRequest.get(url, '', requestOptions)
            .then(function() {
                return true;
            })
            .catch(function() {
                return false;
            });
    }

    /**
     * @description iManager 登录验证。
     * @function SecurityManager.loginManager
     * @param {string} url - iManager 地址。地址参数为 iManager 首页地址，如： http://localhost:8390/imanager。
     * @param {Object} [loginInfoParams] - iManager 登录参数。
     * @param {string} loginInfoParams.userName - 用户名。
     * @param {string} loginInfoParams.password - 密码。
     * @param {Object} options
     * @param {boolean} [options.isNewTab=true] - 不同域时是否在新窗口打开登录页面。
     * @returns {Promise} 包含 iManager 登录请求结果的 Promise 对象。
     */
    static loginManager(url, loginInfoParams) {
        var requestUrl = Util_Util.urlPathAppend(url, '/security/tokens');
        var params = loginInfoParams || {};
        var loginInfo = {
            username: params.userName && params.userName.toString(),
            password: params.password && params.password.toString()
        };
        loginInfo = JSON.stringify(loginInfo);
        var requestOptions = {
            headers: {
                Accept: '*/*',
                'Content-Type': 'application/json; charset=UTF-8'
            }
        };
        var me = this;
        return FetchRequest.post(requestUrl, loginInfo, requestOptions).then(function(response) {
          return response.text();
        }).then(function(result) {
          me.imanagerToken = result;
          return result;
        });
    }

    /**
     * @description 清空全部验证信息。
     * @function SecurityManager.destroyAllCredentials
     */
    static destroyAllCredentials() {
        this.keys = null;
        this.tokens = null;
        this.servers = null;
    }

    /**
     * @description 清空令牌信息。
     * @function SecurityManager.destroyToken
     * @param {string} url - iportal 首页地址，如：http://localhost:8092/iportal。
     */
    static destroyToken(url) {
        if (!url) {
            return;
        }
        var domain = this._getTokenStorageKey(url);
        this.tokens = this.tokens || {};
        if (this.tokens[domain]) {
            delete this.tokens[domain];
        }
    }

    /**
     * @description 清空服务授权码。
     * @function SecurityManager.destroyKey
     * @param {string} url - iServer 首页地址,如：http://localhost:8090/iserver。
     */
    static destroyKey(url) {
        if (!url) {
            return;
        }
        this.keys = this.keys || {};
        var key = this._getUrlRestString(url) || url;
        if (this.keys[key]) {
            delete this.keys[key];
        }
    }

    /**
     * @description 服务URL追加授权信息，授权信息需先通过SecurityManager.registerKey或SecurityManager.registerToken注册。
     * @version 10.1.2
     * @function SecurityManager.appendCredential
     * @param {string} url - 服务URL。
     * @returns {string} 绑定了token或者key的服务URL。
     */
    static appendCredential(url) {
        var newUrl = url;
        var value = this.getToken(url);
        var credential = value ? new Credential(value, 'token') : null;
		if (!credential) {
            value = this.getKey(url);
            credential = value ? new Credential(value, 'key') : null;
          }
        if (credential) {
            newUrl = Util_Util.urlAppend(newUrl, credential.getUrlParameters());
        }
        return newUrl;
    }

    static _open(url, newTab) {
        newTab = newTab != null ? newTab : true;
        var offsetX = window.screen.availWidth / 2 - this.INNER_WINDOW_WIDTH / 2;
        var offsetY = window.screen.availHeight / 2 - this.INNER_WINDOW_HEIGHT / 2;
        var options =
            'height=' +
            this.INNER_WINDOW_HEIGHT +
            ', width=' +
            this.INNER_WINDOW_WIDTH +
            ',top=' +
            offsetY +
            ', left=' +
            offsetX +
            ',toolbar=no, menubar=no, scrollbars=no, resizable=no, location=no, status=no';
        if (newTab) {
            window.open(url, 'login');
        } else {
            window.open(url, 'login', options);
        }
    }

    static _getTokenStorageKey(url) {
        var patten = /(.*?):\/\/([^\/]+)/i;
        var result = url.match(patten);
        if (!result) {
            return url;
        }
        return result[0];
    }

    static _getUrlRestString(url) {
        if (!url) {
            return url;
        }
        // var patten = /http:\/\/(.*\/rest)/i;
        var patten = /(http|https):\/\/(.*\/rest)/i;
        var result = url.match(patten);
        if (!result) {
            return url;
        }
        return result[0];
    }
}
SecurityManager.INNER_WINDOW_WIDTH = 600;
SecurityManager.INNER_WINDOW_HEIGHT = 600;
SecurityManager.SSO = 'https://sso.supermap.com';
SecurityManager.ONLINE = 'https://www.supermapol.com';

;// CONCATENATED MODULE: ./src/common/iServer/CommonServiceBase.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/








/**
 * @class CommonServiceBase
 * @deprecatedclass SuperMap.CommonServiceBase
 * @category  iServer Core
 * @classdesc 对接 iServer 各种服务的 Service 的基类。
 * @param {string} url - 服务地址。
 * @param {Object} options - 参数。
 * @param {string} [options.proxy] - 服务代理地址。
 * @param {boolean} [options.withCredentials=false] - 请求是否携带 cookie。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @usage
 */
class CommonServiceBase {
    constructor(url, options) {
        let me = this;

        this.EVENT_TYPES = ['processCompleted', 'processFailed'];

        this.events = null;

        this.eventListeners = null;

        this.url = null;

        this.urls = null;

        this.proxy = null;

        this.index = null;

        this.length = null;

        this.totalTimes = null;

        this.POLLING_TIMES = 3;

        this.isInTheSameDomain = null;

        this.withCredentials = false;

        if (Util_Util.isArray(url)) {
            me.urls = url;
            me.length = url.length;
            me.totalTimes = me.length;
            if (me.length === 1) {
                me.url = url[0];
            } else {
                me.index = parseInt(Math.random() * me.length);
                me.url = url[me.index];
            }
        } else {
            me.totalTimes = 1;
            me.url = url;
        }

        if (Util_Util.isArray(url) && !me.isServiceSupportPolling()) {
            me.url = url[0];
            me.totalTimes = 1;
        }

        options = options || {};
        this.crossOrigin = options.crossOrigin;
        this.headers = options.headers;
        Util_Util.extend(this, options);

        me.isInTheSameDomain = Util_Util.isInTheSameDomain(me.url);

        me.events = new Events(me, null, me.EVENT_TYPES, true);
        if (me.eventListeners instanceof Object) {
            me.events.on(me.eventListeners);
        }

        this.CLASS_NAME = 'SuperMap.CommonServiceBase';
    }

    /**
     * @function CommonServiceBase.prototype.destroy
     * @description 释放资源，将引用的资源属性置空。
     */
    destroy() {
        let me = this;
        if (Util_Util.isArray(me.urls)) {
            me.urls = null;
            me.index = null;
            me.length = null;
            me.totalTimes = null;
        }
        me.url = null;
        me.isInTheSameDomain = null;
        me.EVENT_TYPES = null;
        if (me.events) {
            me.events.destroy();
            me.events = null;
        }
        if (me.eventListeners) {
            me.eventListeners = null;
        }
    }

    /**
     * @function CommonServiceBase.prototype.request
     * @description: 该方法用于向服务发送请求。
     * @param {Object} options - 参数。
     * @param {string} [options.method='GET'] - 请求方式，包括 "GET"，"POST"，"PUT"，"DELETE"。
     * @param {string} [options.url] - 发送请求的地址。
     * @param {Object} [options.params] - 作为查询字符串添加到 URL 中的一组键值对，此参数只适用于 GET 方式发送的请求。
     * @param {string} [options.data] - 发送到服务器的数据。
     * @param {function} options.success - 请求成功后的回调函数。
     * @param {function} options.failure - 请求失败后的回调函数。
     * @param {Object} [options.scope] - 如果回调函数是对象的一个公共方法，设定该对象的范围。
     * @param {boolean} [options.isInTheSameDomain] - 请求是否在当前域中。
     * @param {boolean} [options.withCredentials=false] - 请求是否携带 cookie。
     * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
     * @param {Object} [options.headers] - 请求头。
     */
    request(options) {
        let format = options.scope.format;
        // 兼容 callback 未传，dataFormat 传入的情况
        if (typeof options.success === 'string') {
          options.scope.format = options.success;
          format = options.success;
          options.success = null;
          options.failure = null;
        }
       
        if (format && !this.supportDataFormat(format)) {
          throw new Error(`${this.CLASS_NAME} is not surport ${format} format!`);
        }
       
        let me = this;
        options.url = options.url || me.url;
        if (this._returnContent(options) && !options.url.includes('returnContent=true')) {
          options.url = Util_Util.urlAppend(options.url, 'returnContent=true');
        }
        options.proxy = options.proxy || me.proxy;
        options.withCredentials = options.withCredentials != undefined ? options.withCredentials : me.withCredentials;
        options.crossOrigin = options.crossOrigin != undefined ? options.crossOrigin : me.crossOrigin;
        options.headers = options.headers || me.headers;
        options.isInTheSameDomain = me.isInTheSameDomain;
        options.withoutFormatSuffix = options.scope.withoutFormatSuffix || false;
        //为url添加安全认证信息片段
        options.url = SecurityManager.appendCredential(options.url);

        me.calculatePollingTimes();
        options.scope = me;
        if (me.totalTimes > 0) {
          me.totalTimes--;
          return me.ajaxPolling(options);
        }
        return me._commit(options);
    }


    /**
     *
     * @function CommonServiceBase.prototype.ajaxPolling
     * @description 请求失败后，如果剩余请求失败次数不为 0，重新获取 URL 发送请求。
     * @param {Object} options - 请求参数对象。
     * @private
     */
    ajaxPolling(options) {
        let me = this,
            url = options.url,
            re = /^http:\/\/([a-z]{9}|(\d+\.){3}\d+):\d{0,4}/;
        me.index = parseInt(Math.random() * me.length);
        me.url = me.urls[me.index];
        url = url.replace(re, re.exec(me.url)[0]);
        options.url = url;
        options.isInTheSameDomain = Util_Util.isInTheSameDomain(url);
        return me._commit(options);
    }

    /**
     * @function CommonServiceBase.prototype.calculatePollingTimes
     * @description 计算剩余请求失败执行次数。
     */
    calculatePollingTimes() {
        let me = this;
        if (me.times) {
            if (me.totalTimes > me.POLLING_TIMES) {
                if (me.times > me.POLLING_TIMES) {
                    me.totalTimes = me.POLLING_TIMES;
                } else {
                    me.totalTimes = me.times;
                }
            } else {
                if (me.times < me.totalTimes) {
                    me.totalTimes = me.times;
                }
            }
        } else {
            if (me.totalTimes > me.POLLING_TIMES) {
                me.totalTimes = me.POLLING_TIMES;
            }
        }
        me.totalTimes--;
    }

    /**
     * @function CommonServiceBase.prototype.isServiceSupportPolling
     * @description 判断服务是否支持轮询。
     */
    isServiceSupportPolling() {
        let me = this;
        return !(
            me.CLASS_NAME === 'SuperMap.REST.ThemeService' || me.CLASS_NAME === 'SuperMap.REST.EditFeaturesService'
        );
    }

    /**
     * @function CommonServiceBase.prototype.transformResult
     * @description 状态完成时转换结果。
     * @param {Object} result - 服务器返回的结果对象。
     * @param {Object} options - 请求参数。
     * @return {Object} 转换结果。
     * @private
     */
    transformResult(result, options) {
        result = Util_Util.transformResult(result);
        return { result, options };
    }

    /**
     * @function CommonServiceBase.prototype.transformErrorResult
     * @description 状态失败时转换结果。
     * @param {Object} result - 服务器返回的结果对象。
     * @param {Object} options - 请求参数。
     * @return {Object} 转换结果。
     * @private
     */
    transformErrorResult(result, options) {
        result = Util_Util.transformResult(result);
        let error = result.error || result;
        return { error, options };
    }

    /**
    * @function CommonServiceBase.prototype.serviceProcessCompleted
    * @description 状态完成，执行此方法。
    * @param {Object} result - 服务器返回的结果对象。
    * @param {Object} options - 请求参数对象。
    * @private
    */
    serviceProcessCompleted(result, options) {
        result = this.transformResult(result).result;
        this.events.triggerEvent('processCompleted', {
            result: result,
            options: options
        });
    }

    /**
     * @function CommonServiceBase.prototype.serviceProcessFailed
     * @description 状态失败，执行此方法。
     * @param {Object} result - 服务器返回的结果对象。
     * @param {Object} options - 请求参数对象。对象
     * @private
     */
    serviceProcessFailed(result, options) {
      result = this.transformErrorResult(result).error;
      let error = result.error || result;
      this.events.triggerEvent('processFailed', {
          error: error,
          options: options
      });
    }

    _returnContent(options) {
      if (options.scope.format === DataFormat.FGB) {
        return false;
      }
      if (options.scope.returnContent) {
        return true;
      }
      return false;
    }

    supportDataFormat(foramt) {
      return this.dataFormat().includes(foramt);
    }

    dataFormat() {
      return [DataFormat.GEOJSON, DataFormat.ISERVER];
    }

    _commit(options) {
        if (options.method === 'POST' || options.method === 'PUT' || options.method === 'PATCH') {
            if (options.params) {
                options.url = Util_Util.urlAppend(options.url, Util_Util.getParameterString(options.params || {}));
            }
            if (typeof options.data === 'object') {
                try {
                    options.params = Util_Util.toJSON(options.data);
                } catch (e) {
                    console.log('不是json对象');
                }
            } else {
                options.params = options.data;
            }
        }
        return FetchRequest.commit(options.method, options.url, options.params, {
            headers: options.headers,
            withoutFormatSuffix: options.withoutFormatSuffix,
            withCredentials: options.withCredentials,
            crossOrigin: options.crossOrigin,
            timeout: options.async ? 0 : null,
            proxy: options.proxy
        })
            .then(function (response) {
                if (response.text) {
                    return response.text();
                }
                if (response.json) {
                    return response.json();
                }
                return response;
            })
            .then(function (text) {
                let requestResult = text;
                if (typeof text === 'string') {
                    requestResult = new JSONFormat().read(text);
                }
                if (
                    !requestResult ||
                    requestResult.error ||
                    (requestResult.code >= 300 && requestResult.code !== 304)
                ) {
                    if (requestResult && requestResult.error) {
                        requestResult = {
                            error: requestResult.error
                        };
                    } else {
                        requestResult = {
                            error: requestResult
                        };
                    }
                }
                if (requestResult && options.scope.format === DataFormat.FGB) {
                  requestResult.newResourceLocation = requestResult.newResourceLocation.replace('.json', '') + '.fgb';
                }
                return requestResult;
            })
            .catch(function (e) {
                return { error: e };
            })
            .then((requestResult) => {
                let response = {
                  object: this
                };
                if (requestResult.error) {
                  const type = 'processFailed';
                  // 兼容服务在构造函数中使用 eventListeners 的老用法
                  if (this.events && this.events.listeners[type] && this.events.listeners[type].length) {
                    var failure = options.failure && (options.scope ? FunctionExt.bind(options.failure, options.scope) : options.failure);
                    failure ? failure(requestResult, options) : this.serviceProcessFailed(requestResult, options);
                  } else {
                    response = {...response, ...this.transformErrorResult(requestResult, options)};
                    response.type = type;
                    options.failure && options.failure(response);
                  }
                } else {
                  const type = 'processCompleted';
                  if (this.events && this.events.listeners[type] && this.events.listeners[type].length) {
                    var success = options.success && (options.scope ? FunctionExt.bind(options.success, options.scope) : options.success);
                    success ? success(requestResult, options) : this.serviceProcessCompleted(requestResult, options);
                  } else {
                    requestResult.succeed = requestResult.succeed == undefined ? true : requestResult.succeed;
                    response = {...response, ...this.transformResult(requestResult, options)};
                    response.type = type;
                    options.success && options.success(response);
                  }
                }
                return response;
            });
    }
}


/**
 * 服务器请求回调函数。
 * @callback RequestCallback
 * @category BaseTypes Util
 * @example
 * var requestCallback = function (serviceResult){
 *      console.log(serviceResult.result);
 * }
 * new QueryService(url).queryByBounds(param, requestCallback);
 * @param {Object} serviceResult
 * @param {Object} serviceResult.result 服务器返回结果。
 * @param {Object} serviceResult.object 发布应用程序事件的对象。
 * @param {Object} serviceResult.type 事件类型。
 * @param {Object} serviceResult.options 请求参数。
 */

;// CONCATENATED MODULE: ./src/common/iServer/KnowledgeGraphService.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/



/**
 * @class KnowledgeGraphService
 * @category iServer KnowledgeGraph
 * @classdesc 知识图谱服务类
 * @version 11.1.0
 * @extends {ProcessingServiceBase}
 * @param {string} url - 服务地址。
 * @param {Object} options - 可选参数。
 * @param {string} [options.proxy] - 服务代理地址。
 * @param {boolean} [options.withCredentials=false] - 请求是否携带 cookie。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @usage
 */
class KnowledgeGraphService_KnowledgeGraphService extends CommonServiceBase {
  constructor(url, options) {
    super(url, options);
    this.options = options || {};
    this.CLASS_NAME = 'SuperMap.KnowledgeGraphService';
  }

  /**
   * @function KnowledgeGraphService.prototype.destroy
   * @override
   */
  destroy() {
    super.destroy();
  }

  /**
   * @function KnowledgeGraphService.prototype.query
   * @description 通过查询语句查询知识图谱数据。
   * @param {string} params - 查询条件。
   * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
   */
  query(params, callback) {
    const paramKey = 'cypherQuery';
    const url = Util_Util.urlAppend(this.url + '/query.json', `${paramKey}=${encodeURI(params)}`);
    this.processAsync({ url, method: 'GET', callback });
  }

  // /**
  //  * @function KnowledgeGraphService.prototype.queryById
  //  * @description 根据实体id查询关联节点。
  //  * @param {string} id - 实体id。
  //  * @param {RequestCallback} callback 回调函数。
  //  */
  // queryById(id, callback) {
  //   const paramKey = 'cypherQuery';
  //   const url = Util.urlAppend(this.url + '/query.json', `${paramKey}=match p=(n)-[]-(m) where id(n)=${id} return p;`);
  //   this.processAsync({ url, method: 'GET', callback });
  // }

  // /**
  //  * @function KnowledgeGraphService.prototype.getMetaData
  //  * @description 获取元信息（展示所有实体类型和关系类型。）
  //  * @param {RequestCallback} callback 回调函数。
  //  */
  // getMetaData(callback) {
  //   const url = this.url + 'management/metadata.json';
  //   this.processAsync({ url, method: 'GET', callback });
  // }

  /**
   * @function KnowledgeGraphService.prototype.getGraphMaps
   * @description 获取图谱列表
   * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
   */
  getGraphMaps(callback) {
    const url = this.url + '/graphmaps.json';
    this.processAsync({ url, method: 'GET', callback });
  }

  /**
   * @function KnowledgeGraphService.prototype.getGraphMap
   * @description 获取图谱图序列化数据
   * @param {string} graphMapName 图谱名称
   * @param {RequestCallback} callback 回调函数
   */
  getGraphMap(graphMapName, callback) {
    const url = this.url + `/graphmaps/${graphMapName}.json`;
    this.processAsync({ url, method: 'GET', callback });
  }

  /**
   * @function KnowledgeGraphService.prototype.getGraphMapData
   * @description 将iServer GraphMap服务的数据格式转换为KnowledgeGraph的数据格式。
   * @param {string} graphMapName - 图谱名称
   * @returns {Promise} Promise 对象。
   */
  async getGraphMapData(graphMapName) {
    let data = [];
    const graphMap = await this._getGraphMapData(graphMapName);
    if (!graphMap) {
      return;
    }
    const query = (graphMap.dataContent.queries && graphMap.dataContent.queries.query) || [];
    let queries = [];
    if (typeof query === 'string') {
      queries = [query];
    } else {
      queries = query;
    }
    const expandQueries = this._getGraphMapExpandQuery(graphMap);
    if (expandQueries.length) {
      queries.push(...expandQueries);
    }
    for (let j = 0; j < queries.length; j++) {
      const cypherQuery = queries[j];
      const res = await this._queryDataBySql(cypherQuery);
      data = data.concat([], res);
    }
    return { data, graphMap };
  }

  /**
   * @private
   * @function KnowledgeGraphService.prototype._getGraphMapExpandQuery
   * @description 获取graphMap图谱展开节点的query条件
   * @param {Object} graphMap -将iServer GraphMap图谱服务的数据
   * @param {Array.<string>} 查询条件
   */
  _getGraphMapExpandQuery(graphMap) {
    const queries = [];
    const expandIds = (graphMap.dataContent.expand && JSON.parse(graphMap.dataContent.expand)) || [];
    expandIds.forEach((id) => {
      queries.push(`match p=(n)-[]-(m) where id(n)=${id} return p;`);
    });
    return queries;
  }

  // /**
  //  * @private
  //  * @function KnowledgeGraphService.prototype.getEntities
  //  * @description 获取实体。
  //  * @param {Object} params - 查询条件。{type:'院落', count:1}
  //  * @param {number} [params.count] - 返回个数
  //  * @param {RequestCallback} callback 回调函数
  //  */
  // getEntities(params, callback) {
  //   const url = Util.urlAppend(this.url + '/entities.json', params);
  //   this.processAsync({ url, params, method: 'GET', callback });
  // }

  // /**
  //  * @private
  //  * @function KnowledgeGraphService.prototype.getEdges
  //  * @description 获取实体。
  //  * @param {Object} params - 查询条件。{type:'院落', count:1}
  //  * @param {number} [params.count] - 返回个数
  //  * @param {RequestCallback} callback 回调函数
  //  */
  // getEdges(params, callback) {
  //   const url = Util.urlAppend(this.url + '/edges.json', params);
  //   this.processAsync({ url, params, method: 'GET', callback });
  // }

  // /**
  //  * @private
  //  * @function KnowledgeGraphService.prototype.getEntities
  //  * @description 获取实体。
  //  * @param {number} id - 查询条件。{type:'院落', count:1}
  //  * @param {RequestCallback} callback 回调函数
  //  */
  // deleteEntitiy(id, callback) {
  //   const url = Util.urlAppend(this.url + '/entities.json', `id=${id}`);
  //   this.processAsync({ url, method: 'DELETE', callback });
  // }

  // /**
  //  * @private
  //  * @function KnowledgeGraphService.prototype.addNode
  //  * @description 获取实体。
  //  * @param {Object} params - 查询条件
  //  * @param {number} [params.count] - 返回个数
  //  * @param {RequestCallback} callback 回调函数
  //  */
  // addNode(params, callback) {
  //   if (!(params instanceof KnowledgeGraphNodeParameter)) {
  //     return;
  //   }
  //   const url = Util.urlAppend(this.url + '/entities.json', params);
  //   this.processAsync({ url, params, method: 'PUT', callback });
  // }

  // /**
  //  * @private
  //  * @function KnowledgeGraphService.prototype.addEdge
  //  * @description 获取实体。
  //  * @param {Object} params - 查询条件
  //  * @param {number} [params.count] - 返回个数
  //  * @param {RequestCallback} callback 回调函数
  //  */
  // addEdge(params, callback) {
  //   if (!(params instanceof KnowledgeGraphEdgeParameter)) {
  //     return;
  //   }
  //   const url = Util.urlAppend(this.url + '/edges.json', params);
  //   this.processAsync({ url, params, method: 'PUT', callback });
  // }
  /**
   * @function KnowledgeGraphService.prototype.processAsync
   * @description 负责将客户端的动态分段服务参数传递到服务端。
   * @param {string} url - 服务地址
   * @param {Object} params - 参数
   * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
   * @returns {Promise} Promise 对象。
   */

  processAsync({ url, params, method, callback }) {
    const requestParams = {
      method,
      url,
      scope: this,
      success: callback,
      failure: callback
    };
    if (params) {
      requestParams.params = params;
    }
    return this.request(requestParams);
  }
  /**
   * @private
   * @function _getGraphMapData
   * @description 获取图谱信息
   * @param {string} graphMapName - 图谱名称
   * @returns {Promise} Promise 对象
   */
  _getGraphMapData(graphMapName) {
    return new Promise((resolve, reject) => {
      this.getGraphMap(graphMapName, (res) => {
        if (res.type === 'processFailed') {
          reject(res.error);
        } else {
          if (res.result.data === '') {
            reject('无数据');
          } else {
            resolve(res.result.graphMap);
          }
        }
      });
    });
  }

  /**
   * @private
   * @function _queryDataBySql
   * @description 查询实体和关系数据。
   * @param {string} cypherQuery - 查询语句
   * @returns {Promise} Promise 对象。
   */
  _queryDataBySql(cypherQuery) {
    return new Promise((resolve, reject) => {
      this.query(cypherQuery, (res) => {
        if (res.type === 'processFailed') {
          reject(res.error);
        } else {
          resolve(res.result);
        }
      });
    });
  }
}

;// CONCATENATED MODULE: ./src/mapboxgl/services/KnowledgeGraphService.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/



/**
 * @class KnowledgeGraphService
 * @category  iServer KnowledgeGraph
 * @classdesc 知识图谱服务类。
 * @version 11.1.0
 * @example
 * new KnowledgeGraphService(url)
 *  .query(param,function(result){
 *     //doSomething
 * })
 * @extends {ServiceBase}
 * @param {string} url - 服务地址。
 * @param {Object} options -参数。
 * @param {string} [options.proxy] - 服务代理地址。
 * @param {boolean} [options.withCredentials=false] - 请求是否携带 cookie。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @usage
 */
class KnowledgeGraphService extends ServiceBase {
  constructor(url, options) {
    super(url, options);
    this._knowledgeGraphService = new KnowledgeGraphService_KnowledgeGraphService(url, options);
  }

  /**
   * @function KnowledgeGraphService.prototype.query
   * @description 通过查询语句查询知识图谱数据。
   * @param {string} cypherQuery - 查询条件。
   * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
   * @returns {Promise} Promise 对象。
   */
  query(cypherQuery, callback) {
    return this._knowledgeGraphService.query(cypherQuery, callback);
  }

  // /**
  //  * @function KnowledgeGraphService.prototype.getMetaData
  //  * @description 获取元信息（展示所有实体类型和关系类型。）
  //  * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
  //  * @returns {Promise} Promise 对象。
  //  */
  // getMetaData(callback) {
  //   this._knowledgeGraphService.getMetaData(callback);
  // }

  /**
   * @function KnowledgeGraphService.prototype.getGraphMaps
   * @description 获取图谱列表。
   * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
   * @returns {Promise} Promise 对象。
   */
  getGraphMaps(callback) {
    return this._knowledgeGraphService.getGraphMaps(callback);
  }

  /**
   * @function KnowledgeGraphService.prototype.getGraphMap
   * @description 获取图谱图序列化数据。
   * @param {string} params 图谱名称。
   * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
   * @returns {Promise} Promise 对象。
   */
  getGraphMap(params, callback) {
    return this._knowledgeGraphService.getGraphMap(params, callback);
  }

  /**
   * @function KnowledgeGraphService.prototype.getGraphMapData
   * @description 将iServer GraphMap服务的数据格式转换为KnowledgeGraph的数据格式。
   * @param {string} graphMapName - 图谱名称。
   * @returns {Promise} Promise 对象。
   */
  async getGraphMapData(graphMapName) {
    const res = await this._knowledgeGraphService.getGraphMapData(graphMapName);
    return res;
  }
}

// EXTERNAL MODULE: ./node_modules/lodash.uniqby/index.js
var lodash_uniqby = __webpack_require__(618);
var lodash_uniqby_default = /*#__PURE__*/__webpack_require__.n(lodash_uniqby);
;// CONCATENATED MODULE: ./src/common/overlay/knowledge-graph/format.js


function transformGraphMap(data, graphMap) {
  const style = graphMap && graphMap.styles && graphMap.styles.style;
  const captionField = graphMap && graphMap.captionFields && graphMap.captionFields.captionField;

  const rst = { nodes: [], edges: [] };
  data.forEach((item) => {
    const pathData = item.path;
    if (pathData) {
      const { nodes, edges } = transformPath(pathData, style, captionField);
      rst.nodes.push(...nodes);
      rst.edges.push(...edges);
    } else if (isEdge(item)) {
      const edge = edgeFromGraphMap(item, style);
      rst.edges.push(edge);
    } else {
      const node = nodeFromGraphMap(item, style, captionField);
      rst.nodes.push(node);
    }
  });
  return { nodes: uniqData(rst.nodes), edges: uniqData(rst.edges, 'edgeId') };
}

function uniqData(data, paramName = 'id') {
  return lodash_uniqby_default()(data, paramName);
}

function isEdge(entity) {
  return entity.hasOwnProperty('start') && entity.hasOwnProperty('end');
}

function transformPath(pathData, style, captionField) {
  const rst = { nodes: [], edges: [] };
  pathData.forEach((item) => {
    if (isEdge(item)) {
      const edge = edgeFromGraphMap(item, style);
      rst.edges.push(edge);
    } else {
      const node = nodeFromGraphMap(item, style, captionField);
      rst.nodes.push(node);
    }
  });
  return rst;
}

function nodeFromGraphMap(entity, style, captionField) {
  const { id, properties, lables } = entity;
  const styleData = style ? getNodeStyle(entity, style) : {};
  const label = getNodeLabel(entity, captionField);
  const fillColor = styleData.fillColor || '';
  const node = {
    id: id + '',
    label: label,
    properties,
    lables
  };
  if (styleData.size) {
    node.size = styleData.size;
    delete styleData.size;
  }
  if (styleData.fillColor) {
    node.style = {
      fill: fillColor,
      stroke: fillColor
    };
    delete styleData.fillColor;
  }
  if (Object.keys(styleData).length !== 0) {
    node.labelCfg = {
      style: styleData
    };
  }
  return node;
}
function edgeFromGraphMap(entity, style) {
  const { start, end, id, type, properties } = entity;
  const styleData = style ? getEdgeStyle(entity, style) : {};
  const edge = {
    source: start + '',
    target: end + '',
    edgeId: id + '',
    label: type,
    style: {},
    labelCfg: {},
    properties
  };
  if (styleData.stroke) {
    edge.style.stroke = styleData.stroke;
    edge.style.endArrow = {
      path: 'M 0,0 L 4,2 L 4,-2 Z',
      fill: styleData.stroke
    };
    delete styleData.stroke;
  }
  if (styleData.lineWidth) {
    edge.style.lineWidth = styleData.lineWidth;
    delete styleData.lineWidth;
  }
  edge.labelCfg = {
    style: styleData
  };
  return edge;
}

function getEdgeStyle(entity, style) {
  if (!style) {
    return {};
  }
  const { id, type } = entity;
  const data = style.filter((item) => item.type === 'relationShip');
  for (let i = 0; i < data.length; i++) {
    const { color, width, textColor, font, relationTypes, relationIds } = data[i];
    const ids = JSON.parse(relationIds || '[]');
    const types = JSON.parse(relationTypes || '[]');
    if (ids.includes(id) || types.includes(type)) {
      return {
        stroke: color,
        lineWidth: Number(width) * 1.4,
        fontSize: font.fontSize,
        fill: textColor,
        ...formatFontName(font.fontName),
        ...formatFontStyle(font.fontStyle)
      };
    }
  }
  return {};
}

function getNodeStyle(entity, style) {
  if (!style) {
    return {};
  }
  const { id, labels } = entity;
  const data = style.filter((item) => item.type === 'entity');
  for (let i = 0; i < data.length; i++) {
    const { color, textColor, font, size, entityTypes, entityIds } = data[i];
    const ids = JSON.parse(entityIds || '[]');
    const types = JSON.parse(entityTypes || '[]');
    if (ids.includes(id) || types.includes(labels[0])) {
      return {
        fillColor: color,
        fontSize: font.fontSize,
        fill: textColor,
        size: size,
        ...formatFontName(font.fontName),
        ...formatFontStyle(font.fontStyle)
      };
    }
  }
  return {};
}

function getNodeLabel(entity, captionField) {
  const { id, labels, properties } = entity;
  if (captionField) {
    const data = captionField instanceof Array ? captionField : [captionField];
    for (let i = 0; i < data.length; i++) {
      const { name, entityTypes, entityIds } = data[i];
      const ids = JSON.parse(entityIds || '[]');
      const types = JSON.parse(entityTypes || '[]');
      const labelStr = labels && labels.join('&');
      if (ids.includes(id) || types.includes(labelStr)) {
        return properties[name] || '';
      }
    }
  }
  return properties[properties._labelfieldname] || '';
}

function formatFontStyle(fontStyle) {
  //TODO: fontStyle为0是plain
  if (fontStyle === 1 || fontStyle === 'bold') {
    return { fontWeight: 'bold' };
  }
  if (fontStyle === 2 || fontStyle === 'italic') {
    return { fontStyle: 'italic' };
  }
  if (fontStyle === 'bolditalic') {
    return { fontWeight: 'bold', fontStyle: 'italic' };
  }
  return {};
}

function formatFontName(fontName) {
  if (!fontName) {
    return {};
  }
  const arrs = fontName.split('.');
  return {
    fontFamily: arrs[0],
    ...formatFontStyle(arrs[1])
  };
}

// 处理graphMap数据的展开 折叠 隐藏的实体数据
function transformExpandCollapseHiddenData(graphMap) {
  const { expand, collapse, hidden } = graphMap.dataContent;
  return {
    expand: expand && JSON.parse(expand),
    collapse: collapse && JSON.parse(collapse),
    hidden: hidden && JSON.parse(hidden)
  };
}

;// CONCATENATED MODULE: external "function(){try{return G6}catch(e){return {}}}()"
const external_function_try_return_G6_catch_e_return_namespaceObject = function(){try{return G6}catch(e){return {}}}();
var external_function_try_return_G6_catch_e_return_default = /*#__PURE__*/__webpack_require__.n(external_function_try_return_G6_catch_e_return_namespaceObject);
// EXTERNAL MODULE: ./node_modules/insert-css/index.js
var insert_css = __webpack_require__(186);
var insert_css_default = /*#__PURE__*/__webpack_require__.n(insert_css);
;// CONCATENATED MODULE: ./src/common/overlay/knowledge-graph/G6Render.js


/**
 * @private
 * @class G6Render
 * @category iServer G6Render
 * @classdesc G6Render
 * @param {KnowledgeGraph.Data} data - 创建graph实例的数据项。
 * @param {KnowledgeGraph.Config} [config] - 创建graph实例的配置项。
 * @private
 */

class G6Render {
  constructor() {
    this.config = null;
    this.graph = null;
    this.data = null;
    this.collpasedData = {};
    this.importG6();
    this.CLASS_NAME = 'SuperMap.G6Render';
  }
  importG6() {
    if (!(external_function_try_return_G6_catch_e_return_default())) {
      console.log('please import g6, eg：https://gw.alipayobjects.com/os/lib/antv/g6/4.3.2/dist/g6.min.js');
    }
  }
  /**
   * @function G6Render.prototype.initGraph
   * @description 创建KnowledgeGraph实例
   * @param {KnowledgeGraph.Config} config - graph配置项。
   * @returns {Object} graph实例。
   */
  initGraph(config) {
    const graph = new (external_function_try_return_G6_catch_e_return_default()).Graph(config);
    this.graph = graph;
    if (!config || config.highlightNode !== false) {
      this.highlightNode(graph);
    }
    if (!config || config.highlightEdge !== false) {
      this.highlightEdge(graph);
    }
    if (config.dragCanvas !== false || config.dragNode !== false) {
      // 阻止事件冒泡
      this.stopDefaultEventPropagation();
    }
    return graph;
  }

  _getContextMenu() {
    const contextMenu = new (external_function_try_return_G6_catch_e_return_default()).Menu({
      shouldBegin(evt) {
        if (evt.target && evt.target.isCanvas && evt.target.isCanvas()) {
          return true;
        }
        if (evt.item) {
          return true;
        }
        return false;
      },
      getContent: (evt) => {
        const { item } = evt;
        if (evt.target && evt.target.isCanvas && evt.target.isCanvas()) {
          return;
        }
        if (!item) {
          return;
        }
        const itemType = item.getType();
        const model = item.getModel();
        if (itemType && model) {
          if (itemType === 'node') {
            if (this.isCollpased(model.id)) {
              return `<ul>
              <li id='expand'>展开</li>
            </ul>`;
            } else {
              return `<ul>
              <li id='collapse'>折叠</li>
            </ul>`;
            }
          }
        }
      },
      handleMenuClick: (target, item) => {
        const liIdStrs = target.id.split('-');
        switch (liIdStrs[0]) {
          case 'hide':
            this.hideItem(item);
            break;
          case 'expand':
            this.expandNode(item);
            break;
          case 'collapse':
            this.collapseNode(item);
            break;
          case 'show':
            this.showItem(item);
            break;
          default:
            break;
        }
      },
      // 需要加上父级容器的 padding-left 16 与自身偏移量 10
      offsetX: 16 + 10,
      // 需要加上父级容器的 padding-top 24 、画布兄弟元素高度、与自身偏移量 10
      offsetY: 0,
      // 在哪些类型的元素上响应
      itemTypes: ['node', 'edge', 'canvas']
    });
    return contextMenu;
  }

  _getGraphConfig(config) {
    const animateConfig = {
      speed: 120,
      maxIteration: 83,
      tick: () => {
        this.refreshPositions()
      }
    };
    const defaultLayout = {
      type: 'fruchterman',
      gravity: 5
    };
    const defaultNode = {};
    const defaultEdge = {
      type: 'line',
      style: {
        endArrow: {
          path: 'M 0,0 L 4,2 L 4,-2 Z',
          fill: '#e0e0e0'
        },
        lineWidth: 0.5
      },
      labelCfg: {
        autoRotate: true,
        style: {
          fontSize: 4,
          fill: '#333'
        }
      }
    };
    const defaultMode = {
      default: ['drag-canvas', 'zoom-canvas', 'drag-node']
    };
    const contextMenu = this._getContextMenu();
    const defaultPlugins = [new (external_function_try_return_G6_catch_e_return_default()).ToolBar(), contextMenu];
    const hoverColor = '#b4d6ff';
    const defaultNodeHighlightStyle = {
      lineWidth: 3,
      stroke: hoverColor
    };
    const defaultEdgeHighlightStyle = {
      stroke: hoverColor,
      shadowColor: hoverColor,
      shadowBlur: 5,
      endArrow: {
        path: 'M 0,0 L 4,2 L 4,-2 Z',
        fill: hoverColor
      }
    };
    const defaultGraphConfig = (container = 'knowledgeGraph') => {
      const dom = document.querySelector(`#${container}`);
      return {
        container: container, // String | HTMLElement，必须，在 Step 1 中创建的容器 id 或容器本身
        width: dom.scrollWidth, // Number，必须，图的宽度
        height: dom.scrollHeight, // Number，必须，图的高度
        plugins: defaultPlugins,
        modes: defaultMode,
        layout: { ...defaultLayout, ...animateConfig },
        defaultNode,
        defaultEdge,
        nodeStateStyles: {
          hover: defaultNodeHighlightStyle
        },
        edgeStateStyles: {
          hover: defaultEdgeHighlightStyle
        }
      };
    };
    if (!config) {
      this._setToolBarStyle();
      return defaultGraphConfig();
    }
    config.container = config.container || 'knowledgeGraph';
    const dom =
      typeof config.container === 'string' ? document.querySelector(`#${config.container}`) : config.container;
    config.width = config.width || dom.scrollWidth;
    config.height = config.height || dom.scrollHeight;
    config.layout = { ...defaultLayout, ...(config.layout || {}), ...(config.animate !== false ? animateConfig : {}) };
    config.defaultNode = { ...defaultNode, ...(config.defaultNode || {}) };
    config.defaultEdge = { ...defaultEdge, ...(config.defaultEdge || {}) };
    config.modes = {
      default: [
        config.dragCanvas !== false && 'drag-canvas',
        config.zoomCanvas !== false && 'zoom-canvas',
        config.dragNode !== false && 'drag-node'
      ]
    };
    config.nodeStateStyles = {
      hover: { ...defaultNodeHighlightStyle, ...(config.nodeHighlightStyle || {}) }
    };
    config.edgeStateStyles = {
      hover: { ...defaultEdgeHighlightStyle, ...(config.edgeHighlightStyle || {}) }
    };
    if (config.showToolBar !== false) {
      config.plugins = [new (external_function_try_return_G6_catch_e_return_default()).ToolBar()];
      this._setToolBarStyle();
    }
    if (config.showContextMenu !== false) {
      config.plugins = [...(config.plugins || []), contextMenu];
      this._setToolBarStyle();
    }
    return config;
  }

  /**
   * @function G6Render.prototype.changeSize
   * @description 当源数据中现有节点/边 的数据项发生配置的变更时，根据新数据刷新视图。
   * @param {number} width - 宽度。
   * @param {number} height - 高度。
   */
  changeSize(width, height) {
    return this.graph.changeSize(width, height);
  }

  /**
   * @function G6Render.prototype.autoResize
   * @description 浏览器窗口大小发生改变时，重新渲染；
   */
  autoResize() {
    const dom = this.getContainer();
    window.addEventListener('resize', () => {
      const width = dom.scrollWidth;
      const height = dom.scrollHeight;
      this.graph.changeSize(width, height);
      this.graph.refresh();
    });
  }

  /**
   * @function G6Render.prototype.zoom
   * @description 改变视口的缩放比例，在当前画布比例下缩放，是相对比例。
   * @param {number} ratio 缩放比例。
   * @param {Object} [center] 以 center 的 x、y 坐标为中心缩放，如果省略了 center 参数，则以元素当前位置为中心缩放。
   * @param {boolean} [animate] 是否开启动画。
   * @param {KnowledgeGraph.AnimateConfig} [animateCfg] 若带有动画，可配置动画。若未配置，则跟随 graph 的 animateCfg 参数。
   */
  zoom(ratio, center, animate, animateCfg) {
    this.graph.zoom(ratio, center, animate, animateCfg);
  }

  /**
   * @function G6Render.prototype.zoomTo
   * @description 改变视口的缩放比例，在当前画布比例下缩放，是相对比例。
   * @param {number} ratio 缩放比例。
   * @param {Object} [center] 以 center 的 x、y 坐标为中心缩放，如果省略了 center 参数，则以元素当前位置为中心缩放。
   * @param {boolean} [animate] 是否开启动画。
   * @param {KnowledgeGraph.AnimateConfig} [animateCfg] 若带有动画，可配置动画。若未配置，则跟随 graph 的 animateCfg 参数。
   */
  zoomTo(ratio, center, animate, animateCfg) {
    this.graph.zoomTo(ratio, center, animate, animateCfg);
  }

  /**
   * @function G6Render.prototype.fitView
   * @description 让画布内容适应视口。
   * @param {Array.<number>|number} [padding] [top, right, bottom, left] 四个方向上的间距值。
   * @param {Object} [rules] fitView 的规则，参数如下：{ onlyOutOfViewPort?: boolean; direction?: 'x' / 'y' / 'both'; ratioRule?: 'max' / 'min}。
   * @param {boolean} [animate] 是否开启动画。
   * @param {KnowledgeGraph.AnimateConfig} [animateCfg] 若带有动画，可配置动画。若未配置，则跟随 graph 的 animateCfg 参数。
   */
  fitView(padding, rules, animate, animateCfg) {
    this.graph.fitView(padding, rules, animate, animateCfg);
  }

  /**
   * @function G6Render.prototype.fitCenter
   * @description 平移图到中心将对齐到画布中心，但不缩放。优先级低于 fitView。
   * @param {boolean} [animate] 是否开启动画。
   * @param {KnowledgeGraph.AnimateConfig} [animateCfg] 若带有动画，可配置动画，参见基础动画教程。若未配置，则跟随 graph 的 animateCfg 参数。
   */
  fitCenter(animate, animateCfg) {
    this.graph.fitCenter(animate, animateCfg);
  }

  /**
   * @function G6Render.prototype.getGraphCenterPoint
   * @description 获取图内容的中心绘制坐标。
   * @return {Object} 包含的属性：x 和 y 属性，分别表示渲染坐标下的 x、y 值。
   */
  getGraphCenterPoint() {
    return this.graph.getGraphCenterPoint();
  }

  /**
   * @function G6Render.prototype.getViewPortCenterPoint
   * @description 获取视口中心绘制坐标。
   * @return {Object} 包含的属性：x 和 y 属性，分别表示渲染坐标下的 x、y 值。
   */
  getViewPortCenterPoint() {
    return this.graph.getViewPortCenterPoint();
  }

  /**
   * @function G6Render.prototype.getZoom
   * @description 获取当前视口的缩放比例。
   * @return {number} 返回值表示当前视口的缩放比例， 默认值为 1。
   */
  getZoom() {
    return this.graph.getZoom();
  }

  /**
   * @function G6Render.prototype.getMinZoom
   * @description 获取 graph 当前允许的最小缩放比例。
   * @return {number} 返回值表示当前视口的最小缩放比例。
   */
  getMinZoom() {
    return this.graph.getMinZoom();
  }

  /**
   * @function G6Render.prototype.setMinZoom
   * @description 设置 graph 当前允许的最小缩放比例。
   * @param {number} ratio 缩放比例。
   */
  setMinZoom(ratio) {
    this.graph.setMinZoom(ratio);
  }

  /**
   * @function G6Render.prototype.getMaxZoom
   * @description 获取 graph 当前允许的最大缩放比例。
   * @return {number} 返回值表示当前视口的最大缩放比例。
   */
  getMaxZoom() {
    return this.graph.getMaxZoom();
  }

  /**
   * @function G6Render.prototype.setMaxZoom
   * @description 设置 graph 当前允许的最大缩放比例。
   * @param {number} ratio 缩放比例。
   */
  setMaxZoom(ratio) {
    this.graph.setMaxZoom(ratio);
  }

  /**
   * @function G6Render.prototype.getWidth
   * @description获取 graph 当前的宽度。
   * @return {number} graph 当前的宽度。
   */
  getWidth() {
    return this.graph.getWidth();
  }

  /**
   * @function G6Render.prototype.getHeight
   * @description 获取 graph 当前的高度。
   * @return {number} graph 当前的高度。
   */
  getHeight() {
    return this.graph.getHeight();
  }

  setCenter(centerDrawPoint) {
    var centerCanvasPointX = this.graph.getWidth() / 2;
    var centerCanvasPointY = this.graph.getHeight() / 2;
    var centerCanvasPointNew = this.graph.getCanvasByPoint(centerDrawPoint.x, centerDrawPoint.y);
    this.graph.translate(centerCanvasPointX - centerCanvasPointNew.x, centerCanvasPointY - centerCanvasPointNew.y);
  }

  /**
   * @function G6Render.prototype._setToolBarStyle
   * @description 隐藏工具栏的redo undo realZoom按钮
   * @private
   */
  _setToolBarStyle() {
    insert_css_default()(`
      .g6-component-toolbar li[code='redo'],
      .g6-component-toolbar li[code='undo'],
      .g6-component-toolbar li[code='realZoom'] {
        display: none;
      }
      .g6-component-contextmenu {
        position: absolute;
        z-index: 2;
        list-style-type: none;
        border-radius: 6px;
        font-size: 14px;
        width: fit-content;
        transition: opacity .2s;
        text-align: center;
        box-shadow: 0 5px 18px 0 rgba(0, 0, 0, 0.6);
        border: 0px;
      }
      .g6-component-contextmenu ul {
        padding-left: 0px;
        margin: 0;
      }
      .g6-component-contextmenu li {
        cursor: pointer;
        list-style-type: none;
        list-style: none;
        margin-left: 0;
        line-height: 38px;
        padding: 0px 35px;
      }
      .g6-component-contextmenu li:hover {
        color: #333;
        background: #aaaaaa45;
      }
    `);
  }

  /**
   * @function G6Render.prototype.highlightNode
   * @description 鼠标移入节点，节点高亮
   * @param {Object} graph - graph实例。
   */
  highlightNode(graph = this.graph) {
    function clearAllStats() {
      graph.setAutoPaint(false);
      graph.getNodes().forEach(function (node) {
        graph.clearItemStates(node);
      });
      graph.paint();
      graph.setAutoPaint(true);
    }

    graph.on('node:mouseenter', function (e) {
      const item = e.item;
      graph.setAutoPaint(false);
      graph.getNodes().forEach(function (node) {
        graph.clearItemStates(node);
      });
      graph.setItemState(item, 'hover', true);
      graph.paint();
      graph.setAutoPaint(true);
    });
    graph.on('node:mouseleave', clearAllStats);
  }

  /**
   * @function G6Render.prototype.highlightNode
   * @description 鼠标移入节点，节点高亮
   * @param {Object} graph - graph实例。
   */
  highlightEdge(graph = this.graph) {
    function clearAllStats() {
      graph.setAutoPaint(false);
      graph.getEdges().forEach(function (edge) {
        graph.clearItemStates(edge);
      });
      graph.paint();
      graph.setAutoPaint(true);
    }

    graph.on('edge:mouseenter', function (e) {
      const item = e.item;
      graph.setAutoPaint(false);
      graph.getNodes().forEach(function (node) {
        graph.clearItemStates(node);
      });
      graph.setItemState(item, 'hover', true);
      graph.paint();
      graph.setAutoPaint(true);
    });
    graph.on('edge:mouseleave', clearAllStats);
  }

  /**
   * @function G6Render.prototype.setData
   * @description 设置数据
   * @param {KnowledgeGraph.Data} data - graph数据。
   * @param {Object} [graph] - graph实例。
   */
  setData(data, graph = this.graph) {
    if (!this.data) {
      graph.data(data);
    } else {
      graph.changeData(data);
    }
    this.data = data;
  }

  /**
   * @function G6Render.prototype.render
   * @description 根据提供的数据渲染视图。
   */
  render(graph = this.graph) {
    return graph.render();
  }

  /**
   * @function G6Render.prototype.updateGraph
   * @description 更新数据
   * @param {Object} graph - graph实例。
   * @param {KnowledgeGraph.Data} data - graph数据。
   */
  updateGraph(data, graph = this.graph) {
    this.data = data;
    graph.changeData(data);
  }

  /**
   * @function G6Render.prototype.refresh
   * @description 当源数据中现有节点/边的数据项发生配置的变更时，根据新数据刷新视图。
   * @param {Object} graph - graph实例。
   */
  refresh(graph = this.graph) {
    graph.refresh();
  }

  /**
   * @function G6Render.prototype.getContainer
   * @description 获取 Graph 的 DOM 容器。
   * @param {Object} graph - graph实例。
   * @return {HTMLElement}  DOM 容器。
   */
  getContainer(graph = this.graph) {
    return graph.getContainer();
  }

  /**
   * @function G6Render.prototype.getCanvas
   * @description 获取canvas。
   * @param {Object} graph - graph实例。
   * @return {HTMLElement} canvas。
   */
  getCanvas(graph = this.graph) {
    return graph.get('canvas');
  }

  /**
   * @function G6Render.prototype.getNodes
   * @description 获取图中所有节点的实例。
      * @param {Object} graph - graph实例。

   * @return {Array} 返回值表示图中所有节点的实例。
   */
  getNodes(graph = this.graph) {
    return graph.getNodes();
  }

  /**
   * @function G6Render.prototype.getEdges
   * @description 获取图中所有节点的实例。这里返回的是边的实例，而不是边的数据项。
   * @param {Object} graph - graph实例。
   * @return {Array} 返回值表示图中所有边的实例。
   */
  getEdges(graph = this.graph) {
    return graph.getEdges();
  }

  /**
   * @function G6Render.prototype.getNeighbors
   * @description 获取邻居节点数组。
   * @param {Object} graph - graph实例。
   * @param {string | INode} node - 节点 ID 或节点实例。
   * @param {string|undefined} type -['source'| 'target' |undefined]	邻居类型， 'source' 只获取当前节点的源节点，'target' 只获取当前节点指向的目标节点， 若不指定则返回所有类型的邻居。
   * @return {Array} 返回值符合要求的节点数组。
   */
  getNeighbors(node, type, graph = this.graph) {
    return graph.getNeighbors(node, type);
  }

  /**
   * @function G6Render.prototype.findById
   * @description 根据 ID，查询对应的元素实例。
   * @param {Object} graph - graph实例。
   * @param {string} id -	元素 ID
   * @return {Object} 如果有符合规则的元素实例，则返回第一个匹配的元素实例，否则返回 undefined 。
   */
  findById(id, graph = this.graph) {
    return graph.findById(id);
  }

  /**
   * @function G6Render.prototype.find
   * @description 获取邻居节点数组。
   * @param {Object} graph - graph实例。
   * @param {string} type - 元素类型，可选值为 'node'、'edge'
   * @param {Function} fn - 	查找的规则。
   * @return {Object} 如果有符合规则的元素实例，则返回第一个匹配的元素实例，否则返回 undefined 。
   */
  find(type, fn, graph = this.graph) {
    return graph.find(type, fn);
  }
  /**
   * @function G6Render.prototype.findAll
   * @description 获取邻居节点数组。
   * @param {Object} graph - graph实例。
   * @param {string} type - 元素类型，可选值为 'node'、'edge'
   * @param {Function} fn - 	查找的规则。
   * @return {Object} 如果有符合规则的元素实例，则返回所有元素实例，否则返回 undefined。
   */
  findAll(type, fn, graph = this.graph) {
    return graph.findAll(type, fn);
  }

  /**
   * @function G6Render.prototype.getEdgesByNode
   * @description 获取与当前节点有关联的所有边。
   * @param {Object} node - node实例。
   * @return {Array} edge实例数组。
   */
  getEdgesByNode(node) {
    return node.getEdges();
  }

  /**
   * @function G6Render.prototype.getEdgesByNode
   * @description 获取与当前节点关联的所有入边。
   * @param {Object} node - node实例。
   * @return {Array} edge实例数组。
   */
  getInEdges(node) {
    return node.getInEdges();
  }

  /**
   * @function G6Render.prototype.getEdgesByNode
   * @description 获取与当前节点关联的所有出边。
   * @param {Object} node - node实例。
   * @return {Array} edge实例数组。
   */
  getOutEdges(node) {
    return node.getOutEdges();
  }

  /**
   * @function G6Render.prototype.getSourceByEdge
   * @description 获取当前边的起始节点
   * @param {Object} edge - node实例。
   * @return {Object} 返回值为起始节点的实例。
   */
  getSourceByEdge(edge) {
    return edge.getSource();
  }

  /**
   * @function G6Render.prototype.getTargetByEdge
   * @description 获取当前边的终止节点。
   * @param {Object} edge - node实例。
   * @return {Object} 终止节点的实例。
   */
  getTargetByEdge(edge) {
    return edge.getTarget();
  }

  /**
   * @function G6Render.prototype.expandNode
   * @description 展开当前节点。
   * @param {Object} item - 元素 ID 或元素实例。
   */
  expandNode(item) {
    const id = item.getModel().id;
    this._expandCollapseNode(this.collpasedData[id], 'show');
    delete this.collpasedData[id];
  }

  /**
   * @function G6Render.prototype.collapseNode
   * @description 收起当前节点。
   * @param {Object} item - 元素 ID 或元素实例。
   * @param {Object} graph - graph实例。
   */
  collapseNode(item) {
    const id = item.getModel().id;
    const result = [];
    this._collapseFunc(item, result);
    this.collpasedData[id] = result;
    this._expandCollapseNode(result);
  }

  isCollpased(id) {
    return !!this.collpasedData[id];
  }

  _collapseFunc(item, res = []) {
    const sourceNodes = this.getNeighbors(item, 'target');
    const targetNodes = this.getNeighbors(item, 'source');

    // 指出节点， 如果没有其他链接，隐藏
    for (let i = 0; i < sourceNodes.length; i++) {
      const sourceNode = sourceNodes[i];
      const model = sourceNode.getModel();
      let nodes = this.getNeighbors(sourceNode);
      // if (nodes && exceptNode) {
      //   nodes = nodes.filter((item) => item.id !== exceptNode);
      // }
      if (nodes.length === 1) {
        res.push({ id: model.id });
      }
    }
    // 指入节点， 如果没有其他链接或者没有指入节点隐藏，隐藏
    for (let i = 0; i < targetNodes.length; i++) {
      const targetNode = targetNodes[i];
      const model = targetNode.getModel();
      let nodes = this.getNeighbors(targetNode);
      let targetNodeNodes = this.getNeighbors(targetNode, 'source');
      // if (nodes && exceptNode) {
      //   nodes = nodes.filter((item) => item.id !== exceptNode);
      // }
      // if (targetNodeNodes && exceptNode) {
      //   targetNodeNodes = targetNodeNodes.filter((item) => item.id !== exceptNode);
      // }
      if (nodes.length === 1 || targetNodeNodes.length === 0) {
        res.push({ id: model.id });
      } else {
        const result = [];
        this._collapseFunc(targetNode, result);
        res.push({ id: model.id, children: result });
      }
    }
    return res;
  }

  _expandCollapseNode(data, type = 'hide') {
    if (!data) {
      return;
    }
    data.forEach((item) => {
      if (type === 'hide') {
        this.hideItem(item.id);
      } else {
        this.showItem(item.id);
        // 如果是把之前的折叠也展开了， 就要把之前的折叠数据删除
        if (this.isCollpased(item.id)) {
          delete this.collpasedData[item.id];
        }
      }
      if (item.children) {
        this._expandCollapseNode(item.children, type);
      }
    });
  }

  /**
   * @function G6Render.prototype.showItem
   * @description 显示指定的元素。若 item 为节点，则相关边也会随之显示。而show() 则将只显示自身。
   * @param {string|Object} item - 元素 ID 或元素实例。
   * @param {boolean} [stack] - 	操作是否入 undo & redo 栈，当实例化 Graph 时设置 enableStack 为 true 时，默认情况下会自动入栈，入栈以后，就支持 undo & redo 操作，如果不需要，则设置该参数为 false 即可。
   * @param {Object} graph - graph实例。
   */
  showItem(item, stack, graph = this.graph) {
    graph.showItem(item, stack);
  }

  /**
   * @function G6Render.prototype.showItem
   * @description 隐藏指定元素。若 item 为节点，则相关边也会随之隐藏。而 hide() 则将只隐藏自身。
   * @param {string|Object} item - 元素 ID 或元素实例。
   * @param {boolean} [stack] -操作是否入 undo & redo 栈，当实例化 Graph 时设置 enableStack 为 true 时，默认情况下会自动入栈，入栈以后，就支持 undo & redo 操作，如果不需要，则设置该参数为 false 即可。
   * @param {Object} graph - graph实例。
   */
  hideItem(item, stack, graph = this.graph) {
    graph.hideItem(item, stack);
  }

  /**
   * @function G6Render.prototype.show
   * @description 显示元素。只显示 item 自身，若需要在显示节点的同时显示相关边，应调用showItem(item)。
   * @param {Object} item - 元素实例。
   */
  show(item) {
    item.show();
  }

  /**
   * @function G6Render.prototype.hide
   * @description 隐藏元素。只隐藏 item 自身，若需要在隐藏节点的同时隐藏相关边，应调用 hideItem(item)。
   * @param {Object} item - 元素实例。
   */
  hide(item) {
    item.hide();
  }

  /**
   * @function G6Render.prototype.changeVisibility
   * @description 更改元素是否显示。
   * @param {Object} item - 元素实例。
   * @param {boolean} visible - 是否显示元素，true 为显示，false 为隐藏。
   */
  changeVisibility(item, visible) {
    item.changeVisibility(visible);
  }

  /**
   * @function G6Render.prototype.isVisible
   * @description 查询元素显示状态。
   * @param {Object} item - 元素实例。
   * @return {boolean} - 返回值为 true，则表示当前元素处于显示状态，否则处于隐藏状态。
   */
  isVisible(item) {
    return item.isVisible();
  }

  /**
   * @function G6Render.prototype.getModel
   * @description 获取元素的数据模型。
   * @param {Object} item - 元素实例。
   * @return {KnowledgeGraph.Data} - 返回值为节点的数据模型。
   */
  getModel(item) {
    return item.getModel();
  }

  /**
   * @function G6Render.prototype.addItem
   * @description 新增元素（节点和边）。
   * @param {Object} graph - graph实例。
   * @param {string} type - 元素类型，可选值为 'node'、'edge'
   * @param {Object} model - 元素的数据模型，具体内容参见元素配置项。
   */
  addItem(type, model, graph = this.graph) {
    graph.addItem(type, model);
  }

  /**
   * @function G6Render.prototype.addItem
   * @description 删除元素。
   * @param {string|Object} item - 	元素 ID 或元素实例
   * @param {Object} graph - graph实例。
   */
  removeItem(item, graph = this.graph) {
    graph.removeItem(item);
  }

  /**
   * @function G6Render.prototype.updateItem
   * @description 更新元素，包括更新数据、样式等。
   * @param {Object} graph - graph实例。
   * @param {string|Object} item - 元素 ID 或元素实例。
   * @param {Object} model - 元素的数据模型，具体内容参见元素配置项。
   */
  updateItem(item, model, graph = this.graph) {
    graph.updateItem(item, model);
  }

  /**
   * @function G6Render.prototype.refreshItem
   * @description 刷新指定元素。
   *  @param {Object} graph - graph实例。
   * @param {string|Object} item - 元素 ID 或元素实例。
   */
  refreshItem(item, graph = this.graph) {
    graph.refreshItem(item);
  }

  /**
   * @function G6Render.prototype.refreshPositions
   * @description 当节点位置发生变化时，刷新所有节点位置，并重计算边的位置。
   *  @param {Object} graph - graph实例。
   */
  refreshPositions(graph = this.graph) {
    graph.refreshPositions();
  }
  /**
   * @function G6Render.prototype.on
   * @description graph监听事件
   * @param {Object} graph - graph实例。
   * @param {string} eventName - 事件名，可选事件名参见 Event。
   * @param {Function} handler -	监听函数。
   */
  on(eventName, handler, graph = this.graph) {
    graph.on(eventName, handler);
  }
  /**
   * @function G6Render.prototype.off
   * @description graph关闭事件
   *  @param {Object} graph - graph实例。
   * @param {string} eventName - 事件名，可选事件名参见 Event。
   * @param {Function} handler -	监听函数。
   */
  off(eventName, handler, graph = this.graph) {
    graph.off(eventName, handler);
  }
  /**
   * @function G6Render.prototype.toDataURL
   * @description 转换成图片
   *  @param {Object} graph - graph实例。
   * @param {string} type - 图片类型 'image/png' / 'image/jpeg' / 'image/webp' / 'image/bmp'。
   * @param {string} [backgroundColor] - 图片的背景色，可选，不传值时将导出透明背景的图片。
   * @return {string} 返回值表示生成的图片的 URL。
   */
  toDataURL(type, backgroundColor, graph = this.graph) {
    graph.toDataURL(type, backgroundColor);
  }

  /**
   * @function G6Render.prototype.bindNodeDefaultDragEvent
   * @description 给graph的节点绑定默认的拖拽事件
   *
   * @param {Object} graph - graph实例。
   */
  bindNodeDefaultDragEvent(graph = this.graph) {
    graph.on('node:dragstart', function (e) {
      refreshDragedNodePosition(e);
    });
    graph.on('node:drag', function (e) {
      refreshDragedNodePosition(e);
    });
    graph.on('node:dragend', function (e) {
      e.item.get('model').fx = null;
      e.item.get('model').fy = null;
    });
  }

  /**
   * @function G6Render.prototype.stopDefaultEventPropagation
   * @description 阻止点击事件冒泡
   * @param {Object} graph - graph实例。
   */
  stopDefaultEventPropagation(graph = this.graph) {
    graph.on('click', function (e) {
      e.stopPropagation();
    });
    graph.on('mousedown', function (e) {
      e.stopPropagation();
    });
    graph.on('mouseover', function (e) {
      e.stopPropagation();
    });
    graph.on('mouseout', function (e) {
      e.stopPropagation();
    });
  }

  /**
   * @function G6Render.prototype.clear
   * @description 清除画布元素
   * @param {Object} graph - graph实例。
   */
  clear(graph = this.graph) {
    graph.clear();
  }
  /**
   * @function G6Render.prototype.destroy
   * @description 销毁画布
   * @param {Object} graph - graph实例。
   */
  destroy(graph = this.graph) {
    graph.destroy();
  }
}
/**
 * @description 更新拖拽后节点的x ,y
 */
function refreshDragedNodePosition(e) {
  const model = e.item.get('model');
  model.fx = e.x;
  model.fy = e.y;
  model.x = e.x;
  model.y = e.y;
  return model;
}

// EXTERNAL MODULE: ./node_modules/lodash.clonedeep/index.js
var lodash_clonedeep = __webpack_require__(465);
var lodash_clonedeep_default = /*#__PURE__*/__webpack_require__.n(lodash_clonedeep);
;// CONCATENATED MODULE: ./src/common/overlay/KnowledgeGraph.js




/**
 * @class KnowledgeGraph
 * @category iServer KnowledgeGraph
 * @classdesc KnowledgeGraph知识图谱
 * @version 11.1.0
 * @param { KnowledgeGraph.Config } config - 创建graph实例的配置项。
 * @usage
 */

/**
 * @typedef {Object} KnowledgeGraph.Data - 创建graph实例的数据项。
 * @property {Array.<KnowledgeGraph.Node>} data.nodes - 创建graph节点。
 * @property {Array.<KnowledgeGraph.Edge>} data.edges - 创建graph边。
 */

/**
 * @typedef {Object} KnowledgeGraph.Config - 创建graph实例的配置项。
 * @property {string | HTMLElement} container - 创建的容器 id 或容器本身, 默认是'knowledgeGraph'。
 * @property {number} width - 图的宽度, 默认是container的width。
 * @property {number} height - 图的高度,默认是container的height。
 * @property {Array.<number>} [center] - 中心点的渲染坐标。可以通过KnowledgeGraph.prototype.getViewPortCenterPoint获取。
 * @property {number} [zoom] - 缩放比例。
 * @property {number} [minZoom] - 最小缩放比例。若 fitView、zoom、zoomTo 等操作导致图的缩放比例小于该值，则将使用该值进行缩放，并返回 false。
 * @property {number} [maxZoom] - 最大缩放比例。若 fitView、zoom、zoomTo 等操作导致图的缩放比例大于该值，则将使用该值进行缩放，并返回 false。
 * @property {KnowledgeGraph.Layout} [layout] - 布局。
 * @property {boolean} [animate=true] - 是否开启动画。
 * @property {boolean} [autoResize=true] - 当视口变换时，是否自动重绘。
 * @property {KnowledgeGraph.NodeStyle} [defaultNode] - 默认状态下节点的配置，比如 type, size, color。会被写入的 data 覆盖。
 * @property {KnowledgeGraph.EdgeStyle} [defaultEdge] - 默认状态下边的配置，比如 type, size, color。会被写入的 data 覆盖。
 * @property {KnowledgeGraph.NodeStyle} [nodeHighlightStyle] - 鼠标移入节点高亮样式。默认样式：{strokeColor: 'blue',stroke: 10, opacity: 0.8}。
 * @property {KnowledgeGraph.EdgeStyle} [edgeHighlightStyle] - 鼠标移入边高亮样式。默认样式：{strokeColor: 'blue',stroke: 10, opacity: 0.8}。
 * @property {boolean} [highlightNode = true] - 鼠标移入是否高亮节点。
 * @property {boolean} [highlightEdge = true] - 鼠标移入是否高亮边。
 * @property {boolean} [showToolBar = true] - 是否打开工具条， 包含放大，缩小，切换到实际大小功能。
 * @property {boolean} [showContextMenu = true] - 是否打开节点的右键菜单， 包含展开\折叠、隐藏功能。
 * @property {boolean} [dragCanvas = true] - 是否可以拖拽canvas。
 * @property {boolean} [zoomCanvas = true] - 是否可以缩放canvas。
 * @property {boolean} [dragNode = true] - 是否可以拖拽node节点。
 * @property {number} [nodeLabelMaxWidth] - node节点的标签开启省略号配置项，大于该宽度使用省略号。
 */

/**
 * @typedef {Object} KnowledgeGraph.Layout - 布局。
 * @property {string} [type='fruchterman'] - 布局类型， 可选值：['fruchterman']。 默认'fruchterman'。
 */

/**
 * @typedef {Object} KnowledgeGraph.Node - node节点配置项。
 * @property {string} id - 元素的标识 ID，必须是唯一的 string
 * @property {string} [category] - 分类。
 * @property {number} [x] - x坐标。
 * @property {number} [y] - y坐标。
 * @property {number} [size=20] - 节点的大小。
 * @property {Array.<number>|number} [anchorPoints=20] - 指定边连入节点的连接点的位置（相对于该节点而言），可以为空。例如: [0, 0]，代表节点左上角的锚点，[1, 1],代表节点右下角的锚点。
 * @property {string} [type] - 元素的类型，不传则使用默认值，节点默认类型为 'circle'。可选值['circle','rect','ellipse','diamond', 'image']
 * @property {string} [label] - 元素的文本标签，有该字段时默认会渲染 label 。
 * @property {KnowledgeGraph.NodeLabelCfg} [labelCfg] - 元素文本标签的配置项，详见各子模块内容。
 * @property {KnowledgeGraph.NodeStyle} [style] - 样式属性。
 */

/**
 * @typedef {Object} KnowledgeGraph.Edge - edge边配置项。
 * @property {string} [source] -起始点 id 。
 * @property {string} [target] - 结束点 id 。
 * @property {number} [sourceAnchor] - 边的起始节点上的锚点的索引值。
 * @property {number} [targetAnchor] - 边的终止节点上的锚点的索引值。
 * @property {string} [type='line'] - 指定边的类型，可以是内置边的类型名称，也可以是自定义边的名称。默认为 'line'。可选值['line','arc','polyline','quadratic']。
 * @property {string} [label] - 文本文字，如果没有则不会显示。
 * @property {KnowledgeGraph.EdgeLabelCfg} [labelCfg] - 配置标签文本。
 * @property {KnowledgeGraph.EdgeStyle} [style] - 通过 style 配置来修改边的填充色、边框颜色、阴影等属性，具体配置属性见：图形样式属性。
 */

/**
 * @typedef {Object} KnowledgeGraph.NodeLabelCfg - node节点配置项。
 * @property {string} [position] - 文本相对于节点的位置，目前支持的位置有：'center'，'top'，'left'，'right'，'bottom'。默认为 'center'。modelRect 节点不支持该属性。
 * @property {KnowledgeGraph.TextStyle} [style] - 标签的样式属性。
 * @property {number} [offset] - 文本的偏移，position 为 'bottom' 时，文本的上方偏移量；position 为 'left' 时，文本的右方偏移量；以此类推在其他 position 时的情况。modelRect 节点的 offset 为左边距。
 */

/**
 * @typedef {Object} KnowledgeGraph.NodeStyle - 节点样式通用配置项。
 * @property {string} [fill] - 	节点填充色。
 * @property {string} [stroke] - 节点的描边颜色。
 * @property {number} [lineWidth] - 描边宽度。
 * @property {Array.<number>} [lineDash] -描边虚线，数组代表实、虚长度。
 * @property {number} [fillOpacity] - 	设置填充的 alpha 或透明值。
 * @property {string} [shadowColor] - 阴影颜色。
 * @property {number} [shadowBlur] -	阴影范围。
 * @property {number} [shadowOffsetX] - 阴影 x 方向偏移量。
 * @property {number} [shadowOffsetY] - 阴影 y 方向偏移量。
 * @property {number} [opacity] - 设置绘图的当前 alpha 或透明值。
 * @property {string} [cursor] - 鼠标在该边上时的鼠标样式，CSS 的 cursor 选项都支持。
 */
/**
 * @typedef {Object} KnowledgeGraph.TextStyle - 文本样式。
 * @property {string} [textAlign] - 设置文本内容的当前对齐方式。支持的属性：center / end / left / right / start，默认值为 start。
 * @property {string} [textBaseline] - 设置在绘制文本时使用的当前文本基线。支持的属性:top / middle / bottom / alphabetic / hanging。默认值为 bottom。
 * @property {string} [fontStyle] - 字体样式。对应 font-style。
 * @property {string} [fontVariant] - 设置为小型大写字母字体。对应 font-variant。
 * @property {number} [fontWeight] - 字体粗细。对应 font-weight。
 * @property {number} [fontSize] - 字体大小。对应 font-size， 边标签文本默认大小是7。
 * @property {string} [fontFamily] - 字体系列。对应 font-family。
 * @property {number} [lineHeight] - 行高。对应 line-height。
 */

/**
 * @typedef {Object} KnowledgeGraph.EdgeLabelCfg - node节点配置项。
 * @property {string} [position] - 文本相对于边的位置，目前支持的位置有：'start'，'middle'，'end'。默认为'middle'。
 * @property {number} [refX] - 标签在 x 方向的偏移量。
 * @property {number} [refY] -标签在 y 方向的偏移量。
 * @property {boolean} [autoRotate=true] - 标签文字是否跟随边旋转，默认： true。
 * @property { KnowledgeGraph.TextStyle} [style] - 标签的样式属性，默认： {fontSize: 3,fill: '#333'}。
 */

/**
 * @typedef {Object} KnowledgeGraph.EdgeStyle - 边样式通用配置项。
 * @property {string} [stroke] - 边的颜色。
 * @property {number} [lineWidth] - 边宽度。
 * @property {number} [lineAppendWidth] -边响应鼠标事件时的检测宽度，当 lineWidth 太小而不易选中时，可以通过该参数提升击中范围。
 * @property {boolean|Object} [endArrow=true] - 为 true 时在边的结束端绘制默认箭头，为 false 时不绘制结束端箭头, 默认值{path: 'M 0,0 L 2,1 L 2,-1 Z'}
 * @property {boolean|Object} [startArrow] - 为 true 时在边的开始端绘制默认箭头，为 false 时不绘制结束端箭头。
 * @property {number} [strokeOpacity] - 边透明度。
 * @property {string} [shadowColor] - 阴影颜色。
 * @property {number} [shadowBlur] - 阴影模糊程度。
 * @property {number} [shadowOffsetX] - 阴影 x 方向偏移量。
 * @property {number} [shadowOffsetY] - 阴影 y 方向偏移量。
 * @property {Array.<number>} [lineDash] - 设置线的虚线样式，可以指定一个数组。一组描述交替绘制线段和间距（坐标空间单位）长度的数字。 如果数组元素的数量是奇数， 数组的元素会被复制并重复。例如， [5, 15, 25] 会变成 [5, 15, 25, 5, 15, 25]。
 * @property {string} [cursor] - 鼠标在该边上时的鼠标样式，CSS 的 cursor 选项都支持。
 */
/**
 * @typedef {Object} KnowledgeGraph.AnimateConfig - 动画配置项。
 * @property {number} [duration= 500] - 一次动画的时长。
 * @property {string} [easing='linearEasing'] - 动画函数。
 * @property {number} [delay=0] - 是否重复执行动画。
 * @property {boolean} [repeat=false] - 边透明度。
 * @property {string} [shadowColor] - 阴影颜色。
 */

class KnowledgeGraph {
  constructor(config, type = 'G6') {
    /**
     * @member {string} KnowledgeGraph.prototype.graph
     * @description graph实例。
     */
    this.graph = null;
    this.config = lodash_clonedeep_default()(config);
    this.graphRender = null;
    this.type = type;
    this.createGraphRender(this.type);
    this.config = this.graphRender._getGraphConfig(this.config);
    this.createGraph(this.config);
    this.CLASS_NAME = 'SuperMap.KnowledgeGraph';
  }

  /**
   * @function KnowledgeGraph.dataFromGraphMap
   * @description 将iServer GraphMap数据转换成KnowledgeGraph数据。
   * @param {Object} queryResult - iServer知识图谱服务query数据。
   * @param {Object} graphMap - iServer知识图谱服务GraphMap数据(data.graphMap)。
   * @return {KnowledgeGraph.Data} 返回数据。
   */
  static dataFromGraphMap(queryResult, graphMap) {
    return transformGraphMap(queryResult, graphMap);
  }

  /**
   * @function KnowledgeGraph.dataFromKnowledgeGraphQuery
   * @description 将iServer KnowledgeGraphService query数据转换成KnowledgeGraph数据。
   * @param {Object} queryResult - iServer知识图谱服务query数据。
   * @return {KnowledgeGraph.Data} 返回数据。
   */
  static dataFromKnowledgeGraphQuery(queryResult) {
    return transformGraphMap(queryResult);
  }

  /**
   * @function KnowledgeGraph.prototype.handleNodeStatus
   * @description 展开、折叠、隐藏节点
   * @param {Object} data - 展开 折叠 隐藏的对象, eg: {expand:['id1'], collapse:['id2'], hidden:['id3']}
   */
  handleNodeStatus(data) {
    const { expand, collapse, hidden } = data;
    // 解析expand参数,里面的节点再执行一次查询显示出来
    this.expandNodes(expand);
    // 解析collapse参数,折叠这个里面的节点
    this.collapseNodes(collapse);
    // 解析hidden，隐藏这个里面额的节点
    this.hideNodes(hidden);
  }

  /**
   * @function KnowledgeGraph.prototype.expandNodes
   * @description 展开节点。
   * @param {Array.<string>} expandData - 元素 ID 数组。
   */
  expandNodes(expandData) {
    if (!expandData) {
      return;
    }
    expandData.forEach((item) => {
      this.expandNode(item + '');
    });
  }

  /**
   * @function KnowledgeGraph.prototype.collapseNodes
   * @description 折叠节点。
   * @param {Array.<string>} collapseData - 元素 ID 数组。
   */
  collapseNodes(collapseData) {
    if (!collapseData) {
      return;
    }
    collapseData.forEach((item) => {
      this.collapseNode(item + '');
    });
  }

  /**
   * @function KnowledgeGraph.prototype.hideNodes
   * @description 隐藏节点。
   * @param {Array.<string>} hiddenData - 元素 ID 数组。
   */
  hideNodes(hiddenData) {
    if (!hiddenData) {
      return;
    }
    hiddenData.forEach((item) => {
      this.hideItem(item + '');
    });
  }

  /**
   * @function KnowledgeGraph.prototype.createGraphRender
   * @description 创建KnowledgeGraphRender
   * @param {string} type -类型， 默认是G6。
   * @private
   */
  createGraphRender(type) {
    if (type === 'G6') {
      this.graphRender = new G6Render();
    }
  }

  /**
   * @function KnowledgeGraph.prototype.createGraph
   * @description 创建KnowledgeGraph的guaph实例。
   * @param {Object} config - graph配置项。
   * @returns {Object} graph实例。
   */
  createGraph(config) {
    const graph = this.initGraph(config);
    this.graph = graph;
    this.autoResize();
    return graph;
  }

  /**
   * @function KnowledgeGraph.prototype.getGraph
   * @description 获取KnowledgeGraph的guaph实例。
   * @returns {Object} graph实例。
   */
  getGraph() {
    return this.graph;
  }

  /**
   * @function KnowledgeGraph.prototype.autoResize
   * @description 浏览器窗口大小发生改变时，重新设置canvas画布的大小，重新渲染。
   */
  autoResize() {
    if (this.config && this.config.autoResize !== false) {
      this.graphRender.autoResize();
    }
  }

  /**
   * @function KnowledgeGraph.prototype.zoom
   * @description 改变视口的缩放比例，在当前画布比例下缩放，是相对比例。
   * @param {number} ratio 缩放比例。
   * @param {Object} [center] 以 center 的 x、y 坐标为中心缩放，如果省略了 center 参数，则以元素当前位置为中心缩放。
   * @param {boolean} [animate] 是否开启动画。
   * @param {KnowledgeGraph.AnimateConfig} [animateCfg] 若带有动画，可配置动画。若未配置，则跟随 graph 的 animateCfg 参数。
   */
  zoom(ratio, center, animate, animateCfg) {
    this.graphRender.zoom(ratio, center, animate, animateCfg);
  }

  /**
   * @function KnowledgeGraph.prototype.zoomTo
   * @description 改变视口的缩放比例，在当前画布比例下缩放，是相对比例。
   * @param {number} ratio 缩放比例。
   * @param {Object} [center] 以 center 的 x、y 坐标为中心缩放，如果省略了 center 参数，则以元素当前位置为中心缩放。
   * @param {boolean} [animate] 是否开启动画。
   * @param {KnowledgeGraph.AnimateConfig} [animateCfg] 若带有动画，可配置动画。若未配置，则跟随 graph 的 animateCfg 参数。
   */
  zoomTo(ratio, center, animate, animateCfg) {
    this.graphRender.zoomTo(ratio, center, animate, animateCfg);
  }

  /**
   * @function KnowledgeGraph.prototype.fitView
   * @description 让画布内容适应视口。
   * @param {Array.<number>|number} [padding] [top, right, bottom, left] 四个方向上的间距值。
   * @param {Object} [rules] fitView 的规则，参数如下：{ onlyOutOfViewPort?: boolean; direction?: 'x' / 'y' / 'both'; ratioRule?: 'max' / 'min}。
   * @param {boolean} [animate] 是否开启动画。
   * @param {KnowledgeGraph.AnimateConfig} [animateCfg] 若带有动画，可配置动画。若未配置，则跟随 graph 的 animateCfg 参数。
   */
  fitView(padding, rules, animate, animateCfg) {
    this.graphRender.fitView(padding, rules, animate, animateCfg);
  }

  /**
   * @function KnowledgeGraph.prototype.fitCenter
   * @description 平移图到中心将对齐到画布中心，但不缩放。优先级低于 fitView。
   * @param {boolean} [animate] 是否开启动画。
   * @param {KnowledgeGraph.AnimateConfig} [animateCfg] 若带有动画，可配置动画，参见基础动画教程。若未配置，则跟随 graph 的 animateCfg 参数。
   */
  fitCenter(animate, animateCfg) {
    this.graphRender.fitCenter(animate, animateCfg);
  }

  /**
   * @function KnowledgeGraph.prototype.getGraphCenterPoint
   * @description 获取图内容的中心绘制坐标。
   * @return {Object} 包含的属性：x 和 y 属性，分别表示渲染坐标下的 x、y 值。
   */
  getGraphCenterPoint() {
    return this.graphRender.getGraphCenterPoint();
  }

  /**
   * @function KnowledgeGraph.prototype.getViewPortCenterPoint
   * @description 获取窗口的中心绘制坐标。
   * @return {Object} 包含的属性：x 和 y 属性，分别表示渲染坐标下的 x、y 值。
   */
  getViewPortCenterPoint() {
    return this.graphRender.getViewPortCenterPoint();
  }

  /**
   * @function KnowledgeGraph.prototype.getZoom
   * @description 获取当前视口的缩放比例。
   * @return {number} 返回值表示当前视口的缩放比例， 默认值为 1。
   */
  getZoom() {
    return this.graphRender.getZoom();
  }

  /**
   * @function KnowledgeGraph.prototype.getMinZoom
   * @description 获取 graph 当前允许的最小缩放比例。
   * @return {number} 返回值表示当前视口的最小缩放比例。
   */
  getMinZoom() {
    return this.graphRender.getMinZoom();
  }

  /**
   * @function KnowledgeGraph.prototype.setMinZoom
   * @description 设置 graph 当前允许的最小缩放比例。
   * @param {number} ratio 缩放比例。
   */
  setMinZoom(ratio) {
    this.graphRender.setMinZoom(ratio);
  }

  /**
   * @function KnowledgeGraph.prototype.getMaxZoom
   * @description 获取 graph 当前允许的最大缩放比例。
   * @return {number} 返回值表示当前视口的最大缩放比例。
   */
  getMaxZoom() {
    return this.graphRender.getMaxZoom();
  }

  /**
   * @function KnowledgeGraph.prototype.setMaxZoom
   * @description 设置 graph 当前允许的最大缩放比例。
   * @param {number} ratio 缩放比例。
   */
  setMaxZoom(ratio) {
    this.graphRender.setMaxZoom(ratio);
  }

  /**
   * @function KnowledgeGraph.prototype.getWidth
   * @description获取 graph 当前的宽度。
   * @return {number} graph 当前的宽度。
   */
  getWidth() {
    return this.graphRender.getWidth();
  }

  /**
   * @function KnowledgeGraph.prototype.getHeight
   * @description 获取 graph 当前的高度。
   * @return {number} graph 当前的高度。
   */
  getHeight() {
    return this.graphRender.getHeight();
  }

  /**
   * @function KnowledgeGraph.prototype.initGraph
   * @description 创建KnowledgeGraph实例
   * @param {Object} config - graph配置项。
   * @returns {Object} graph实例。
   */
  initGraph(config) {
    const graph = this.graphRender.initGraph(config);
    this.graph = graph;
    const cb = () => {
      if (this.config.zoom !== undefined) {
        this.zoom(this.config.zoom);
      }
      if (this.config.center !== undefined) {
        this.graphRender.setCenter({ x: this.config.center[0], y: this.config.center[1] });
      }
    };
    this.graph.on('beforelayout', cb);
    return graph;
  }

  /**
   * @function KnowledgeGraph.prototype.setData
   * @description 设置默认数据
   * @param {KnowledgeGraph.Data} data - graph数据。
   * @param {Object} [graph = this.graph] - graph实例。
   */
  setData(data, graph = this.graph) {
    data = data || { nodes: [], edges: [] };
    if (this.config && this.config.nodeLabelMaxWidth) {
      data.nodes = this.nodeLabelOpenEllipsis(this.config.nodeLabelMaxWidth, data.nodes);
    }
    this.graphRender.setData(data, graph);
    this.render(graph); // 渲染图
    this.data = data;
  }

  /**
   * @function KnowledgeGraph.prototype.render
   * @description 根据提供的数据渲染视图。
   * @param {Object} [graph = this.graph] - graph实例。
   */
  render(graph = this.graph) {
    graph && this.graphRender.render(graph);
  }

  /**
   * @function KnowledgeGraph.prototype.updateGraph
   * @description 更新数据
   * @param {KnowledgeGraph.Data} data - graph数据。
   * @param {Object} [graph = this.graph] - graph实例。
   */
  updateGraph(data, graph = this.graph) {
    graph && this.graphRender.updateGraph(data, graph);
  }

  /**
   * @function KnowledgeGraph.prototype.refresh
   * @description 改变画布大小。
   */
  refresh() {
    return this.graphRender.refresh();
  }

  /**
   * @function KnowledgeGraph.prototype.changeSize
   * @description 改变画布大小。
   * @param {number} width - 宽度。
   * @param {number} height - 高度。
   */
  changeSize(width, height) {
    return this.graphRender.changeSize(width, height);
  }

  /**
   * @function KnowledgeGraph.prototype.resize
   * @description 改变画布大小后，重新渲染。
   * @param {number} width - 宽度。
   * @param {number} height - 高度。
   */
  resize(width, height) {
    this.graphRender.changeSize(width, height);
    this.graphRender.refresh();
  }

  /**
   * @function KnowledgeGraph.prototype.getContainer
   * @description 获取 Graph 的 DOM 容器。
   * @return {HTMLElement} DOM 容器。
   */
  getContainer() {
    return this.graphRender.getContainer();
  }

  /**
   * @function KnowledgeGraph.prototype.getCanvas
   * @description 获取canvas。
   * @return {HTMLElement} canvas。
   */
  getCanvas() {
    return this.graphRender.getCanvas();
  }

  /**
   * @function KnowledgeGraph.prototype.getNodes
   * @description 获取图中所有节点的实例。
   * @return {Array} 返回值表示图中所有节点的实例。
   */
  getNodes() {
    return this.graphRender.getNodes();
  }

  /**
   * @function KnowledgeGraph.prototype.getEdges
   * @description 获取图中所有节点的实例。这里返回的是边的实例，而不是边的数据项。
   * @return {Array} 返回值表示图中所有边的实例。
   */
  getEdges() {
    return this.graphRender.getEdges();
  }

  /**
   * @function KnowledgeGraph.prototype.getNeighbors
   * @description 获取邻居节点数组。
   * @param {string | INode} node - 节点 ID 或节点实例。
   * @param {string | undefined} type - ['source'| 'target' | undefined]	邻居类型， 'source' 只获取当前节点的源节点，'target' 只获取当前节点指向的目标节点， 若不指定则返回所有类型的邻居。
   * @return {Array} 返回值符合要求的节点数组。
   */
  getNeighbors(node, type) {
    return this.graphRender.getNeighbors(node, type);
  }

  /**
   * @function KnowledgeGraph.prototype.findById
   * @description 根据 ID，查询对应的元素实例。
   * @param {string} id -	元素 ID。
   * @return {Object} 如果有符合规则的元素实例，则返回第一个匹配的元素实例，否则返回 undefined 。
   */
  findById(id) {
    return this.graphRender.findById(id);
  }

  /**
   * @function KnowledgeGraph.prototype.find
   * @description 获取邻居节点数组。
   * @param {string} type - 元素类型，可选值为 'node'、'edge'
   * @param {Function} fn -	查找的规则。
   * @return {Object} 如果有符合规则的元素实例，则返回第一个匹配的元素实例，否则返回 undefined 。
   */
  find(type, fn) {
    return this.graphRender.find(type, fn);
  }
  /**
   * @function KnowledgeGraph.prototype.findAll
   * @description 获取邻居节点数组。
   * @param {string} type - 元素类型，可选值为 'node'、'edge'。
   * @param {Function} fn - 查找的规则。
   * @return {Object} 如果有符合规则的元素实例，则返回所有元素实例，否则返回 undefined。
   */
  findAll(type, fn) {
    return this.graphRender.findAll(type, fn);
  }

  /**
   * @function KnowledgeGraph.prototype.getEdgesByNode
   * @description 获取与当前节点有关联的所有边。
   * @param {Object} node - node实例。
   * @return {Array} edge实例数组。
   */
  getEdgesByNode(node) {
    return this.graphRender.getEdgesByNode(node);
  }

  /**
   * @function KnowledgeGraph.prototype.getInEdges
   * @description 获取与当前节点关联的所有入边。
   * @param {Object} node - node实例。
   * @return {Array} edge实例数组。
   */
  getInEdges(node) {
    return this.graphRender.getInEdges(node);
  }

  /**
   * @function KnowledgeGraph.prototype.getOutEdges
   * @description 获取与当前节点关联的所有出边。
   * @param {Object} node - node实例。
   * @return {Array} edge实例数组。
   */
  getOutEdges(node) {
    return this.graphRender.getOutEdges(node);
  }

  /**
   * @function KnowledgeGraph.prototype.getSourceByEdge
   * @description 获取当前边的起始节点
   * @param {Object} edge - node实例。
   * @return {Object} 返回值为起始节点的实例。
   */
  getSourceByEdge(edge) {
    return this.graphRender.getSourceByEdge(edge);
  }

  /**
   * @function KnowledgeGraph.prototype.getTargetByEdge
   * @description 获取当前边的终止节点。
   * @param {Object} edge - node实例。
   * @return {Object} 终止节点的实例。
   */
  getTargetByEdge(edge) {
    return this.graphRender.getTargetByEdge(edge);
  }

  /**
   * @function KnowledgeGraph.prototype.expandNode
   * @description 展开当前节点。
   * @param {string} id - 元素 ID。
   */
  expandNode(id) {
    const item = this.findById(id);
    item && this.graphRender.expandNode(item);
  }

  /**
   * @function KnowledgeGraph.prototype.collapseNode
   * @description 收起当前节点。
   * @param {string} id - 元素 ID。
   */
  collapseNode(id) {
    const item = this.findById(id);
    item && this.graphRender.collapseNode(item);
  }

  /**
   * @function KnowledgeGraph.prototype.showItem
   * @description 显示指定的元素。若 item 为节点，则相关边也会随之显示。而show() 则将只显示自身。
   * @param {string|Object} item - 元素 ID 或元素实例。
   * @param {boolean} [stack] - 	操作是否入 undo & redo 栈，当实例化 Graph 时设置 enableStack 为 true 时，默认情况下会自动入栈，入栈以后，就支持 undo & redo 操作，如果不需要，则设置该参数为 false 即可。
   */
  showItem(item, stack) {
    this.graphRender.showItem(item, stack);
  }

  /**
   * @function KnowledgeGraph.prototype.hideItem
   * @description 隐藏指定元素。若 item 为节点，则相关边也会随之隐藏。而 hide() 则将只隐藏自身。
   * @param {string|Object} item - 元素 ID 或元素实例。
   * @param {boolean} [stack] -操作是否入 undo & redo 栈，当实例化 Graph 时设置 enableStack 为 true 时，默认情况下会自动入栈，入栈以后，就支持 undo & redo 操作，如果不需要，则设置该参数为 false 即可。
   */
  hideItem(item, stack) {
    this.graphRender.hideItem(item, stack);
  }

  /**
   * @function KnowledgeGraph.prototype.show
   * @description 显示元素。只显示 item 自身，若需要在显示节点的同时显示相关边，应调用showItem(item)。
   * @param {Object} item - 元素实例。
   */
  show(item) {
    this.graphRender.show(item);
  }

  /**
   * @function KnowledgeGraph.prototype.hide
   * @description 隐藏元素。只隐藏 item 自身，若需要在隐藏节点的同时隐藏相关边，应调用 hideItem(item)。
   * @param {Object} item - 元素实例。
   */
  hide(item) {
    this.graphRender.hide(item);
  }

  /**
   * @function KnowledgeGraph.prototype.changeVisibility
   * @description 更改元素是否显示。
   * @param {Object} item - 元素实例。
   * @param {boolean} visible - 是否显示元素，true 为显示，false 为隐藏。
   */
  changeVisibility(item, visible) {
    this.graphRender.changeVisibility(item, visible);
  }

  /**
   * @function KnowledgeGraph.prototype.isVisible
   * @description 查询元素显示状态。
   * @param {Object} item - 元素实例。
   * @return {boolean} - 返回值为 true，则表示当前元素处于显示状态，否则处于隐藏状态。
   */
  isVisible(item) {
    return this.graphRender.isVisible(item);
  }

  /**
   * @function KnowledgeGraph.prototype.getModel
   * @description 获取元素的数据模型。
   * @param {Object} item - 元素实例。
   * @return {Object} - 返回值为节点的数据模型。
   */
  getModel(item) {
    return this.graphRender.getModel(item);
  }

  /**
   * @function KnowledgeGraph.prototype.addItem
   * @description 新增元素（节点和边）。
   * @param {string} type - 元素类型，可选值为 'node'、'edge'。
   * @param {Object} model - 元素的数据模型，具体内容参见元素配置项。
   */
  addItem(type, model) {
    return this.graphRender.addItem(type, model);
  }

  /**
   * @function KnowledgeGraph.prototype.removeItem
   * @description 删除元素。
   * @param {string|Object} item - 	元素 ID 或元素实例。
   */
  removeItem(item) {
    return this.graphRender.removeItem(item);
  }

  /**
   * @function KnowledgeGraph.prototype.updateItem
   * @description 更新元素，包括更新数据、样式等。
   * @param {string|Object} item - 元素 ID 或元素实例。
   * @param {Object} model - 元素的数据模型，具体内容参见元素配置项。
   */
  updateItem(item, model) {
    return this.graphRender.updateItem(item, model);
  }

  /**
   * @function KnowledgeGraph.prototype.refreshItem
   * @description 刷新指定元素。
   * @param {string|Object} item - 元素 ID 或元素实例。
   */
  refreshItem(item) {
    return this.graphRender.refreshItem(item);
  }

  /**
   * @function KnowledgeGraph.prototype.refreshPositions
   * @description 当节点位置发生变化时，刷新所有节点位置，并重计算边的位置。
   */
  refreshPositions() {
    return this.graphRender.refreshPositions();
  }

  /**
   * @function KnowledgeGraph.prototype.on
   * @description graph监听事件
   * @param {string} eventName - 事件名，可选事件名参见： Node交互事件名、Edge交互事件名、Canvas交互事件名 时机事件
   * 通用事件名： click  dbclick mouseenter mousemove mouseout mouseover mouseleave mousedown mouseup contextmenu dragstart drag dragend dragenter dragleave drop keydown keyup wheel touchstart touchmove touchend
   * Node交互事件名： node:通用事件名， 例如 node:click
   * Edge交互事件名： edge:通用事件名， 例如 edge:click
   * Canvas交互事件名： canvas:通用事件名，例如 canvas:click
   * 时机事件：用于监听图的某方法调用前后的时机。
   * beforerender 调用 render 方法之前触发
   * afterrender 调用 render 方法之后触发
   * beforeadditem 	调用 addItem 方法之前触发
   * afteradditem 调用 addItem 方法之后触发
   * beforeremoveitem 调用 removeItem 方法之前触发
   * afterremoveitem 调用 removeItem 方法之后触发
   * beforeupdateitem 调用 updateItem  方法之前触发
   * afterupdateitem 调用 updateItem 方法之后触发
   * beforegraphrefresh 调用 refresh  方法之前触发
   * aftergraphrefresh 调用 refresh  方法之后触发
   * beforelayout	布局前触发。调用 graph.render 时会进行布局，因此 render 时会触发。或用户主动调用图的 graph.layout 时触发
   * afterlayout	布局完成后触发。调用 graph.render 时会进行布局，因此 render 时布局完成后会触发。或用户主动调用图的 graph.layout 时布局完成后触发
   * viewportchange 调用 graph.moveTo 或 graph.zoom 均会触发该事件
   * @param {Function} handler -	监听函数。
   */
  on(eventName, handler) {
    this.graphRender.on(eventName, handler);
  }

  /**
   * @function KnowledgeGraph.prototype.off
   * @description graph关闭事件。
   * @param {string} eventName - 事件名，参考on方法的事件名。
   * @param {Function} handler -	监听函数。
   */
  off(eventName, handler) {
    this.graphRender.off(eventName, handler);
  }

  /**
   * @function KnowledgeGraph.prototype.toDataURL
   * @description 转换成图片。
   * @param {string} type - 图片类型 'image/png' / 'image/jpeg' / 'image/webp' / 'image/bmp'。
   * @param {string} [backgroundColor] - 图片的背景色，可选，不传值时将导出透明背景的图片。
   * @return {string} 返回值表示生成的图片的 URL。
   */
  toDataURL(type, backgroundColor) {
    this.graphRender.toDataURL(type, backgroundColor);
  }

  /**
   * @function KnowledgeGraph.prototype.nodeLabelOpenEllipsis
   * @description 转换label的省略号。
   * @param {Object} nodeLabelMaxWidth - node节点标签是否开启省略号
   * @param {Object} nodes - graph的nodes数据。
   * @return {Array} nodes
   */
  nodeLabelOpenEllipsis(nodeLabelMaxWidth, nodes) {
    if (!nodes) {
      return [];
    }
    if (!nodeLabelMaxWidth) {
      return nodes;
    }
    return nodes.map((node) => {
      const fontSize =
        (node.labelCfg && node.labelCfg.fontSize) ||
        (this.defaultNode && this.defaultNode.labelCfg && this.defaultNode.labelCfg.fontSize) ||
        14;
      node.label = fittingStr(node.label, nodeLabelMaxWidth, fontSize);
      return node;
    });
  }

  /**
   * @function KnowledgeGraph.prototype.clear
   * @description 清除画布元素。
   * @param {Object} [graph = this.graph] - graph实例。
   */
  clear(graph = this.graph) {
    graph && graph.clear();
  }

  /**
   * @function KnowledgeGraph.prototype.destroy
   * @description 销毁画布。
   * @param {Object} [graph = this.graph] - graph实例。
   */
  destroy(graph = this.graph) {
    graph && graph.destroy();
  }
}

/**
 * @private
 * @description 大于最大宽度的字符串会返回带有省略号的字符串 xxx...。
 * @param {string} label - 需要处理的字符串。
 * @param {number} maxWidth - 最大宽度。
 * @param {number} fontSize - 字体大小。
 * @returns {string} 处理之后的字符串。
 */
function fittingStr(label, maxWidth, fontSize) {
  const calcLabelLength = (label) => {
    let len = 0;
    for (let i = 0; i < label.length; i++) {
      if (label.charCodeAt(i) > 0 && label.charCodeAt(i) < 128) {
        len++;
      } else {
        len += 2;
      }
    }
    return len;
  };
  const fontWidth = fontSize * 1; //字号+边距
  maxWidth = maxWidth * 1.6; // 需要根据自己项目调整
  const width = calcLabelLength(label) * fontWidth;
  const ellipsis = '…';
  if (width > maxWidth) {
    const len = Math.floor((maxWidth - 20) / fontWidth);
    const result = label.substring(0, len);
    if ((label.substring(len).length + ellipsis.length) * fontWidth > maxWidth) {
      return result + '\n' + label.substring(len, len + len - 2) + ellipsis;
    } else if (label.substring(len).length == 0) {
      return result;
    } else {
      return result + '\n' + label.substring(len);
    }
  } else {
    return label;
  }
}

;// CONCATENATED MODULE: ./src/mapboxgl/overlay/GraphMap.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/





/**
 * @class GraphMap
 * @classdesc 对接 iServer GraphMap。
 * @category iServer KnowledgeGraph
 * @version 11.1.0
 * @param {string} serverUrl - GraphMap服务地址， 例如：http://{iserver}/services/{knowledgeGraph-provider}/restjsr/graph/graphmaps/{graphmap}。
 * @param {Object} [options] - 参数。
 * @param {KnowledgeGraph.Config} [options.config] - KnowledgeGraph的配置项。
 * @param {string} [options.proxy] - 服务代理地址。
 * @param {boolean} [options.withCredentials=false] - 请求是否携带 cookie。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @fires GraphMap#loaded
 * @extends {mapboxgl.Evented}
 * @usage
 */
class GraphMap extends (external_mapboxgl_default()).Evented {
  constructor(serverUrl, options) {
    super(serverUrl, options);
    /**
     * @member GraphMap.prototype.graph
     * @description KnowledgeGraph的实例.
     *
     */
    this.graph = null;
    /**
     * @member GraphMap.prototype.EVENT_TYPES
     * @description 监听一个自定义事件可用如下方式:
     *
     * 支持的事件如下:
     * loaded - 渲染完成时触发。
     */
    this.EVENT_TYPES = ['loaded'];
    const graphMapName = serverUrl.split('/').pop();
    this.url = serverUrl.replace(`/graphmaps/${graphMapName}`, '');
    this.createGraphMap(graphMapName, options);
  }

  /**
   * @private
   * @function GraphMap.prototype.createGraphMap
   * @description 创建图谱。
   * @param {string} graphMapName - 图谱名称
   * @param {Object} options - 参数。
   * @param {string} [options.proxy] - 服务代理地址。
   * @param {boolean} [options.withCredentials=false] - 请求是否携带 cookie。
   * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
   * @param {Object} [options.headers] - 请求头。
   * @param {KnowledgeGraph.Config} [options.config] - knowledgegrah配置项。
   */
  async createGraphMap(graphMapName, options) {
    this.knowledgeGraphService = this.createKnowledgeGraphService(this.url, options);
    const res = await this.knowledgeGraphService.getGraphMapData(graphMapName);
    const result = KnowledgeGraph.dataFromGraphMap(res.data, res.graphMap);
    this.graph = new KnowledgeGraph(options && options.config);
    this.graph.on('beforelayout', () => {
      /**
       * @event GraphMap#loaded
       * @description 渲染完成时触发。
       */
      this.fire(this.EVENT_TYPES[0]);
    });
    this.graph.setData(result);
    this.graph.handleNodeStatus(transformExpandCollapseHiddenData(res.graphMap));
  }

  /**
   * @private
   * @function GraphMap.prototype.createKnowledgeGraphService
   * @description 创建KnowledgeGraphService实例。
   * @param {string} serverUrl - GraphMap服务地址， 例如：http://{iserver}/services/knowledgeGraph-test/restjsr/graph
   * @param {Object} options - 参数。
   * @param {string} [options.proxy] - 服务代理地址。
   * @param {boolean} [options.withCredentials=false] - 请求是否携带 cookie。
   * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
   * @param {Object} [options.headers] - 请求头。
   */
  createKnowledgeGraphService(serverUrl, options) {
    return new KnowledgeGraphService(serverUrl, options);
  }
}

;// CONCATENATED MODULE: ./src/mapboxgl/overlay/graphic/Graphic.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/




/**
 * @class Graphic
 * @classdesc 高效率点图层点要素类。
 * @category  Visualization Graphic
 * @param {(Object|Array.<number>)} lngLat - 坐标。格式：经纬度数组或包含{lng,lat}格式对象。
 * @param {Object} style - 图形参数。
 * @param {Array.<number>} [style.color] - 点颜色。目前只支持 rgba 数组。
 * @param {Object} [style.radius] - 点半径。
 * @param {Object} [attributes] - 属性信息。
 * @example
 * var graphic = new Graphic(
 *    {
 *         lng:116,
 *         lat:39
 *    },{
 *         color:[255,0,0],
 *         radius:30
 *    }
 * });
 * @usage
 */
class Graphic {
    constructor(lngLat, style, attributes) {

        this.lngLat = core_Util_Util.isArray(lngLat) ? {lng: lngLat[0], lat: lngLat[1]} : lngLat;
        this.style = core_Util_Util.extend({}, style);
        this.attributes = attributes;
    }
    /**
     * @function Graphic.prototype.getId
     * @description 获取当前 ID。
     * @returns {string} ID。
     */
    getId() {
        return this.id;
    }

    /**
     * @function Graphic.prototype.setId
     * @description 设置当前要素 ID。
     * @param {string} id - 要素 ID。
     */

    setId(id) {
        this.id = id;
    }

    /**
     * @function Graphic.prototype.getLngLat
     * @description 获取经纬度坐标。
     * @returns {Object} 经纬度坐标，数据格式{lng,lat}。
     */
    getLngLat() {
        return this.lngLat;
    }

    /**
     * @function Graphic.prototype.setLngLat
     * @description 设置经纬度坐标。
     * @param {Object} lngLat - 经纬度坐标，数据格式{lng,lat}。
     */
    setLngLat(lngLat) {
        this.lngLat = core_Util_Util.isArray(lngLat) ? {lng: lngLat[0], lat: lngLat[1]} : lngLat;
    }

    /**
     * @function Graphic.prototype.setStyle
     * @description 设置点样式。
     * @param {Object} style -样式选项。
     * @param {Array} [style.color] - 颜色。
     * @param {number} [style.radius] - 半径。
     */
    setStyle(style) {
        this.style = core_Util_Util.extend(this.style, style);
    }

    /**
     * @function Graphic.prototype.getStyle
     * @description 获取样式。
     * @returns {Object} 点样式。
     */
    getStyle() {
        return this.style;
    }

    /**
     * @function Graphic.prototype.setAttributes
     * @description 设置属性信息。
     * @param {Object} [attributes] - 属性信息。
     */
    setAttributes(attributes) {
        this.attributes = core_Util_Util.extend({}, this.attributes, attributes);
    }

    /**
     * @function Graphic.prototype.getAttributes
     * @description 获取属性信息。
     * @returns {Object} 属性信息。
     */
    getAttributes() {
        return this.attributes;
    }
}


;// CONCATENATED MODULE: ./src/mapboxgl/overlay/graphic/index.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/

;// CONCATENATED MODULE: ./src/mapboxgl/overlay/mapv/MapvDataSet.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/



var MapvDataSet = {

    /**
     * 返回mapv点数据集
     */
    getPoint: function (center) {
        if (center && (center instanceof Array)) {
            return new external_function_try_return_mapv_catch_e_return_namespaceObject.DataSet([{
                geometry: {
                    type: 'Point',
                    coordinates: center
                }
            }]);
        }
    },

    /**
     * 返回mapv多点数据集
     */
    getPoints: function (points) {
        if (points && (points instanceof Array)) {
            var mPoints = [];
            points.forEach(data => {
                mPoints.push({
                    geometry: {
                        type: 'Point',
                        coordinates: data.geometry.coordinates
                    }
                });
            });
            return new external_function_try_return_mapv_catch_e_return_namespaceObject.DataSet(mPoints);
        }
    },

    /**
     * 返回mapv弧形线数据集
     */
    getCurveLines: function (startPoint, LinePoints) {
        if (startPoint && (startPoint instanceof Array) && LinePoints && (LinePoints instanceof Array)) {
            var lineData = [];
            LinePoints.forEach(data => {
                var coords = data.geometry && data.geometry.coordinates;
                var toCenter = {lng: coords[0], lat: coords[1]};
                var fromCenter = {lng: startPoint[0], lat: startPoint[1]};
                var cv = external_function_try_return_mapv_catch_e_return_namespaceObject.utilCurve.getPoints([fromCenter, toCenter]);
                lineData.push({
                    geometry: {
                        type: 'LineString',
                        coordinates: cv
                    }
                });
            });
            return new external_function_try_return_mapv_catch_e_return_namespaceObject.DataSet(lineData);
        }
    },

    /**
     * 返回mapv弧形动态点数据集
     */
    getCurveDynamicPoints: function (center, endPoints) {
        if (center && (center instanceof Array) && endPoints && (endPoints instanceof Array)) {
            var timeData = [];
            endPoints.forEach(data => {
                var coords = data.geometry && data.geometry.coordinates;
                var toCenter = {lng: coords[0], lat: coords[1]};
                var fromCenter = {lng: center[0], lat: center[1]};
                var cv = external_function_try_return_mapv_catch_e_return_namespaceObject.utilCurve.getPoints([fromCenter, toCenter]);
                for (var j = 0; j < cv.length; j++) {
                    timeData.push({
                        geometry: {
                            type: 'Point',
                            coordinates: cv[j]
                        },
                        time: j
                    });
                }
            });
            return new external_function_try_return_mapv_catch_e_return_namespaceObject.DataSet(timeData);
        }
    }
};

;// CONCATENATED MODULE: ./src/mapboxgl/overlay/mapv/MapExtend.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/

var getDefaultVectorTileStyle = function (urlTemplate, options) {
    options = options || {};
    var defaultOptions = {};
    defaultOptions.version = options.version || 8;
    defaultOptions.layers = options.layers || [];
    defaultOptions.light = options.light || {
        "anchor": "viewport",
        "color": "#fcf6ef",
        "intensity": 0.5,
        "position": [1.15, 201, 20]
    };

    var style = {
        "version": defaultOptions.version,
        "sources": {
            "vector-tiles": {
                "type": "vector",
                "tiles": [urlTemplate]
            }
        },
        "layers": defaultOptions.layers,
        "light": defaultOptions.light
    };
    if (options.sprite != null) {
        style.sprite = options.sprite;
    }
    if (options.glyphs != null) {
        style.glyphs = options.glyphs;
    }
    return style;
};
var setBackground = function (map, color) {
    if (color && map) {
        map.addLayer({
            "id": "background",
            "type": "background",
            "paint": {
                "background-color": color
            }
        }, "background");
    }
};

var setPaintProperty = function (map, layerIds, type, paint, source, sourceLayers) {
    if (layerIds && map) {
        if (Object.prototype.toString.call(layerIds) !== '[object Array]') {
            layerIds = [layerIds];
        }
        for (var i = 0; i < layerIds.length; i++) {
            var sourceLayer = sourceLayers ? sourceLayers[i] : null;
            var layer = getLayer(layerIds[i], type, source, sourceLayer, paint);
            map.addLayer(layer, layerIds[i]);
            map.moveLayer(layerIds[i]);
        }
    }
};

function getLayer(id, type, source, sourceLayer, paint) {
    var sourceType = source || "vector-tiles";
    var sLayer = sourceLayer || id;
    var layer = {
        "id": id,
        "type": type,
        "source": sourceType,
        "source-layer": sLayer,
        "paint": paint
    };
    return layer;
}


;// CONCATENATED MODULE: ./src/mapboxgl/overlay/mapv/index.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


;// CONCATENATED MODULE: ./src/mapboxgl/overlay/theme/index.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/





;// CONCATENATED MODULE: ./src/mapboxgl/overlay/symbol/SingleSymbolRender.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/
/**
 * 单个符号
 * @returns {Object}
 * @private
 */
class SingleSymbolRender {
    constructor(map) {
        this.map = map;
    }

    /**
     * 符号转换成图层
     * @param {object} layer
     * @param {object} symbol
     * @param {string | undefined} before
     */
    addLayer(layer, symbol, before) {
        layer.paint && Object.assign(symbol.paint || {}, layer.paint);
        layer.layout && Object.assign(symbol.layout || {}, layer.layout);
        this.map.addLayerBySymbolBak({ ...layer, ...symbol }, before);
    }
}

/* harmony default export */ const symbol_SingleSymbolRender = (SingleSymbolRender);

;// CONCATENATED MODULE: ./src/mapboxgl/overlay/symbol/CompositeSymbolRender.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/



/**
 * 符号图层管理器
 * @returns {Object}
 * @private
 */
class CompositeSymbolRender {
    constructor(map) {
        this.map = map;
        this.singleSymbol = new symbol_SingleSymbolRender(map);
        this.layerIds = {};
    }

    /**
     * 符号转换成图层
     * @param {*} layer
     * @param {*} before
     */
    addLayer(layer, symbol, before) {
        symbol.forEach((style) => {
            const id = Util_Util.createUniqueID(`${layer.id}_compositeLayer_`);
            this.singleSymbol.addLayer({ ...layer, id }, style, before);
            this.addLayerId(layer.id, id);
        })
    }

    /**
     * 添加图层
     * @param {string} id
     * @param {string} childId
     */
    addLayerId(id, childId) {
        if (!this.layerIds[id]) {
            this.layerIds[id] = [];
        }
        !this.layerIds[id].includes(childId) && this.layerIds[id].push(childId);
    }

    /**
     * 删除图层
     * @param {string} id
     */
    removeLayerId(id) {
        delete this.layerIds[id];
    }

    /**
     * 获取图层
     * @param {string} id
     * @returns {Array}
     */
    getLayerIds(id) {
        return this.layerIds[id];
    }

    /**
     * 获取组合图层ID
     * @param {string} childId
     * @returns {string}
     */
    getLayerId(childId) {
        for (const id in this.layerIds) {
            if (this.layerIds[id].find(i => i === childId)) {
                return id;
            }
        }
    }
}

/* harmony default export */ const symbol_CompositeSymbolRender = (CompositeSymbolRender);

;// CONCATENATED MODULE: ./src/mapboxgl/overlay/symbol/SymbolManager.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/
class SymbolManager {

    constructor() {
        this.symbols = {};//addSymbol接口添加的symbol信息
        this.images = {};//在loadImage的时候存下image
    }

    addSymbol(id, symbol) {
        symbol.layout && delete symbol.layout.visibility;
        this.symbols[id] = symbol;
    }

    getSymbol(id) {
        return this.symbols[id] && JSON.parse(JSON.stringify(this.symbols[id]));
    }

    removeSymbol(id) {
        delete this.symbols[id];
    }

    addImageInfo(id, image) {
        this.images[id] = image;
    }

    getImageInfo(id) {
        return this.images[id];
    }
}

/* harmony default export */ const symbol_SymbolManager = (SymbolManager);


;// CONCATENATED MODULE: ./src/mapboxgl/overlay/symbol/SymbolUtil.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/
const SymbolUtil_LayerType = {
    circle: 'circle',
    symbol: 'symbol',
    line: 'line',
    fill: 'fill'
}

// 判断符号类型
const GET_TYPE_RULE = [{
    prefix: 'line-',
    type: SymbolUtil_LayerType.line
}, {
    prefix: 'fill-',
    type: SymbolUtil_LayerType.fill
}, {
    prefix: 'circle-',
    type: SymbolUtil_LayerType.circle
}];

function isMultiSymbol(symbol) {
    return symbol && symbol.length > 0;
}

/**
 * 获取不同图层类型使用image的属性名
 * @param {object} symbol 
 * @returns {object}
 * @private
 */
function getImageKey(symbol) {
    const symbolType = getSymbolType(symbol);
    const IMAGE_MAPBOX_KEY = {
        [SymbolUtil_LayerType.symbol]: {
            type: 'layout',
            name: 'icon-image'
        },
        [SymbolUtil_LayerType.line]: {
            type: 'paint',
            name: 'line-pattern'
        },
        [SymbolUtil_LayerType.fill]: {
            type: 'paint',
            name: 'fill-pattern'
        }
    }
    const result = IMAGE_MAPBOX_KEY[symbolType];
    return result;
}

/**
 * 通过符号属性获取该符号类型
 * @param {*} symbol 
 * @returns {string}
 * @private
 */
function getSymbolType(symbol) {
    const { paint = {}, layout = {} } = symbol;
    const keys = Object.keys(paint).concat(Object.keys(layout));
    let type;
    for (const v of GET_TYPE_RULE) {
        const isMatch = keys.some(k => k.startsWith(v.prefix));
        if (isMatch) {
            type = v.type;
            break;
        }
    }
    return type || SymbolUtil_LayerType.symbol;
}

const MAPBOX_EXPRESSION_FIRST_VALUE = [
    'array',
    'boolean',
    'collator',
    'format',
    'literal',
    'number',
    'object',
    'string',
    'to-boolean',
    'to-color',
    'to-number',
    'to-string',
    'typeof',
    'feature-state',
    'geometry-type',
    'id',
    'line-progress',
    'properties',
    'at',
    'get',
    'has',
    'length',
    '!',
    '!=',
    '<',
    '<=',
    '==',
    '>',
    '>=',
    'all',
    'any',
    'case',
    'match',
    'coalesce',
    'interpolate',
    'interpolate-hcl',
    'interpolate-lab',
    'step',
    'let',
    'var',
    'concat',
    'downcase',
    'is-supported-script',
    'resolved-locale',
    'upcase',
    'rgb',
    'rgba',
    '-',
    '*',
    '/',
    '%',
    '^',
    '+',
    'abs',
    'acos',
    'asin',
    'atan',
    'ceil',
    'cos',
    'e',
    'floor',
    'ln',
    'ln2',
    'log10',
    'log2',
    'max',
    'min',
    'pi',
    'round',
    'sin',
    'sqrt',
    'tan',
    'zoom',
    'heatmap-density'
];

/**
 * 是否为表达式
 * @param key
 * @param value
 * @returns boolean
 * @private
 */
function isMapboxExpression(value) {
    if (value && value.length > 0) {
        const [v] = value;
        return typeof v === 'string' && MAPBOX_EXPRESSION_FIRST_VALUE.includes(v);
    }
    return false;
}

function validateStyleKey(value) {
    return Object.keys(value).every(k => {
        return !isMapboxExpression(value[k]);
    });
}

function validateSymbol(symbol) {
    const symbolInfo = isMultiSymbol(symbol) ? symbol : [symbol];
    return symbolInfo.every((s) => {
        return validateStyleKey(s.paint || {}) && validateStyleKey(s.layout || {});
    });
}

const isPaintKey = (key) => {
    return [
        'icon-color',
        'icon-opacity',
        'icon-translate',
        'line-opacity',
        'line-blur',
        'line-translate',
        'line-color',
        'line-width',
        'line-offset',
        'line-dasharray',
        'line-pattern',
        'fill-color',
        'fill-opacity',
        'fill-pattern',
        'fill-outline-color',
        'text-color',
        'text-halo-blur',
        'text-halo-color',
        'text-halo-width',
        'text-opacity',
        'text-translate',
        'text-translate-anchor',
        'circle-blur',
        'circle-color',
        'circle-opacity',
        'circle-translate',
        'circle-radius',
        'circle-stroke-color',
        'circle-stroke-opacity',
        'circle-stroke-width'
    ].includes(key);
}
;// CONCATENATED MODULE: ./src/mapboxgl/overlay/symbol/SymbolHandler.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/






/**
 * 符号图层管理器
 * @returns {Object}
 * @private
 */
class SymbolHandler {

    constructor(map) {
        this.map = map;
        this.symbolManager = new symbol_SymbolManager();
        this.singleSymbolRender = new symbol_SingleSymbolRender(map);
        this.compositeSymbolRender = new symbol_CompositeSymbolRender(map);
        this._layerSymbols = {};// 图层与symbol的映射关系
    }

    _update(map) {
        this.map = map;
        return this;
    }

    /**
     * 添加符号图层
     * @param {Object} layer
     * @param {string} before
     */
    addLayer(layer, before) {
        if (typeof layer.symbol === 'string') {
            const id = layer.symbol;
            if (id) {
                const symbol = this.getSymbol(id);
                if (!symbol) {
                    return this.map.fire('error', {
                        error: new Error(`Symbol "${id}" could not be loaded. Please make sure you have added the symbol with map.addSymbol().`)
                    });
                }
                this.setSymbolTolayer(layer.id, id);
                this.getSymbolRender(symbol).addLayer(layer, symbol, before);
            }
        } else if (isMapboxExpression(layer.symbol)) {
            this.setSymbolTolayer(layer.id, layer.symbol);
            this.addExpressionLayer(layer, before);
        }
    }

    /**
     * 更新图层上的symbol
     * @param {string} layerId
     * @param {string | array} symbol
     */
    setSymbol(layerId, symbol) {
        const layers = this.map.getStyle().layers;
        const layerIndex = layers.findIndex(l => l.id === layerId);
        if (layerIndex === -1) {
            return this.map.fire('error', {
                error: new Error(`Cannot set symbol "${symbol}" to non-existing layer "${layerId}".`)
            });
        }
        this.map.removeLayer(layerId);
        const beforeId = layers[layerIndex + 1] && layers[layerIndex + 1].id;
        const layer = beforeId && this.map.style.getLayer(beforeId);
        const before = (layer && layer.id) || (beforeId && this.getFirstLayerId(beforeId));
        const orginLayer = layers[layerIndex];
        this.addLayer({ ...orginLayer, paint: {}, layout: {
            visibility: (orginLayer.layout && orginLayer.layout.visibility) || 'visible'
        }, symbol }, before);
    }

    /**
     * 处理match表达式为多个图层
     * @param {object} layer
     * @returns {array}
     */
    getMatchLayers(layer) {
        const layers = [];
        const filter = ["all"];
        if (layer.filter) {
            filter.push(layer.filter);
        }
        const defaultFilter = [];
        const expression = layer.symbol.slice(2);
        expression.forEach((r, index) => {
            if (index % 2 === 1) {
                layers.push({
                    ...layer, "filter": [
                        ...filter,
                        [
                            "==",
                            layer.symbol[1][1],
                            expression[index - 1]
                        ]
                    ], symbol: r
                });
                defaultFilter.push([
                    "!=",
                    layer.symbol[1][1],
                    expression[index - 1]
                ]);
            } else if (index === expression.length - 1) {
                layers.unshift({ ...layer, "filter": [
                    ...filter,
                    ...defaultFilter
                ], symbol: r });
            }
        });
        return layers;
    }

    /**
     * 处理match表达式为多个图层
     * @param {object} layer
     * @returns {array}
     */
    getCaseLayers(layer) {
        const layers = [];
        const filter = ["all"];
        if (layer.filter) {
            filter.push(layer.filter);
        }
        const defaultFilter = [];
        const expression = layer.symbol.slice(1);
        expression.forEach((r, index) => {
            if (index % 2 === 1) {
                layers.push({
                    ...layer, "filter": [
                        ...filter,
                        expression[index - 1]
                    ], symbol: r
                });
                defaultFilter.push(['!', expression[index - 1]])
            } else if (index === expression.length - 1) {
                layers.unshift({ ...layer, "filter": [
                    ...filter,
                    ...defaultFilter
                ], symbol: r });
            }
        });
        return layers;
    }

    /**
     * 将symbol表达式拆成filter
     * @param {object} layer
     * @param {string} before
     */
    addExpressionLayer(layer, before) {
        const rules = {
            match: this.getMatchLayers,
            case: this.getCaseLayers
        }
        const getLayersFn = rules[layer.symbol[0]];
        const layers = getLayersFn && getLayersFn(layer);
        if (!layers) {
            return this.map.fire('error', {
                error: new Error(`This expressions not supported`)
            });
        }
        layers.forEach((l) => {
            l.id = Util_Util.createUniqueID(`${layer.id}_compositeLayer_`);
            this.compositeSymbolRender.addLayerId(layer.id, l.id);
            this.addLayer(l, before);
        });
    }

    /**
     * 通过symbol判断使用管理器
     * @param {object | array} symbol
     * @returns {SingleSymbolRender | CompositeSymbolRender}
     */
    getSymbolRender(symbol) {
        return isMultiSymbol(symbol) ? this.compositeSymbolRender : this.singleSymbolRender;
    }

    /**
     * 将Web符号中的image添加到地图上
     * @param {object} symbol
     * @param {object} image
     */
    addSymbolImageToMap(symbol, image) {
        const { type, name } = getImageKey(symbol);
        const id = symbol[type] && symbol[type][name];
        if (id && !this.map.hasImage(id)) {
            // 如果需要使用到image 的需要addImage
            this.map.addImage(id, image);
            // 为了解决sdf问题，需要把load后的image信息存下
            this.symbolManager.addImageInfo(id, image);
        }
    }

    /**
     * 给指定图层添加symbol
     * @param {string} id
     * @param {object} symbol
     */
    addSymbol(id, symbol) {
        if (this.getSymbol(id)) {
            return this.map.fire('error', {
                error: new Error('An symbol with this name already exists.')
            });
        }
        if (validateSymbol(symbol)) {
            this.symbolManager.addSymbol(id, symbol);
        } else {
            return this.map.fire('error', {
                error: new Error('Symbol is not supported expressions.')
            });
        }
    }

    /**
     * 设置layer 对应的 symbol属性值
     * @param {string} layerId
     * @param {string | array} symbol
     */
    setSymbolTolayer(layerId, symbol) {
        this._layerSymbols[layerId] = symbol;
    }

    /**
     * 通过layerID获取symbol属性值
     * @param {string} layerId
     * @return {string | array} symbol
     */
    getLayerSymbol(layerId) {
        return this._layerSymbols[layerId];
    }

    /**
     * 判断是否有symbol
     * @return {boolean}
     */
    hasSymbol() {
        return Object.keys(this._layerSymbols).length > 0;
    }

    /**
     * 删除symbol
     * @param {string} id
     */
    removeSymbol(id) {
        this.symbolManager.removeSymbol(id);
    }

    /**
     * 通过symbolId获取symbol内容
     * @param {string} symbolId
     */
    getSymbol(symbolId) {
        return this.symbolManager.getSymbol(symbolId);
    }

    /**
     * 获取组合图层的子图层IDs
     * @param {string} layerId
     * @returns {array}
     */
    getLayerIds(layerId) {
        return this.compositeSymbolRender.getLayerIds(layerId) || [];
    }

    /**
     * 获取子图层ID对应的组合图层
     * @param {string} layerId
     * @returns {string}
     */
    getLayerId(layerId) {
        return this.compositeSymbolRender.getLayerId(layerId);
    }

    /**
     * 删除图层ID
     * @param {string} layerId
     * @returns {string}
     */
    removeLayerId(layerId) {
        return this.compositeSymbolRender.removeLayerId(layerId);
    }

    /**
     * 获取指定ID的layer
     * @param {string} layerId
     * @returns {object}
     */
    getLayer(layerId) {
        const layer = this.map.getLayerBySymbolBak(layerId);
        const symbol = this.getLayerSymbol(layerId);
        if (layer) {
            return symbol ? { ...layer, symbol } : layer;
        } else {
            const layerIds = this.getLayerIds(layerId);
            if (layerIds[0]) {
                const reallayer = this.map.getLayerBySymbolBak(layerIds[0]);
                return reallayer && { ...reallayer, symbol, id: layerId }
            }
        }
    }

    /**
     * 删除指定图层
     * @param {string} layerId
     */
    removeLayer(layerId) {
        const layerIds = this.getLayerIds(layerId);
        if (layerIds.length > 0) {
            layerIds.forEach(id => this.map.style.removeLayer(id));
            this.removeLayerId(layerId);
        } else {
            this.map.style.removeLayer(layerId);
        }
    }

    /**
     * 获取style
     * @returns {object}
     */
    getStyle() {
        const style = this.map.style.serialize();
        if (this.hasSymbol()) {
            style.layers = style.layers.reduce((pre, layer) => {
                const compositeId = this.getLayerId(layer.id);
                if (compositeId) {
                    !pre.find(l => l.id === compositeId) && pre.push({ ...layer, symbol: this.getLayerSymbol(compositeId), id: compositeId })
                } else if (this.getLayerSymbol(layer.id)) {
                    pre.push({ ...layer, symbol: this.getLayerSymbol(layer.id) })
                } else {
                    pre.push(layer);
                }
                return pre;
            }, []);
        }
        return style;
    }

    /**
     * 获取组合图层的子图层0 id
     * @param {string} layerId
     * @returns {string | undefined}
     */
    getFirstLayerId(layerId) {
        const layerIds = this.getLayerIds(layerId);
        return layerIds[0];
    }

    /**
     * 扩展map的moveLayer
     * @param {string} layerId
     * @param {string | undefined} beforeId
     */
    moveLayer(layerId, beforeId) {
        const layerIds = this.getLayerIds(layerId);
        const layer = beforeId && this.map.style.getLayer(beforeId);
        const realBeforeId = (layer && layer.id) || (beforeId && this.getFirstLayerId(beforeId));
        if (layerIds.length > 0) {
            layerIds.forEach(id => this.map.style.moveLayer(id, realBeforeId));
        } else {
            this.map.style.moveLayer(layerId, realBeforeId);
        }
    }

    /**
     * 扩展map的setFilter
     * @param {string} layerId
     * @param {Array} filter
     * @param {object} options
     */
    setFilter(layerId, filter, options) {
        const symbol = this.getLayerSymbol(layerId);
        if (isMapboxExpression(symbol)) {
            // 如果 symbol 是数据驱动，filter需要重新计算
            const realLayerId = this.getFirstLayerId(layerId);
            this.map.style.setFilter(realLayerId, filter, options);
            const symbol = this.getLayerSymbol(layerId);
            this.setSymbol(layerId, symbol);
            return;
        }
        const layerIds = this.getLayerIds(layerId);
        if (layerIds.length > 0) {
            layerIds.forEach(id => this.map.style.setFilter(id, filter, options));
        } else {
            this.map.style.setFilter(layerId, filter, options);
        }
    }

    /**
     * 扩展map的getFilter
     * @param {string} layerId
     * @returns {object}
     */
    getFilter(layerId) {
        const realLayerId = this.getFirstLayerId(layerId);
        if (this.map.style.getLayer(realLayerId)) {
            return this.map.style.getFilter(realLayerId);
        }
    }

    /**
     * 扩展map的setLayerZoomRange
     * @param {string} layerId
     * @param {number} minzoom
     * @param {number} maxzoom
     */
    setLayerZoomRange(layerId, minzoom, maxzoom) {
        const layerIds = this.getLayerIds(layerId);
        if (layerIds.length > 0) {
            layerIds.forEach(id => this.map.style.setLayerZoomRange(id, minzoom, maxzoom));
        } else {
            this.map.style.setLayerZoomRange(layerId, minzoom, maxzoom);
        }
    }

    /**
     * 扩展map的setPaintProperty
     * @param {string} layerId
     * @param {string} name
     * @param {*} value
     * @param {object} options
     */
    setPaintProperty(layerId, name, value, options) {
        const layerIds = this.getLayerIds(layerId);
        if (layerIds.length > 0) {
            layerIds.forEach(id => this.map.style.setPaintProperty(id, name, value, options));
        } else {
            this.map.style.setPaintProperty(layerId, name, value, options);
        }
    }

    /**
     * 扩展map的getPaintProperty
     * @param {string} layerId
     * @param {string} name
     * @returns {object}
     */
    getPaintProperty(layerId, name) {
        const realLayerId = this.getFirstLayerId(layerId);
        return this.map.style.getPaintProperty(realLayerId, name);
    }

    /**
     * 扩展map的setLayoutProperty
     * @param {string} layerId
     * @param {string} name
     * @param {*} value
     * @param {object} options
     */
    setLayoutProperty(layerId, name, value, options) {
        const layerIds = this.getLayerIds(layerId);
        if (layerIds.length > 0) {
            layerIds.forEach(id => this.map.style.setLayoutProperty(id, name, value, options));
        } else {
            this.map.style.setLayoutProperty(layerId, name, value, options);
        }
    }

    /**
     * 扩展map的getLayoutProperty
     * @param {string} layerId
     * @param {string} name
     * @returns {object}
     */
    getLayoutProperty(layerId, name) {
        const realLayerId = this.getFirstLayerId(layerId);
        return this.map.style.getLayoutProperty(realLayerId, name);
    }

    /**
     * 遍历this._layerSymbols， 更新使用到symbolId的图层
     * @param {string} symbolId 
     */
    updateLayerSymbol(symbolId) {
        Object.keys(this._layerSymbols).forEach(layerId => {
            const symbol = this._layerSymbols[layerId];
            if (symbol.includes(symbolId)) {
                this.setSymbol(layerId, symbol);
            }
        })
    }

    /**
     * 更新符号
     * @param {string} symbolId 
     * @param {object | array} symbol 
     */
    updateSymbol(symbolId, symbol) {
        // symbol不存在
        if (!this.getSymbol(symbolId)) {
            return this.map.fire('error', {
                error: new Error(`Symbol "${symbolId}" could not be loaded. Please make sure you have added the symbol with map.addSymbol().`)
            });
        }
        if (validateSymbol(symbol)) {
            // 更新symbol
            this.symbolManager.addSymbol(symbolId, symbol);
            this.updateLayerSymbol(symbolId);
        } else {
            return this.map.fire('error', {
                error: new Error('Symbol is not supported expressions.')
            });
        }
    }

    /**
     * 设置symbol属性值
     * @param {string} symbolId 
     * @param {number} symbolIndex 
     * @param {string} name 
     * @param {any} value
     */
    setSymbolProperty(symbolId, symbolIndex, name, value) {
        const symbol = this.getSymbol(symbolId);
        // symbol不存在
        if (!symbol) {
            return this.map.fire('error', {
                error: new Error(`Symbol "${symbolId}" could not be loaded. Please make sure you have added the symbol with map.addSymbol().`)
            });
        }
        // value不支持表达式
        if (isMapboxExpression(value)) {
            return this.map.fire('error', {
                error: new Error('Symbol value is not supported expressions.')
            });
        }
        const paintOrLayout = isPaintKey(name) ? 'paint' : 'layout';
        if (symbol.length > 0) {
            const symbolChild = symbol[symbolIndex];
            if (!symbolChild) {
                return this.map.fire('error', {
                    error: new Error(`symbol[${symbolIndex}] does not exist.`)
                });
            }
            if (!symbolChild[paintOrLayout]) {
                symbolChild[paintOrLayout] = {};
            }
            Object.assign(symbolChild[paintOrLayout], { [name]: value });
        } else {
            if (!symbol[paintOrLayout]) {
                symbol[paintOrLayout] = {};
            }
            Object.assign(symbol[paintOrLayout], { [name]: value });
        }
        // 更新symbol
        this.symbolManager.addSymbol(symbolId, symbol);
        this.updateLayerSymbol(symbolId);
    }

    /**
     * 获取symbol的属性值
     * @param {string} symbolId 
     * @param {number} symbolIndex 
     * @param {string} name 
     * @returns {any}
     */
    getSymbolProperty(symbolId, symbolIndex, name) {
        const symbol = this.getSymbol(symbolId);
        // symbol不存在
        if (!symbol) {
            this.map.fire('error', {
                error: new Error(`Symbol "${symbolId}" could not be loaded. Please make sure you have added the symbol with map.addSymbol().`)
            });
            return;
        }
        const paintOrLayout = isPaintKey(name) ? 'paint' : 'layout';
        if (symbol.length > 0) {
            return symbol[symbolIndex] && symbol[symbolIndex][paintOrLayout] && symbol[symbolIndex][paintOrLayout][name];
        } else {
            return symbol[paintOrLayout] && symbol[paintOrLayout][name];
        }
    }
}

/* harmony default export */ const symbol_SymbolHandler = (SymbolHandler);

;// CONCATENATED MODULE: ./src/mapboxgl/overlay/symbol/MapExtendSymbol.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/





/**
 * @function MapExtendSymbol
 * @description  扩展了 mapboxgl.Map 对图层相关的操作。
 * @private
 */
function MapExtendSymbol(){
  /**
   * 获取symbol管理
   * @param {*} map
   * @returns {object}
   */
  const getSymbolHandler = (map) => {
    if (!(external_mapboxgl_default()).Map.prototype.symbolHandler) {
      (external_mapboxgl_default()).Map.prototype.symbolHandler = new symbol_SymbolHandler(map);
    }
    return external_mapboxgl_default().Map.prototype.symbolHandler._update(map);
  }

  if ((external_mapboxgl_default()).Map.prototype.addLayerBySymbolBak === undefined) {
    (external_mapboxgl_default()).Map.prototype.addLayerBySymbolBak = (external_mapboxgl_default()).Map.prototype.addLayer;
    (external_mapboxgl_default()).Map.prototype.addLayer = function (layer, before) {
      const symbolHandler = getSymbolHandler(this);
      if(symbolHandler.getLayerIds(layer.id).length > 0) {
        this.fire('error', {
          error: new Error('A layer with this id already exists.')
        });
        return;
      }
      if (layer.symbol) {
        symbolHandler.addLayer(layer, before);
        return this;
      }
      this.addLayerBySymbolBak(layer, before);
      return this;
    };
  }

  if ((external_mapboxgl_default()).Map.prototype.getLayerBySymbolBak === undefined) {
    (external_mapboxgl_default()).Map.prototype.getLayerBySymbolBak = (external_mapboxgl_default()).Map.prototype.getLayer;
    (external_mapboxgl_default()).Map.prototype.getLayer = function (id) {
      return getSymbolHandler(this).getLayer(id);
    };
  }

  if ((external_mapboxgl_default()).Map.prototype.moveLayerBySymbolBak === undefined) {
    (external_mapboxgl_default()).Map.prototype.moveLayerBySymbolBak = (external_mapboxgl_default()).Map.prototype.moveLayer;
    ;(external_mapboxgl_default()).Map.prototype.moveLayer = function (id, beforeId) {
      if (this.style.getLayer(id) && (!beforeId || this.style.getLayer(beforeId))) {
        return this.moveLayerBySymbolBak(id, beforeId);
      }
      getSymbolHandler(this).moveLayer(id, beforeId);
      return this._update(true);
    }
  }

  if ((external_mapboxgl_default()).Map.prototype.removeLayerBySymbolBak === undefined) {
    (external_mapboxgl_default()).Map.prototype.removeLayerBySymbolBak = (external_mapboxgl_default()).Map.prototype.removeLayer;
    (external_mapboxgl_default()).Map.prototype.removeLayer = function (id) {
      if (this.style.getLayer(id)) {
        return this.removeLayerBySymbolBak(id);
      }
      return getSymbolHandler(this).removeLayer(id);
    };
  }

  if ((external_mapboxgl_default()).Map.prototype.setLayoutPropertyBySymbolBak === undefined) {
    //目前扩展的overlayer，只支持显示或隐藏图层操作
    (external_mapboxgl_default()).Map.prototype.setLayoutPropertyBySymbolBak = (external_mapboxgl_default()).Map.prototype.setLayoutProperty;
    (external_mapboxgl_default()).Map.prototype.setLayoutProperty = function (layerID, name, value, options) {
      if (this.overlayLayersManager[layerID] || this.style.getLayer(layerID)) {
        return this.setLayoutPropertyBySymbolBak(layerID, name, value, options);
      }
      getSymbolHandler(this).setLayoutProperty(layerID, name, value, options);
      return this._update(true);
    };
  }

  /**
   * 指定图层设置符号
   * @param {string} layerId
   * @param {string | array} symbol
   */
  (external_mapboxgl_default()).Map.prototype.setSymbol = function (layerId, symbol) {
    getSymbolHandler(this).setSymbol(layerId, symbol);
  };

  /**
   * Layer新增symbol属性
   */
  if (!((external_mapboxgl_default()).Map.prototype).setStyleBak) {
    ((external_mapboxgl_default()).Map.prototype).setStyleBak = (external_mapboxgl_default()).Map.prototype.setStyle;
    ;(external_mapboxgl_default()).Map.prototype.setStyle = function (style, options) {
      this.setStyleBak(style, options);
      this.style && this.style.once('style.load', () => {
        const symbolLayers = style.layers.filter(l => l.symbol);
        symbolLayers.forEach((l) => {
          this.setSymbol(l.id, l.symbol);
        });
      });
      return this;
    }
  } 

  /**
   * 加载Web符号
   * @param {string | string[]} id
   * @param {function} callback
   */
  (external_mapboxgl_default()).Map.prototype.loadSymbol = async function (id, callback) {
    if (typeof id === 'string') {
      const symbolInfo = await loadSymbol(id, this);
      let message = null;
      if(!symbolInfo) {
        message = `Symbol ${id} is not exists`;
      }
      callback(message, symbolInfo);
    } else if (Util_Util.isArray(id)) {
      const promises = id.map(i => loadSymbol(i, this));
      const symbolInfo = await Promise.all(promises);
      let message = null;
      const errorIds = id.filter((_i, index) => !symbolInfo[index]);
      if(errorIds.length > 0){
        message = `Symbol ${errorIds.join(',')} is not exists`;
      }
      callback(message, symbolInfo);
    } else {
      callback({
        message: 'Symbol id must be a string or string[].'
      });
    }
  };

  /**
   * 添加符号
   * @param {string} id
   * @param {object} symbol
   */
  (external_mapboxgl_default()).Map.prototype.addSymbol = function (id, symbol) {
    getSymbolHandler(this).addSymbol(id, symbol);
  };

  /**
   * 获取符号信息
   * @param {string} id
   */
  (external_mapboxgl_default()).Map.prototype.getSymbol = function (id) {
    return getSymbolHandler(this).getSymbol(id);
  };

  /**
   * 判断符号是否存在
   * @param {string} id
   */
  (external_mapboxgl_default()).Map.prototype.hasSymbol = function (id) {
    if (!id) {
      this.fire('error', {
        error: new Error('Missing required symbol id')
      });
      return false;
    }

    return !!this.getSymbol(id);
  };

  /**
   * 删除符号
   * @param {string} id
   */
  (external_mapboxgl_default()).Map.prototype.removeSymbol = function (id) {
    getSymbolHandler(this).removeSymbol(id);
  };
  
  /**
   * 更新符号
   * @param {string} id
   * @param {object} symbol
   */
  (external_mapboxgl_default()).Map.prototype.updateSymbol = function (id, symbol) {
    getSymbolHandler(this).updateSymbol(id, symbol);
  };

  /**
   * 设置symbol属性值
   * @param {string} id 
   * @param {number} index 
   * @param {string} name 
   * @param {any} value
   */
  (external_mapboxgl_default()).Map.prototype.setSymbolProperty = function (id, index, name, value) {
    getSymbolHandler(this).setSymbolProperty(id, index, name, value);
  };

  /**
   * 获取symbol的属性值
   * @param {string} id 
   * @param {number} index 
   * @param {string} name 
   * @returns {any}
   */
  (external_mapboxgl_default()).Map.prototype.getSymbolProperty = function (id, index, name) {
    return getSymbolHandler(this).getSymbolProperty(id, index, name);
  };

  (external_mapboxgl_default()).Map.prototype.getStyle = function () {
    if (this.style) {
      return getSymbolHandler(this).getStyle();
    }
  };

  (external_mapboxgl_default()).Map.prototype.setFilter = function (layerId, filter, options) {
    if (this.style.getLayer(layerId)) {
      this.style.setFilter(layerId, filter, options);
      return this._update(true);
    }
    getSymbolHandler(this).setFilter(layerId, filter, options);
    return this._update(true);
  };

  (external_mapboxgl_default()).Map.prototype.getFilter = function (layerId) {
    if (this.style.getLayer(layerId)) {
      return this.style.getFilter(layerId);
    }
    return getSymbolHandler(this).getFilter(layerId);
  };

  (external_mapboxgl_default()).Map.prototype.setLayerZoomRange = function (layerId, minzoom, maxzoom) {
    if (this.style.getLayer(layerId)) {
      this.style.setLayerZoomRange(layerId, minzoom, maxzoom);
      return this._update(true);
    }
    getSymbolHandler(this).setLayerZoomRange(layerId, minzoom, maxzoom);
    return this._update(true);
  };

  (external_mapboxgl_default()).Map.prototype.setPaintProperty = function (layerId, name, value, options) {
    if (this.style.getLayer(layerId)) {
      this.style.setPaintProperty(layerId, name, value, options);
      return this._update(true);
    }
    getSymbolHandler(this).setPaintProperty(layerId, name, value, options);
    return this._update(true);
  };

  (external_mapboxgl_default()).Map.prototype.getPaintProperty = function (layerId, name) {
    if (this.style.getLayer(layerId)) {
      return this.style.getPaintProperty(layerId, name);
    }
    return getSymbolHandler(this).getPaintProperty(layerId, name);
  };

  (external_mapboxgl_default()).Map.prototype.getLayoutProperty = function (layerId, name) {
    if (this.style.getLayer(layerId)) {
      return this.style.getLayoutProperty(layerId, name);
    }
    return getSymbolHandler(this).getLayoutProperty(layerId, name);
  };
  
  if ((external_mapboxgl_default()).Map.prototype.onBak === undefined) {
    (external_mapboxgl_default()).Map.prototype.onBak = (external_mapboxgl_default()).Map.prototype.on;
    (external_mapboxgl_default()).Map.prototype.on = function (type, layerId, listener) {
      if (listener === undefined || this.style.getLayer(layerId)) {
        return this.onBak(type, layerId, listener);
      }
      const layerIds = getSymbolHandler(this).getLayerIds(layerId);
      layerIds.forEach(id => this.onBak(type, id, listener));
      return this;
    };
  }
  
  if ((external_mapboxgl_default()).Map.prototype.onceBak === undefined) {
    (external_mapboxgl_default()).Map.prototype.onceBak = (external_mapboxgl_default()).Map.prototype.once;
    (external_mapboxgl_default()).Map.prototype.once = function (type, layerId, listener) {
      if (listener === undefined || this.style.getLayer(layerId)) {
        return this.onceBak(type, layerId, listener);
      }
      const layerIds = getSymbolHandler(this).getLayerIds(layerId);
      layerIds.forEach(id => this.onceBak(type, id, listener));
      return this;
    };
  }
  
  if ((external_mapboxgl_default()).Map.prototype.offBak === undefined) {
    (external_mapboxgl_default()).Map.prototype.offBak = (external_mapboxgl_default()).Map.prototype.off;
    (external_mapboxgl_default()).Map.prototype.off = function (type, layerId, listener) {
      if (listener === undefined || this.style.getLayer(layerId)) {
        return this.offBak(type, layerId, listener);
      }
      const layerIds = getSymbolHandler(this).getLayerIds(layerId);
      layerIds.forEach(id => this.offBak(type, id, listener));
      return this;
    };
  }

  /**
   * @function WebSymbol.prototype.getSymbol
   * @param {string} id - 符号ID。
   * @description 获取符号信息。
   * @returns {object} 符号信息。
   * @private
   */
  async function getSymbol(id, map) {
    let url = `${map.basePath}/${id}/${id}`;
    if (false) {}

    const value = await FetchRequest.get(`${url}.json`).then(response => {
      if (!response.ok) {
        return null;
      }
      return response.json();
    })
      .catch(() => null);
    if (!value) {
      return null;
    }
    const paint = value.paint || {};
    const layout = value.layout || {};
    const hasImage = paint['fill-pattern'] || paint['line-pattern'] || layout['icon-image'];
    const image = hasImage && await new Promise((resolve) => {
      const image = new Image();
      image.src = `${url}.png`;
      image.onload = (content) => {
        resolve(content ? image : null);
      };
      image.onerror = () => {
        resolve(null);
      };
    });
    return {
      value,
      image
    }
  }

  /**
   * 加载单个Web符号
   * @param {string} id 
   * @param {Mapboxgl.Map} map 
   * @returns {object} symbol对象
   */
  function loadSymbol(id, map) {
    return getSymbol(id, map).then((symbolResult) => {
      if (!symbolResult) {
        return null;
      }
      const { value, image } = symbolResult;
      image && getSymbolHandler(map).addSymbolImageToMap(value, image);
      return value;
    })
  }
}
/* harmony default export */ const symbol_MapExtendSymbol = (MapExtendSymbol);

;// CONCATENATED MODULE: ./src/mapboxgl/overlay/symbol/WebSymbol.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


/**
* @class WebSymbol
* @classdesc SuperMap iClient for MapboxGL 支持 Web 符号库，扩展了 [MapboxGL](https://docs.mapbox.com/mapbox-gl-js/api/) 的 API。
* @category Visualization WebSymbol
* @description 
* 
* ## 初始化
* 使用Web符号资源时, 通过接口指定符号资源路径。
* ```
* new mapboxgl.supermap.WebSymbol().init({basePath: "./resources/symbols"});
* ```
*
* ## 新增 API
* ## mapboxgl.Map.prototype.loadSymbol
* 通过[Web符号ID](../../../../../examples/mapboxgl/websymbol_gallery.html)加载Web符号， 用于Map#addSymbol。
* 
* 参数名称			     |类型			 |描述  
* :----				|:---		    |:---	
* id				    |string、string[]		    |[Web符号ID](../../../../../examples/mapboxgl/websymbol_gallery.html)
* callback			    |function		|在符号加载完成后调用，返回符号信息；如果有错误，则返回错误参数。
* 
* **Version:**
* 
* 11.1.0
* 
* **Example**
* ```
* // 加载单个Web符号
* map.loadSymbol('point-1', (error, symbol) => {
*       if (error) throw error;
*       // Add the loaded symbol with the ID 'point-1'.
*       map.addSymbol('point-1', symbol);
* });
*
* // 加载多个Web符号
* var symbolIds = ['point-1', 'point-2'];
* map.loadSymbol(symbolIds, (error, symbols) => {
*      symbols.forEach((symbol, index) => {
*          symbol && map.addSymbol(symbolIds[index], symbol);
*      })
* });
* ```
* 
* 
* ## mapboxgl.Map.prototype.addSymbol
* 添加一个符号。该符号可以显示在地图上。Mapbox layers 的 symbol属性可以使用该符号ID。
* 
* |参数名称			     |类型			     |描述                | ||
* |----				|---		        |---			    |---|---|
* |id				    |string		        |符号ID              |||
* |symbol			    |object	            |由Mapbox Layers中的[paint](https://docs.mapbox.com/mapbox-gl-js/style-spec/layers/#paint-property)、[layout](https://docs.mapbox.com/mapbox-gl-js/style-spec/layers/#layout-property)（visibility 属性除外）组成的符号对象|||
* |                    |                   |参数名称			 |类型			     |描述  |
* |                    |                   |paint				|object		        |可选，Mapbox Layers [paint](https://docs.mapbox.com/mapbox-gl-js/style-spec/layers/#paint-property)|
* |                    |                   |layout			    |object	            |可选，Mapbox Layers [layout](https://docs.mapbox.com/mapbox-gl-js/style-spec/layers/#layout-property)（visibility 属性除外）|
* 
* **Version:**
* 
* 11.1.0
* 
* **Example**
* ```
* map.addSymbol('point-1', symbol);
* ```
* 
* 
* ## mapboxgl.Map.prototype.setSymbol
* 给指定图层设置符号。
* 
* 参数名称			     |类型			 |描述
* :----				|:---		    |:---	
* layerId				|string		    |图层ID
* symbol			    |string、array		    |已经添加的符号ID（addSymbol中的符号ID), 或者[符号表达式](#expression)
* 
* **Version:**
* 
* 11.1.0
* 
* **Example**
* ```
* map.setSymbol("layerId", 'point-1');
* map.setSymbol("layerId", [
  "match",
  ["get", "DLBM"],
  "011", "line-964458", //公路用地
  "013", "line-964462", //农村道路
  "021", "line-962613", //河流水面
  "023", "line-962613", //河流水面
  "line-962613"
]);
* ```
* 
* 
* ## mapboxgl.Map.prototype.hasSymbol
* 检查是否存在指定 ID 的符号。
* 
* 参数名称			     |类型			 |描述  
* :----			    |:---		    |:---	
* id			    |string		    |符号ID
* 
* **Version:**
* 
* 11.1.0
* 
* **Returns**
* 类型			   |描述  
* :---		     |:---	
* boolean		   |符号是否存在
*   
* **Example**
* ```
* const pointExists = map.hasSymbol('point-1');
* ```
* 
* 
* ## mapboxgl.Map.prototype.removeSymbol
* 删除指定 ID 的符号。
* 
* 参数名称			     |类型			 |描述  
* :----				|:---		    |:---	
* id			      |string		    |已经添加的符号ID
* 
* **Version:**
* 
* 11.1.0
* 
* **Example**
* ```
* map.removeSymbol('point-1');
* ```
* 
* 
* ## mapboxgl.Map.prototype.updateSymbol
* 更新指定 ID 的符号。
* 
* |参数名称			     |类型			     |描述                | ||
* |----				|---		        |---			    |---|---|
* id			      |string		    |已经添加的符号ID|||
* |symbol			  |object	      |由Mapbox Layers中的[paint](https://docs.mapbox.com/mapbox-gl-js/style-spec/layers/#paint-property)、[layout](https://docs.mapbox.com/mapbox-gl-js/style-spec/layers/#layout-property)（visibility 属性除外）组成的符号对象|||
* |             |             |参数名称			 |类型			     |描述  |
* |             |             |paint				|object		      |可选，Mapbox Layers [paint](https://docs.mapbox.com/mapbox-gl-js/style-spec/layers/#paint-property)|
* |             |             |layout			  |object	        |可选，Mapbox Layers [layout](https://docs.mapbox.com/mapbox-gl-js/style-spec/layers/#layout-property)（visibility 属性除外）|
* 
* **Version:**
* 
* 11.1.0
* 
* **Example**
* ```
* map.updateSymbol('point-1', symbol);
* ```
* 
* 
* ## mapboxgl.Map.prototype.getSymbol
* 获取指定 ID 的符号信息。
* 
* 参数名称			     |类型			 |描述  
* :----			    |:---		    |:---	
* id			    |string		    |符号ID
* 
* **Version:**
* 
* 11.1.0
* 
* **Returns**
* 类型			   |描述  
* :---		     |:---	
* object	      |由Mapbox Layers中的[paint](https://docs.mapbox.com/mapbox-gl-js/style-spec/layers/#paint-property)、[layout](https://docs.mapbox.com/mapbox-gl-js/style-spec/layers/#layout-property)（visibility 属性除外）组成的符号对象
* 
* 
* **Example**
* ```
* const point1 = map.getSymbol('point-1');
* ```
* 
* 
* ## mapboxgl.Map.prototype.setSymbolProperty
* 设置指定ID符号的属性值。
* 
* 参数名称			   |类型			  |描述  
* :----				    |:---		      |:---	
* id			        |string		    |符号ID
* index			      |number、null	|符号数组的index， 符号不是数组的设置为null
* name			      |string		    |属性名称
* value			      |any		      |可选，属性值
* 
* **Version:**
* 
* 11.1.0
* 
* **Example**
* ```
* map.setSymbolProperty('point-1', null, "icon-color", "black");
* map.setSymbolProperty('line-962529', 0, "line-width", 10);
* ```
* 
* 
* ## mapboxgl.Map.prototype.getSymbolProperty
* 获取指定ID符号的属性值。
* 
* 参数名称			   |类型			  |描述  
* :----				    |:---		      |:---	
* id			        |string		    |符号ID
* index			      |number、null	|符号数组的index， 符号不是数组的设置为null
* name			      |string		    |属性名称
* 
* **Version:**
* 
* 11.1.0
* 
* **Returns**
* 类型			  |描述  
* :---		        |:---	
* any		        |属性值 
* 
* **Example**
* ```
* map.getSymbolProperty('point-1', null, "icon-color");
* map.getSymbolProperty('line-962529', 0, "line-width");
* ```
* 
* 
* ## 扩展 [Mapbox Layers](https://docs.mapbox.com/mapbox-gl-js/style-spec/layers/)
* 在[Mapbox Layers](https://docs.mapbox.com/mapbox-gl-js/style-spec/layers/) 属性的基础上新增了symbol 属性， 指定符号ID 或者 [符号表达式](#expression)。
* 
* **符号ID**
* ```
* map.addLayer({
*     id: "symbol",
*     source: "sourceId",
*     type: "symbol",
*     symbol: 'point-1'
* });
* ```
* ```
* map.setStyle({
*     version: 8,
*     sources: {},
*     layers: [{
*         id: "symbol",
*         source: "sourceId",
*         type: "symbol",
*         symbol: 'point-1'
*     }]
* })
* ```
* **<a id="expression">符号支持的MapboxGL表达式</a>**
* 
* **[Match](https://docs.mapbox.com/mapbox-gl-js/style-spec/expressions/#match)**
* 
* ```
* map.addLayer({
*     id: "symbol",
*     source: "sourceId",
*     type: "symbol",
*     symbol: [
        "match",
        ["get", "DLBM"],
        "011", "line-964458", //公路用地
        "013", "line-964462", //农村道路
        "021", "line-962613", //河流水面
        "023", "line-962613", //河流水面
        "line-962613"
      ]
* });
* ```
* **[Case](https://docs.mapbox.com/mapbox-gl-js/style-spec/expressions/#case)**
* ```
* map.addLayer({
*     id: "symbol",
*     source: "sourceId",
*     type: "symbol",
*     symbol: [
        "case",
        ["all", ["<=", ["get", "dMaxZValue"], 70]], "PoPdensity_R_MAX70",
        ["all", [">", ["get", "dMaxZValue"], 70],["<=", ["get", "dMaxZValue"], 140]], "PoPdensity_R_MAX140",
        ["all", [">", ["get", "dMaxZValue"], 140],["<=", ["get", "dMaxZValue"], 210]], "PoPdensity_R_MAX210",
        ["all", [">", ["get", "dMaxZValue"], 210],["<=", ["get", "dMaxZValue"], 280]], "PoPdensity_R_MAX280",
        ["all", [">", ["get", "dMaxZValue"], 280],["<=", ["get", "dMaxZValue"], 350]], "PoPdensity_R_MAX350",
        ["all", [">", ["get", "dMaxZValue"], 350],["<=", ["get", "dMaxZValue"], 420]], "PoPdensity_R_MAX420",
        ["all", [">", ["get", "dMaxZValue"], 420],["<=", ["get", "dMaxZValue"], 490]], "PoPdensity_R_MAX490",
        ["all", [">", ["get", "dMaxZValue"], 490],["<=", ["get", "dMaxZValue"], 560]], "PoPdensity_R_MAX560",
        ["all", [">", ["get", "dMaxZValue"], 560],["<=", ["get", "dMaxZValue"], 640]], "PoPdensity_R_MAX640",
        ["all", [">", ["get", "dMaxZValue"], 640],["<=", ["get", "dMaxZValue"], 700]], "PoPdensity_R_MAX700",
        ["all", [">", ["get", "dMaxZValue"], 700],["<=", ["get", "dMaxZValue"], 770]], "PoPdensity_R_MAX770",
        ["all", [">", ["get", "dMaxZValue"], 770],["<=", ["get", "dMaxZValue"], 1000]], "PoPdensity_R_MAX1000",
        ["all", [">", ["get", "dMaxZValue"], 1000]], "PoPdensity_R_Exceed1000",
        "Country_R"
      ]
* });
* ```
* @usage
*/
class WebSymbol {

  constructor() {
    /**
     * @member WebSymbol.prototype.defaultBasePath
     * @description 符号资源路径。
     * @private
     */
    this.defaultBasePath = './resources/symbols';
  }

  /**
   * @function WebSymbol.prototype.init
   * @description 初始化Web符号配置。
   * @version 11.1.0
   * @param {object} config - 配置信息
   * @param {string} [config.basePath] - 指定符号资源路径
   */
  init(config) {
    (external_mapboxgl_default()).Map.prototype.basePath = config && config.basePath || this.defaultBasePath;
    symbol_MapExtendSymbol();
  }
}
;// CONCATENATED MODULE: ./src/mapboxgl/overlay/symbol/index.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/

;// CONCATENATED MODULE: ./src/mapboxgl/overlay/index.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/





















;// CONCATENATED MODULE: ./src/common/iServer/GeoCodingParameter.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


/**
 * @class GeoCodingParameter
 * @deprecatedclass SuperMap.GeoCodingParameter
 * @category  iServer AddressMatch
 * @classdesc 地理正向匹配参数类。
 * @param {Object} options - 参数。
 * @param {string} options.address - 地点关键词。
 * @param {number} [options.fromIndex] - 设置返回对象的起始索引值。
 * @param {number} [options.toIndex] - 设置返回对象的结束索引值。
 * @param {Array.<string>} [options.filters] - 过滤字段，限定查询区域。
 * @param {string} [options.prjCoordSys] - 查询结果的坐标系。
 * @param {number} [options.maxReturn] - 最大返回结果数。
 * @usage
 */
class GeoCodingParameter {
    constructor(options) {
        if (options.filters && typeof(options.filters) === 'string') {
            options.filters =  options.filters.split(',');
        }
        /**
         * @member {string} GeoCodingParameter.prototype.address
         * @description 地点关键词。
         */
        this.address = null;

        /**
         * @member {number} [GeoCodingParameter.prototype.fromIndex]
         * @description 设置返回对象的起始索引值。
         */
        this.fromIndex = null;

        /**
         * @member {number} [GeoCodingParameter.prototype.toIndex]
         * @description 设置返回对象的结束索引值。
         */
        this.toIndex = null;

        /**
         * @member {Array.<string>} [GeoCodingParameter.prototype.filters]
         * @description 过滤字段，限定查询区域。
         */
        this.filters = null;

        /**
         * @member {string} [GeoCodingParameter.prototype.prjCoordSys]
         * @description  查询结果的坐标系。
         */
        this.prjCoordSys = null;

        /**
         * @member {number} [GeoCodingParameter.prototype.maxReturn]
         * @description 最大返回结果数。
         */
        this.maxReturn = null;
        Util_Util.extend(this, options);
    }

    /**
     * @function GeoCodingParameter.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        this.address = null;
        this.fromIndex = null;
        this.toIndex = null;
        this.filters = null;
        this.prjCoordSys = null;
        this.maxReturn = null;
    }

}

;// CONCATENATED MODULE: ./src/common/iServer/GeoDecodingParameter.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


/**
 * @class GeoDecodingParameter
 * @deprecatedclass SuperMap.GeoDecodingParameter
 * @category iServer AddressMatch
 * @classdesc 地理反向匹配参数类。
 * @param {Object} options - 参数。
 * @param {number} options.x - 查询位置的横坐标。
 * @param {number} options.y - 查询位置的纵坐标。
 * @param {number} [options.fromIndex] - 设置返回对象的起始索引值。
 * @param {number} [options.toIndex] - 设置返回对象的结束索引值。
 * @param {Array.<string>} [options.filters] - 过滤字段，限定查询区域。
 * @param {string} [options.prjCoordSys] - 查询结果的坐标系。
 * @param {number} [options.maxReturn] - 最大返回结果数。
 * @param {number} [options.geoDecodingRadius] - 查询半径。
 * @usage
 */
class GeoDecodingParameter {


    constructor(options) {

        if (options.filters) {
            options.filters = options.filters.split(',');
        }
        /**
         * @member {number} GeoDecodingParameter.prototype.x
         * @description 查询位置的横坐标。
         */
        this.x = null;

        /**
         * @member {number} GeoDecodingParameter.prototype.y
         * @description 查询位置的纵坐标。
         */
        this.y = null;
        /**
         * @member {number} [GeoDecodingParameter.prototype.fromIndex]
         * @description  设置返回对象的起始索引值。
         */
        this.fromIndex = null;

        /**
         * @member {number} [GeoDecodingParameter.prototype.toIndex]
         * @description 设置返回对象的结束索引值。
         */
        this.toIndex = null;

        /**
         * @member {Array.<string>} [GeoDecodingParameter.prototype.filters]
         * @description 过滤字段，限定查询区域。
         */
        this.filters = null;

        /**
         * @member {string} [GeoDecodingParameter.prototype.prjCoordSys]
         * @description 查询结果的坐标系。
         */
        this.prjCoordSys = null;

        /**
         *  @member {number} [GeoDecodingParameter.prototype.maxReturn]
         *  @description 最大返回结果数。
         */
        this.maxReturn = null;

        /**
         * @member {number} GeoDecodingParameter.prototype.geoDecodingRadius
         * @description 查询半径。
         */
        this.geoDecodingRadius = null;
        Util_Util.extend(this, options);
    }

    /**
     * @function GeoDecodingParameter.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        this.x = null;
        this.y = null;
        this.fromIndex = null;
        this.toIndex = null;
        this.filters = null;
        this.prjCoordSys = null;
        this.maxReturn = null;
        this.geoDecodingRadius = null;
    }

}

;// CONCATENATED MODULE: ./src/common/iServer/AddressMatchService.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/




/**
 * @class AddressMatchService
 * @deprecatedclass SuperMap.AddressMatchService
 * @category iServer AddressMatch
 * @classdesc 地址匹配服务，包括正向匹配和反向匹配。
 * @param {string} url - 服务地址。
 * @param {Object} options - 可选参数。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @usage
 */
class AddressMatchService_AddressMatchService extends CommonServiceBase {
    constructor(url, options) {
        super(url, options);
        this.options = options || {};
        this.CLASS_NAME = 'SuperMap.AddressMatchService';
    }

    /**
     * @function AddressMatchService.prototype.destroy
     * @override
     */
    destroy() {
        super.destroy();
    }

    /**
     * @function AddressMatchService.prototype.code
     * @param {string} url - 正向地址匹配服务地址。
     * @param {GeoCodingParameter} params - 正向地址匹配服务参数。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    code(url, params, callback) {
        if (!(params instanceof GeoCodingParameter)) {
            return;
        }
        return this.processAsync(url, params, callback);
    }

    /**
     * @function AddressMatchService.prototype.decode
     * @param {string} url - 反向地址匹配服务地址。
     * @param {GeoDecodingParameter} params - 反向地址匹配服务参数。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    decode(url, params, callback) {
        if (!(params instanceof GeoDecodingParameter)) {
            return;
        }
        return this.processAsync(url, params, callback);
    }

    /**
     * @function AddressMatchService.prototype.processAsync
     * @description 负责将客户端的动态分段服务参数传递到服务端。
     * @param {string} url - 服务地址。
     * @param {Object} params - 参数。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */

    processAsync(url, params, callback) {
      return this.request({
          method: 'GET',
          url,
          params,
          scope: this,
          success: callback,
          failure: callback
      });
    }
    /**
     * @function AddressMatchService.prototype.transformResult
     * @param {Object} result - 服务器返回的结果对象。
     * @param {Object} options - 请求参数。
     * @return {Object} 转换结果。
     * @description 状态完成时转换结果。
     */
    transformResult(result, options) {
        if (result.succeed) {
            delete result.succeed;
        }
        return { result, options };
    }
}


;// CONCATENATED MODULE: ./src/mapboxgl/services/AddressMatchService.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/





/**
 * @class AddressMatchService
 * @category  iServer AddressMatch
 * @classdesc 地址匹配服务类。
 * @modulecategory Services
 * @example
 * new AddressMatchService(url,options)
 * .code(function(result){
 *     //doSomething
 * })
 * @param {string} url - 服务地址。
 * @param {Object} options - 参数。
 * @param {string} [options.proxy] - 服务代理地址。
 * @param {boolean} [options.withCredentials=false] - 请求是否携带 cookie。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @extends {ServiceBase}
 * @usage
 */
class AddressMatchService extends ServiceBase {
    constructor(url, options) {
        super(url, options);
        this._addressMatchService = new AddressMatchService_AddressMatchService(url, options);
    }

    /**
     * @function AddressMatchService.prototype.code
     * @description 获取正向地址匹配结果。
     * @param {GeoCodingParameter} params - 正向匹配参数。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    code(params, callback) {
      return this._addressMatchService.code(Util_Util.urlPathAppend(this.url, 'geocoding'), params, callback);
    }

    /**
     * @function AddressMatchService.prototype.decode
     * @description 获取反向地址匹配结果。
     * @param {GeoDecodingParameter} params -反向匹配参数。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    decode(params, callback) {
      return this._addressMatchService.decode(Util_Util.urlPathAppend(this.url, 'geodecoding'), params, callback);
    }
}

;// CONCATENATED MODULE: ./src/common/iServer/QueryParameters.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/



/**
 * @class QueryParameters
 * @deprecatedclass SuperMap.QueryParameters
 * @category  iServer Map QueryResults
 * @classdesc 查询参数基类。距离查询、SQL 查询、几何地物查询等各自的参数均继承此类。
 * @param {Object} options - 参数。
 * @param {Array.<FilterParameter>} options.queryParams - 查询过滤条件参数数组。
 * @param {string} [options.customParams] - 自定义参数，供扩展使用。
 * @param {Object} [options.prjCoordSys] - 自定义参数，供 SuperMap Online 提供的动态投影查询扩展使用。如 {"epsgCode":3857}。
 * @param {number} [options.expectCount=100000] - 期望返回结果记录个数。
 * @param {GeometryType} [options.networkType=GeometryType.LINE] - 网络数据集对应的查询类型。
 * @param {QueryOption} [options.queryOption=QueryOption.ATTRIBUTEANDGEOMETRY] - 查询结果类型枚举类。
 * @param {number} [options.startRecord=0] - 查询起始记录号。
 * @param {number} [options.holdTime=10] - 资源在服务端保存的时间,单位为分钟。
 * @param {boolean} [options.returnCustomResult=false] - 仅供三维使用。
 * @param {boolean} [options.returnFeatureWithFieldCaption = false] - 返回的查询结果要素字段标识是否为字段别名。为 false 时，返回的是字段名；为 true 时，返回的是字段别名。
 * @usage
 */
class QueryParameters {


    constructor(options) {
        if (!options) {
            return;
        }
        /**
         * @member {string} [QueryParameters.prototype.customParams]
         * @description 自定义参数，供扩展使用。
         */
        this.customParams = null;

        /**
         * @member {Object} [QueryParameters.prototype.prjCoordSys]
         * @description 自定义参数，供 SuperMap Online 提供的动态投影查询扩展使用。如 {"epsgCode":3857}
         */
        this.prjCoordSys = null;

        /**
         * @member {number} [QueryParameters.prototype.expectCount=100000]
         * @description 期望返回结果记录个数，默认返回100000条查询记录，
         *              如果实际不足100000条则返回实际记录条数。
         */
        this.expectCount = 100000;

        /**
         * @member {GeometryType} [QueryParameters.prototype.networkType=GeometryType.LINE]
         * @description 网络数据集对应的查询类型，分为点和线两种类型。
         */
        this.networkType = REST_GeometryType.LINE;

        /**
         * @member {QueryOption} [QueryParameters.prototype.queryOption=QueryOption.ATTRIBUTEANDGEOMETRY]
         * @description 查询结果类型枚举类。
         *              该类描述查询结果返回类型，包括只返回属性、
         *              只返回几何实体以及返回属性和几何实体。
         */
        this.queryOption = QueryOption.ATTRIBUTEANDGEOMETRY;

        /**
         * @member {Array.<FilterParameter>} QueryParameters.prototype.queryParams
         * @description 查询过滤条件参数数组。
         *              该类用于设置查询数据集的查询过滤参数。
         */
        this.queryParams = null;

        /**
         * @member {number} [QueryParameters.prototype.startRecord=0]
         * @description 查询起始记录号。
         */
        this.startRecord = 0;

        /**
         * @member {number} [QueryParameters.prototype.holdTime=10]
         * @description 资源在服务端保存的时间，单位为分钟。
         */
        this.holdTime = 10;

        /**
         * @member {boolean} [QueryParameters.prototype.returnCustomResult=false]
         * @description 仅供三维使用。
         */
        this.returnCustomResult = false;
        /**
         * @member {boolean} [QueryParameters.prototype.returnFeatureWithFieldCaption=false]
         * @description 返回的查询结果要素字段标识是否为字段别名。为 false 时，返回的是字段名；为 true 时，返回的是字段别名。
         */
        this.returnFeatureWithFieldCaption = false;
        Util_Util.extend(this, options);

        this.CLASS_NAME = "SuperMap.QueryParameters";
    }

    /**
     * @function QueryParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        var me = this;
        me.customParams = null;
        me.expectCount = null;
        me.networkType = null;
        me.queryOption = null;
        if (me.queryParams) {
            for (var i = 0, qps = me.queryParams, len = qps.length; i < len; i++) {
                qps[i].destroy();
            }
            me.queryParams = null;
        }
        me.startRecord = null;
        me.holdTime = null;
        me.returnCustomResult = null;
        me.prjCoordSys = null;
    }

}

;// CONCATENATED MODULE: ./src/common/iServer/ChartQueryFilterParameter.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


/**
 * @class ChartQueryFilterParameter
 * @deprecatedclass SuperMap.ChartQueryFilterParameter
 * @category  iServer Map Chart
 * @classdesc 海图查询过滤参数类，用于设置海图查询的过滤参数。包括：物标代码、物标可应用对象的选择（是否查询点、线或面）、属性字段过滤条件。
 * @param {Object} options - 参数。
 * @param {string} options.attributeFilter - 属性字段过滤条件。
 * @param {number} options.chartFeatureInfoSpecCode - 查询的物标代号。
 * @param {boolean} [options.isQueryPoint] - 是否查询点。
 * @param {boolean} [options.isQueryLine] - 是否查询线。
 * @param {boolean} [options.isQueryRegion] - 是否查询面。
 * @usage
 */
class ChartQueryFilterParameter {


    constructor(options) {
        /**
         * @member {boolean} [ChartQueryFilterParameter.prototype.isQueryPoint]
         * @description 是否查询点。
         */
        this.isQueryPoint = null;

        /**
         * @member {boolean} [ChartQueryFilterParameter.prototype.isQueryLine]
         * @description 是否查询线。
         */
        this.isQueryLine = null;

        /**
         * @member {boolean} [ChartQueryFilterParameter.prototype.isQueryRegion]
         * @description 是否查询面。
         */
        this.isQueryRegion = null;

        /**
         * @member {string} ChartQueryFilterParameter.prototype.attributeFilter
         * @description 属性字段过滤条件。
         */
        this.attributeFilter = null;

        /**
         * @member {number} ChartQueryFilterParameter.prototype.chartFeatureInfoSpecCode
         * @description 查询的物标代号。
         */
        this.chartFeatureInfoSpecCode = null;

        Util_Util.extend(this, options);

        this.CLASS_NAME = "SuperMap.ChartQueryFilterParameter";
    }

    /**
     * @function ChartQueryFilterParameter.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        var me = this;
        me.isQueryPoint = null;
        me.isQueryLine = null;
        me.isQueryRegion = null;
        me.attributeFilter = null;
        me.chartFeatureInfoSpecCode = null;
    }

    /**
     * @function ChartQueryFilterParameter.prototype.toJson
     * @description 将属性信息转化成 JSON 格式字符串。
     */
    toJson() {
        var json = "";
        json += "\"isQueryPoint\":" + this.isQueryPoint + ",";
        json += "\"isQueryLine\":" + this.isQueryLine + ",";
        json += "\"isQueryRegion\":" + this.isQueryRegion + ",";
        if (this.attributeFilter) {
            json += "\"attributeFilter\": \"" + this.attributeFilter + "\",";
        }
        json += "\"chartFeatureInfoSpecCode\":" + this.chartFeatureInfoSpecCode;
        json = "{" + json + "}";
        return json;
    }


}

;// CONCATENATED MODULE: ./src/common/iServer/ChartQueryParameters.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/



/**
 * @class ChartQueryParameters
 * @deprecatedclass SuperMap.ChartQueryParameters
 * @category iServer Map Chart
 * @classdesc 海图查询参数类，该类用于设置海图查询时的相关参数，海图查询分为海图属性查询和海图范围查询两类，通过属性 queryMode 指定查询模式。
 *            必设属性有：queryMode、chartLayerNames、chartQueryFilterParameters。当进行海图范围查询时，必设属性还包括 bounds。
 * @param {Object} options - 参数。
 * @param {string} options.queryMode - 海图查询模式类型，支持两种查询方式：海图属性查询（"ChartAttributeQuery"）和海图空间查询（"ChartBoundsQuery"）。
 * @param {Array.<string>} options.chartLayerNames - 查询的海图图层的名称。
 * @param {Array.<ChartQueryFilterParameter>} options.chartQueryFilterParameters - 海图查询过滤参数。包括：物标代码、物标可应用对象的选择（是否查询点、线或面）、属性字段过滤条件。
 * @param {(SuperMap.Bounds|L.Bounds|L.LatLngBounds|ol.extent|mapboxgl.LngLatBounds|GeoJSONObject)} options.bounds - 海图查询范围。当进行海图范围查询时，此为必选参数。
 * @param {boolean} [options.returnContent=true] - 获取或设置是返回查询结果记录集 recordsets，还是返回查询结果的资源 resourceInfo。
 * @param {number} [options.startRecord=0] - 查询起始记录位置。
 * @param {number} [options.expectCount] - 期望查询结果返回的记录数，该值大于0。
 * @usage
 */
class ChartQueryParameters {


    constructor(options) {
        /**
         * @member {string} ChartQueryParameters.prototype.queryMode
         * @description 海图查询模式类型，支持两种查询方式：海图属性查询（"ChartAttributeQuery"）和海图空间查询（"ChartBoundsQuery"）。
         */
        this.queryMode = null;

        /**
         * @member {(SuperMap.Bounds|L.Bounds|L.LatLngBounds|ol.extent|mapboxgl.LngLatBounds|GeoJSONObject)} ChartQueryParameters.prototype.bounds
         * @description 海图查询范围。
         */
         this.bounds = null;

        /**
         * @member {Array.<string>} ChartQueryParameters.prototype.chartLayerNames
         * @description 查询的海图图层的名称。
         */
        this.chartLayerNames = null;

        /**
         * @member {Array.<ChartQueryFilterParameter>} ChartQueryParameters.prototype.chartQueryFilterParameters
         * @description 海图查询过滤参数。包括：物标代码、物标可应用对象的选择（是否查询点、线或面）、属性字段过滤条件。
         */
        this.chartQueryFilterParameters = null;

        /**
         * @member {boolean} [ChartQueryParameters.prototype.returnContent=true]
         * @description 获取或设置是返回查询结果记录集 recordsets，还是返回查询结果的资源 resourceInfo。
         */
        this.returnContent = true;

        /**
         * @member {number} [ChartQueryParameters.prototype.startRecord=0]
         * @description 查询起始记录位置。
         */
        this.startRecord = 0;

        /**
         * @member {number} [ChartQueryParameters.prototype.expectCount]
         * @description 期望查询结果返回的记录数，该值大于0。
         */
        this.expectCount = null;
        Util_Util.extend(this, options);

        this.CLASS_NAME = "SuperMap.ChartQueryParameters";
    }

    /**
     * @function ChartQueryParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        var me = this;
        me.queryMode = null;
        me.bounds = null;
        me.chartLayerNames = null;
        me.chartQueryFilterParameters = null;
        me.returnContent = true;
        me.startRecord = 0;
        me.expectCount = null;
    }

    /**
     * @function ChartQueryParameters.prototype.getVariablesJson
     * @description 将属性信息转换成能够被服务识别的 JSON 格式字符串。
     * @returns {string} JSON 字符串。
     */
    getVariablesJson() {
        var json = "";

        json += "\"queryMode\":\"" + this.queryMode + "\",";

        if (this.chartLayerNames && this.chartLayerNames.length) {
            var chartLayersArray = [];
            var layerLength = this.chartLayerNames.length;
            for (var i = 0; i < layerLength; i++) {
                chartLayersArray.push("\"" + this.chartLayerNames[i] + "\"");
            }
            var layerNames = "[" + chartLayersArray.join(",") + "]";
            json += "\"chartLayerNames\":" + layerNames + ",";
        }

        if (this.queryMode === "ChartBoundsQuery" && this.bounds) {
            json += "\"bounds\":" + "{" + "\"leftBottom\":" + "{" + "\"x\":" + this.bounds.left + "," +
                "\"y\":" + this.bounds.bottom + "}" + "," + "\"rightTop\":" + "{" + "\"x\":" + this.bounds.right + "," +
                "\"y\":" + this.bounds.top + "}" + "},";
        }

        if (this.chartQueryFilterParameters && this.chartQueryFilterParameters.length) {
            var chartParamArray = [];
            var chartLength = this.chartQueryFilterParameters.length;
            for (var j = 0; j < chartLength; j++) {
                var chartQueryFilterParameter = this.chartQueryFilterParameters[j];
                if (!(chartQueryFilterParameter instanceof ChartQueryFilterParameter)) {
                    continue;
                }
                chartParamArray.push(chartQueryFilterParameter.toJson());
            }
            var chartParamsJson = "[" + chartParamArray.join(",") + "]";
            chartParamsJson = "\"chartQueryParams\":" + chartParamsJson + ",";
            chartParamsJson += "\"startRecord\":" + this.startRecord + ",";
            chartParamsJson += "\"expectCount\":" + this.expectCount;
            chartParamsJson = "{" + chartParamsJson + "}";
            json += "\"chartQueryParameters\":" + chartParamsJson;
        }
        json = "{" + json + "}";
        return json;
    }
}

;// CONCATENATED MODULE: ./src/common/iServer/ChartQueryService.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/







/**
 * @class ChartQueryService
 * @deprecatedclass SuperMap.ChartQueryService
 * @category  iServer Map Chart
 * @classdesc 海图查询服务类。该类负责将海图查询所需参数（ChartQueryParameters）传递至服务端，并获取服务端的返回结果。
 *      用户可以通过两种方式获取查询结果：
 *      1.通过 AsyncResponder 类获取（推荐使用）；
 *      2.通过监听 QueryEvent.PROCESS_COMPLETE 事件获取。
 * @extends {CommonServiceBase}
 * @param {string} url - 地图查询服务访问地址。如："http://localhost:8090/iserver/services/map-ChartW/rest/maps/海图"。
 * @param {Object} options - 参数。
 * @param {DataFormat} [options.format] - 查询结果返回格式，目前支持 iServerJSON 和 GeoJSON 两种格式。参数格式为"ISERVER","GEOJSON"。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @example
 * 下面示例显示了如何进行海图属性查询：
 * var nameArray = ["GB4X0000_52000"];
 * var chartQueryFilterParameter = new ChartQueryFilterParameter({
 *       isQueryPoint:true,
 *        isQueryLine:true,
 *        isQueryRegion:true,
 *        attributeFilter:"SmID<10",
 *        chartFeatureInfoSpecCode:1
 *    });
 *
 * var chartQueryParameters = new ChartQueryParameters({
 *        queryMode:"ChartAttributeQuery",
 *        chartLayerNames:nameArray,
 *        returnContent:true,
 *        chartQueryFilterParameters:[chartQueryFilterParameter]
 *    });
 *
 * var chartQueryService = new ChartQueryService(url);
 *
 * chartQueryService.events.on({
 *        "processCompleted":processCompleted,
 *        "processFailed":processFailed
 *    });
 * chartQueryService.processAsync(chartQueryParameters);
 * @usage
 */
class ChartQueryService extends CommonServiceBase {


    constructor(url, options) {
        super(url, options);
        options = options || {};

        /**
         * @member {boolean} ChartQueryService.prototype.returnContent
         * @description 是否立即返回新创建资源的表述还是返回新资源的URI。
         */
        this.returnContent = null;

        /**
         * @member {DataFormat} ChartQueryService.prototype.format
         * @description 查询结果返回格式，目前支持iServerJSON 和GeoJSON两种格式
         *              参数格式为"ISERVER","GEOJSON",GEOJSON
         */
        this.format = DataFormat.GEOJSON;

        Util_Util.extend(this, options);
        var me = this;
        if (options.format) {
            me.format = options.format.toUpperCase();
        }

        if (!me.url) {
            return;
        }
        me.url = Util_Util.urlPathAppend(me.url, 'queryResults');

        this.CLASS_NAME = "SuperMap.ChartQueryService";
    }


    /**
     * @function ChartQueryService.prototype.destroy
     * @override
     */
    destroy() {
        var me = this;
        CommonServiceBase.prototype.destroy.apply(this, arguments);
        me.returnContent = null;
        me.format = null;
    }


    /**
     * @function ChartQueryService.prototype.processAsync
     * @description 使用服务地址 URL 实例化 ChartQueryService 对象。
     * @param {ChartQueryParameters} params - 查询参数。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    processAsync(params, callback) {
        //todo重点需要添加代码的地方
        if (!(params instanceof ChartQueryParameters)) {
            return;
        }
        var me = this, jsonParameters;
        me.returnContent = params.returnContent;
        jsonParameters = params.getVariablesJson();
        if (me.returnContent) {
            me.url = Util_Util.urlAppend(me.url, 'returnContent=true');
        }
        return me.request({
            method: "POST",
            data: jsonParameters,
            scope: me,
            success: callback,
            failure: callback
        });
    }


    /**
     * @function ChartQueryService.prototype.transformResult
     * @description 状态完成时转换结果。
     * @param {Object} result - 服务器返回的结果对象。
     * @param {Object} options - 请求参数。
     * @return {Object} 转换结果。
     */
    transformResult(result, options) {
        var me = this;
        result = Util_Util.transformResult(result);
        if (result && result.recordsets && me.format === DataFormat.GEOJSON) {
            for (var i = 0, recordsets = result.recordsets, len = recordsets.length; i < len; i++) {
                if (recordsets[i].features) {
                    var geoJSONFormat = new GeoJSON();
                    recordsets[i].features = geoJSONFormat.toGeoJSON(recordsets[i].features);
                }
            }

        }
        return { result, options };
    }

    /**
     * @function ChartQueryService.prototype.getQueryParameters
     * @description 将 JSON 对象表示的查询参数转化为 QueryParameters 对象。
     * @param {Object} params - JSON 字符串表示的查询参数。
     * @returns {QueryParameters} 返回查询结果
     */
    getQueryParameters(params) {
        return new QueryParameters({
            queryMode: params.queryMode,
            bounds: params.bounds,
            chartLayerNames: params.chartLayerNames,
            chartQueryFilterParameters: params.chartQueryFilterParameters,
            returnContent: params.returnContent
        });
    }
}

;// CONCATENATED MODULE: ./src/common/iServer/ChartFeatureInfoSpecsService.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/



/**
 * @class ChartFeatureInfoSpecsService
 * @deprecatedclass SuperMap.ChartFeatureInfoSpecsService
 * @category  iServer Map Chart
 * @classdesc 海图物标信息服务类，通过该服务类可以查询到服务端支持的所有海图物标信息。
 *            用户可以通过两种方式获取查询结果：
 *            一种是通过监听 ChartFeatureInfoSpecsEvent.PROCESS_COMPLETE 事件；
 *            另一种是使用 AsyncResponder 类实现异步处理。
 * @extends {CommonServiceBase}
 * @param {string} url - 地图（特指海图）服务地址。
 *        如："http://localhost:8090/iserver/services/map-ChartW/rest/maps/海图"。
 *        发送请求格式类似于："http://localhost:8090/iserver/services/map-ChartW/rest/maps/海图/chartFeatureInfoSpecs.json"。
 * @param {Object} options - 参数。
 * @param {DataFormat} [options.format] - 查询结果返回格式，目前支持 iServerJSON 和 GeoJSON 两种格式，参数格式为"ISERVER","GEOJSON"。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @usage
 */
class ChartFeatureInfoSpecsService extends CommonServiceBase {

    constructor(url, options) {
        super(url, options);
        this.CLASS_NAME = "SuperMap.ChartFeatureInfoSpecsService";
    }

    /**
     * @function ChartFeatureInfoSpecsService.prototype.destroy
     * @override
     */
    destroy() {
        super.destroy();
        Util_Util.reset(this);
    }

    /**
     * @function ChartFeatureInfoSpecsService.prototype.processAsync
     * @description 根据地图（特指海图）服务地址与服务端完成异步通讯，获取物标信息。
     *              当查询物标信息成功时，将触发 ChartFeatureInfoSpecsEvent.PROCESS_COMPLETE
     *              事件。用可以通过户两种方式获取图层信息:
     *              1. 通过 AsyncResponder 类获取（推荐使用）；
     *              2. 通过监听 ChartFeatureInfoSpecsEvent.PROCESS_COMPLETE 事件获取。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    processAsync(callback) {
        var me = this, method = "GET";
        if (!me.isTempLayers) {
            Util_Util.urlPathAppend(me.url,'chartFeatureInfoSpecs');
        }
        return me.request({
            method: method,
            params: null,
            scope: me,
            success: callback,
            failure: callback
        });
    }
}

;// CONCATENATED MODULE: ./src/common/iServer/ChartService.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/
 
 
 
 
 
 /**
  * @class ChartService
  * @category  iServer Map Chart
  * @classdesc 海图服务。
  * @extends {ServiceBase}
  * @example
  *      new ChartService(url).queryChart(param,function(result){
  *          //doSomething
  *      })
  * @param {string} url - 服务地址。
  * @param {Object} options - 参数。
  * @param {string} [options.proxy] - 服务代理地址。
  * @param {boolean} [options.withCredentials=false] - 请求是否携带 cookie。
  * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
  * @param {Object} [options.headers] - 请求头。
  * @usage
  */
 class ChartService_ChartService {
 
     constructor(url, options) {
      this.url = url;
      this.options = options || {};
     }
 
     /**
      * @function ChartService.prototype.queryChart
      * @description 查询海图服务。
      * @param {ChartQueryParameters} params - 海图查询所需参数类。
      * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
      * @param {DataFormat} resultFormat - 返回结果类型。
      * @returns {Promise} Promise 对象。
      */
     queryChart(params, callback, resultFormat) {
         var me = this,
             param = params,
             format = me._processFormat(resultFormat);
         var chartQueryService = new ChartQueryService(me.url, {
             proxy: me.options.proxy,
             withCredentials: me.options.withCredentials,
             crossOrigin: me.options.crossOrigin,
             headers: me.options.headers,
             format: format
         });
 
         return chartQueryService.processAsync(param, callback);
     }
 
     /**
      * @function ChartService.prototype.getChartFeatureInfo
      * @description 获取海图物标信息服务。
      * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
      * @returns {Promise} Promise 对象。
      */
     getChartFeatureInfo(callback) {
         var me = this;
         var url = Util_Util.urlPathAppend(me.url, 'chartFeatureInfoSpecs');
         var chartFeatureInfoSpecsService = new ChartFeatureInfoSpecsService(url, {
             proxy: me.options.proxy,
             withCredentials: me.options.withCredentials,
             crossOrigin: me.options.crossOrigin,
             headers: me.options.headers
         });
         return chartFeatureInfoSpecsService.processAsync(callback);
     }
 
     _processFormat(resultFormat) {
         return (resultFormat) ? resultFormat : DataFormat.GEOJSON;
     }
 }
 
;// CONCATENATED MODULE: ./src/mapboxgl/services/ChartService.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/





/**
 * @class ChartService
 * @category  iServer Map Chart
 * @classdesc 海图服务类。
 * @modulecategory Services
 * @extends {ServiceBase}
 * @example
 * new ChartService(url)
 *  .queryChart(param,function(result){
 *     //doSomething
 * })
 * @param {string} url - 服务地址。
 * @param {Object} options - 参数。
 * @param {string} [options.proxy] - 服务代理地址。
 * @param {boolean} [options.withCredentials=false] - 请求是否携带 cookie。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @usage
 */
class ChartService extends ServiceBase {
    constructor(url, options) {
        super(url, options);
        this._chartService = new ChartService_ChartService(url, options);
    }

    /**
     * @function ChartService.prototype.queryChart
     * @description 查询海图服务。
     * @param {ChartQueryParameters} params - 海图查询参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @param {DataFormat} [resultFormat=DataFormat.GEOJSON] - 返回结果类型。
     * @returns {Promise} Promise 对象。
     */
    queryChart(params, callback, resultFormat) {
      return this._chartService.queryChart(params, callback, resultFormat);
    }

    /**
     * @function ChartService.prototype.getChartFeatureInfo
     * @description 获取海图物标信息服务。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    getChartFeatureInfo(callback) {
      return this._chartService.getChartFeatureInfo(callback);
    }

    _processFormat(resultFormat) {
      return resultFormat ? resultFormat : DataFormat.GEOJSON;
    }
}


;// CONCATENATED MODULE: ./src/common/iServer/DataFlowService.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/




/**
 * @class DataFlowService
 * @deprecatedclass SuperMap.DataFlowService
 * @category iServer DataFlow
 * @classdesc 数据流服务类。
 * @extends {CommonServiceBase}
 * @param {string} url - 数据流服务地址。
 * @param {Object} options - 参数。
 * @param {function} options.style - 设置数据加载样式。
 * @param {function} [options.onEachFeature] - 设置每个数据加载popup等。
 * @param {GeoJSONObject} [options.geometry] - 指定几何范围，该范围内的要素才能被订阅。
 * @param {Object} [options.excludeField] - 排除字段。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @usage
 */
class DataFlowService_DataFlowService extends CommonServiceBase {


    constructor(url, options) {
        options = options || {};
        /*
         * @constant EVENT_TYPES
         * {Array.<string>}
         * 此类支持的事件类型
         */
        options.EVENT_TYPES = ["broadcastSocketConnected", "broadcastSocketClosed", "broadcastSocketError", "broadcastFailed", "broadcastSucceeded", "subscribeSocketConnected", "subscribeSocketClosed", "subscribeSocketError", "messageSucceeded", "setFilterParamSucceeded"]
        super(url, options);

        /**
         * @member {GeoJSONObject} DataFlowService.prototype.geometry
         * @description 指定几何范围，该范围内的要素才能被订阅。
         */
        this.geometry = null;

        /**
         * @member {Object} DataFlowService.prototype.prjCoordSys
         * @description 动态投影参数。
         */
        this.prjCoordSys = null;

        /**
         * @member {Object} DataFlowService.prototype.excludeField
         * @description 排除字段。
         */
        this.excludeField = null;

        Util_Util.extend(this, options);

        this.CLASS_NAME = "SuperMap.DataFlowService";
    }

    /**
     * @function DataFlowService.prototype.initBroadcast
     * @description 初始化广播。
     * @returns {DataFlowService}
     */
    initBroadcast() {
        var me = this;
        this.broadcastWebSocket = this._connect(Util_Util.urlPathAppend(me.url, 'broadcast'));
        this.broadcastWebSocket.onopen = function (e) {
            me.broadcastWebSocket.isOpen = true;
            e.eventType = 'broadcastSocketConnected';
            me.events.triggerEvent('broadcastSocketConnected', e);
        };
        this.broadcastWebSocket.onclose = function (e) {
            if (me.broadcastWebSocket) {
                me.broadcastWebSocket.isOpen = false;
            }
            e.eventType = 'broadcastSocketClosed';
            me.events.triggerEvent('broadcastSocketClosed', e);
        };
        this.broadcastWebSocket.onerror = function (e) {
            e.eventType = 'broadcastSocketError';
            me.events.triggerEvent('broadcastSocketError', e);
        };
        return this;
    }

    /**
     * @function DataFlowService.prototype.broadcast
     * @description 加载广播数据。
     * @param {GeoJSONObject} geoJSONFeature - JSON 格式的要素数据。
     */
    broadcast(geoJSONFeature) {
        if (!this.broadcastWebSocket||!this.broadcastWebSocket.isOpen) {
            this.events.triggerEvent('broadcastFailed');
            return;
        }
        this.broadcastWebSocket.send(JSON.stringify(geoJSONFeature));
        this.events.triggerEvent('broadcastSucceeded');
    }

    /**
     * @function DataFlowService.prototype.initSubscribe
     * @description 初始化订阅数据。
     * @returns {DataFlowService} DataFlowService的实例对象。
     */
    initSubscribe() {
        var me = this;
        this.subscribeWebSocket = this._connect(Util_Util.urlPathAppend(me.url, 'subscribe'));
        this.subscribeWebSocket.onopen = function (e) {
            me.subscribeWebSocket.send(me._getFilterParams());
            e.eventType = 'subscribeSocketConnected';
            me.events.triggerEvent('subscribeSocketConnected', e);
        };
        this.subscribeWebSocket.onclose = function (e) {
            e.eventType = 'subscribeWebSocketClosed';
            me.events.triggerEvent('subscribeWebSocketClosed', e);
        };
        this.subscribeWebSocket.onerror = function (e) {
            e.eventType = 'subscribeSocketError';
            me.events.triggerEvent('subscribeSocketError', e);
        };
        this.subscribeWebSocket.onmessage = function (e) {
            me._onMessage(e);
        };
        return this;
    }


    /**
     * @function DataFlowService.prototype.setExcludeField
     * @description 设置排除字段。
     * @param {Object} excludeField - 排除字段。
     * @returns {DataFlowService} DataFlowService的实例对象。
     */
    setExcludeField(excludeField) {
        this.excludeField = excludeField;
        this.subscribeWebSocket.send(this._getFilterParams());
        return this;
    }

    /**
     * @function DataFlowService.prototype.setGeometry
     * @description 设置添加的几何要素数据。
     * @param {GeoJSONObject} geometry - 指定几何范围，该范围内的要素才能被订阅。
     * @returns {DataFlowService} DataFlowService的实例对象。
     */
    setGeometry(geometry) {
        this.geometry = geometry;
        this.subscribeWebSocket.send(this._getFilterParams());
        return this;
    }

    /**
     * @function DataFlowService.prototype.unSubscribe
     * @description 结束订阅数据。
     */
    unSubscribe() {
        if (!this.subscribeWebSocket) {
            return;
        }
        this.subscribeWebSocket.close();
        this.subscribeWebSocket = null;
    }

    /**
     * @function DataFlowService.prototype.unBroadcast
     * @description 结束加载广播。
     */
    unBroadcast() {
        if (!this.broadcastWebSocket) {
            return;
        }
        this.broadcastWebSocket.close();
        this.broadcastWebSocket = null;
    }

    /**
     * @function DataFlowService.prototype.destroy
     * @override
     */
    destroy() {
        CommonServiceBase.prototype.destroy.apply(this, arguments);
        var me = this;
        me.geometry = null;
        me.prjCoordSys = null;
        me.excludeField = null;
        this.unBroadcast();
        this.unSubscribe();

    }


    _getFilterParams() {
        var filter = {
            filterParam: {
                prjCoordSys: this.prjCoordSys,
                excludeField: this.excludeField,
                geometry: this.geometry
            }
        };
        return Util_Util.toJSON(filter);
    }


    _onMessage(e) {
        if (e.data && e.data.indexOf("filterParam") >= 0) {
            var filterParam = JSON.parse(e.data);
            e.filterParam = filterParam;
            e.eventType = 'setFilterParamSucceeded';
            this.events.triggerEvent('setFilterParamSucceeded', e);
            return;
        }
        var feature = JSON.parse(e.data);
        e.featureResult = feature;
        e.eventType = 'messageSucceeded';
        this.events.triggerEvent('messageSucceeded', e);
    }


    _connect(url) {
        url = SecurityManager.appendCredential(url);
        if ("WebSocket" in window) {
            return new WebSocket(url);
        } else if ("MozWebSocket" in window) {
            var mozWebSocket = window.MozWebSocket;
            return new mozWebSocket(url);
        } else {
            console.log("no WebSocket");
            return null;
        }
    }
}

;// CONCATENATED MODULE: ./src/mapboxgl/services/DataFlowService.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/



/**
 * @class DataFlowService
 * @category  iServer DataFlow
 * @classdesc 数据流服务类。
 * @modulecategory Services
 * @extends {ServiceBase}
 * @example
 * new DataFlowService(url)
 *  .queryChart(param,function(result){
 *     //doSomething
 * })
 * @param {string} url - 服务地址。
 * @param {Object} options - 参数。
 * @param {GeoJSONObject} [options.geometry] - 指定几何范围，该范围内的要素才能被订阅。
 * @param {Object} [options.excludeField] - 排除字段。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @fires DataFlowService#broadcastSocketConnected
 * @fires DataFlowService#broadcastSocketError
 * @fires DataFlowService#broadcastFailed
 * @fires DataFlowService#broadcastSucceeded
 * @fires DataFlowService#subscribeSocketError
 * @fires DataFlowService#messageSucceeded
 * @fires DataFlowService#setFilterParamSucceeded
 * @usage
 */
class DataFlowService extends ServiceBase {


    constructor(url, options) {
        options = options || {};
        if (options.projection) {
            options.prjCoordSys = options.projection;
        }
        super(url, options);
        this.dataFlow = new DataFlowService_DataFlowService(url, options);
        /**
        * @event DataFlowService#broadcastSocketConnected
        * @description broadcast Socket 连接成功。
        */
        /**
        * @event DataFlowService#broadcastSocketError
        * @description broadcast Socket 连接失败。
        */
        /**
        * @event DataFlowService#broadcastFailed
        * @description 广播失败。
        */
        /**
        * @event DataFlowService#broadcastSucceeded
        * @description 广播成功。
        */
        /**
        * @event DataFlowService#subscribeSocketConnected
        * @description 订阅数据连接成功。
        */
        /**
        * @event DataFlowService#subscribeSocketError
        * @description 订阅数据连接失败。
        */
        /**
        * @event DataFlowService#messageSucceeded
        * @description 获取信息成功。
        */
        /**
        * @event DataFlowService#setFilterParamSucceeded
        * @description 设置过滤参数成功。
        */

        this.dataFlow.events.on({
            "broadcastSocketConnected": this._defaultEvent,
            "broadcastSocketError": this._defaultEvent,
            "broadcastFailed": this._defaultEvent,
            "broadcastSucceeded": this._defaultEvent,
            "subscribeSocketConnected": this._defaultEvent,
            "subscribeSocketError": this._defaultEvent,
            "messageSucceeded": this._defaultEvent,
            "setFilterParamSucceeded": this._defaultEvent,
            scope: this
        });
        var me = this;
        me.on('subscribeSocketConnected', function (e) {
            /**
             * @event DataFlowService#subscribesucceeded
             * @description 数据流服务订阅成功后触发。
             * @property {Object} e - 事件对象。
             */
            me.fire('subscribesucceeded', e);
        })

    }


    /**
     * @function DataFlowService.prototype.initBroadcast
     * @description 初始化广播。
     * @returns {DataFlowService}
     */
    initBroadcast() {
        this.dataFlow.initBroadcast();
        return this;
    }

    /**
     * @function DataFlowService.prototype.broadcast
     * @description 加载广播数据。
     * @param {JSONObject} obj - 要素数据。
     */
    broadcast(obj) {
        this.dataFlow.broadcast(obj);
    }

    /**
     * @function DataFlowService.prototype.initSubscribe
     * @description 初始化订阅数据。
     */
    initSubscribe() {
        this.dataFlow.initSubscribe();
        return this;
    }


    /**
     * @function DataFlowService.prototype.setExcludeField
     * @description 设置排除字段。
     * @param {Object} excludeField - 排除字段。
     */
    setExcludeField(excludeField) {
        this.dataFlow.setExcludeField(excludeField);
        this.options.excludeField = excludeField;
        return this;
    }

    /**
     * @function DataFlowService.prototype.setGeometry
     * @description 设置添加的几何要素数据。
     * @param {GeoJSONObject} geometry - 指定几何范围，该范围内的要素才能被订阅。
     */
    setGeometry(geometry) {
        this.dataFlow.setGeometry(geometry);
        this.options.geometry = geometry;
        return this;
    }

    /**
     * @function DataFlowService.prototype.unSubscribe
     * @description 结束订阅数据。
     */
    unSubscribe() {
        this.dataFlow.unSubscribe();
    }

    /**
     * @function DataFlowService.prototype.unBroadcast
     * @description 结束加载广播。
     */
    unBroadcast() {
        this.dataFlow.unBroadcast();
    }

    _defaultEvent(e) {
        this.fire(e.eventType || e.type, e);
    }
}

;// CONCATENATED MODULE: ./src/common/iServer/DatasetService.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/



/**
 * @class DatasetService
 * @deprecatedclass SuperMap.DatasetService
 * @category iServer Data Dataset
 * @classdesc 数据集查询服务。
 * @param {string} url - 服务的访问地址。如访问World Data服务，只需将url设为：http://localhost:8090/iserver/services/data-world/rest/data 即可。
 * @param {Object} options - 参数。
 * @param {DataFormat} [options.format=DataFormat.GEOJSON] - 查询结果返回格式，目前支持 iServerJSON 和 GeoJSON 两种格式。参数格式为 "ISERVER"，"GEOJSON"。
 * @param {string}options.datasource - 数据源名称。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @usage
 */
class DatasetService_DatasetService extends CommonServiceBase {

    constructor(url, options) {
        super(url, options);
        if(!options){
            return;
        }
        /**
         * @member {string} DatasetService.prototype.datasource
         * @description 要查询的数据集所在的数据源名称。
         */
        this.datasource = null;

        /**
         *  @member {string} DatasetService.prototype.dataset
         *  @description 要查询的数据集名称。
         */
        this.dataset = null;
        if (options) {
            Util_Util.extend(this, options);
        }

        this.CLASS_NAME = "SuperMap.DatasetService";
    }

    /**
     * @function DatasetService.prototype.destroy
     * @override
     */
    destroy() {
        super.destroy();
        var me = this;
        me.datasource = null;
        me.dataset = null;
    }

    /**
     * @function DatasetService.prototype.getDatasetsService
     * @description 执行服务，查询数据集服务。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    getDatasetsService(params, callback) {
        const url = Util_Util.urlPathAppend(this.url,`datasources/name/${params}/datasets`);
        return this.processAsync(url, 'GET', callback);
    }

    /**
     * @function DatasetService.prototype.getDatasetService
     * @description 执行服务，查询数据集信息服务。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    getDatasetService(datasourceName, datasetName, callback) {
        const url = Util_Util.urlPathAppend(this.url,`datasources/name/${datasourceName}/datasets/name/${datasetName}`);
        return this.processAsync(url, 'GET', callback);
    }

    /**
     * @function DatasetService.prototype.setDatasetService
     * @description 执行服务，更改数据集信息服务。
     * @returns {Promise} Promise 对象。
     */
    setDatasetService(params, callback) {
        if (!params) {
            return;
        }
        const url = Util_Util.urlPathAppend(this.url, `datasources/name/${params.datasourceName}/datasets/name/${params.datasetName}`);
        delete params.datasourceName;
        return this.processAsync(url, 'PUT', callback, params);
    }

     /**
     * @function DatasetService.prototype.deleteDatasetService
     * @description 执行服务，删除数据集信息服务。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    deleteDatasetService(datasourceName, datasetName, callback) {
      const url = Util_Util.urlPathAppend(this.url, `datasources/name/${datasourceName}/datasets/name/${datasetName}`);
      return this.processAsync(url, 'DELETE', callback);
    }

    processAsync(url, method, callback, params) {
       var me = this;
       let requestConfig = {
          url,
          method,
          scope: me,
          success: callback,
          failure: callback
        }
        params && (requestConfig.data = Util_Util.toJSON(params));
        return me.request(requestConfig);
    }
}

;// CONCATENATED MODULE: ./src/common/iServer/CreateDatasetParameters.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


/**
 * @class CreateDatasetParameters
 * @deprecatedclass SuperMap.CreateDatasetParameters
 * @category iServer Data Dataset
 * @classdesc 数据集创建参数类。
 * @param {Object} options - 参数。
 * @param {string} options.datasourceName - 数据源名称，此为必选参数。
 * @param {string} options.datasetName - 数据集名称，此为必选参数。
 * @param {string} options.datasetType - 数据集类型。目前支持创建的数据集类型有：点、线、面、文本、复合（CAD）和属性数据集。
 * @usage
 */
class CreateDatasetParameters {

    constructor(options) {
        if (!options) {
            return;
        }

        /**
         * @member {string} CreateDatasetParameters.prototype.datasourceName
         * @description 数据源名称，此为必选参数。
         */
         this.datasourceName = null;

        /**
         * @member {string} CreateDatasetParameters.prototype.datasetName
         * @description 数据集名称，此为必选参数。
         */
         this.datasetName = null;

        /**
         * @member {string} CreateDatasetParameters.prototype.datasetType
         * @description 数据集类型。目前支持创建的数据集类型有：点、线、面、文本、复合（CAD）和属性数据集。
         */
        this.datasetType = null;

        if (options) {
            Util_Util.extend(this, options);
        }
        this.CLASS_NAME = "SuperMap.CreateDatasetParameters";
    }
    /**
     * @function CreateDatasetParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        var me = this;
        me.datasourceName = null;
        me.datasetName = null;
        me.datasetType = null;
    }
}


;// CONCATENATED MODULE: ./src/common/iServer/UpdateDatasetParameters.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


/**
 * @class UpdateDatasetParameters
 * @deprecatedclass SuperMap.UpdateDatasetParameters
 * @category iServer Data Dataset
 * @classdesc 数据集信息更改参数类。
 * @param {Object} options - 参数。
 * @param {string} options.datasourceName - 数据源名称。
 * @param {string} options.datasetName - 数据集名称。
 * @param {boolean} options.isFileCache - 是否使用文件形式的缓存。仅对数据库型数据源中的矢量数据集有效。
 * @param {string} options.description - 数据集描述信息。
 * @param {string} options.prjCoordSys - 投影坐标系。
 * @param {Object} options.charset - 矢量数据集的字符集。当数据集类型为矢量数据集时，可以传递此参数。如果用户传递空值，则编码方式保持不变。
 * @param {Array.<string>} options.palette - 影像数据的颜色调色板。当数据集类型为影像数据集时，可以传递此参数。
 * @param {number} options.noValue - 栅格数据集中没有数据的像元的栅格值。当数据集类型为栅格数据集时，可以传递此参数。
 * @usage
 */
class UpdateDatasetParameters {

    constructor(options) {
        if (!options) {
            return;
        }

        /**
         * @member {string} UpdateDatasetParameters.prototype.datasourceName
         * @description 数据源名称。
         */
        this.datasourceName = null;

        /**
         * @member {string} UpdateDatasetParameters.prototype.datasetName
         * @description 数据集名称。
         */
        this.datasetName = null;

        /**
         * @member {boolean} UpdateDatasetParameters.prototype.isFileCache
         * @description 是否使用文件形式的缓存。仅对数据库型数据源中的矢量数据集有效。
         */
        this.isFileCache = null;

        /**
         * @member {string} UpdateDatasetParameters.prototype.description
         * @description 数据集描述信息。
         */
        this.description = null;

        /**
         * @member {string} UpdateDatasetParameters.prototype.prjCoordSys
         * @description 投影坐标系。
         */
        this.prjCoordSys = null;

        /**
         * @member {Object} UpdateDatasetParameters.prototype.charset
         * @description 矢量数据集的字符集。
         */
        this.charset = null;

        /**
         * @member {Array.<string>} UpdateDatasetParameters.prototype.palette
         * @description 影像数据的颜色调色板。
         */
        this.palette = null;

        /**
         * @member {number} UpdateDatasetParameters.prototype.noValue
         * @description 栅格数据集中没有数据的像元的栅格值。
         */
        this.noValue = null;

        if (options) {
            Util_Util.extend(this, options);
        }
        this.CLASS_NAME = "SuperMap.UpdateDatasetParameters";
    }

    /**
     * @function UpdateDatasetParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        var me = this;
        me.datasourceName = null;
        me.datasetName = null;
        me.isFileCache = null;
        me.prjCoordSys = null;
        me.charset = null;
        me.palette = null;
        me.noValue = null;
    }

}


;// CONCATENATED MODULE: ./src/mapboxgl/services/DatasetService.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/





/**
 * @class DatasetService
 * @category  iServer Data Dataset
 * @classdesc 数据集信息服务类。
 * @modulecategory Services
 * @param {string} url - 服务地址。
 * @param {Object} options - 参数。
 * @param {string} [options.proxy] - 服务代理地址。
 * @param {boolean} [options.withCredentials=false] - 请求是否携带 cookie。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @extends {ServiceBase}
 * @usage
 */

class DatasetService extends ServiceBase {

    constructor(url, options) {
        super(url, options);
        this._datasetService = new DatasetService_DatasetService(this.url, {
          proxy: this.options.proxy,
          withCredentials: this.options.withCredentials,
          crossOrigin: this.options.crossOrigin,
          headers: this.options.headers
        });
    }

    /**
     * @function DatasetService.prototype.getDatasets
     * @description 数据集查询服务。
     * @example
     *   new DatasetService(url).getDatasets(datasourceName,function(result){
     *     //doSomething
     *   });
     * @param {string} datasourceName - 数据源名称。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    getDatasets(datasourceName, callback) {
      if (!datasourceName) {
        return;
      }
      return this._datasetService.getDatasetsService(datasourceName, callback);
    }

    /**
     * @function DatasetService.prototype.getDataset
     * @description 数据集查询服务。
     * @example
     *   new DatasetService(url).getDataset(datasourceName, datasetName, function(result){
     *     //doSomething
     *   });
     * @param {string} datasourceName - 数据源名称。
     * @param {string} datasetName - 数据集名称。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    getDataset(datasourceName, datasetName, callback) {
      if (!datasourceName || !datasetName) {
        return;
      }
      return this._datasetService.getDatasetService(datasourceName, datasetName, callback);
    }

    /**
     * @function DatasetService.prototype.setDataset
     * @description 数据集信息设置服务。可实现修改已存在数据集，新增不存在数据集。
     * @example
     *   new DatasetService(url).setDataset(params, function(result){
     *     //doSomething
     *   });
     * @param {CreateDatasetParameters|UpdateDatasetParameters} params - 数据集创建参数类或数据集信息更改参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    setDataset(params, callback) {
      if(!(params instanceof CreateDatasetParameters) && !(params instanceof UpdateDatasetParameters)){
        return;
      }else if (params instanceof CreateDatasetParameters) {
          var datasetParams = {
              "datasetType": params.datasetType,
              "datasetName": params.datasetName,
              "datasourceName": params.datasourceName
          }
      }else if(params instanceof UpdateDatasetParameters){
            datasetParams = {
                  "datasetName": params.datasetName,
                  "datasourceName": params.datasourceName,
                  "isFileCache": params.isFileCache,
                  "description": params.description,
                  "prjCoordSys": params.prjCoordSys,
                  "charset": params.charset
              }
      }
      return this._datasetService.setDatasetService(datasetParams, callback);
    }

    /**
     * @function DatasetService.prototype.deleteDataset
     * @description 指定数据源下的数据集删除服务。
     * @example
     *   new DatasetService(url).deleteDataset(datasourceName, datasetName, function(result){
     *     //doSomething
     *   });
     * @param {string} datasourceName - 数据源名称。
     * @param {string} datasetName - 数据集名称。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    deleteDataset(datasourceName, datasetName, callback) {
      return this._datasetService.deleteDatasetService(datasourceName, datasetName, callback);
    }
}

;// CONCATENATED MODULE: ./src/common/iServer/SetDatasourceParameters.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


/**
 * @class SetDatasourceParameters
 * @deprecatedclass SuperMap.SetDatasourceParameters
 * @category iServer Data Datasource
 * @classdesc 设置数据源信息参数类。
 * @param {Object} options - 参数。
 * @param {string} options.datasourceName - 数据源名称。
 * @param {string} options.description - 数据源描述信息。
 * @param {string} options.coordUnit - 坐标单位。
 * @param {string} options.distanceUnit - 距离单位。
 * @usage
 */
class SetDatasourceParameters {

    constructor(options) {
        if (!options) {
            return;
        }

        /**
         * @member {string} SetDatasourceParameters.prototype.datasourceName
         * @description 数据源名称。
         */
        this.datasourceName = null;

        /**
         * @member {string} SetDatasourceParameters.prototype.description
         * @description 数据源描述信息。
         */
        this.description = null;

        /**
         * @member {string} SetDatasourceParameters.prototype.coordUnit
         * @description 坐标单位。
         */
        this.coordUnit = null;

        /**
         * @member {string} SetDatasourceParameters.prototype.distanceUnit
         * @description 距离单位。
         */
        this.distanceUnit = null;

        if (options) {
            Util_Util.extend(this, options);
        }
        this.CLASS_NAME = "SuperMap.SetDatasourceParameters";
    }

    /**
     * @function SetDatasourceParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        var me = this;
        me.datasourceName = null;
        me.description = null;
        me.coordUnit = null;
        me.distanceUnit = null;
    }

}


;// CONCATENATED MODULE: ./src/common/iServer/DatasourceService.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/



/**
 * @class DatasourceService
 * @deprecatedclass SuperMap.DatasourceService
 * @category iServer Data Datasource
 * @classdesc 数据源查询服务类。
 * @param {string} url - 服务地址。如访问World Data服务，只需将url设为：http://localhost:8090/iserver/services/data-world/rest/data 即可。
 * @param {Object} options - 参数。
 * @param {DataFormat} [options.format=DataFormat.GEOJSON] - 查询结果返回格式，目前支持 iServerJSON 和 GeoJSON 两种格式。参数格式为 "ISERVER"，"GEOJSON"。
 * @param {string} options.datasource - 要查询的数据集所在的数据源名称。
 * @param {string} options.dataset - 要查询的数据集名称。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @extends {CommonServiceBase}
 * @usage
 */

class DatasourceService_DatasourceService extends CommonServiceBase {

    constructor(url, options) {
        super(url, options);
        if (options) {
            Util_Util.extend(this, options);
        }
        this.CLASS_NAME = "SuperMap.DatasourceService";
    }


    /**
     * @function DatasourceService.prototype.destroy
     * @override
     */
    destroy() {
        super.destroy();
    }


    /**
     * @function DatasourceService.prototype.getDatasourceService
     * @description 获取指定数据源信息。
     * @param {string} datasourceName - 数据源名称。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    getDatasourceService(datasourceName, callback) {
        let url = Util_Util.urlPathAppend(this.url,`datasources/name/${datasourceName}`);
        return this.processAsync(url, "GET", callback);
    }

    /**
     * @function DatasourceService.prototype.getDatasourcesService
     * @description 获取所有数据源信息。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    getDatasourcesService(callback) {
        let url = Util_Util.urlPathAppend(this.url,`datasources`);
        return this.processAsync(url, "GET", callback);
    }
    /**
     * @function DatasourceService.prototype.setDatasourceService
     * @description 更新数据源信息。
     * @param {Object} params 请求参数信息。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    setDatasourceService(params, callback) {
        if (!params) {
            return;
        }
        const url = Util_Util.urlPathAppend(this.url,`datasources/name/${params.datasourceName}`);
        return this.processAsync(url, "PUT", callback, params);
    }

    processAsync(url, method, callback, params) {
       var me = this;
       let requestConfig = {
          url,
          method,
          scope: me,
          success: callback,
          failure: callback
        }
        params && (requestConfig.data = Util_Util.toJSON(params));
        return me.request(requestConfig);
    }
}

;// CONCATENATED MODULE: ./src/mapboxgl/services/DatasourceService.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/





/**
 * @class DatasourceService
 * @category  iServer Data Datasource
 * @classdesc 数据源服务类。
 * @modulecategory Services
 * @param {string} url - 服务地址。
 * @param {Object} options - 参数。
 * @param {string} [options.proxy] - 服务代理地址。
 * @param {boolean} [options.withCredentials=false] - 请求是否携带 cookie。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @extends {ServiceBase}
 * @usage
 */
class DatasourceService extends ServiceBase {
    constructor(url, options) {
        super(url, options);
        this._datasourceService = new DatasourceService_DatasourceService(this.url, {
          proxy: this.proxy,
          withCredentials: this.withCredentials,
          crossOrigin: this.crossOrigin,
          headers: this.headers
        });
    }

    /**
     * @function DatasourceService.prototype.getDatasources
     * @description 数据源集查询服务。
     * @example
     *   new DatasourceService(url).getDatasources(function(result){
     *     //doSomething
     *   });
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    getDatasources(callback) {
      return this._datasourceService.getDatasourcesService(callback);
    }

    /**
     * @function DatasourceService.prototype.getDatasource
     * @description 数据源信息查询服务。
     * @example
     *   new DatasourceService(url).getDatasource(datasourceName,function(result){
     *     //doSomething
     *   });
     * @param {string} datasourceName - 数据源名称。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。。
     * @returns {Promise} Promise 对象。
     */
    getDatasource(datasourceName, callback) {
      if (!datasourceName) {
        return;
      }
      return this._datasourceService.getDatasourceService(datasourceName, callback);
    }

    /**
     * @function DatasourceService.prototype.setDatasource
     * @description 数据源信息设置服务。可实现更改当前数据源信息。
     * @example
     *  new DatasourceService(url).setDatasource(params, function(result){
     *     //doSomething
     *   });
     * @param {SetDatasourceParameters} params - 数据源信息查询参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    setDatasource(params, callback) {
      if (!(params instanceof SetDatasourceParameters)) {
        return;
      }
      const datasourceParams = {
          description: params.description ,
          coordUnit: params.coordUnit,
          distanceUnit: params.distanceUnit,
          datasourceName: params.datasourceName
      };
      return this._datasourceService.setDatasourceService(datasourceParams, callback);
    }
}


;// CONCATENATED MODULE: ./src/common/iServer/EditFeaturesParameters.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/




/**
 * @class EditFeaturesParameters
 * @deprecatedclass SuperMap.EditFeaturesParameters
 * @category iServer Data Feature
 * @classdesc 数据集添加、修改、删除参数类。
 * @param {Object} options - 参数。
 * @param {Array.<FeatureVector|GeoJSONObject|ol.Feature>} options.features - 当前需要创建或者是修改的要素集。
 * @param {boolean} [options.returnContent=false] - 是否返回要素内容。如果为true则返回创建要素的 ID 数组，否则返回 featureResult 资源的 URI。
 * @param {EditType} [options.editType=EditType.ADD] - POST 动作类型 (ADD、UPDATE、DELETE)。
 * @param {Array.<string|number>} [options.IDs] - 删除要素时的要素的 ID 数组。
 * @usage
 */
class EditFeaturesParameters {


    constructor(options) {
        /**
         * @member {string} EditFeaturesParameters.prototype.dataSourceName
         * @description 当前需要创建或者是修改的要素的数据源。
         */
        this.dataSourceName = null;

        /**
         * @member {string} EditFeaturesParameters.prototype.dataSetName
         * @description 当前需要创建或者是修改的要素的数据集。
         */
        this.dataSetName = null;

        /**
         * @member {Array.<FeatureVector|GeoJSONObject|ol.Feature>} EditFeaturesParameters.prototype.features
         * @description 当前需要创建或者是修改的要素集。
         */
        this.features = null;

        /**
         * @member {EditType} [EditFeaturesParameters.prototype.editType=EditType.ADD]
         * @description 要素集更新类型 (add、update、delete)。
         */
        this.editType = EditType.ADD;

        /**
         * @member {Array.<string|number>} [EditFeaturesParameters.prototype.IDs]
         * @description 执行删除时要素集 ID 集合。
         */
        this.IDs = null;

        /**
         * @member {boolean} [EditFeaturesParameters.prototype.returnContent=false]
         * @description 要素添加时，isUseBatch 不传或传为 false 的情况下有效。
         *              true 表示直接返回新创建的要素的 ID 数组；false 表示返回创建的 featureResult 资源的 URI。
         */
        this.returnContent = false;

        /**
         * @member {boolean} [EditFeaturesParameters.prototype.isUseBatch=false]
         * @description 是否使用批量添加要素功能，要素添加时有效。批量添加能够提高要素编辑效率。true 表示批量添加；false 表示不使用批量添加。
         */
        this.isUseBatch = false;
        Util_Util.extend(this, options);

        this.CLASS_NAME = "SuperMap.EditFeaturesParameters";
    }


    /**
     * @function EditFeaturesParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        var me = this;
        me.dataSourceName = null;
        me.dataSetName = null;
        me.features = null;
        me.editType = null;
        me.IDs = null;
        me.returnContent = null;
    }

    /**
     * @function EditFeaturesParameters.prototype.toJsonParameters
     * @description 将 EditFeaturesParameters 对象参数转换为 JSON 字符串。
     * @param {EditFeaturesParameters} params - 地物编辑参数。
     * @returns {string} JSON 字符串。
     */
    static toJsonParameters(params) {
        var feature,
            len,
            features,
            editType = params.editType;

        if (editType === EditType.DELETE) {
            if (params.IDs === null) {
                return;
            }

            features = {ids: params.IDs};
        } else {
            features = [];
            if (params.features) {
                len = params.features.length;
                for (var i = 0; i < len; i++) {
                    feature = params.features[i];
                    feature.geometry = ServerGeometry.fromGeometry(feature.geometry);
                    features.push(feature);
                }
            }
        }

        return Util_Util.toJSON(features);
    }

}

;// CONCATENATED MODULE: ./src/common/iServer/EditFeaturesService.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/






/**
 * @class EditFeaturesService
 * @deprecatedclass SuperMap.EditFeaturesService
 * @category  iServer Data Feature
 * @classdesc 数据服务中数据集添加、更新、删除服务类。
 * @extends {CommonServiceBase}
 * @param {string} url - 服务端的数据服务资源地址。请求数据服务中数据集编辑服务，URL 应为：</br>
 * http://{服务器地址}:{服务端口号}/iserver/services/{数据服务名}/rest/data/datasources/name/{数据源名}/datasets/name/{数据集名} 。</br>
 * 例如：http://localhost:8090/iserver/services/data-jingjin/rest/data/datasources/name/Jingjin/datasets/name/Landuse_R
 * @param {Object} options - 参数。
 * @param {DataFormat} [format] -查询结果返回格式，目前支持iServerJSON 和GeoJSON两种格式。参数格式为"ISERVER","GEOJSON"。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @example
 * var myService = new EditFeaturesService(url);
 * @usage
 */
class EditFeaturesService extends CommonServiceBase {

    constructor(url, options) {
        super(url, options);
        /**
         * @member {boolean} [EditFeaturesService.prototype.returnContent=false]
         * @description要素添加时，isUseBatch 不传或传为 false 的情况下有效。true 表示直接返回新创建的要素的 ID 数组;false 表示返回创建的 featureResult 资源的 URI。
         */
        this.returnContent = false;

        /**
         * @member {boolean} [EditFeaturesService.prototype.isUseBatch=false]
         * @description 是否使用批量添加要素功能，要素添加时有效。
         *              批量添加能够提高要素编辑效率。
         *              true 表示批量添加；false 表示不使用批量添加。
         */
        this.isUseBatch = false;

        if (options) {
            Util_Util.extend(this, options);
        }
        this.url = Util_Util.urlPathAppend(this.url, 'features');

        this.CLASS_NAME = "SuperMap.EditFeaturesService";
    }


    /**
     * @function EditFeaturesService.prototype.destroy
     * @override
     */
    destroy() {
        super.destroy();
        var me = this;
        me.returnContent = null;
        me.isUseBatch = null;
        me.fromIndex = null;
        me.toIndex = null;
    }


    /**
     * @function EditFeaturesService.prototype.processAsync
     * @description 负责将客户端的更新参数传递到服务端。
     * @param {EditFeaturesParameters} params - 编辑要素参数。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    processAsync(params, callback) {
        if (!(params instanceof EditFeaturesParameters)) {
            return;
        }
        var me = this,
            method = "POST",
            ids = "",
            editType = params.editType,
            jsonParameters = null;

        me.returnContent = params.returnContent;
        me.isUseBatch = params.isUseBatch;
        jsonParameters = EditFeaturesParameters.toJsonParameters(params);
        if (editType === EditType.DELETE) {
            ids = Util_Util.toJSON(params.IDs);
            jsonParameters = ids;
            var urlWithIds = Util_Util.urlAppend(me.url, Util_Util.getParameterString({ids}))
            if(FetchRequest.urlIsLong(urlWithIds)) {
                me.url = Util_Util.urlAppend(me.url, Util_Util.getParameterString({_method: 'DELETE'}));
                method = "POST";
            } else{
                me.url = urlWithIds;
                method = "DELETE";
            }
           
        } else if (editType === EditType.UPDATE) {
            method = "PUT";
        } else {
            if (me.isUseBatch) {
                me.url = Util_Util.urlAppend(me.url, `isUseBatch=${me.isUseBatch}`);
                me.returnContent = false;
            }
            if (me.returnContent) {
                me.url = Util_Util.urlAppend(me.url, 'returnContent=true');
                method = "POST";
            }
        }

        return me.request({
            method: method,
            data: jsonParameters,
            scope: me,
            success: callback,
            failure: callback
        });
    }

    /**
     * @function EditFeaturesService.prototype.getMetaData
     * @description 获取地理要素元信息。
     * @version 11.1.1
     */
    getMetaData(params, callback){
      var me = this;
      var featureId = params.featureId;
      me.url = Util_Util.urlPathAppend(me.url, featureId +'/metadata');
      return me.request({
        method: "GET",
        data: null,
        scope: me,
        success: callback,
        failure: callback
      });
    }
}

;// CONCATENATED MODULE: ./src/common/iServer/GetFeaturesServiceBase.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/





/**
 * @class GetFeaturesServiceBase
 * @deprecatedclass SuperMap.GetFeaturesServiceBase
 * @category  iServer Data FeatureResults
 * @classdesc 数据服务中数据集查询服务基类。获取结果数据类型为 Object。包含 result 属性，result 的数据格式根据 format 参数决定为 GeoJSON 或者 iServerJSON。
 * @extends CommonServiceBase
 * @param {string} url - 服务地址。请求数据服务中数据集查询服务，
 * URL应为：http://{服务器地址}:{服务端口号}/iserver/services/{数据服务名}/rest/data/
 * 例如："http://localhost:8090/iserver/services/data-jingjin/rest/data/"
 * @param {Object} options - 参数。
 * @param {DataFormat} [options.format=DataFormat.GEOJSON] - 查询结果返回格式，目前支持 iServerJSON、GeoJSON、FGB 三种格式。参数格式为 "ISERVER"，"GEOJSON"，"FGB"。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @example
 * var myService = new GetFeaturesServiceBase(url);
 * @usage
 */
class GetFeaturesServiceBase extends CommonServiceBase {

    constructor(url, options) {
        super(url, options);
        options = options || {};

        /**
         * @member {boolean} [GetFeaturesServiceBase.prototype.returnContent=true]
         * @description 是否立即返回新创建资源的表述还是返回新资源的 URI。
         * 如果为 true，则直接返回新创建资源，即查询结果的表述。
         * 如果为 false，则返回的是查询结果资源的 URI。
         */
        this.returnContent = true;

        /**
         * @member {number} [GetFeaturesServiceBase.prototype.fromIndex=0]
         * @description 查询结果的最小索引号。如果该值大于查询结果的最大索引号，则查询结果为空。
         */
        this.fromIndex = 0;

        /**
         * @member {number} [GetFeaturesServiceBase.prototype.toIndex=19]
         * @description 查询结果的最大索引号。
         * 如果该值大于查询结果的最大索引号，则以查询结果的最大索引号为终止索引号。
         */
        this.toIndex = 19;

         /**
         * @member {number} [GetFeaturesServiceBase.prototype.hasGeometry=true]
         * @description 返回结果是否包含Geometry。
         */
        this.hasGeometry = true;

        /**
         * @member {number} [GetFeaturesServiceBase.prototype.maxFeatures=1000]
         * @description 进行 SQL 查询时，用于设置服务端返回查询结果条目数量。
         */
        this.maxFeatures = null;

        /**
         * @member {string} [GetFeaturesServiceBase.prototype.format=DataFormat.GEOJSON]
         * @description 查询结果返回格式，目前支持 iServerJSON、GeoJSON、FGB 三种格式。
         * 参数格式为 "ISERVER"，"GEOJSON"，"FGB"。
         */
        this.format = DataFormat.GEOJSON;

        Util_Util.extend(this, options);
        this.url = Util_Util.urlPathAppend(this.url, 'featureResults');
        this.CLASS_NAME = "SuperMap.GetFeaturesServiceBase";
    }

    /**
     * @function GetFeaturesServiceBase.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        super.destroy();
        var me = this;
        me.returnContent = null;
        me.fromIndex = null;
        me.toIndex = null;
        me.maxFeatures = null;
        me.format = null;
        me.hasGeometry = null;
    }

    /**
     * @function GetFeaturesServiceBase.prototype.processAsync
     * @description 将客户端的查询参数传递到服务端。
     * @param {Object} params - 查询参数。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    processAsync(params, callback) {
        if (!params) {
            return;
        }
        var me = this,
            jsonParameters = null,
            firstPara = true;

        me.returnContent = params.returnContent;
        me.fromIndex = params.fromIndex;
        me.toIndex = params.toIndex;
        me.maxFeatures = params.maxFeatures;
        me.hasGeometry = params.hasGeometry;
        if (me.returnContent) {
          firstPara = false;
        }
        var isValidNumber = me.fromIndex != null && me.toIndex != null && !isNaN(me.fromIndex) && !isNaN(me.toIndex);
        if (isValidNumber && me.fromIndex >= 0 && me.toIndex >= 0 && !firstPara) {
            me.url = Util_Util.urlAppend(me.url, `fromIndex=${me.fromIndex}&toIndex=${me.toIndex}`);
        }

        if (params.returnCountOnly) {
            me.url = Util_Util.urlAppend(me.url, "&returnCountOnly=" + params.returnContent)
        }

        jsonParameters = me.getJsonParameters(params);
        return me.request({
            method: "POST",
            data: jsonParameters,
            scope: me,
            success: callback,
            failure: callback
        });
    }

    /**
     * @function GetFeaturesServiceBase.prototype.transformResult
     * @description 状态完成时转换结果。
     * @param {Object} result - 服务器返回的结果对象。
     * @param {Object} options - 请求参数。
     * @return {Object} 转换结果。
     */
    transformResult(result, options) {
        var me = this;
        result = Util_Util.transformResult(result);
        if (me.format === DataFormat.GEOJSON && result.features) {
            var geoJSONFormat = new GeoJSON();
            result.features = geoJSONFormat.toGeoJSON(result.features);
        }
       return { result, options };
    }

    dataFormat() {
      return [DataFormat.GEOJSON, DataFormat.ISERVER, DataFormat.FGB];
    }

}

;// CONCATENATED MODULE: ./src/common/iServer/FilterParameter.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


/**
 * @class FilterParameter
 * @deprecatedclass SuperMap.FilterParameter
 * @category iServer Data FeatureResults
 * @classdesc 查询过滤条件参数类。该类用于设置查询数据集的查询过滤参数。
 * @param {Object} options - 参数。
 * @param {string} options.attributeFilter - 属性过滤条件。
 * @param {string} options.name - 查询数据集名称或者图层名称。
 * @param {Array.<JoinItem>} [options.joinItems] - 与外部表的连接信息 JoinItem 数组。
 * @param {Array.<LinkItem>} [options.linkItems] - 与外部表的关联信息 LinkItem 数组。
 * @param {Array.<string>} [options.ids] - 查询 id 数组，即属性表中的 SmID 值。
 * @param {string} [options.orderBy] - 查询排序的字段，orderBy 的字段须为数值型的。
 * @param {string} [options.groupBy] - 查询分组条件的字段。
 * @param {Array.<string>} [options.fields] - 查询字段数组。
 * @usage
 */
class FilterParameter {


    constructor(options) {
        /**
         * @member {string} FilterParameter.prototype.attributeFilter
         * @description 属性过滤条件。
         * 相当于 SQL 语句中的 WHERE 子句，其格式为：WHERE <条件表达式>，
         * attributeFilter 就是其中的“条件表达式”。
         * 该字段的用法为 attributeFilter = "过滤条件"。
         * 例如，要查询字段 fieldValue 小于100的记录，设置 attributeFilter = "fieldValue < 100"；
         * 要查询字段 name 的值为“酒店”的记录，设置 attributeFilter = "name like '%酒店%'"，等等。
         */
        this.attributeFilter = null;

        /**
         * @member {string} FilterParameter.prototype.name
         * @description 查询数据集名称或者图层名称，根据实际的查询对象而定。
         * 一般情况下该字段为数据集名称，但在进行与地图相关功能的操作时，
         * 需要设置为图层名称（图层名称格式：数据集名称@数据源别名）。
         * 因为一个地图的图层可能是来自于不同数据源的数据集，
         * 而不同的数据源中可能存在同名的数据集，
         * 使用数据集名称不能唯一的确定数据集，
         * 所以在进行与地图相关功能的操作时，该值需要设置为图层名称。
         */
        this.name = null;

        /**
         * @member {Array.<JoinItem>} [FilterParameter.prototype.joinItems]
         * @description 与外部表的连接信息 JoinItem 数组。
         */
        this.joinItems = null;

        /**
         * @member {Array.<LinkItem>} [FilterParameter.prototype.linkItems]
         * @description 与外部表的关联信息 LinkItem 数组。
         */
        this.linkItems = null;

        /**
         * @member {Array.<string>} [FilterParameter.prototype.ids]
         * @description 查询 id 数组，即属性表中的 SmID 值。
         */
        this.ids = null;

        /**
         * @member {string} [FilterParameter.prototype.orderBy]
         * @description 查询排序的字段，orderBy的字段须为数值型的。
         * 相当于 SQL 语句中的 ORDER BY 子句，其格式为：ORDER BY <列名>，
         * 列名即属性表中每一列的名称，列又可称为属性，在 SuperMap 中又称为字段。
         * 对单个字段排序时，该字段的用法为 orderBy = "字段名"；
         * 对多个字段排序时，字段之间以英文逗号进行分割，用法为 orderBy = "字段名1, 字段名2"。
         * 例如，现有一个国家数据集，它有两个字段分别为“SmArea”和“pop_1994”，
         * 分别表示国家的面积和1994年的各国人口数量。
         * 如果要按照各国人口数量对记录进行排序，则 orderBy = "pop_1994"；
         * 如果要以面积和人口进行排序，则 orderBy = "SmArea, pop_1994"。
         */
        this.orderBy = null;


        /**
         * @member {string} [FilterParameter.prototype.groupBy]
         * @description 查询分组条件的字段。
         * 相当于 SQL 语句中的 GROUP BY 子句，其格式为：GROUP BY <列名>，
         * 列名即属性表中每一列的名称，列又可称为属性，在 SuperMap 中又称为字段。
         * 对单个字段分组时，该字段的用法为 groupBy = "字段名"；
         * 对多个字段分组时，字段之间以英文逗号进行分割，用法为 groupBy = "字段名1, 字段名2"。
         * 例如，现有一个全球城市数据集，该数据集有两个字段分别为“Continent”和“Country”，
         * 分别表示某个城市所属的洲和国家。
         * 如果要按照国家对全球的城市进行分组，可以设置 groupBy = "Country"；
         * 如果以洲和国家对城市进行分组，设置 groupBy = "Continent, Country"。
         */
        this.groupBy = null;

        /**
         * @member {Array.<string>} [FilterParameter.prototype.fields]
         * @description 查询字段数组，如果不设置则使用系统返回的所有字段。
         */
        this.fields = null;
        if (options) {
            Util_Util.extend(this, options);
        }

        this.CLASS_NAME = "SuperMap.FilterParameter";
    }


    /**
     * @function FilterParameter.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        var me = this;
        me.attributeFilter = null;
        me.name = null;
        if (me.joinItems) {
            for (let i = 0, joinItems = me.joinItems, len = joinItems.length; i < len; i++) {
                joinItems[i].destroy();
            }
            me.joinItems = null;
        }
        if (me.linkItems) {
            for (let i = 0, linkItems = me.linkItems, len = linkItems.length; i < len; i++) {
                linkItems[i].destroy();
            }
            me.linkItems = null;
        }
        me.ids = null;
        me.orderBy = null;
        me.groupBy = null;
        me.fields = null;
    }


}

;// CONCATENATED MODULE: ./src/common/iServer/GetFeaturesParametersBase.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


/**
 * @class GetFeaturesParametersBase
 * @deprecatedclass SuperMap.GetFeaturesParametersBase
 * @category  iServer Data FeatureResults
 * @classdesc 要素查询参数基类。
 * @param {Object} options - 参数。
 * @param {Array.<string>} options.datasetNames - 数据集名称列表。
 * @param {boolean} [options.returnContent=true] - 是否直接返回查询结果。
 * @param {number} [options.fromIndex=0] - 查询结果的最小索引号。
 * @param {number} [options.toIndex=19] - 查询结果的最大索引号。
 * @param {string|number} [options.targetEpsgCode] - 动态投影的目标坐标系对应的 EPSG Code，使用此参数时，returnContent 参数需为 true。
 * @param {Object} [options.targetPrj] - 动态投影的目标坐标系。使用此参数时，returnContent 参数需为 true。如：prjCoordSys={"epsgCode":3857}。当同时设置 targetEpsgCode 参数时，此参数不生效。
 * @param {MetricsAggParameter|GeoHashGridAggParameter} [options.aggregations] - 聚合查询参数。该参数仅支持数据来源 Elasticsearch 服务的Supermap iServer的rest数据服务。
 * @usage
 */
class GetFeaturesParametersBase {
    constructor(options) {
        /**
         * @member {Array.<string>} GetFeaturesParametersBase.prototype.datasetName
         * @description 数据集集合中的数据集名称列表。
         */
        this.datasetNames = null;

        /**
         * @member {string} GetFeaturesParametersBase.prototype.targetEpsgCode
         * @description 动态投影的目标坐标系对应的 EPSG Code，使用时需设置 returnContent 参数为 true。
         */
        this.targetEpsgCode = null;

        /**
         * @member {Object} GetFeaturesParametersBase.prototype.targetPrj
         * @description 动态投影的目标坐标系。使用时需设置 returnContent 参数为 true。如：prjCoordSys={"epsgCode":3857}。当同时设置 targetEpsgCode 参数时，此参数不生效。
         */
        this.targetPrj = null;

        /**
         * @member {boolean} [GetFeaturesParametersBase.prototype.returnContent=true]
         * @description 是否立即返回新创建资源的表述还是返回新资源的 URI。
         *              如果为 true，则直接返回新创建资源，即查询结果的表述。
         *              如果为 false，则返回的是查询结果资源的 URI。
         */
        this.returnContent = true;

        /**
         * @member {number} [GetFeaturesParametersBase.prototype.fromIndex=0]
         * @description 查询结果的最小索引号。如果该值大于查询结果的最大索引号，则查询结果为空。
         */
        this.fromIndex = 0;

        /**
         * @member {number} [GetFeaturesParametersBase.prototype.toIndex=19]
         * @description 查询结果的最大索引号。如果该值大于查询结果的最大索引号，则以查询结果的最大索引号为终止索引号。
         */
        this.toIndex = 19;

        /**
         * @member {boolean} [GetFeaturesParametersBase.prototype.returnCountOnly=false]
         * @description 只返回查询结果的总数。
         */
        this.returnCountOnly = false;

        /**
         * @member {number} [GetFeaturesParametersBase.prototype.maxFeatures=1000]
         * @description 进行 SQL 查询时，用于设置服务端返回查询结果条目数量。
         */
        this.maxFeatures = null;

        /**
         * @member {number} [GetFeaturesParametersBase.prototype.hasGeometry=true]
         * @description 返回结果是否包含Geometry。
         */
        this.hasGeometry = true;

        /**
         * @member {MetricsAggParameter|GeoHashGridAggParameter} GetFeaturesParametersBase.prototype.aggregations
         * @description 聚合查询参数，该参数仅支持数据来源 Elasticsearch 服务的Supermap iServer的rest数据服务。
         */
        this.aggregations = null;

        Util_Util.extend(this, options);

        this.CLASS_NAME = 'SuperMap.GetFeaturesParametersBase';
    }

    /**
     *
     * @function GetFeaturesParametersBase.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        var me = this;
        me.datasetNames = null;
        me.returnContent = null;
        me.fromIndex = null;
        me.toIndex = null;
        me.hasGeometry = null;
        me.maxFeatures = null;
        me.targetEpsgCode = null;
        me.targetPrj = null;
        if (me.aggregation) {
            me.aggregation = null;
        }
    }
}

;// CONCATENATED MODULE: ./src/common/iServer/GetFeaturesByIDsParameters.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/




/**
 * @class GetFeaturesByIDsParameters
 * @deprecatedclass SuperMap.GetFeaturesByIDsParameters
 * @category  iServer Data FeatureResults
 * @classdesc ID 查询参数类。
 * @param {Object} options - 参数。
 * @param {Array.<number>} options.IDs - 指定查询的元素 ID 信息。
 * @param {Array.<string>} [options.fields] - 设置查询结果返回字段。默认返回所有字段。
 * @param {Array.<string>} options.dataSetNames - 数据集集合中的数据集名称列表。
 * @param {boolean} [options.returnContent=true] - 是否直接返回查询结果。
 * @param {number} [options.fromIndex=0] - 查询结果的最小索引号。
 * @param {number} [options.toIndex=19] - 查询结果的最大索引号。
 * @param {string|number} [options.targetEpsgCode] - 动态投影的目标坐标系对应的 EPSG Code，使用此参数时，returnContent 参数需为 true。
 * @param {Object} [options.targetPrj] - 动态投影的目标坐标系。使用此参数时，returnContent 参数需为 true。如：prjCoordSys={"epsgCode":3857}。当同时设置 targetEpsgCode 参数时，此参数不生效。
 * @param {MetricsAggParameter|GeoHashGridAggParameter} [options.aggregations] - 聚合查询参数。该参数仅支持数据来源 Elasticsearch 服务的Supermap iServer的rest数据服务。
 * @extends {GetFeaturesParametersBase}
 * @usage
 */
class GetFeaturesByIDsParameters extends GetFeaturesParametersBase {
    constructor(options) {
        super(options);
        /**
         * @member {string} GetFeaturesByIDsParameters.prototype.getFeatureMode
         * @description 数据集查询模式。
         */
        this.getFeatureMode = 'ID';

        /**
         * @member {Array.<number>} GetFeaturesByIDsParameters.prototype.IDs
         * @description 所要查询指定的元素 ID 信息。
         */
        this.IDs = null;

        /**
         *  @member {Array.<string>} GetFeaturesByIDsParameters.prototype.fields
         *  @description 设置查询结果返回字段。当指定了返回结果字段后，则 GetFeaturesResult 中的 features 的属性字段只包含所指定的字段。不设置即返回全部字段。
         */
        this.fields = null;
        Util_Util.extend(this, options);

        this.CLASS_NAME = 'SuperMap.GetFeaturesByIDsParameters';
    }

    /**
     * @function GetFeaturesByIDsParameters.prototype.destroy
     * @override
     */
    destroy() {
        super.destroy();
        var me = this;
        me.IDs = null;
        me.getFeatureMode = null;
        if (me.fields) {
            while (me.fields.length > 0) {
                me.fields.pop();
            }
            me.fields = null;
        }
    }

    /**
     * @function GetFeaturesByIDsParameters.toJsonParameters
     * @description 将 GetFeaturesByIDsParameters 对象转换为 JSON 字符串。
     * @param {GetFeaturesByIDsParameters} params - ID 查询参数对象。
     * @returns {string} 转化后的 JSON 字符串。
     */
    static toJsonParameters(params) {
        var parasByIDs, filterParameter;

        parasByIDs = {
            datasetNames: params.datasetNames,
            getFeatureMode: 'ID',
            ids: params.IDs
        };
        if (params.fields) {
            filterParameter = new FilterParameter();
            filterParameter.name = params.datasetNames;
            filterParameter.fields = params.fields;
            parasByIDs.queryParameter = filterParameter;
        }
        if (params.targetEpsgCode) {
            parasByIDs.targetEpsgCode = params.targetEpsgCode;
        }

        if (typeof params.hasGeometry === 'boolean') {
            parasByIDs.hasGeometry = params.hasGeometry;
        }

        if (!params.targetEpsgCode && params.targetPrj) {
            parasByIDs.targetPrj = params.targetPrj;
        }
        if (params.aggregations) {
            parasByIDs.aggregations = params.aggregations;
        }

        return Util_Util.toJSON(parasByIDs);
    }
}


;// CONCATENATED MODULE: ./src/common/iServer/GetFeaturesByIDsService.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/



/**
 * @class GetFeaturesByIDsService
 * @deprecatedclass SuperMap.GetFeaturesByIDsService
 * @category iServer Data FeatureResults
 * @classdesc 数据集ID查询服务类。在数据集集合中查找指定 ID 号对应的空间地物要素。
 * @param {string} url - 服务地址。请求数据服务中数据集查询服务。
 *                       URL 应为：http://{服务器地址}:{服务端口号}/iserver/services/{数据服务名}/rest/data/；</br>
 *                       例如："http://localhost:8090/iserver/services/data-jingjin/rest/data/"
 * @param {Object} options - 参数。
 * @param {DataFormat} [options.format=DataFormat.GEOJSON] - 查询结果返回格式，目前支持 iServerJSON、GeoJSON、FGB 三种格式。参数格式为 "ISERVER"，"GEOJSON"，"FGB"。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @extends {GetFeaturesServiceBase}
 * @example
 * var myGetFeaturesByIDsService = new GetFeaturesByIDsService(url);
 * function getFeatureCompleted(object){//todo};
 * function getFeatureError(object){//todo}
 * @usage
 */
class GetFeaturesByIDsService extends GetFeaturesServiceBase {


    constructor(url, options) {
        super(url, options);

        this.CLASS_NAME = "SuperMap.GetFeaturesByIDsService";
    }

    /**
     * @function GetFeaturesByIDsService.prototype.destroy
     * @override
     */
    destroy() {
        super.destroy();
    }

    /**
     * @function GetFeaturesByIDsService.prototype.getJsonParameters
     * @description 将查询参数转化为 JSON 字符串。
     * 在本类中重写此方法，可以实现不同种类的查询（ID, SQL, Buffer, Geometry等）。
     * @param {GetFeaturesByIDsParameters} params - ID查询参数类。
     * @returns {string} 转化后的 JSON 字符串。
     */
    getJsonParameters(params) {
        return GetFeaturesByIDsParameters.toJsonParameters(params);
    }

}

;// CONCATENATED MODULE: ./src/common/iServer/GetFeaturesBySQLParameters.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/



/**
 * @class GetFeaturesBySQLParameters
 * @deprecatedclass SuperMap.GetFeaturesBySQLParameters
 * @category iServer Data FeatureResults
 * @classdesc 数据集 SQL 查询参数类。
 * @param {Object} options - 参数。
 * @param {FilterParameter} options.queryParameter - 查询过滤条件参数。
 * @param {Array.<string>} options.datasetNames - 数据集集合中的数据集名称列表。
 * @param {boolean} [options.returnContent=true] - 是否直接返回查询结果。
 * @param {number} [options.fromIndex=0] - 查询结果的最小索引号。
 * @param {number} [options.toIndex=19] - 查询结果的最大索引号。
 * @param {string|number} [options.targetEpsgCode] - 动态投影的目标坐标系对应的 EPSG Code，使用此参数时，returnContent 参数需为 true。
 * @param {Object} [options.targetPrj] - 动态投影的目标坐标系。使用此参数时，returnContent 参数需为 true。如：prjCoordSys={"epsgCode":3857}。当同时设置 targetEpsgCode 参数时，此参数不生效。
 * @param {MetricsAggParameter|GeoHashGridAggParameter} [options.aggregations] - 聚合查询参数。该参数仅支持数据来源 Elasticsearch 服务的Supermap iServer的rest数据服务。
 * @extends {GetFeaturesParametersBase}
 * @usage
 */
class GetFeaturesBySQLParameters extends GetFeaturesParametersBase {
    constructor(options) {
        super(options);
        /**
         * @member {string} GetFeaturesBySQLParameters.prototype.getFeatureMode
         * @description 数据集查询模式。
         */
        this.getFeatureMode = 'SQL';

        /**
         * @member {FilterParameter} GetFeaturesBySQLParameters.prototype.queryParameter
         * @description 查询过滤条件参数类。
         */
        this.queryParameter = null;

        Util_Util.extend(this, options);

        this.CLASS_NAME = 'SuperMap.GetFeaturesBySQLParameters';
    }

    /**
     * @function GetFeaturesBySQLParameters.prototype.destroy
     * @override
     */
    destroy() {
        super.destroy();
        var me = this;
        me.getFeatureMode = null;
        if (me.queryParameter) {
            me.queryParameter.destroy();
            me.queryParameter = null;
        }
    }

    /**
     * @function GetFeaturesBySQLParameters.prototype.toJsonParameters
     * @description 将 GetFeaturesBySQLParameters 对象转换为 JSON 字符串。
     * @param {GetFeaturesBySQLParameters} params - 数据集 SQL 查询参数对象。
     * @returns {string} 转化后的 JSON 字符串。
     */
    static toJsonParameters(params) {
        var paramsBySql = {
            datasetNames: params.datasetNames,
            getFeatureMode: 'SQL',
            queryParameter: params.queryParameter
        };
        if (params.maxFeatures && !isNaN(params.maxFeatures)) {
            paramsBySql.maxFeatures = params.maxFeatures;
        }
        if (typeof params.hasGeometry === 'boolean') {
            paramsBySql.hasGeometry = params.hasGeometry;
        }
        if (params.aggregations) {
            paramsBySql.aggregations = params.aggregations;
        }
        if (params.targetEpsgCode) {
            paramsBySql.targetEpsgCode = params.targetEpsgCode;
        }
        if (!params.targetEpsgCode && params.targetPrj) {
            paramsBySql.targetPrj = params.targetPrj;
        }
        if (params.aggregations) {
            paramsBySql.aggregations = params.aggregations;
        }
        return Util_Util.toJSON(paramsBySql);
    }
}


;// CONCATENATED MODULE: ./src/common/iServer/GetFeaturesBySQLService.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/



/**
 * @class GetFeaturesBySQLService
 * @deprecatedclass SuperMap.GetFeaturesBySQLService
 * @constructs GetFeaturesBySQLService
 * @category iServer Data FeatureResults
 * @classdesc 数据服务中数据集 SQL 查询服务类。在一个或多个指定的图层上查询符合 SQL 条件的空间地物信息。
 * @param {string} url - 服务地址。请求数据服务中数据集查询服务，
 *                       URL 应为：http://{服务器地址}:{服务端口号}/iserver/services/{数据服务名}/rest/data/；</br>
 *                       例如："http://localhost:8090/iserver/services/data-jingjin/rest/data/"
 * @param {Object} options - 参数。
 * @param {DataFormat} [options.format=DataFormat.GEOJSON] - 查询结果返回格式，目前支持 iServerJSON、GeoJSON、FGB 三种格式。参数格式为 "ISERVER"，"GEOJSON"，"FGB"。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @extends {GetFeaturesServiceBase}
 * @example
 * var myGetFeaturesBySQLService = new GetFeaturesBySQLService(url);
 * function getFeaturesCompleted(object){//todo};
 * function getFeaturesError(object){//todo};
 * @usage
 */
class GetFeaturesBySQLService extends GetFeaturesServiceBase {

    constructor(url, options) {
        super(url, options);
        this.CLASS_NAME = "SuperMap.GetFeaturesBySQLService";
    }

    /**
     * @function GetFeaturesBySQLService.prototype.destroy
     * @override
     */
    destroy() {
        super.destroy();
    }

    /*
     * @function GetFeaturesBySQLService.prototype.getJsonParameters
     * @description 将查询参数转化为 JSON 字符串。
     * 在本类中重写此方法，可以实现不同种类的查询（ID, SQL, Buffer, Geometry等）。
     * @param {GetFeaturesBySQLParameters} params - 数据集SQL查询参数类。
     * @returns {string} 转化后的 JSON 字符串。
     */
    getJsonParameters(params) {
        return GetFeaturesBySQLParameters.toJsonParameters(params);
    }


}

;// CONCATENATED MODULE: ./src/common/iServer/GetFeaturesByBoundsParameters.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/





/**
 * @class GetFeaturesByBoundsParameters
 * @deprecatedclass SuperMap.GetFeaturesByBoundsParameters
 * @category iServer Data FeatureResults
 * @classdesc 数据集范围查询参数类，该类用于设置数据集范围查询的相关参数。
 * @param {Object} options - 参数。
 * @param {(SuperMap.Bounds|L.Bounds|L.LatLngBounds|ol.extent|mapboxgl.LngLatBounds|GeoJSONObject)} options.bounds - 查询的范围对象。
 * @param {Array.<string>} options.datasetNames - 数据集名称列表。
 * @param {string} [options.attributeFilter] - 范围查询属性过滤条件。
 * @param {Array.<string>} [options.fields] - 设置查询结果返回字段。默认返回所有字段。
 * @param {SpatialQueryMode} [options.spatialQueryMode=SpatialQueryMode.CONTAIN] - 空间查询模式常量。
 * @param {boolean} [options.returnContent=true] - 是否直接返回查询结果。
 * @param {number} [options.fromIndex=0] - 查询结果的最小索引号。
 * @param {number} [options.toIndex=19] - 查询结果的最大索引号。
 * @param {string|number} [options.targetEpsgCode] - 动态投影的目标坐标系对应的 EPSG Code，使用此参数时，returnContent 参数需为 true。
 * @param {Object} [options.targetPrj] - 动态投影的目标坐标系。使用此参数时，returnContent 参数需为 true。如：prjCoordSys={"epsgCode":3857}。当同时设置 targetEpsgCode 参数时，此参数不生效。
 * @param {MetricsAggParameter|GeoHashGridAggParameter} [options.aggregations] - 聚合查询参数。该参数仅支持数据来源 Elasticsearch 服务的Supermap iServer的rest数据服务。
 * @extends {GetFeaturesParametersBase}
 * @usage
 */

class GetFeaturesByBoundsParameters extends GetFeaturesParametersBase {
    constructor(options) {
        super(options);
        /**
         * @member {string} GetFeaturesByBoundsParameters.prototype.getFeatureMode
         * @description 数据集查询模式。范围查询有 "BOUNDS"，"BOUNDS_ATTRIBUTEFILTER" 两种，当用户设置 attributeFilter 时会自动切换到 BOUNDS_ATTRIBUTEFILTER 访问服务。
         */
        this.getFeatureMode = GetFeaturesByBoundsParameters.getFeatureMode.BOUNDS;

        /**
         * @member {(SuperMap.Bounds|L.Bounds|L.LatLngBounds|ol.extent|mapboxgl.LngLatBounds|GeoJSONObject)} GetFeaturesByBoundsParameters.prototype.bounds
         * @description 用于查询的范围对象。
         *
         */
        this.bounds = null;

        /**
         * @member {Array.<string>} GetFeaturesByBoundsParameters.prototype.fields
         * @description 设置查询结果返回字段。当指定了返回结果字段后，则 GetFeaturesResult 中的 features 的属性字段只包含所指定的字段。不设置即返回全部字段。
         */
        this.fields = null;

        /**
         * @member {string} GetFeaturesByBoundsParameters.prototype.attributeFilter
         * @description 范围查询属性过滤条件。
         */
        this.attributeFilter = null;

        /**
         * @member {SpatialQueryMode} [GetFeaturesByBoundsParameters.prototype.spatialQueryMode=SpatialQueryMode.CONTAIN]
         * @description 空间查询模式常量。
         */
        this.spatialQueryMode = SpatialQueryMode.CONTAIN;

        Util_Util.extend(this, options);
        this.CLASS_NAME = 'SuperMap.GetFeaturesByBoundsParameters';
    }

    /**
     * @function GetFeaturesByBoundsParameters.prototype.destroy
     * @override
     */
    destroy() {
        super.destroy();
        var me = this;
        if (me.bounds) {
            me.bounds.destroy();
            me.bounds = null;
        }
        if (me.fields) {
            while (me.fields.length > 0) {
                me.fields.pop();
            }
            me.fields = null;
        }
        me.attributeFilter = null;
        me.spatialQueryMode = null;
        me.getFeatureMode = null;
    }

    /**
     * @function GetFeaturesByBoundsParameters.toJsonParameters
     * @description 将 {@link GetFeaturesByBoundsParameters} 对象参数转换为 JSON 字符串。
     * @param {GetFeaturesByBoundsParameters} params - 范围查询参数。
     * @returns {string} 转化后的 JSON 字符串。
     *
     */
    static toJsonParameters(params) {
        var filterParameter, bounds, parasByBounds;

        bounds = {
            leftBottom: { x: params.bounds.left, y: params.bounds.bottom },
            rightTop: { x: params.bounds.right, y: params.bounds.top }
        };
        parasByBounds = {
            datasetNames: params.datasetNames,
            getFeatureMode: GetFeaturesByBoundsParameters.getFeatureMode.BOUNDS,
            bounds: bounds,
            spatialQueryMode: params.spatialQueryMode
        };
        if (params.fields) {
            filterParameter = new FilterParameter();
            filterParameter.name = params.datasetNames;
            filterParameter.fields = params.fields;
            parasByBounds.queryParameter = filterParameter;
        }
        if (params.attributeFilter) {
            parasByBounds.attributeFilter = params.attributeFilter;
            parasByBounds.getFeatureMode = GetFeaturesByBoundsParameters.getFeatureMode.BOUNDS_ATTRIBUTEFILTER;
        }
        if (params.maxFeatures && !isNaN(params.maxFeatures)) {
            parasByBounds.maxFeatures = params.maxFeatures;
        }

        if (typeof params.hasGeometry === 'boolean') {
          parasByBounds.hasGeometry = params.hasGeometry;
        }

        if (params.targetEpsgCode) {
            parasByBounds.targetEpsgCode = params.targetEpsgCode;
        }
        if (!params.targetEpsgCode && params.targetPrj) {
            parasByBounds.targetPrj = params.targetPrj;
        }
        if (params.aggregations) {
            parasByBounds.aggregations = params.aggregations;
        }

        return Util_Util.toJSON(parasByBounds);
    }
}

GetFeaturesByBoundsParameters.getFeatureMode = {
    BOUNDS: 'BOUNDS',
    BOUNDS_ATTRIBUTEFILTER: 'BOUNDS_ATTRIBUTEFILTER'
};


;// CONCATENATED MODULE: ./src/common/iServer/GetFeaturesByBoundsService.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/



/**
 * @class GetFeaturesByBoundsService
 * @deprecatedclass SuperMap.GetFeaturesByBoundsService
 * @category iServer Data FeatureResults
 * @classdesc 数据集范围查询服务类,查询与指定范围对象符合一定空间关系的矢量要素。
 * @description 数据集范围查询服务类构造函数。
 * @extends {GetFeaturesServiceBase}
 * @param {string} url - 服务地址。请求数据服务中数据集查询服务，URL 应为：http://{服务器地址}:{服务端口号}/iserver/services/{数据服务名}/rest/data/；
 * 例如："http://localhost:8090/iserver/services/data-jingjin/rest/data/"
 * @param {Object} options - 参数。
 * @param {DataFormat} [options.format=DataFormat.GEOJSON] - 查询结果返回格式，目前支持 iServerJSON、GeoJSON、FGB 三种格式。参数格式为 "ISERVER"，"GEOJSON"，"FGB"。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @example
 * var myGetFeaturesByBoundsService = new SuperMa.GetFeaturesByBoundsService(url);
 * @usage
 */

class GetFeaturesByBoundsService extends GetFeaturesServiceBase {

    constructor(url, options) {
        super(url, options);

        this.CLASS_NAME = "SuperMap.GetFeaturesByBoundsService";
    }

    /**
     * @function GetFeaturesByBoundsService.prototype.destroy
     * @override
     */
    destroy() {
        super.destroy();
    }

    /**
     * @function GetFeaturesByBoundsService.prototype.getJsonParameters
     * @description 将查询参数转化为 JSON 字符串。在本类中重写此方法，可以实现不同种类的查询（ID, SQL, Buffer, Geometry,Bounds等）。
     * @param params {GetFeaturesByBoundsParameters}
     * @returns {string} 转化后的 JSON 字符串。
     *
     */
    getJsonParameters(params) {
        return GetFeaturesByBoundsParameters.toJsonParameters(params);
    }

}

;// CONCATENATED MODULE: ./src/common/iServer/GetFeaturesByBufferParameters.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/





/**
 * @class GetFeaturesByBufferParameters
 * @deprecatedclass SuperMap.GetFeaturesByBufferParameters
 * @category iServer Data FeatureResults
 * @classdesc 数据集缓冲区查询参数类。
 * @param {Object} options - 参数。
 * @param {number} options.bufferDistance - buffer 距离，单位与所查询图层对应的数据集单位相同。
 * @param {GeoJSONObject} options.geometry - 空间查询条件。
 * @param {Array.<string>} options.dataSetNames - 数据集集合中的数据集名称列表。
 * @param {Array.<string>} [options.fields] - 设置查询结果返回字段。默认返回所有字段。
 * @param {string} [options.attributeFilter] - 属性查询条件。
 * @param {boolean} [options.returnContent=true] - 是否直接返回查询结果。
 * @param {number} [options.fromIndex=0] - 查询结果的最小索引号。
 * @param {number} [options.toIndex=19] - 查询结果的最大索引号。
 * @param {string|number} [options.targetEpsgCode] - 动态投影的目标坐标系对应的 EPSG Code，使用此参数时，returnContent 参数需为 true。
 * @param {Object} [options.targetPrj] - 动态投影的目标坐标系。使用此参数时，returnContent 参数需为 true。如：prjCoordSys={"epsgCode":3857}。当同时设置 targetEpsgCode 参数时，此参数不生效。
 * @extends {GetFeaturesParametersBase}
 * @usage
 */
class GetFeaturesByBufferParameters extends GetFeaturesParametersBase {
    constructor(options) {
        super(options);
        /**
         * @member {number} GetFeaturesByBufferParameters.prototype.bufferDistance
         * @description buffer 距离，单位与所查询图层对应的数据集单位相同。
         */
        this.bufferDistance = null;

        /**
         * @member {string} GetFeaturesByBufferParameters.prototype.attributeFilter
         * @description 属性查询条件。
         */
        this.attributeFilter = null;

        /**
         * @member {GeoJSONObject} GetFeaturesByBufferParameters.prototype.geometry
         * @description 空间查询条件。<br>
         * 点类型可以是：{@link GeometryPoint}|{@link L.Marker}|{@link L.CircleMarker}|{@link L.Circle}|{@link L.GeoJSON}|{@link ol.geom.Point}|{@link ol.format.GeoJSON}|{@link mapboxgl.LngLat}|{@link mapboxgl.Point}|{@link GeoJSONObject}。</br>
         * 线类型可以是：{@link GeometryLineString}|{@link GeometryLinearRing}|{@link L.Polyline}|{@link L.GeoJSON}|{@link ol.geom.LineString}|{@link ol.format.GeoJSON}|{@link GeoJSONObject}。</br>
         * 面类型可以是：{@link GeometryPolygon}|{@link L.Polygon}|{@link L.GeoJSON}|{@link ol.geom.Polygon}|{@link ol.format.GeoJSON}|{@link mapboxgl.LngLatBounds}|{@link GeoJSONObject}。
         */
        this.geometry = null;

        /**
         * @member {Array.<string>} GetFeaturesByBufferParameters.prototype.fields
         * @description 设置查询结果返回字段。当指定了返回结果字段后，则 GetFeaturesResult 中的 features 的属性字段只包含所指定的字段。不设置即返回全部字段。
         */
        this.fields = null;
        Util_Util.extend(this, options);
        this.CLASS_NAME = 'SuperMap.GetFeaturesByBufferParameters';
    }

    /**
     * @function GetFeaturesByBufferParameters.prototype.destroy
     * @override
     */
    destroy() {
        super.destroy();
        var me = this;
        me.bufferDistance = null;
        me.attributeFilter = null;
        if (me.fields) {
            while (me.fields.length > 0) {
                me.fields.pop();
            }
            me.fields = null;
        }
        if (me.geometry) {
            me.geometry.destroy();
            me.geometry = null;
        }
    }

    /**
     * @function GetFeaturesByBufferParameters.toJsonParameters
     * @description 将 GetFeaturesByBufferParameters 对象转换为 JSON 字符串。
     * @param {GetFeaturesByBufferParameters} params - 数据集缓冲区查询参数对象。
     * @returns {string} 转化后的 JSON 字符串。
     */
    static toJsonParameters(params) {
        var filterParameter, paramsByBuffer, geometry;
        geometry = ServerGeometry.fromGeometry(params.geometry);
        paramsByBuffer = {
            datasetNames: params.datasetNames,
            getFeatureMode: 'BUFFER',
            bufferDistance: params.bufferDistance,
            geometry: geometry
        };
        if (params.fields) {
            filterParameter = new FilterParameter();
            filterParameter.name = params.datasetNames;
            filterParameter.fields = params.fields;
            paramsByBuffer.queryParameter = filterParameter;
        }
        if (params.attributeFilter) {
            paramsByBuffer.attributeFilter = params.attributeFilter;
            paramsByBuffer.getFeatureMode = 'BUFFER_ATTRIBUTEFILTER';
        }
        if (params.maxFeatures && !isNaN(params.maxFeatures)) {
            paramsByBuffer.maxFeatures = params.maxFeatures;
        }

        if (typeof params.hasGeometry === 'boolean') {
            paramsByBuffer.hasGeometry = params.hasGeometry;
        }

        if (params.targetEpsgCode) {
            paramsByBuffer.targetEpsgCode = params.targetEpsgCode;
        }
        if (!params.targetEpsgCode && params.targetPrj) {
            paramsByBuffer.targetPrj = params.targetPrj;
        }
        return Util_Util.toJSON(paramsByBuffer);
    }
}


;// CONCATENATED MODULE: ./src/common/iServer/GetFeaturesByBufferService.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/



/**
 * @class GetFeaturesByBufferService
 * @deprecatedclass SuperMap.GetFeaturesByBufferService
 * @category iServer Data FeatureResults
 * @classdesc 数据服务中数据集缓冲区查询服务类。
 * @param {string} url - 服务地址。请求数据服务中数据集查询服务，
 * URL 应为：http://{服务器地址}:{服务端口号}/iserver/services/{数据服务名}/rest/data/；
 * 例如："http://localhost:8090/iserver/services/data-jingjin/rest/data/"
 * @param {Object} options - 参数。
 * @param {DataFormat} [options.format=DataFormat.GEOJSON] - 查询结果返回格式，目前支持 iServerJSON、GeoJSON、FGB 三种格式。参数格式为 "ISERVER"，"GEOJSON"，"FGB"。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @extends {GetFeaturesServiceBase}
 * @example
 * var myGetFeaturesByBufferService = new GetFeaturesByBufferService(url);
 * function GetFeaturesCompleted(object){//todo};
 * function GetFeaturesError(object){//todo};
 * @usage
 */

class GetFeaturesByBufferService extends GetFeaturesServiceBase {

    constructor(url, options) {
        super(url, options);

        this.CLASS_NAME = "SuperMap.GetFeaturesByBufferService";
    }

    /**
     * @function GetFeaturesByBufferService.prototype.destroy
     * @override
     */
    destroy() {
        super.destroy();
    }

    /**
     * @function GetFeaturesByBufferService.prototype.getJsonParameters
     * @description 将查询参数转化为 JSON 字符串。在本类中重写此方法，可以实现不同种类的查询（IDs, SQL, Buffer, Geometry等）。
     * @param {GetFeaturesByBufferParameters} params - 数据集缓冲区查询参数类。
     * @returns {Object} 转化后的 JSON 字符串。
     */
    getJsonParameters(params) {
        if (!(params instanceof GetFeaturesByBufferParameters)) {
            return;
        }
        return GetFeaturesByBufferParameters.toJsonParameters(params);
    }

}

;// CONCATENATED MODULE: ./src/common/iServer/GetFeaturesByGeometryParameters.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/






/**
 * @class GetFeaturesByGeometryParameters
 * @deprecatedclass SuperMap.GetFeaturesByGeometryParameters
 * @category iServer Data FeatureResults
 * @classdesc 数据集几何查询参数类。该类用于设置数据集几何查询的相关参数。
 * @param {Object} options - 参数。
 * @param {GeoJSONObject} options.geometry - 查询的几何对象。
 * @param {Array.<string>} options.datasetNames - 数据集集合中的数据集名称列表。
 * @param {string} [options.attributeFilter] - 几何查询属性过滤条件。
 * @param {Array.<string>} [options.fields] - 设置查询结果返回字段。默认返回所有字段。
 * @param {SpatialQueryMode} [options.spatialQueryMode=SpatialQueryMode.CONTAIN] - 空间查询模式常量。
 * @param {boolean} [options.returnContent=true] - 是否直接返回查询结果。
 * @param {number} [options.fromIndex=0] - 查询结果的最小索引号。
 * @param {number} [options.toIndex=19] - 查询结果的最大索引号。
 * @param {string|number} [options.targetEpsgCode] - 动态投影的目标坐标系对应的 EPSG Code，使用此参数时，returnContent 参数需为 true。
 * @param {Object} [options.targetPrj] - 动态投影的目标坐标系。使用此参数时，returnContent 参数需为 true。如：prjCoordSys={"epsgCode":3857}。当同时设置 targetEpsgCode 参数时，此参数不生效。
 * @param {MetricsAggParameter|GeoHashGridAggParameter} [options.aggregations] - 聚合查询参数。该参数仅支持数据来源 Elasticsearch 服务的Supermap iServer的rest数据服务。
 * @extends {GetFeaturesParametersBase}
 * @usage
 */
class GetFeaturesByGeometryParameters extends GetFeaturesParametersBase {
    constructor(options) {
        super(options);
        /**
         * @member {string} GetFeaturesByGeometryParameters.prototype.getFeatureMode
         * @description 数据集查询模式。几何查询有 "SPATIAL"，"SPATIAL_ATTRIBUTEFILTER" 两种，当用户设置 attributeFilter 时会自动切换到 SPATIAL_ATTRIBUTEFILTER 访问服务。
         */
        this.getFeatureMode = 'SPATIAL';

        /**
         * @member {GeoJSONObject} GetFeaturesByGeometryParameters.prototype.geometry
         * @description 用于查询的几何对象。 </br>
         * 点类型可以是：{@link GeometryPoint}|{@link L.Marker}|{@link L.CircleMarker}|{@link L.Circle}|{@link L.GeoJSON}|{@link ol.geom.Point}|{@link ol.format.GeoJSON}|{@link mapboxgl.LngLat}|{@link mapboxgl.Point}|{@link GeoJSONObject}。</br>
         * 线类型可以是：{@link GeometryLineString}|{@link GeometryLinearRing}|{@link L.Polyline}|{@link L.GeoJSON}|{@link ol.geom.LineString}|{@link ol.format.GeoJSON}|{@link GeoJSONObject}。</br>
         * 面类型可以是：{@link GeometryPolygon}|{@link L.Polygon}|{@link L.GeoJSON}|{@link ol.geom.Polygon}|{@link ol.format.GeoJSON}|{@link mapboxgl.LngLatBounds}|{@link GeoJSONObject}。
         */
        this.geometry = null;

        /**
         * @member {Array.<string>} GetFeaturesByGeometryParameters.prototype.fields
         * @description 设置查询结果返回字段。当指定了返回结果字段后，则 GetFeaturesResult 中的 features 的属性字段只包含所指定的字段。不设置即返回全部字段。
         */
        this.fields = null;

        /**
         * @member {string} GetFeaturesByGeometryParameters.prototype.attributeFilter
         *  @description 几何查询属性过滤条件。
         */
        this.attributeFilter = null;

        /**
         * @member {SpatialQueryMode} [GetFeaturesByGeometryParameters.prototype.spatialQueryMode=SpatialQueryMode.CONTAIN]
         * @description 空间查询模式常量。
         */
        this.spatialQueryMode = SpatialQueryMode.CONTAIN;
        Util_Util.extend(this, options);

        this.CLASS_NAME = 'SuperMap.GetFeaturesByGeometryParameters';
    }

    /**
     * @function GetFeaturesByGeometryParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        super.destroy();
        var me = this;
        if (me.geometry) {
            me.geometry.destroy();
            me.geometry = null;
        }
        if (me.fields) {
            while (me.fields.length > 0) {
                me.fields.pop();
            }
            me.fields = null;
        }
        me.attributeFilter = null;
        me.spatialQueryMode = null;
        me.getFeatureMode = null;
    }

    /**
     * @function GetFeaturesByGeometryParameters.toJsonParameters
     * @description 将 GetFeaturesByGeometryParameters 对象参数转换为 JSON 字符串。
     * @param {GetFeaturesByGeometryParameters} params - 查询参数对象。
     * @returns {string} 转化后的 JSON 字符串。
     */
    static toJsonParameters(params) {
        var filterParameter, geometry, parasByGeometry;

        geometry = ServerGeometry.fromGeometry(params.geometry);
        parasByGeometry = {
            datasetNames: params.datasetNames,
            getFeatureMode: 'SPATIAL',
            geometry: geometry,
            spatialQueryMode: params.spatialQueryMode
        };
        if (params.fields) {
            filterParameter = new FilterParameter();
            filterParameter.name = params.datasetNames;
            filterParameter.fields = params.fields;
            parasByGeometry.queryParameter = filterParameter;
        }
        if (params.attributeFilter) {
            parasByGeometry.attributeFilter = params.attributeFilter;
            parasByGeometry.getFeatureMode = 'SPATIAL_ATTRIBUTEFILTER';
        }

        if (params.maxFeatures && !isNaN(params.maxFeatures)) {
            parasByGeometry.maxFeatures = params.maxFeatures;
        }

        if (typeof params.hasGeometry === 'boolean') {
            parasByGeometry.hasGeometry = params.hasGeometry;
        }

        if (params.targetEpsgCode) {
            parasByGeometry.targetEpsgCode = params.targetEpsgCode;
        }
        if (!params.targetEpsgCode && params.targetPrj) {
            parasByGeometry.targetPrj = params.targetPrj;
        }
        if (params.aggregations) {
            parasByGeometry.aggregations = params.aggregations;
        }

        return Util_Util.toJSON(parasByGeometry);
    }
}


;// CONCATENATED MODULE: ./src/common/iServer/GetFeaturesByGeometryService.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/



/**
 * @class GetFeaturesByGeometryService
 * @deprecatedclass SuperMap.GetFeaturesByGeometryService
 * @category iServer Data FeatureResults
 * @classdesc 数据集几何查询服务类，查询与指定几何对象符合一定空间关系的矢量要素。
 * @param {string} url - 服务地址。请求数据服务中数据集查询服务。
 * URL 应为：http://{服务器地址}:{服务端口号}/iserver/services/{数据服务名}/rest/data；
 * 例如："http://localhost:8090/iserver/services/data-jingjin/rest/data"
 * @param {Object} options - 参数。
 * @param {DataFormat} [options.format=DataFormat.GEOJSON] - 查询结果返回格式，目前支持 iServerJSON、GeoJSON、FGB 三种格式。参数格式为 "ISERVER"，"GEOJSON"，"FGB"。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @extends {GetFeaturesServiceBase}
 * @example
 * var myService = new GetFeaturesByGeometryService(url);
 * function getFeatureCompleted(object){//todo};
 * function getFeatureError(object){//todo}
 * @usage
 */
class GetFeaturesByGeometryService extends GetFeaturesServiceBase {

    constructor(url, options) {
        super(url, options);
        this.CLASS_NAME = "SuperMap.GetFeaturesByGeometryService";
    }

    /**
     * @function GetFeaturesByGeometryService.prototype.destroy
     * @override
     */
    destroy() {
        super.destroy();
    }

    /**
     * @function GetFeaturesByGeometryService.prototype.getJsonParameters
     * @param {GetFeaturesByGeometryParameters} params - 数据集几何查询参数类。
     * @description 将查询参数转化为 JSON 字符串。
     * 在本类中重写此方法，可以实现不同种类的查询（ID, SQL, Buffer, Geometry等）。
     * @returns {Object} 转化后的 JSON 字符串。
     */
    getJsonParameters(params) {
        return GetFeaturesByGeometryParameters.toJsonParameters(params);
    }


}

;// CONCATENATED MODULE: ./src/common/iServer/FeatureService.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/









/**
 * @class FeatureService
 * @constructs FeatureService
 * @category  iServer Data Feature
 * @classdesc 数据集类。提供：ID 查询，范围查询，SQL查询，几何查询，bounds 查询，缓冲区查询，地物编辑。
 * @example
 *      new FeatureService(url).getFeaturesByIDs(param,function(result){
 *          //doSomething
 *      })
 * @param {string} url - 服务地址。
 * @param {Object} options - 参数。
 * @param {string} [options.proxy] - 服务代理地址。
 * @param {boolean} [options.withCredentials=false] - 请求是否携带 cookie。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @extends {ServiceBase}
 * @usage
 */
class FeatureService_FeatureService {

    constructor(url, options) {
      this.url = url;
      this.options = options || {};
    }

    /**
     * @function FeatureService.prototype.getFeaturesByIDs
     * @description 数据集 ID 查询服务。
     * @param {GetFeaturesByIDsParameters} params - ID查询参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @param {DataFormat} [resultFormat=DataFormat.GEOJSON] - 返回的数据格式。
     * @returns {Promise} Promise 对象。
     */
    getFeaturesByIDs(params, callback, resultFormat) {
        var me = this;
        var getFeaturesByIDsService = new GetFeaturesByIDsService(me.url, {
            proxy: me.options.proxy,
            withCredentials: me.options.withCredentials,
            crossOrigin: me.options.crossOrigin,
            headers: me.options.headers,
            format: resultFormat
        });
        return getFeaturesByIDsService.processAsync(params, callback);
    }

    /**
     * @function FeatureService.prototype.getFeaturesByBounds
     * @description 数据集 Bounds 查询服务。
     * @param {GetFeaturesByBoundsParameters} params - 数据集范围查询参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @param {DataFormat} [resultFormat=DataFormat.GEOJSON] - 返回的数据格式。
     * @returns {Promise} Promise 对象。
     */
    getFeaturesByBounds(params, callback, resultFormat) {
        var me = this;
        var getFeaturesByBoundsService = new GetFeaturesByBoundsService(me.url, {
            proxy: me.options.proxy,
            withCredentials: me.options.withCredentials,
            crossOrigin: me.options.crossOrigin,
            headers: me.options.headers,
            format: me._processFormat(resultFormat)
        });
        return getFeaturesByBoundsService.processAsync(params, callback);
    }

    /**
     * @function FeatureService.prototype.getFeaturesByBuffer
     * @description 数据集 Buffer 查询服务。
     * @param {GetFeaturesByBufferParameters} params - 数据集缓冲区查询参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @param {DataFormat} [resultFormat=DataFormat.GEOJSON] - 返回的数据格式。
     * @returns {Promise} Promise 对象。
     */
    getFeaturesByBuffer(params, callback, resultFormat) {
        var me = this;
        var getFeatureService = new GetFeaturesByBufferService(me.url, {
            proxy: me.options.proxy,
            withCredentials: me.options.withCredentials,
            crossOrigin: me.options.crossOrigin,
            headers: me.options.headers,
            format: me._processFormat(resultFormat)
        });
        return getFeatureService.processAsync(params, callback);
    }

    /**
     * @function FeatureService.prototype.getFeaturesBySQL
     * @description 数据集 SQL 查询服务。
     * @param {GetFeaturesBySQLParameters} params - 数据集 SQL 查询参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @param {DataFormat} [resultFormat=DataFormat.GEOJSON] - 返回的数据格式。
     * @returns {Promise} Promise 对象。
     */
    getFeaturesBySQL(params, callback, resultFormat) {
        var me = this;
        var getFeatureBySQLService = new GetFeaturesBySQLService(me.url, {
            proxy: me.options.proxy,
            withCredentials: me.options.withCredentials,
            crossOrigin: me.options.crossOrigin,
            headers: me.options.headers,
            format: me._processFormat(resultFormat)
        });
        return getFeatureBySQLService.processAsync(params, callback);
    }

    /**
     * @function FeatureService.prototype.getFeaturesByGeometry
     * @description 数据集几何查询服务类。
     * @param {GetFeaturesByGeometryParameters} params - 数据集几何查询参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @param {DataFormat} [resultFormat=DataFormat.GEOJSON] - 返回的数据格式。
     * @returns {Promise} Promise 对象。
     */
    getFeaturesByGeometry(params, callback, resultFormat) {
        var me = this;
        var getFeaturesByGeometryService = new GetFeaturesByGeometryService(me.url, {
            proxy: me.options.proxy,
            withCredentials: me.options.withCredentials,
            crossOrigin: me.options.crossOrigin,
            headers: me.options.headers,
            format: me._processFormat(resultFormat)
        });
        return getFeaturesByGeometryService.processAsync(params, callback);
    }

    /**
     * @function FeatureService.prototype.editFeatures
     * @description 地物编辑服务。
     * @param {EditFeaturesParameters} params - 数据服务中数据集添加、修改、删除参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    editFeatures(params, callback) {
        if (!params || !params.dataSourceName || !params.dataSetName) {
            return;
        }
        var me = this,
            url = me.url,
            dataSourceName = params.dataSourceName,
            dataSetName = params.dataSetName;
        url = Util_Util.urlPathAppend(url, "datasources/" + dataSourceName + "/datasets/" + dataSetName);

        var editFeatureService = new EditFeaturesService(url, {
            proxy: me.options.proxy,
            withCredentials: me.options.withCredentials,
            crossOrigin: me.options.crossOrigin,
            headers: me.options.headers
        });
        return editFeatureService.processAsync(params, callback);
    }

    /**
     * @function FeatureService.prototype.getMetadata
     * @description 地理要素元信息服务。
     * @param {Object} params - 包括数据源名称、数据集名称、要素ID。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    getMetadata(params, callback) {
        var me = this,
            url = me.url,
            dataSourceName = params.dataSourceName,
            dataSetName = params.dataSetName;
        url = Util_Util.urlPathAppend(url, "datasources/" + dataSourceName + "/datasets/" + dataSetName);
        var editFeatureService = new EditFeaturesService(url, {
            proxy: me.options.proxy,
            withCredentials: me.options.withCredentials,
            crossOrigin: me.options.crossOrigin,
            headers: me.options.headers
        });
        return editFeatureService.getMetaData(params, callback);
    }
    _processFormat(resultFormat) {
      return resultFormat ? resultFormat : DataFormat.GEOJSON;
  }
}

;// CONCATENATED MODULE: ./src/mapboxgl/services/FeatureService.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/









/**
 * @class FeatureService
 * @category  iServer Data Feature
 * @classdesc 要素数据集类。提供：ID 查询、范围查询、SQL 查询、几何查询、bounds 查询、缓冲区查询、地物编辑。
 * @modulecategory Services
 * @example
 * new FeatureService(url)
 *  .getFeaturesByIDs(param,function(result){
 *     //doSomething
 * })
 * @extends {ServiceBase}
 * @param {string} url - 服务地址。
 * @param {Object} options -参数。
 * @param {string} [options.proxy] - 服务代理地址。
 * @param {boolean} [options.withCredentials=false] - 请求是否携带 cookie。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @usage
 */
class FeatureService extends ServiceBase {
    constructor(url, options) {
        super(url, options);
        this._featureService = new FeatureService_FeatureService(url, options);
    }

    /**
     * @function FeatureService.prototype.getFeaturesByIDs
     * @description 数据集 ID 查询服务。
     * @param {GetFeaturesByIDsParameters} params - ID查询参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @param {DataFormat} [resultFormat=DataFormat.GEOJSON] - 返回结果类型。
     * @returns {Promise} Promise 对象。
     */
    getFeaturesByIDs(params, callback, resultFormat) {
        params = this._processParams(params);
        return this._featureService.getFeaturesByIDs(params, callback, resultFormat);
    }

    /**
     * @function FeatureService.prototype.getFeaturesByBounds
     * @description 数据集 Bounds 查询服务。
     * @param {GetFeaturesByBoundsParameters} params - 数据集范围查询参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @param {DataFormat} [resultFormat=DataFormat.GEOJSON] - 返回结果类型。
     * @returns {Promise} Promise 对象。
     */
    getFeaturesByBounds(params, callback, resultFormat) {
        params = this._processParams(params);
        return this._featureService.getFeaturesByBounds(params, callback, resultFormat);
    }

    /**
     * @function FeatureService.prototype.getFeaturesByBuffer
     * @description 数据集 Buffer 查询服务。
     * @param {GetFeaturesByBufferParameters} params - 数据集缓冲区查询参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @param {DataFormat} [resultFormat=DataFormat.GEOJSON] - 返回结果类型。
     * @returns {Promise} Promise 对象。
     */
    getFeaturesByBuffer(params, callback, resultFormat) {
        params = this._processParams(params);
        return this._featureService.getFeaturesByBuffer(params, callback, resultFormat);
    }

    /**
     * @function FeatureService.prototype.getFeaturesBySQL
     * @description 数据集 SQL 查询服务。
     * @param {GetFeaturesBySQLParameters} params - 数据集 SQL 查询参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @param {DataFormat} [resultFormat=DataFormat.GEOJSON] - 返回结果类型。
     * @returns {Promise} Promise 对象。
     */
    getFeaturesBySQL(params, callback, resultFormat) {
      params = this._processParams(params);
      return this._featureService.getFeaturesBySQL(params, callback, resultFormat);
    }

    /**
     * @function FeatureService.prototype.getFeaturesByGeometry
     * @description 数据集几何查询服务类。
     * @param {GetFeaturesByGeometryParameters} params - 数据集几何查询参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @param {DataFormat} [resultFormat=DataFormat.GEOJSON] - 返回结果类型。
     * @returns {Promise} Promise 对象。
     */
    getFeaturesByGeometry(params, callback, resultFormat) {
      params = this._processParams(params);
      return this._featureService.getFeaturesByGeometry(params, callback, resultFormat);
    }

    /**
     * @function FeatureService.prototype.editFeatures
     * @description 地物编辑服务。
     * @param {EditFeaturesParameters} params - 数据集添加、修改、删除参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    editFeatures(params, callback) {
        if (!params || !params.dataSourceName || !params.dataSetName) {
            return;
        }
        var me = this,
            url = me.url,
            dataSourceName = params.dataSourceName,
            dataSetName = params.dataSetName;

        url = Util_Util.urlPathAppend(url, 'datasources/' + dataSourceName + '/datasets/' + dataSetName);
        var editFeatureService = new EditFeaturesService(url, {
            proxy: me.options.proxy,
            withCredentials: me.options.withCredentials,
            crossOrigin: me.options.crossOrigin,
            headers: me.options.headers
        });
        return editFeatureService.processAsync(me._processParams(params), callback);
    }

    /**
     * @function FeatureService.prototype.getMetadata
     * @description 地理要素元信息。
     * @version 11.1.1
     * @param {Object} params - 包括数据源名称、数据集名称、要素ID。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    getMetadata(params, callback) {
        return this._featureService.getMetadata(params, callback);
    }

    /**
     * @private
     * @description 参数类型转换。
     * @param {Object} params - 参数 。
     * @returns {Object} params - 转换后的对接 SuperMap 服务的参数。
     */
    _processParams(params) {
        if (!params) {
            return {};
        }
        var me = this;
        params.returnContent = params.returnContent == null ? true : params.returnContent;
        params.fromIndex = params.fromIndex ? params.fromIndex : 0;
        params.toIndex = params.toIndex === 0 ? 0 : params.toIndex ? params.toIndex : -1;
        if (params.bounds) {
            params.bounds = core_Util_Util.toSuperMapBounds(params.bounds);
        }
        if (params.editType) {
            params.editType = params.editType.toLowerCase();
        }

        //mapboxgl geojson要素对象转 SuperMap Geometry 对象
        if (params.geometry) {
            if (params.geometry instanceof (external_mapboxgl_default()).LngLatBounds) {
                params.geometry = core_Util_Util.toSuperMapPolygon(params.geometry);
                params.geometry.SRID = 4326;
            } else if (params.geometry instanceof (external_mapboxgl_default()).Point) {
                params.geometry = new Point(params.geometry.x, params.geometry.y);
            } else if (params.geometry instanceof (external_mapboxgl_default()).LngLat) {
                params.geometry = new Point(params.geometry.lng, params.geometry.lat);
                params.geometry.SRID = 4326;
            } else if (!(params.geometry instanceof Geometry_Geometry)) {
                params.geometry = core_Util_Util.toSuperMapGeometry(params.geometry);
            }
        }
        //editFeature服务参数转换,传入单独得对象或对象数组
        if (params.features) {
            var features = [];
            if (core_Util_Util.isArray(params.features)) {
                params.features.map(function (feature) {
                    features.push(me._createServerFeature(feature));
                    return features;
                });
            } else {
                features.push(me._createServerFeature(params.features));
            }
            params.features = features;
        }
        return params;
    }

    //geoFeature严格按照 mapboxgl geojson的结构
    _createServerFeature(geoFeature) {
        var feature = {},
            fieldNames = [],
            fieldValues = [];
        var properties = geoFeature.properties;
        for (var key in properties) {
            fieldNames.push(key);
            fieldValues.push(properties[key]);
        }
        feature.fieldNames = fieldNames;
        feature.fieldValues = fieldValues;
        if (geoFeature.id) {
            feature.id = geoFeature.id;
        }
        feature.geometry = core_Util_Util.toSuperMapGeometry(geoFeature);
        return feature;
    }
}


;// CONCATENATED MODULE: ./src/common/iServer/GetFieldsService.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/



/**
 * @class GetFieldsService
 * @deprecatedclass SuperMap.GetFieldsService
 * @category iServer Data Field
 * @classdesc 字段查询服务，支持查询指定数据集的中所有属性字段（field）的集合。
 * @param {string} url - 服务地址。如访问World Map服务，只需将url设为：http://localhost:8090/iserver/services/data-world/rest/data 即可。
 * @param {Object} options - 参数。
 * @param {DataFormat} [options.format=DataFormat.GEOJSON] - 查询结果返回格式，目前支持 iServerJSON 和 GeoJSON 两种格式。参数格式为 "ISERVER"，"GEOJSON"。
 * @param {string}options.datasource - 数据源名称。
 * @param {string}options.dataset - 数据集名称。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @extends {CommonServiceBase}
 * @example
 * var myService = new GetFieldsService(url,
 *     datasource: "World",
 *     dataset: "Countries"
 * };
 * @usage
 */
class GetFieldsService extends CommonServiceBase {


    constructor(url, options) {
        super(url, options);
        /**
         * @member {string} GetFieldsService.prototype.datasource
         * @description 要查询的数据集所在的数据源名称。
         */
        this.datasource = null;

        /**
         *  @member {string} GetFieldsService.prototype.dataset
         *  @description 要查询的数据集名称。
         */
        this.dataset = null;
        if (options) {
            Util_Util.extend(this, options);
        }

        this.CLASS_NAME = "SuperMap.GetFieldsService";
    }


    /**
     * @function GetFieldsService.prototype.destroy
     * @override
     */
    destroy() {
        super.destroy();
        var me = this;
        me.datasource = null;
        me.dataset = null;
    }


    /**
     * @function GetFieldsService.prototype.processAsync
     * @description 执行服务，查询指定数据集的字段信息。
     * @returns {Promise} Promise 对象。
     */
    processAsync(callback) {
        var me = this;
        me.url = Util_Util.urlPathAppend(me.url,`datasources/${me.datasource}/datasets/${me.dataset}/fields`);
        return me.request({
            method: "GET",
            data: null,
            scope: me,
            success: callback,
            failure: callback
        });
    }
}

;// CONCATENATED MODULE: ./src/common/iServer/FieldParameters.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


/**
 * @class FieldParameters
 * @deprecatedclass SuperMap.FieldParameters
 * @category iServer Data Field
 * @classdesc 字段信息查询参数类。
 * @param {Object} options - 参数。
 * @param {string} options.datasource - 数据源名称。
 * @param {string} options.dataset - 数据集名称。
 * @usage
 */
class FieldParameters {


    constructor(options) {
        /**
         * @member {string} FieldParameters.prototype.datasource
         * @description 要查询的数据集所在的数据源名称。
         */
        this.datasource = null;

        /**
         *  @member {string} FieldParameters.prototype.dataset
         *  @description 要查询的数据集名称。
         */
        this.dataset = null;

        if (options) {
            Util_Util.extend(this, options);
        }

        this.CLASS_NAME = "SuperMap.FieldParameters";
    }

    /**
     * @function FieldParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        var me = this;
        me.datasource = null;
        me.dataset = null;
    }

}


;// CONCATENATED MODULE: ./src/common/iServer/FieldStatisticsParameters.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/



/**
 * @class FieldStatisticsParameters
 * @deprecatedclass SuperMap.FieldStatisticsParameters
 * @category iServer Data Field
 * @classdesc 字段统计信息查询参数类。
 * @param {Object} options - 参数。
 * @param {string} options.datasource - 数据源名称。
 * @param {string} options.dataset - 数据集名称。
 * @param {string} options.fieldName - 字段名。
 * @param {(string.<StatisticMode>|Array.<string.<StatisticMode>>)} statisticMode - 字段统计方法类型。
 * @extends {FieldParameters}
 * @usage
 */
class FieldStatisticsParameters extends FieldParameters {


    constructor(options) {
        super(options);
        /**
         * @member {string} FieldStatisticsParameters.prototype.fieldName
         * @description 字段名。
         */
        this.fieldName = null;

        /**
         * @member {(string.<StatisticMode>|Array.<string.<StatisticMode>>)} FieldStatisticsParameters.prototype.statisticMode
         * @description 字段统计方法类型。
         */
        this.statisticMode = null;

        if (options) {
            Util_Util.extend(this, options);
        }

        this.CLASS_NAME = "SuperMap.FieldStatisticsParameters";
    }

    /**
     * @function FieldStatisticsParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        var me = this;
        me.fieldName = null;
        me.statisticMode = null;
    }

}


;// CONCATENATED MODULE: ./src/common/iServer/FieldStatisticService.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/




/**
 * @class FieldStatisticService
 * @deprecatedclass SuperMap.FieldStatisticService
 * @category iServer Data Field
 * @classdesc 字段查询统计服务类。用来完成对指定数据集指定字段的查询统计分析，即求平均值，最大值等。
 * @extends {CommonServiceBase}
 * @param {string} url - 服务地址。如访问 World Map 服务，只需将 url 设为：http://localhost:8090/iserver/services/data-world/rest/data 即可。
 * @param {Object} options - 参数。
 * @param {DataFormat} [options.format] - 查询结果返回格式，目前支持 iServerJSON 和GeoJSON 两种格式。参数格式为 "ISERVER","GEOJSON"。
 * @param {string} options.datasource - 数据集所在的数据源名称。
 * @param {string} options.dataset - 数据集名称。
 * @param {string} options.field - 查询统计的目标字段名称。
 * @param {StatisticMode} options.statisticMode - 字段查询统计的方法类型。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @example
 * var myService = new FieldStatisticService(url,
 *     datasource: "World",
 *     dataset: "Countries",
 *     field: "SmID",
 *     statisticMode: StatisticMode.AVERAGE
 * };
 * @usage
 */


class FieldStatisticService extends CommonServiceBase {


    constructor(url, options) {
        super(url, options);
        /**
         * @member {string} FieldStatisticService.prototype.datasource
         * @description 数据集所在的数据源名称。
         */
        this.datasource = null;


        /**
         * @member {string} FieldStatisticService.prototype.dataset
         * @description 数据集名称。
         */
        this.dataset = null;

        /**
         * @member {string} FieldStatisticService.prototype.field
         * @description 查询统计的目标字段名称。
         */
        this.field = null;

        /**
         * @member {StatisticMode} FieldStatisticService.prototype.statisticMode
         * @description 字段查询统计的方法类型。
         */
        this.statisticMode = null;
        if (options) {
            Util_Util.extend(this, options);
        }

        this.CLASS_NAME = "SuperMap.FieldStatisticService";
    }


    /**
     * @function FieldStatisticService.prototype.destroy
     * @override
     */
    destroy() {
        super.destroy();
        var me = this;
        me.datasource = null;
        me.dataset = null;
        me.field = null;
        me.statisticMode = null;
    }


    /**
     * @function FieldStatisticService.prototype.processAsync
     * @description 执行服务，进行指定字段的查询统计。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    processAsync(callback) {
        var me = this,
            fieldStatisticURL = "datasources/" + me.datasource + "/datasets/" + me.dataset + "/fields/" + me.field + "/" + me.statisticMode;
        me.url = Util_Util.urlPathAppend(me.url, fieldStatisticURL);

        return me.request({
            method: "GET",
            data: null,
            scope: me,
            success: callback,
            failure: callback
        });
    }

}

;// CONCATENATED MODULE: ./src/common/iServer/FieldService.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/




/**
 * @class FieldService
 * @category  iServer Data Field
 * @classdesc 字段服务类。
 * @example
 * new FieldService(url).getFields(function(result){
 *     //doSomething
 * });
 * @param {string} url - 服务地址。
 * @param {Object} options - 参数。
 * @param {string} [options.proxy] - 服务代理地址。
 * @param {boolean} [options.withCredentials=false] - 请求是否携带 cookie。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @extends {ServiceBase}
 * @usage
 */
class FieldService_FieldService {
    constructor(url, options) {
      this.url = url;
      this.options = options || {};
    }

    /**
     * @function FieldService.prototype.getFields
     * @description 字段查询服务。
     * @param {FieldParameters} params - 字段信息查询参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    getFields(params, callback) {
        var me = this;
        var getFieldsService = new GetFieldsService(me.url, {
            proxy: me.options.proxy,
            withCredentials: me.options.withCredentials,
            crossOrigin: me.options.crossOrigin,
            headers: me.options.headers,
            datasource: params.datasource,
            dataset: params.dataset
        });
        return getFieldsService.processAsync(callback);
    }

    /**
     * @function FieldService.prototype.getFieldStatisticsInfo
     * @description 字段统计服务。
     * @param {FieldStatisticsParameters} params - 字段统计信息查询参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     */
    getFieldStatisticsInfo(params, callback) {
      if (!(params instanceof FieldStatisticsParameters)) {
        return;
      }
        var me = this,
            fieldName = params.fieldName,
            modes = params.statisticMode;
        if (modes && !Array.isArray(modes)) {
          modes = [modes];
        }
        me.currentStatisticResult = {fieldName: fieldName};
        me._statisticsCallback = callback;
        //针对每种统计方式分别进行请求
        modes.forEach(mode => {
            me.currentStatisticResult[mode] = null;
            me._fieldStatisticRequest(params.datasource, params.dataset, fieldName, mode);
        })
    }

    _fieldStatisticRequest(datasource, dataset, fieldName, statisticMode) {
        var me = this;
        var statisticService = new FieldStatisticService(me.url, {
            datasource: datasource,
            dataset: dataset,
            field: fieldName,
            statisticMode: statisticMode,
            crossOrigin: me.options.crossOrigin,
            headers: me.options.headers
        });
        statisticService.processAsync(me._processCompleted.bind(me));
    }

    _processCompleted(fieldStatisticResult) {
        var me = this;
        if (fieldStatisticResult.error) {
          me._statisticsCallback(fieldStatisticResult);
          return;
        }
        var getAll = true,
            result = fieldStatisticResult.result;
        if (this.currentStatisticResult) {
            if (null == me.currentStatisticResult[result.mode]) {
                this.currentStatisticResult[result.mode] = result.result;
            }
        }
        for (var mode in me.currentStatisticResult) {
            if (null == me.currentStatisticResult[mode]) {
                getAll = false;
                break;
            }
        }
        if (getAll) {
            me._statisticsCallback({result: me.currentStatisticResult});
        }
    }
}

;// CONCATENATED MODULE: ./src/mapboxgl/services/FieldService.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/




/**
 * @class FieldService
 * @category  iServer Data Field
 * @classdesc 字段服务类。
 * @modulecategory Services
 * @example
 * new FieldService(url).getFields(function(result){
 *     //doSomething
 * });
 * @param {string} url - 服务地址。
 * @param {Object} options - 参数。
 * @param {string} [options.proxy] - 服务代理地址。
 * @param {boolean} [options.withCredentials=false] - 请求是否携带 cookie。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @extends {ServiceBase}
 * @usage
 */
class FieldService extends ServiceBase {
    constructor(url, options) {
        super(url, options);
        this._fieldService = new FieldService_FieldService(url, options);
    }

    /**
     * @function FieldService.prototype.getFields
     * @description 字段查询服务。
     * @param {FieldParameters} params - 字段信息查询参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。 
     */
    getFields(params, callback) {
      return this._fieldService.getFields(params, callback);
    }

    /**
     * @function FieldService.prototype.getFieldStatisticsInfo
     * @description 字段统计服务。
     * @param {FieldStatisticsParameters} params - 字段统计信息查询参数类。
     * @param {RequestCallback} callback 回调函数。
     */
    getFieldStatisticsInfo(params, callback) {
      return this._fieldService.getFieldStatisticsInfo(params, callback);
    }
}

;// CONCATENATED MODULE: ./src/common/iServer/GetGridCellInfosParameters.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


/**
 * @class GetGridCellInfosParameters
 * @deprecatedclass SuperMap.GetGridCellInfosParameters
 * @category iServer Data Grid
 * @classdesc 数据服务栅格查询参数类。
 * @param {Object} options - 参数。
 * @param {string} options.datasetName - 数据集名称。
 * @param {string} options.dataSourceName - 数据源名称。
 * @param {number} options.X - 地理位置 X 轴。
 * @param {number} options.Y - 地理位置 Y 轴。
 * @usage
 */
class GetGridCellInfosParameters {


    constructor(options) {
        /**
         * @member {string} GetGridCellInfosParameters.prototype.datasetName
         * @description 数据集名称。
         */
        this.datasetName = null;

        /**
         * @member {string} GetGridCellInfosParameters.prototype.dataSourceName
         * @description 数据源名称。
         */
        this.dataSourceName = null;

        /**
         * @member {number} GetGridCellInfosParameters.prototype.X
         * @description 要查询的地理位置 X 轴。
         */
        this.X = null;

        /**
         * @member {number} GetGridCellInfosParameters.prototype.Y
         * @description 要查询的地理位置 Y 轴。
         */
        this.Y = null;
        Util_Util.extend(this, options);

        this.CLASS_NAME = "SuperMap.GetGridCellInfosParameters";
    }


    /**
     * @function GetGridCellInfosParameters.prototype.destroy
     * @description 释放资源，将引用的资源属性置空。
     */
    destroy() {
        var me = this;
        me.datasetName = null;
        me.dataSourceName = null;
        me.X = null;
        me.Y = null;
    }


}


;// CONCATENATED MODULE: ./src/common/iServer/GetGridCellInfosService.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/




/**
 * @class GetGridCellInfosService
 * @deprecatedclass SuperMap.GetGridCellInfosService
 * @category iServer Data Grid
 * @classdesc 数据栅格查询服务，支持查询指定地理位置的栅格信息。
 * @param {string} url - 服务地址。例如: http://localhost:8090/iserver/services/data-jingjin/rest/data
 * @param {Object} options - 参数。
 * @param {DataFormat} [options.format=DataFormat.GEOJSON] - 查询结果返回格式，目前支持 iServerJSON 和 GeoJSON 两种格式。参数格式为 "ISERVER"，"GEOJSON"。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @extends {CommonServiceBase}
 * @example
 * var myService = new GetGridCellInfosService(url);
 * @usage
 */
class GetGridCellInfosService extends CommonServiceBase {


    constructor(url, options) {
        super(url, options);
        /**
         * @member {string} GetGridCellInfosService.prototype.datasetName
         * @description 数据集名称。
         */
        this.datasetName = null;

        /**
         * @member {string} GetGridCellInfosService.prototype.dataSourceName
         * @description 数据源名称。
         */
        this.dataSourceName = null;

        /**
         * @member {string} GetGridCellInfosService.prototype.datasetType
         * @description 数据集类型。
         */
        this.datasetType = null;

        /**
         * @member {number} GetGridCellInfosService.prototype.X
         * @description 要查询的地理位置X轴
         */
        this.X = null;

        /**
         * @member {number} GetGridCellInfosService.prototype.Y
         * @description 要查询的地理位置Y轴
         */
        this.Y = null;
        if (options) {
            Util_Util.extend(this, options);
        }
        this.CLASS_NAME = "SuperMap.GetGridCellInfosService";
    }

    /**
     * @function GetGridCellInfosService.prototype.destroy
     * @override
     */
    destroy() {
        super.destroy();
        var me = this;
        me.X = null;
        me.Y = null;
        me.datasetName = null;
        me.dataSourceName = null;
        me.datasetType = null;
    }

    /**
     * @function GetGridCellInfosService.prototype.processAsync
     * @description 执行服务，查询数据集信息。
     * @param {GetGridCellInfosParameters} params - 查询参数。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    processAsync(params, callback) {
        if (!(params instanceof GetGridCellInfosParameters)) {
            return;
        }
        Util_Util.extend(this, params);
        var me = this;
        me.url = Util_Util.urlPathAppend(me.url,`datasources/${me.dataSourceName}/datasets/${me.datasetName}`);
        return me.request({
          method: "GET",
          data: null,
          scope: me,
          success({result}) {
            callback && me.getDatasetInfoCompleted(result, callback);
          },
          failure: callback
        }).then(({result}) => {
          return me.getDatasetInfoCompleted(result);
        });
    }

    /**
     * @function GetGridCellInfosService.prototype.getDatasetInfoCompleted
     * @description 数据集查询完成，执行此方法。
     * @param {Object} result - 服务器返回的结果对象。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    getDatasetInfoCompleted(result, callback) {
        var me = this;
        result = Util_Util.transformResult(result);
        me.datasetType = result.datasetInfo.type;
        return me.queryGridInfos(callback);
    }

    /**
     * @function GetGridCellInfosService.prototype.queryGridInfos
     * @description 执行服务，查询数据集栅格信息。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    queryGridInfos(callback) {
        var me = this;
        var url = Util_Util.urlPathAppend(me.url, me.datasetType == 'GRID' ? 'gridValue' : 'imageValue');
        if (me.X != null && me.Y != null) {
            url = Util_Util.urlAppend(url, `x=${me.X}&y=${me.Y}`);
        }
        return me.request({
          url,
          method: "GET",
          data: null,
          scope: me,
          success: callback,
          failure: callback
      });
    }
}

;// CONCATENATED MODULE: ./src/mapboxgl/services/GridCellInfosService.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/




/**
 * @class GridCellInfosService
 * @category  iServer Data Grid
 * @classdesc 数据栅格查询服务类。
 * @modulecategory Services
 * @extends {ServiceBase}
 * @example
 * new GridCellInfosService(url)
 *  .getGridCellInfos(param,function(result){
 *     //doSomething
 * })
 * @param {string} url - 服务地址。请求地图服务，URL 应为：</br>
 *                       http://{服务器地址}:{服务端口号}/iserver/services/{地图服务名}/rest/maps/{地图名}/tempLayersSet/{tempLayerID}/Rivers@World@@World。
 * @param {Object} options - 参数。
 * @param {string} [options.proxy] - 服务代理地址。
 * @param {boolean} [options.withCredentials=false] - 请求是否携带 cookie。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @usage
 */
class GridCellInfosService extends ServiceBase {

    constructor(url, options) {
        super(url, options);
        this._gridCellQueryService = new GetGridCellInfosService(this.url, {
          proxy: this.options.proxy,
          withCredentials: this.options.withCredentials,
          crossOrigin: this.options.crossOrigin,
          headers: this.options.headers
      });
    }

    /**
     * @function GridCellInfosService.prototype.getGridCellInfos
     * @description 获取某一地理位置所对应的栅格单元信息。
     * @param {GetGridCellInfosParameters} params - 数据服务栅格查询参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} null或者Promise 对象。
     */
    getGridCellInfos(params, callback) {
      if (!params) {
        return null;
      }
      return this._gridCellQueryService.processAsync(params, callback);
    }
}

;// CONCATENATED MODULE: ./src/common/iServer/GeoprocessingService.js


/**
 * @class GeoprocessingService
 * @deprecatedclass SuperMap.GeoprocessingService
 * @category  iServer ProcessingAutomationService
 * @classdesc 处理自动化服务接口的基类。
 * @version 10.1.0
 * @extends {CommonServiceBase}
 * @param {string} url - 服务地址。
 * @param {Object} options - 参数。
 * @param {Events} options.events - 处理所有事件的对象。
 * @usage
 */
class GeoprocessingService_GeoprocessingService extends CommonServiceBase {
    constructor(url, options) {
        options = options || {};
        super(url, options);
        this.CLASS_NAME = 'SuperMap.GeoprocessingService';
        this.headers = {};
        this.crossOrigin = true;
    }
    /**
     * @function GeoprocessingService.prototype.getTools
     * @description 获取处理自动化工具列表。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    getTools(callback) {
      return this._processAsync({ url: `${this.url}/list`, callback });
    }
    /**
     * @function GeoprocessingService.prototype.getTool
     * @description 获取处理自动化工具的ID、名称、描述、输入参数、环境参数和输出结果等相关参数。
     * @param {string} identifier - 处理自动化工具ID。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    getTool(identifier, callback) {
      return this._processAsync({ url: `${this.url}/${identifier}`, callback });
    }
    /**
     * @function GeoprocessingService.prototype.execute
     * @description 同步执行处理自动化工具。
     * @param {string} identifier - 处理自动化工具ID。
     * @param {Object} parameter - 处理自动化工具的输入参数。
     * @param {Object} environment - 处理自动化工具的环境参数。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    execute(identifier, parameter, environment, callback) {
        parameter = parameter ? parameter : null;
        environment = environment ? environment : null;
        const executeParamter = { parameter, environment };
        return this._processAsync({ url: `${this.url}/${identifier}/execute`, executeParamter, callback });
    }
    /**
     * @function GeoprocessingService.prototype.submitJob
     * @description 异步执行处理自动化工具。
     * @param {string} identifier - 处理自动化工具ID。
     * @param {Object} parameter - 处理自动化工具的输入参数。
     * @param {Object} environments - 处理自动化工具的环境参数。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    submitJob(identifier, parameter, environments, callback) {
        parameter = parameter ? parameter : null;
        environments = environments ? environments : null;
        const asyncParamter = JSON.stringify({ parameter: parameter, environments: environments });
        return this._processAsync({ url: `${this.url}/${identifier}/jobs`, method: 'POST', callback, params: asyncParamter });
    }

    /**
     * @function GeoprocessingService.prototype.waitForJobCompletion
     * @description 获取处理自动化异步执行状态信息。
     * @param {string} jobId - 处理自动化任务ID。
     * @param {string} identifier - 处理自动化工具ID。
     * @param {Object} options - 状态信息参数。
     * @param {number} options.interval - 定时器时间间隔。
     * @param {function} options.statusCallback - 任务状态的回调函数。
     */
    waitForJobCompletion(jobId, identifier, options, callback) {
        const me = this;
        const timer = setInterval(function () {
            const transformResult = function (serverResult) {
                const state = serverResult.result.state.runState;
                if (serverResult.options.statusCallback) {
                    serverResult.options.statusCallback(state);
                }
                if (['FINISHED', 'FAILED', 'CANCELED'].indexOf(state) !== -1) {
                  clearInterval(timer);
                  callback(serverResult);
                }
            };
            me._processAsync({ url: `${me.url}/${identifier}/jobs/${jobId}`, callback: transformResult });
        }, options.interval);
    }

    /**
     * @function GeoprocessingService.prototype.getJobInfo
     * @description 获取处理自动化任务的执行信息。
     * @param {string} identifier - 处理自动化工具ID。
     * @param {string} jobId - 处理自动化任务ID。
     * @returns {Promise} Promise 对象。
     */
    getJobInfo(identifier, jobId, callback) {
      return this._processAsync({ url: `${this.url}/${identifier}/jobs/${jobId}`, callback });
    }

    /**
     * @function GeoprocessingService.prototype.cancelJob
     * @description 取消处理自动化任务的异步执行。
     * @param {string} identifier - 处理自动化工具ID。
     * @param {string} jobId - 处理自动化任务ID。
     * @returns {Promise} Promise 对象。
     */
    cancelJob(identifier, jobId, callback) {
      return this._processAsync({ url: `${this.url}/${identifier}/jobs/${jobId}/cancel`, callback });
    }
    /**
     * @function GeoprocessingService.prototype.getJobs
     * @description 获取处理自动化服务任务列表。
     * @param {string} identifier - 处理自动化工具ID。(传参代表identifier算子的任务列表，不传参代表所有任务的列表)
     * @returns {Promise} Promise 对象。
     */
    getJobs(identifier, callback) {
        let url = `${this.url}/jobs`;
        if (identifier && typeof identifier === 'string') {
            url = `${this.url}/${identifier}/jobs`;
        } else {
          callback = identifier;
        }
        this._processAsync({ url, callback });
    }
    /**
     * @function GeoprocessingService.prototype.getResults
     * @description 处理自动化工具执行的结果等,支持结果过滤。
     * @param {string} identifier - 处理自动化工具ID。
     * @param {string} jobId - 处理自动化任务ID。
     * @param {string} filter - 输出异步结果的ID。(可选，传入filter参数时对该处理自动化工具执行的结果进行过滤获取，不填参时显示所有的执行结果)
     * @returns {Promise} Promise 对象。
     */
    getResults(identifier, jobId, filter, callback) {
        let url = `${this.url}/${identifier}/jobs/${jobId}/results`;
        if (filter) {
          if (typeof filter === 'string') {
            url = `${url}/${filter}`;
          } else {
            callback = filter;
          }
        } 
        return this._processAsync({ url, callback });
    }
   
    _processAsync({ url, method, callback, paramter }) {
          return this.request({
              url: url,
              method: method || 'GET',
              params: paramter,
              headers: { 'Content-type': 'application/json' },
              scope: this,
              success: callback,
              failure: callback
          });
      }
}

;// CONCATENATED MODULE: ./src/mapboxgl/services/GeoprocessingService.js




/**
 * @class GeoprocessingService
 * @classdesc 处理自动化服务接口类。
 * @version 10.1.0
 * @category  iServer ProcessingAutomationService
 * @modulecategory Services
 * @extends  {ServiceBase}
 * @example
 *  //为了安全访问受保护的处理自动化服务，必须通过传递iserver令牌(token)，才能正确访问相关资源。
 * SecurityManager.registerToken(serviceUrl, token);
 *  var geoprocessingService = new GeoprocessingService("http://localhost:8090/iserver/services/geoprocessing/restjsr/gp/v2")
        geoprocessingService.submitJob(identifier,params, environments, function(serverResult) {
            console.log(serverResult.result);
            var jobID = serverResult.result.jobID;
            var options = {
                interval: 5000,
                statusCallback: function(state) {
                console.log("Job Status: ", state);
                }
            };
            geoprocessingService.waitForJobCompletion(jobID, identifier, options, function(serverResult) {
                console.log(serverResult);
            })
        })
 * @param {string} url - 服务地址。
 * @param {Object} options - 参数。
 * @usage
 */
class GeoprocessingService extends ServiceBase {
    constructor(url, options) {
        super(url, options);
        this.headers = {};
        this.crossOrigin = true;
        this.withCredentials = true;
        this.proxy = true;
        this._geoprocessingJobsService = new GeoprocessingService_GeoprocessingService(this.url, {
          proxy: this.options.proxy,
          withCredentials: this.options.withCredentials,
          crossOrigin: this.options.crossOrigin,
          headers: this.options.headers
        });
    }
    /**
     * @function GeoprocessingService.prototype.getTools
     * @description 获取处理自动化工具列表。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    getTools(callback) {
      return this._geoprocessingJobsService.getTools(callback);
    }
    /**
     * @function GeoprocessingService.prototype.getTool
     * @description 获取处理自动化工具的ID、名称、描述、输入参数、环境参数和输出结果等相关参数。
     * @param {string} identifier - 处理自动化工具ID。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     */
    getTool(identifier, callback) {
      this._geoprocessingJobsService.getTool(identifier, callback);
    }

    /**
     * @function GeoprocessingService.prototype.execute
     * @description 同步执行处理自动化工具。
     * @param {string} identifier - 处理自动化工具ID。
     * @param {Object} parameter - 处理自动化工具的输入参数。
     * @param {Object} environment - 处理自动化工具的环境参数。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    execute(identifier, parameter, environment, callback) {
      return this._geoprocessingJobsService.execute(identifier, parameter, environment, callback);
    }

    /**
     * @function GeoprocessingService.prototype.submitJob
     * @description 异步执行处理自动化工具。
     * @param {string} identifier - 处理自动化工具ID。
     * @param {Object} parameter - 处理自动化工具的输入参数。
     * @param {Object} environment - 处理自动化工具的环境参数。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    submitJob(identifier, parameter, environment, callback) {
      return this._geoprocessingJobsService.submitJob(identifier, parameter, environment, callback);
    }

    /**
     * @function GeoprocessingService.prototype.waitForJobCompletion
     * @description 获取处理自动化异步执行状态信息。
     * @param {string} jobId - 处理自动化任务ID。
     * @param {string} identifier - 处理自动化工具ID。
     * @param {Object} options - 状态信息参数。
     * @param {number} options.interval - 定时器时间间隔。
     * @param {function} options.statusCallback - 任务状态的回调函数。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    waitForJobCompletion(jobId, identifier, options, callback) {
      return this._geoprocessingJobsService.waitForJobCompletion(jobId, identifier, options, callback);
    }

    /**
     * @function GeoprocessingService.prototype.getJobInfo
     * @description 获取处理自动化任务的执行信息。
     * @param {string} identifier - 处理自动化工具ID。
     * @param {string} jobId - 处理自动化任务ID。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    getJobInfo(identifier, jobId, callback) {
      return this._geoprocessingJobsService.getJobInfo(identifier, jobId, callback);
    }

    /**
     * @function GeoprocessingService.prototype.cancelJob
     * @description 取消处理自动化任务的异步执行。
     * @param {string} identifier - 处理自动化工具ID。
     * @param {string} jobId - 处理自动化任务ID。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    cancelJob(identifier, jobId, callback) {
      return this._geoprocessingJobsService.cancelJob(identifier, jobId, callback);
    }

    /**
     * @function GeoprocessingService.prototype.getJobs
     * @description 获取处理自动化服务任务列表。
     * @param {string} identifier - 处理自动化工具ID。(可选，传参代表identifier算子的任务列表，不传参代表所有任务的列表)
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    getJobs(identifier, callback) {
      return this._geoprocessingJobsService.getJobs(identifier, callback);
    }

    /**
     * @function GeoprocessingService.prototype.getResults
     * @description 处理自动化工具异步执行的结果,支持结果过滤。
     * @param {string} identifier - 处理自动化工具ID。
     * @param {string} jobId - 处理自动化任务ID。
     * @param {string} filter - 输出异步结果的ID。(可选，传入filter参数时对该处理自动化工具执行的结果进行过滤获取，不填参时显示所有的执行结果)
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    getResults(identifier, jobId, filter, callback) {
      return this._geoprocessingJobsService.getResults(identifier, jobId, filter, callback);
    }
}


;// CONCATENATED MODULE: ./src/common/iServer/Theme.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


/**
 * @class CommonTheme
 * @aliasclass Theme
 * @deprecatedclass SuperMap.Theme
 * @category  iServer Map Theme
 * @classdesc 专题图基类。
 * @param {string} type - 专题图类型。
 * @param {Object} options - 可选参数。
 * @param {ThemeMemoryData} [options.memoryData] - 专题图内存数据。
 * @usage
 */
class Theme_Theme {

    constructor(type, options) {
        if (!type) {
            return this;
        }
        /**
         * @member {ThemeMemoryData} CommonTheme.prototype.memoryData
         * @description 专题图内存数据。<br>
         *              用内存数据制作专题图的方式与表达式制作专题图的方式互斥，前者优先级较高。
         *              第一个参数代表专题值，即数据集中用来做专题图的字段或表达式的值；第二个参数代表外部值。在制作专题图时，会用外部值代替专题值来制作相应的专题图。
         */
        this.memoryData = null;

        /**
         * @member {string} CommonTheme.prototype.type
         * @description 专题图类型。
         */
        this.type = type;

        if (options) {
            Util_Util.extend(this, options);
        }

        this.CLASS_NAME = "SuperMap.Theme";
    }

    /**
     * @function CommonTheme.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        var me = this;
        if (me.memoryData) {
            me.memoryData.destroy();
            me.memoryData = null;
        }
        me.type = null;
    }

    /**
     * @function CommonTheme.prototype.toServerJSONObject
     * @description 转换成对应的 JSON 格式对象。
     * @returns {Object} 对应的 JSON 格式对象。
     */
    toServerJSONObject() {
        //return 子类实现
        return;
    }

}

;// CONCATENATED MODULE: ./src/common/iServer/ServerTextStyle.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/




/**
 * @class ServerTextStyle
 * @deprecatedclass SuperMap.ServerTextStyle
 * @category  iServer Map Theme
 * @classdesc 服务端文本风格类。该类用于定义文本风格的相关属性。
 * @param {Object} options - 可选参数。
 * @param {TextAlignment} [options.align=TextAlignment.BASELINECENTER] - 文本的对齐方式。
 * @param {ServerColor} [options.backColor] - 文本的背景色。默认 backColor = new ServerColor(255, 255, 255)。
 * @param {ServerColor} [options.foreColor] - 文本的前景色。默认 foreColor = new ServerColor(0, 0, 0)。
 * @param {boolean} [options.backOpaque=false] - 文本背景是否不透明。
 * @param {boolean} [options.sizeFixed=true] - 文本大小是否固定。
 * @param {number} [options.fontHeight=6] - 文本字体的高度。
 * @param {number} [options.fontWidth=0] - 文本字体的宽度。
 * @param {number} [options.fontWeight=400] - 文本字体的磅数。
 * @param {string} [options.fontName='Times New Roman'] - 文本字体的名称。
 * @param {boolean} [options.bold=false] - 文本是否为粗体字。
 * @param {boolean} [options.italic=false] - 文本是否采用斜体。
 * @param {number} [options.italicAngle=0] - 字体倾斜角度。
 * @param {boolean} [options.shadow=false] - 文本是否有阴影。
 * @param {boolean} [options.strikeout=false] - 文本字体是否加删除线。
 * @param {boolean} [options.outline=false] - 是否以轮廓的方式来显示文本的背景。
 * @param {number} [options.opaqueRate=0] - 注记文字的不透明度。
 * @param {boolean} [options.underline=false] - 文本字体是否加下划线。
 * @param {number} [options.rotation=0.0] -  文本旋转的角度。
 * @usage
 */
class ServerTextStyle {


    constructor(options) {
        /**
         * @member {TextAlignment} [ServerTextStyle.prototype.align= TextAlignment.BASELINECENTER]
         * @description 文本的对齐方式。
         */
        this.align = TextAlignment.BASELINECENTER;

        /**
         * @member {ServerColor} [ServerTextStyle.prototype.backColor=(255, 255, 255)]
         * @description 文本的背景色。
         */
        this.backColor = new ServerColor(255, 255, 255);

        /**
         * @member {ServerColor} [ServerTextStyle.prototype.foreColor=(0, 0, 0)]
         * @description 文本的前景色。
         */
        this.foreColor = new ServerColor(0, 0, 0);

        /**
         * @member {boolean} [ServerTextStyle.prototype.backOpaque=false]
         * @description 文本背景是否不透明。true 表示文本背景不透明。
         */
        this.backOpaque = false;

        /**
         * @member {boolean} [ServerTextStyle.prototype.sizeFixed=true]
         * @description 文本大小是否固定。设置为 true，表示图片为固定像素大小，具体大小请参考 fontHeight。当设为 false 时，图片会随着地图缩放而缩放。
         */
        this.sizeFixed = true;

        /**
         * @member {number} [ServerTextStyle.prototype.fontHeight=6]
         * @description 文本字体的高度，单位与 sizeFixed 有关，当 sizeFixed 为 False 时，即非固定文本大小时使用地图坐标单位，
         *              如地理坐标系下的地图中单位为度；当 sizeFixed 为 True 时，单位为毫米（mm）。
         */
        this.fontHeight = 6;

        /**
         * @member {number} [ServerTextStyle.prototype.fontWidth=0]
         * @description 文本字体的宽度。字体的宽度以英文字符为标准，由于一个中文字符相当于两个英文字符。
         */
        this.fontWidth = 0;

        /**
         * @member {number} [ServerTextStyle.prototype.fontWeight=400]
         * @description 文本字体的磅数。表示粗体的具体数值。取值范围为从0－900之间的整百数。
         */
        this.fontWeight = 400;

        /**
         * @member {string} [ServerTextStyle.prototype.fontName="Times New Roman"]
         * @description 文本字体的名称。
         */
        this.fontName = "Times New Roman";

        /**
         * @member {boolean} [ServerTextStyle.prototype.bold=false]
         * @description 文本是否为粗体字。true 表示为粗体。false 表示文本不是粗体字。
         */
        this.bold = false;

        /**
         * @member {boolean} [ServerTextStyle.prototype.italic=false]
         * @description 文本是否采用斜体。true 表示采用斜体。
         */
        this.italic = false;

        /**
         * @member {number} [ServerTextStyle.prototype.italicAngle=0]
         * @description 字体倾斜角度。正负度之间，以度为单位，精确到0.1度。当倾斜角度为0度，为系统默认的字体倾斜样式。
         *              正负度是指以纵轴为起始零度线，其纵轴左侧为正，右侧为负。允许的最大角度为60，最小-60。大于60按照60处理，小于-60按照-60处理。目前只对标签专题图有效。
         */
        this.italicAngle = 0;

        /**
         * @member {boolean} [ServerTextStyle.prototype.shadow=false]
         * @description 文本是否有阴影。true 表示给文本增加阴影。false 表示文本没有阴影。
         */
        this.shadow = false;

        /**
         * @member {boolean} [ServerTextStyle.prototype.strikeout=false]
         * @description 文本字体是否加删除线。true 表示加删除线。false 表示文本字体不加删除线。
         */
        this.strikeout = false;

        /**
         * @member {boolean} [ServerTextStyle.prototype.outline=false]
         * @description 是否以轮廓的方式来显示文本的背景。true 表示以轮廓的方式来显示文本的背景。false 表示不以轮廓的方式来显示文本的背景。
         */
        this.outline = false;

        /**
         * @member {number} [ServerTextStyle.prototype.opaqueRate=0]
         * @description 注记文字的不透明度。不透明度的范围为0-100。0表示透明。
         */
        this.opaqueRate = 0;

        /**
         * @member {boolean} [ServerTextStyle.prototype.underline=false]
         * @description 文本字体是否加下划线。true 表示加下划线。
         */
        this.underline = false;

        /**
         * @member {number} [ServerTextStyle.prototype.rotation=0.0]
         * @description 文本旋转的角度。逆时针方向为正方向，单位为度，精确到0.1度。
         */
        this.rotation = 0.0;

        if (options) {
            Util_Util.extend(this, options);
        }

       this.CLASS_NAME = "SuperMap.ServerTextStyle";
    }


    /**
     * @function ServerTextStyle.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        var me = this;
        me.align = null;
        if (me.backColor) {
            me.backColor.destroy();
            me.backColor = null;
        }
        if (me.foreColor) {
            me.foreColor.destroy();
            me.foreColor = null;
        }
        me.backOpaque = null;
        me.sizeFixed = null;
        me.fontHeight = null;
        me.fontWidth = null;
        me.fontWeight = null;
        me.fontName = null;
        me.bold = null;
        me.italic = null;
        me.italicAngle = null;
        me.shadow = null;
        me.strikeout = null;
        me.outline = null;
        me.opaqueRate = null;
        me.underline = null;
        me.rotation = null;
    }

    /**
     * @function ServerTextStyle.fromObj
     * @description 从传入对象获服务端文本风格类。
     * @param {Object} obj - 传入对象
     * @returns {ServerTextStyle} 返回服务端文本风格对象
     */
    static fromObj(obj) {
        var res = new ServerTextStyle(obj);
        Util_Util.copy(res, obj);
        res.backColor = ServerColor.fromJson(obj.backColor);
        res.foreColor = ServerColor.fromJson(obj.foreColor);
        return res;
    }

}


;// CONCATENATED MODULE: ./src/common/iServer/ThemeLabelItem.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/



/**
 * @class ThemeLabelItem
 * @deprecatedclass SuperMap.ThemeLabelItem
 * @category  iServer Map Theme
 * @classdesc 分段标签专题图的子项。标签专题图用专题值对点、线、面等对象做标注。
 * 值得注意的是，分段标签专题图允许用户通过 rangeExpression 字段指定用于分段的数值型字段，
 * 同一范围段内的标签具有相同的显示风格，其中每一个范围段就是一个专题图子项，
 * 每一个子项都具有其名称、风格、起始值和终止值。注意：每个分段所表示的范围为 [Start, End)。例如：标签专题图的分段点有两个子项，
 * 他们所代表的分段区间分别为[0,5)，[5,10)。那么需要分别设置 ThemeLabelItem[0].start=0，
 *  ThemeLabelItem[0].end=5，SuperMap.ThemeLabelItem[1].start=5，SuperMap.ThemeLabelItem[1].end=10。
 * @param {Object} options - 可选参数。
 * @param {string} [options.caption] - 子项的名称。
 * @param {number} [options.end=0] - 子项的终止值。
 * @param {number} [options.start=0] - 子项的分段起始值。
 * @param {boolean} [options.visible=true] - 子项是否可见。
 * @param {ServerTextStyle} [options.style] - 子项文本的显示风格。
 * @usage
 */
class ThemeLabelItem {

    constructor(options) {
        /**
         * @member {string} [ThemeLabelItem.prototype.caption]
         * @description 标签专题子项的标题。
         */
        this.caption = null;

        /**
         * @member {number} [ThemeLabelItem.prototype.end=0]
         * @description 标签专题图子项的终止值。如果该子项是分段中最后一个子项，那么该终止值就是分段的最大值；
         *              如果不是最后一项，该终止值必须与其下一子项的起始值相同，否则系统抛出异常。
         */
        this.end = 0;

        /**
         * @member {number} [ThemeLabelItem.prototype.start=0]
         * @description 标签专题图子项的分段起始值。如果该子项是分段中第一项，那么该起始值就是分段的最小值；
         *              如果该子项的序号大于等于 1 的时候，该起始值必须与前一子项的终止值相同，否则系统会抛出异常。
         */
        this.start = 0;

        /**
         * @member {boolean} [ThemeLabelItem.prototype.visible=true]
         * @description 标签专题图子项是否可见。如果标签专题图子项可见，则为 true，否则为 false。
         */
        this.visible = true;

        /**
         * @member {ServerTextStyle} ThemeLabelItem.prototype.style
         * @description 标签专题图子项文本的显示风格。各种风格的优先级从高到低为：<br>
         *              uniformMixedStyle（标签文本的复合风格），ThemeLabelItem.style（分段子项的文本风格），uniformStyle（统一文本风格）。
         */
        this.style = new ServerTextStyle();

        if (options) {
            Util_Util.extend(this, options);
        }
        this.CLASS_NAME = "SuperMap.ThemeLabelItem";

    }


    /**
     * @function ThemeLabelItem.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        var me = this;
        me.caption = null;
        me.end = null;
        me.start = null;
        if (me.style) {
            me.style.destroy();
            me.style = null;
        }
        me.visible = null;
    }

    /**
     * @function ThemeLabelItem.fromObj
     * @description 从传入对象获取分段标签专题图的子项类。
     * @param {Object} obj - 传入对象。
     * @returns {ThemeLabelItem} ThemeLabelItem 对象。
     */
    static fromObj(obj) {
        if (!obj) {
            return;
        }
        var t = new ThemeLabelItem();
        Util_Util.copy(t, obj);
        return t;
    }

}


;// CONCATENATED MODULE: ./src/common/iServer/ThemeUniqueItem.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/



/**
 * @class ThemeUniqueItem
 * @deprecatedclass SuperMap.ThemeUniqueItem
 * @category  iServer Map Theme
 * @classdesc 单值专题图子项类。单值专题图是将专题值相同的要素归为一类，为每一类设定一种渲染风格，其中每一类就是一个专题图子项。比如，利用单值专题图制作行政区划图，Name 字段代表省/直辖市名，该字段用来做专题变量，如果该字段的字段值总共有 5 种不同值，则该行政区划图有 5 个专题图子项。
 * @param {Object} options - 参数。
 * @param {string} options.unique - 子项的单值字段。
 * @param {string} [options.caption] - 子项的标题。
 * @param {ServerStyle} [options.style] - 子项的风格。
 * @param {boolean} [options.visible=true] - 子项是否可见。
 * @usage
 */
class ThemeUniqueItem {

    constructor(options) {
        /**
         * @member {string} [ThemeUniqueItem.prototype.caption]
         * @description 单值专题图子项的标题。
         */
        this.caption = null;

        /**
         * @member {ServerStyle} [ThemeUniqueItem.prototype.style]
         * @description 单值专题图子项的显示风格。
         */
        this.style = new ServerStyle();

        /**
         * @member {string} ThemeUniqueItem.prototype.unique
         * @description 单值专题图子项的值，可以为数字、字符串等。
         */
        this.unique = null;

        /**
         * @member {boolean} [ThemeUniqueItem.prototype.visible=true]
         * @description 单值专题图子项的可见性。
         */
        this.visible = true;

        if (options) {
            Util_Util.extend(this, options);
        }

        this.CLASS_NAME = "SuperMap.ThemeUniqueItem";
    }

    /**
     * @function ThemeUniqueItem.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        var me = this;
        me.caption = null;
        me.unique = null;

        if (me.style) {
            me.style.destroy();
            me.style = null;
        }
        me.visible = null;
    }

    /**
     * @function ThemeUniqueItem.prototype.toServerJSONObject
     * @description 转换成对应的 JSON 格式对象。
     * @returns {Object} 对应的 JSON 格式对象。
     */
    toServerJSONObject() {
        var obj = {};
        obj = Util_Util.copyAttributes(obj, this);
        if (obj.style) {
            if (obj.style.toServerJSONObject) {
                obj.style = obj.style.toServerJSONObject();
            }
        }
        return obj;
    }

    /**
     * @function ThemeUniqueItem.fromObj
     * @description 从传入对象获取单值专题图子项类。
     * @param {Object} obj - 传入对象。
     * @returns {ThemeUniqueItem} ThemeUniqueItem 对象。
     */
    static fromObj(obj) {
        var res = new ThemeUniqueItem();
        Util_Util.copy(res, obj);
        res.style = ServerStyle.fromJson(obj.style);
        return res;

    }

}



;// CONCATENATED MODULE: ./src/common/iServer/ThemeOffset.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


/**
 * @class ThemeOffset
 * @deprecatedclass SuperMap.ThemeOffset
 * @category  iServer Map Theme
 * @classdesc 专题图中文本或符号相对于要素内点的偏移量设置类。
 *            通过该类可以设置专题图中标记文本或符号的偏移量以及偏移量是否随地图缩放而改变。
 * @param {Object} options - 可选参数。
 * @param {boolean} [options.offsetFixed=false] - 当前专题图是否固定标记文本或符号的偏移量。
 * @param {string} [options.offsetX='0.0'] - 专题图中文本或符号相对于要素内点的水平偏移量。
 * @param {string} [options.offsetY='0.0'] - 专题图中文本或符号相对于要素内点的垂直偏移量。
 * @usage
 */
class ThemeOffset {

    constructor(options) {
        /**
         * @member {boolean} [ThemeOffset.prototype.offsetFixed=false]
         * @description 当前专题图是否固定标记文本或符号的偏移量。所谓固定偏移量，指文本或符号的偏移量不随地图的缩放而变化。
         */
        this.offsetFixed = false;

        /**
         * @member {string} [ThemeOffset.prototype.offsetX=0.0]
         * @description 专题图中文本或符号相对于要素内点的水平偏移量。偏移量的单位为地图单位。
         *              该偏移量的值为一个常量值或者字段表达式所表示的值，即如果字段表达式为 SmID，其中 SmID = 2，那么水平偏移量为2。
         */
        this.offsetX = "0.0";

        /**
         * @member {string} [ThemeOffset.prototype.offsetY=0.0]
         * @description 专题图中文本或符号相对于要素内点的垂直偏移量。偏移量的单位为地图单位。
         *              该偏移量的值为一个常量值或者字段表达式所表示的值，即如果字段表达式为 SmID，其中 SmID = 2，那么垂直偏移量为2。
         */
        this.offsetY = "0.0";

        if (options) {
            Util_Util.extend(this, options);
        }
        this.CLASS_NAME = "SuperMap.ThemeOffset";
    }

    /**
     * @function ThemeOffset.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        var me = this;
        me.offsetFixed = null;
        me.offsetX = null;
        me.offsetY = null;
    }

    /**
     * @function ThemeOffset.fromObj
     * @description 从传入对象获取专题图中文本或符号相对于要素内点的偏移量设置类。
     * @param {Object} obj - 传入对象。
     * @returns {ThemeOffset} ThemeOffset 对象。
     */
    static fromObj(obj) {
        if (!obj) {
            return;
        }
        var res = new ThemeOffset();
        Util_Util.copy(res, obj);
        return res;
    }

}


;// CONCATENATED MODULE: ./src/common/iServer/LabelMixedTextStyle.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/



/**
 * @class LabelMixedTextStyle
 * @deprecatedclass SuperMap.LabelMixedTextStyle
 * @category iServer Map Theme
 * @classdesc 标签文本复合风格类。
 * 该类主要用于对标签专题图中标签的文本内容进行风格设置。通过该类用户可以使标签的文字显示不同的风格，比如文本 “喜马拉雅山”，通过本类可以将前三个字用红色显示，后两个字用蓝色显示。对同一文本设置不同的风格实质上是对文本的字符进行分段，同一分段内的字符具有相同的显示风格。对字符分段有两种方式，一种是利用分隔符对文本进行分段；另一种是根据分段索引值进行分段：</br>
 *  1.利用分隔符对文本进行分段: 比如文本 “5&109” 被分隔符 “&” 分为 “5” 和 “109” 两部分，
 *     在显示时，“5” 和分隔符 “&” 使用同一个风格，字符串 “109” 使用相同的风格。<br>
 *  2.利用分段索引值进行分段: 文本中字符的索引值是以0开始的整数，比如文本 “珠穆朗玛峰”，
 *     第一个字符（“珠”）的索引值为 0，第二个字符（“穆”）的索引值为 1，以此类推；当设置分段索引值为 1，3，4，9 时，
 *     字符分段范围相应的就是 (-∞，1)，[1，3)，[3，4)，[4，9)，[9，+∞)，可以看出索引号为 0 的字符（即“珠” ）在第一个分段内，
 *     索引号为 1，2 的字符（即“穆”、“朗”）位于第二个分段内，索引号为 3 的字符（“玛”）在第三个分段内，索引号为 4 的字符（“峰”）在第四个分段内，其余分段中没有字符。
 * @param {Object} options - 可选参数。
 * @param {ServerTextStyle} [options.defaultStyle] - 默认的文本复合风格。
 * @param {string} [options.separator] - 文本的分隔符。
 * @param {boolean} [options.separatorEnabled=false] - 文本的分隔符是否有效。
 * @param {Array.<number>} [options.splitIndexes] - 分段索引值，分段索引值用来对文本中的字符进行分段。
 * @param {Array.<ServerTextStyle>} [options.styles] - 文本样式集合。
 * @usage
 */
class LabelMixedTextStyle {

    constructor(options) {
        /**
         * @member {ServerTextStyle} LabelMixedTextStyle.prototype.defaultStyle
         * @description 默认的文本复合风格，即 ServerTextStyle 各字段的默认值。
         */
        this.defaultStyle = null;

        /**
         * @member {string} LabelMixedTextStyle.prototype.separator
         * @description 文本的分隔符，分隔符的风格与前一个字符的风格一样。文本的分隔符是一个将文本分割开的符号，
         *              比如文本 “5_109” 被 “ _ ” 分隔为 “5” 和 “109” 两部分，假设有风格数组：style1、style2。
         *              在显示时，“5” 和分隔符 “ _ ” 使用 Style1 风格渲染，字符串 “109” 使用 Style2 的风格。
         */
        this.separator = null;

        /**
         * @member {boolean} [LabelMixedTextStyle.prototype.separatorEnabled=false]
         * @description 文本的分隔符是否有效。分隔符有效时利用分隔符对文本进行分段；无效时根据文本中字符的位置进行分段。
         *              分段后，同一分段内的字符具有相同的显示风格。
         */
        this.separatorEnabled = false;

        /**
         * @member {Array.<number>} LabelMixedTextStyle.prototype.splitIndexes
         * @description 分段索引值，分段索引值用来对文本中的字符进行分段。
         *              文本中字符的索引值是以 0 开始的整数，比如文本“珠穆朗玛峰”，第一个字符（“珠”）的索引值为0，第二个字符（“穆”）的索引值为 1，
         *              以此类推；当设置分段索引值数组为 [1，3，4，9] 时，字符分段范围相应的就是 (-∞，1)，[1，3)，[3，4)，[4，9)，[9，+∞)，
         *              可以看出索引号为 0 的字符（即 “珠”）在第一个分段内，索引号为 1，2 的字符（即 “穆”、“朗”）位于第二个分段内，
         *              索引号为 3 的字符（“玛”）在第三个分段内，索引号为 4 的字符（“峰”）在第四个分段内，其余分段中没有字符。
         */
        this.splitIndexes = null;

        /**
         * @member {Array.<ServerTextStyle>} LabelMixedTextStyle.prototype.styles
         * @description 文本样式集合。文本样式集合中的样式根据索引与不同分段一一对应，
         *              如果有分段没有风格对应则使用 defaultStyle。
         */
        this.styles = new ServerTextStyle();

        if (options) {
            Util_Util.extend(this, options);
        }
        this.CLASS_NAME = "SuperMap.LabelMixedTextStyle"
    }

    /**
     * @function LabelMixedTextStyle.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        var me = this;
        if (me.defaultStyle) {
            me.defaultStyle.destroy();
            me.defaultStyle = null;
        }
        me.separator = null;
        me.separatorEnabled = null;
        if (me.splitIndexes) {
            me.splitIndexes = null;
        }
        if (me.styles) {
            for (var i = 0, styles = me.styles, len = styles.length; i < len; i++) {
                styles[i].destroy();
            }
            me.styles = null;
        }
    }

    /**
     * @function LabelMixedTextStyle.fromObj
     * @description 从传入对象获取标签文本复合风格类。
     * @param {Object} obj - 传入对象。
     * @returns {LabelMixedTextStyle} 返回新的 LabelMixedTextStyle 对象。
     */
    static fromObj(obj) {
        if (!obj) {
            return;
        }
        var res = new LabelMixedTextStyle();
        var stys = obj.styles;
        Util_Util.copy(res, obj);
        res.defaultStyle = new ServerTextStyle(obj.defaultStyle);
        if (stys) {
            res.styles = [];
            for (var i = 0, len = stys.length; i < len; i++) {
                res.styles.push(new ServerTextStyle(stys[i]));
            }
        }
        return res;
    }

}



;// CONCATENATED MODULE: ./src/common/iServer/ThemeLabelText.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/




/**
 * @class ThemeLabelText
 * @deprecatedclass SuperMap.ThemeLabelText
 * @category  iServer Map Theme
 * @classdesc 标签中文本风格类。
 *            通过该类可以设置标签中的文本字体大小和显示风格。
 * @param {Object} options - 参数。
 * @param {number} [options.maxTextHeight=0] - 标签中文本的最大高度。
 * @param {number} [options.maxTextWidth=0] - 标签中文本的最大宽度。
 * @param {number} [options.minTextHeight=0] - 标签中文本的最小高度。
 * @param {number} [options.minTextWidth=0] - 标签中文本的最小宽度。
 * @param {ServerTextStyle} [options.uniformStyle] - 统一文本风格。
 * @param {LabelMixedTextStyle} [options.uniformMixedStyle] - 标签专题图统一的文本复合风格。
 * @usage
 */
class ThemeLabelText {

    constructor(options) {
        /**
         * @member {number} [ThemeLabelText.prototype.maxTextHeight=0]
         * @description 标签中文本的最大高度。当标签文本不固定大小时，即 ServerTextStyle.sizeFixed = false 有效，
         *              当放大后的文本高度超过最大高度之后就不再放大。高度单位为毫米。
         */
        this.maxTextHeight = 0;

        /**
         * @member {number} [ThemeLabelText.prototype.maxTextWidth=0]
         * @description 标签中文本的最大宽度。当标签文本不固定大小时，即 ServerTextStyle.sizeFixed = false 有效，
         *              当放大后的文本宽度超过最大高度之后就不再放大。宽度单位为毫米。
         */
        this.maxTextWidth = 0;

        /**
         * @member {number} [ThemeLabelText.prototype.minTextHeight=0]
         * @description 标签中文本的最小高度。当标签文本不固定大小时，即 ServerTextStyle.sizeFixed = false 有效，
         *              当缩小后的文本高度小于最小高度之后就不再缩小。高度单位为毫米。
         */
        this.minTextHeight = 0;

        /**
         * @member {number} [ThemeLabelText.prototype.minTextWidth=0]
         * @description 标签中文本的最小宽度。当标签文本不固定大小时，即 ServerTextStyle.sizeFixed = false 有效，
         *              当缩小后的文本宽度小于最小宽度之后就不再缩小。宽度单位为毫米。
         */
        this.minTextWidth = 0;

        /**
         * @member {ServerTextStyle} [ThemeLabelText.prototype.uniformStyle]
         * @description 统一文本风格。当标签专题图子项的个数大于等于1时，
         *              uniformStyle 不起作用，各标签的风格使用子项中设置的风格。各种风格的优先级从高到低为：uniformMixedStyle（标签文本的复合风格），
         *              ThemeLabelItem.style（分段子项的文本风格），uniformStyle（统一文本风格）。
         */
        this.uniformStyle = new ServerTextStyle();

        /**
         *@member {LabelMixedTextStyle} [ThemeLabelText.prototype.uniformMixedStyle]
         *@description  标签专题图统一的文本复合风格。通过该类可以使同一个标签中的文字使用多种风格显示。各种风格的优先级从高到低为：uniformMixedStyle（标签文本的复合风格），
         *              ThemeLabelItem.style（分段子项的文本风格），uniformStyle（统一文本风格）。
         */
        this.uniformMixedStyle =  null;

        if (options) {
            Util_Util.extend(this, options);
        }
        this.CLASS_NAME = "SuperMap.ThemeLabelText";
    }

    /**
     * @function ThemeLabelText.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        var me = this;
        me.maxTextHeight = null;
        me.maxTextWidth = null;
        me.minTextHeight = null;
        me.minTextWidth = null;
        if (me.uniformStyle) {
            me.uniformStyle.destroy();
            me.uniformStyle = null;
        }
        if (me.uniformMixedStyle) {
            me.uniformMixedStyle.destroy();
            me.uniformMixedStyle = null;
        }
    }

    /**
     * @function ThemeLabelText.fromObj
     * @description 从传入对象获取标签中文本风格类。
     * @param {Object} obj - 传入对象。
     * @returns {ThemeLabelText} ThemeLabelText 对象。
     */
    static fromObj(obj) {
        if (!obj) {
            return;
        }
        var res = new ThemeLabelText();
        Util_Util.copy(res, obj);
        res.uniformStyle = ServerTextStyle.fromObj(obj.uniformStyle);
        res.uniformMixedStyle = LabelMixedTextStyle.fromObj(obj.uniformMixedStyle);
        return res;
    }
}


;// CONCATENATED MODULE: ./src/common/iServer/ThemeLabelAlongLine.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/



/**
 * @class ThemeLabelAlongLine
 * @deprecatedclass SuperMap.ThemeLabelAlongLine
 * @category  iServer Map Theme
 * @classdesc 标签沿线标注样式类。
 * @param {Object} options - 可选参数。
 * @param {boolean} [options.isAlongLine=true] - 是否沿线显示文本。
 * @param {AlongLineDirection} [options.alongLineDirection=AlongLineDirection.LB_TO_RT] - 标签沿线标注方向。
 * @param {boolean} [options.angleFixed=false] - 当沿线显示文本时，是否将文本角度固定。
 * @param {boolean} [options.repeatedLabelAvoided=false] - 沿线循环标注时是否避免标签重复标注。
 * @param {boolean} [options.repeatIntervalFixed=false] - 循环标注间隔是否固定。
 * @param {number} [options.labelRepeatInterval=0] - 沿线且循环标注时循环标注的间隔。
 * @usage
 */
class ThemeLabelAlongLine {


    constructor(options) {
        /**
         * @member {boolean} [ThemeLabelAlongLine.prototype.isAlongLine=true]
         * @description 是否沿线显示文本。true 表示沿线显示文本，false 表示正常显示文本。
         */
        this.isAlongLine = true;

        /**
         * @member {AlongLineDirection} [ThemeLabelAlongLine.prototype.alongLineDirection=AlongLineDirection.LB_TO_RT]
         * @description 标签沿线标注方向。
         */
        this.alongLineDirection = AlongLineDirection.LB_TO_RT;

        /**
         * @member {boolean} [ThemeLabelAlongLine.prototype.angleFixed=false]
         * @description 当沿线显示文本时，是否将文本角度固定。true 表示按固定文本角度显示文本，false 表示按照沿线角度显示文本。
         *              如果固定角度，则所有标签均按所设置的文本风格中字体的旋转角度来显示，不考虑沿线标注的方向；
         *              如果不固定角度，在显示标签时会同时考虑字体的旋转角度和沿线标注的方向。
         */
        this.angleFixed = false;

        /**
         * @member {boolean} ThemeLabelAlongLine.prototype.repeatedLabelAvoided
         * @description 沿线循环标注时是否避免标签重复标注。
         */
        this.repeatedLabelAvoided = false;

        /**
         * @member {boolean} [ThemeLabelAlongLine.prototype.repeatIntervalFixed=false]
         * @description 循环标注间隔是否固定。true 表示使用固定循环标注间隔，即使用逻辑坐标来显示循环标注间隔；
         *              false 表示循环标注间隔随地图的缩放而变化，即使用地理坐标来显示循环标注间隔。
         */
        this.repeatIntervalFixed = false;

        /**
         * @member {number} [ThemeLabelAlongLine.prototype.labelRepeatInterval=0]
         * @description 沿线且循环标注时循环标注的间隔。长度的单位与地图的地理单位一致。只有设定 RepeatedLabelAvoided 为 true
         *              的时候，labelRepeatInterval 属性才有效。
         */
        this.labelRepeatInterval = 0;

        if (options) {
            Util_Util.extend(this, options);
        }

        this.CLASS_NAME = "SuperMap.ThemeLabelAlongLine";
    }


    /**
     * @function ThemeLabelAlongLine.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        var me = this;
        me.isAlongLine = null;
        me.alongLineDirection = null;
        me.angleFixed = null;
        me.repeatedLabelAvoided = null;
        me.repeatIntervalFixed = null;
        me.labelRepeatInterval = null;
    }

    /**
     * @function ThemeLabelAlongLine.fromObj
     * @description 从传入对象获取标签沿线标注样式类。
     * @param {Object} obj - 传入对象。
     * @returns {ThemeLabelAlongLine} ThemeLabelAlongLine 对象。
     */
    static fromObj(obj) {
        if (!obj) {
            return;
        }
        var t = new ThemeLabelAlongLine();
        Util_Util.copy(t, obj);
        return t;
    }

}


;// CONCATENATED MODULE: ./src/common/iServer/ThemeLabelBackground.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/




/**
 * @class ThemeLabelBackground
 * @deprecatedclass SuperMap.ThemeLabelBackground
 * @category  iServer Map Theme
 * @classdesc 标签背景风格类。通过该类可以设置标签的背景形状和风格。
 * @param {Object} options - 可选参数。
 * @param {LabelBackShape} [options.labelBackShape=LabelBackShape.NONE] - 标签专题图中标签背景的形状枚举类。
 * @param {ServerStyle} [options.backStyle] - 标签专题图中标签背景风格。
 * @usage
 */
class ThemeLabelBackground {

    constructor(options) {
        /**
         * @member {LabelBackShape} [ThemeLabelBackground.prototype.labelBackShape=LabelBackShape.NONE]
         * @description 标签专题图中标签背景风格。当背景形状
         *              labelBackShape 属性设为 NONE（即无背景形状）时，backStyle 属性无效。
         */
        this.labelBackShape = LabelBackShape.NONE;

        /**
         * @member {ServerStyle} [ThemeLabelBackground.prototype.backStyle]
         * @description 标签专题图中标签背景的形状枚举类。背景类型可以是矩形、圆角矩形、菱形、椭圆形、三角形和符号等，即不使用任何的形状作为标签的背景。
         */
        this.backStyle = new ServerStyle();

        if (options) {
            Util_Util.extend(this, options);
        }

        this.CLASS_NAME = "SuperMap.ThemeLabelBackground";
    }

    /**
     * @function ThemeLabelBackground.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        var me = this;
        me.labelBackShape = null;
        if (me.backStyle) {
            me.backStyle.destroy();
            me.backStyle = null;
        }
    }

    /**
     * @function ThemeLabelBackground.fromObj
     * @description 从传入对象获取标签背景风格类。
     * @param {Object} obj - 传入对象。
     * @returns {ThemeLabelBackground} ThemeLabelBackground 对象。
     */
    static fromObj(obj) {
        if (!obj) {
            return;
        }
        var t = new ThemeLabelBackground();
        t.labelBackShape = obj.labelBackShape;
        t.backStyle = ServerStyle.fromJson(obj.backStyle);

        return t;
    }

}


;// CONCATENATED MODULE: ./src/common/iServer/ThemeLabel.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/










/**
 * @class ThemeLabel
 * @deprecatedclass SuperMap.ThemeLabel
 * @category  iServer Map Theme
 * @classdesc 标签专题图类。
 * @extends CommonTheme
 * @param {Object} options - 参数。
 * @param {Array.<ThemeLabelItem>} options.items - 子项数组。
 * @param {string} options.labelExpression - 标注字段表达式。
 * @param {Array.<LabelImageCell|LabelSymbolCell|LabelThemeCell>} options.matrixCells - 矩阵标签元素数组。
 * @param {ThemeLabelAlongLine} [options.alongLine] - 标签沿线标注方向样式类。
 * @param {ThemeLabelBackground} [options.background] - 标签的背景风格类。
 * @param {LabelOverLengthMode} [options.labelOverLengthMode=LabelOverLengthMode.NONE] - 超长标签的处理模式枚举类。
 * @param {number} [options.maxLabelLength=256] - 标签在每一行显示的最大长度。
 * @param {number} [options.numericPrecision=0] - 通过该字段设置其显示的精度。
 * @param {ThemeOffset} [options.offset] - 指定标签专题图中标记文本相对于要素内点的偏移量对象。
 * @param {boolean} [options.overlapAvoided=true] - 是否允许以文本避让方式显示文本。
 * @param {string} [options.rangeExpression] - 制作分段标签专题的分段字段或字段表达式。
 * @param {boolean} [options.smallGeometryLabeled=false] - 是否显示长度大于被标注对象本身长度的标签。
 * @param {ThemeLabelText} options.text - 标签中文本风格。
 * @param {number} [options.textSpace=0] - 沿线标注，相邻两个文字之间的间距，单位当前设置的字高。
 * @param {ThemeMemoryData} [options.memoryData] - 专题图内存数据。
 * @usage
 */
class ThemeLabel extends Theme_Theme {


    constructor(options) {
        super("LABEL", options);
        /**
         * @member {ThemeLabelAlongLine} [ThemeLabel.prototype.alongLine]
         * @description 标签沿线标注方向样式类。
         *              在该类中可以设置标签是否沿线标注以及沿线标注的多种方式。沿线标注属性只适用于线数据集专题图。
         */
        this.alongLine = new ThemeLabelAlongLine();

        /**
         * @member {ThemeLabelBackground} [ThemeLabel.prototype.background]
         * @description 标签专题图中标签的背景风格类。通过该字段可以设置标签的背景形状和风格。
         */
        this.background = new ThemeLabelBackground();

        /**
         * @member {Array.<ThemeLabelItem>} [ThemeLabel.prototype.items]
         * @description 分段标签专题图的子项数组。分段标签专题图使用 rangeExpression
         *              指定数字型的字段作为分段数据，items 中的每个子对象的 [start，end) 分段值必须来源于属性 rangeExpression 的字段值。每个子项拥有自己的风格。
         */
        this.items = null;

        /**
         * @member {Array.<ThemeLabelUniqueItem>} ThemeLabel.prototype.uniqueItems
         * @description 单值标签专题图子项数组。单值标签专题图使用 uniqueExpression单值标签专题图子项集合。
         */
        this.uniqueItems = null;

        /**
         * @member {string} ThemeLabel.prototype.labelExpression
         * @description 标注字段表达式。系统将 labelExpression 对应的字段或字段表达式的值以标签的形式显示在图层中。
         */
        this.labelExpression = null;

        /**
         * @member {LabelOverLengthMode} [ThemeLabel.prototype.labelOverLengthMode=LabelOverLengthMode.NONE] - 标签专题图中超长标签的处理模式枚举类。
         * @description 对于标签的长度超过设置的标签最大长度 maxLabelLength 时称为超长标签。
         */
        this.labelOverLengthMode = LabelOverLengthMode.NONE;

        /**
         * @member {Array.<LabelImageCell|LabelSymbolCell|LabelThemeCell>} ThemeLabel.prototype.matrixCells
         * @description 矩阵标签元素数组，用于制作矩阵标签专题图。
         *              数组中可以放置符号类型的矩阵标签元素和图片类型的矩阵标签元素。
         */
        this.matrixCells = null;

        /**
         * @member {number} [ThemeLabel.prototype.maxLabelLength=256]
         * @description 标签在每一行显示的最大长度，一个中文为两个字符。
         *              如果超过最大长度，可以采用两种方式来处理，一种是换行的模式进行显示，另一种是以省略号方式显示。单位为字符。
         */
        this.maxLabelLength = 256;

        /**
         * @member {number} [ThemeLabel.prototype.numericPrecision=0]
         * @description 如果显示的标签内容为数字，通过该字段设置其显示的精度。例如标签对应的数字是8071.64529347，
         *              如果该属性为0时，显示8071；为1时，显示8071.6；为3时，则是8071.645。
         */
        this.numericPrecision = 0;

        /**
         * @member {ThemeOffset} [ThemeLabel.prototype.offset]
         * @description 用于设置标签专题图中标记文本相对于要素内点的偏移量对象。
         */
        this.offset = new ThemeOffset();

        /**
         * @member {boolean} [ThemeLabel.prototype.overlapAvoided=true]
         * @description 是否允许以文本避让方式显示文本。true 表示自动避免文本叠盖。只针对该标签专题图层中的文本数据。
         *              在标签重叠度很大的情况下，即使使用自动避让功能，可能也无法完全避免标签重叠现象。
         */
        this.overlapAvoided = true;

        /**
         * @member {string} ThemeLabel.prototype.rangeExpression
         * @description 制作分段标签专题的分段字段或字段表达式。该表达式对应的字段（或者字段表达式）的值应该为数值型。
         *              该字段与 items 分段子项联合使用，每个子项的起始值 [start，end)来源于 rangeExpression 字段值。
         *              最后 labelExpression 指定的标签字段（标签专题图要显示的具体内容）会根据分段子项的风格进行分段显示。
         */
        this.rangeExpression = null;

        /**
         * @member {string} ThemeLabel.prototype.uniqueExpression
         * @description 用于制作单值专题图的字段或字段表达式。
         *              该字段值的数据类型可以为数值型或字符型。如果设置字段表达式，只能是相同数据类型字段间的运算。必须与labelExpression一起使用。
         */
        this.uniqueExpression = null;

        /**
         * @member {boolean} [ThemeLabel.prototype.smallGeometryLabeled=false]
         * @description 是否显示长度大于被标注对象本身长度的标签。在标签的长度大于线或者面对象本身的长度时，
         *              如果该值为 true，则标签文字会叠加在一起显示，为了清楚完整的显示该标签，
         *              可以采用换行模式来显示标签，但必须保证每行的长度小于对象本身的长度。
         */
        this.smallGeometryLabeled = false;

        /**
         * @member {ThemeLabelText} ThemeLabel.prototype.text
         * @description 标签中文本风格。
         */
        this.text = new ThemeLabelText();

        /**
         * @member {number} [ThemeLabel.prototype.textSpace=0]
         * @description 沿线标注，相邻两个文字之间的间距，单位当前设置的字高。
         */
        this.textSpace = 0;

        if (options) {
            Util_Util.extend(this, options);
        }

        this.CLASS_NAME = "SuperMap.ThemeLabel";
    }


    /**
     * @function ThemeLabel.prototype.destroy
     * @override
     */
    destroy() {
        super.destroy();
        var me = this;
        me.alongLine = null;
        if (me.background) {
            me.background.destroy();
            me.background = null;
        }
        if (me.items) {
            for (var i = 0, items = me.items, len = items.length; i < len; i++) {
                items[i].destroy();
            }
            me.items = null;
        }
        if (me.uniqueItems) {
            for (var j = 0, uniqueItems = me.uniqueItems, uniqueLen = uniqueItems.length; j < uniqueLen; j++) {
                uniqueItems[j].destory();
            }
            me.uniqueItems = null;
        }
        me.labelExpression = null;
        me.labelOverLengthMode = null;
        me.matrixCells = null;
        me.maxLabelLength = null;
        me.numericPrecision = null;
        me.overlapAvoided = null;
        me.rangeExpression = null;
        me.uniqueExpression = null;
        if (me.offset) {
            me.offset.destroy();
            me.offset = null;
        }
        me.overlapAvoided = null;
        me.smallGeometryLabeled = null;
        if (me.text) {
            me.text.destroy();
            me.text = null;
        }
        me.textSpace = null;
    }

    /**
     * @function ThemeLabel.prototype.toJSON
     * @description 将themeLabel对象转化为 JSON 字符串。
     * @returns {string} 返回转换后的 JSON 字符串。
     */
    toJSON() {
        return Util_Util.toJSON(this.toServerJSONObject());
    }

    /**
     * @function ThemeLabel.prototype.toServerJSONObject
     * @description 转换成对应的 JSON 格式对象。
     * @returns {Object} 对应的 JSON 格式对象。
     */
    toServerJSONObject() {
        var obj = {};
        obj.type = this.type;
        obj.memoryData = this.memoryData;
        if (this.alongLine) {
            obj.alongLine = this.alongLine.isAlongLine;
            obj.alongLineDirection = this.alongLine.alongLineDirection;
            obj.angleFixed = this.alongLine.angleFixed;
            obj.isLabelRepeated = this.alongLine.isLabelRepeated;
            obj.labelRepeatInterval = this.alongLine.labelRepeatInterval;
            obj.repeatedLabelAvoided = this.alongLine.repeatedLabelAvoided;
            obj.repeatIntervalFixed = this.alongLine.repeatIntervalFixed;
        }
        if (this.offset) {
            obj.offsetFixed = this.offset.offsetFixed;
            obj.offsetX = this.offset.offsetX;
            obj.offsetY = this.offset.offsetY;
        }
        if (this.text) {
            obj.maxTextHeight = this.text.maxTextHeight;
            obj.maxTextWidth = this.text.maxTextWidth;
            obj.minTextHeight = this.text.minTextHeight;
            obj.minTextWidth = this.text.minTextWidth;
            obj.uniformStyle = this.text.uniformStyle;
            obj.uniformMixedStyle = this.text.uniformMixedStyle;
        }
        if (this.background) {
            obj.labelBackShape = this.background.labelBackShape;
            obj.backStyle = this.background.backStyle;
        }
        obj.labelOverLengthMode = this.labelOverLengthMode;
        obj.maxLabelLength = this.maxLabelLength;
        obj.smallGeometryLabeled = this.smallGeometryLabeled;
        obj.rangeExpression = this.rangeExpression;
        obj.uniqueExpression = this.uniqueExpression;
        obj.numericPrecision = this.numericPrecision;
        obj.items = this.items;
        obj.uniqueItems = this.uniqueItems;
        obj.labelExpression = this.labelExpression;
        obj.overlapAvoided = this.overlapAvoided;
        obj.matrixCells = this.matrixCells;
        obj.textSpace = this.textSpace;
        return obj;
    }

    /**
     * @function ThemeLabel.fromObj
     * @description 从传入对象获取标签专题图类。
     * @param {Object} obj - 传入对象。
     * @returns {ThemeLabel} ThemeLabel 对象。
     */
    static fromObj(obj) {
        if (!obj) {
            return;
        }
        var lab = new ThemeLabel();
        var itemsL = obj.items, itemsU = obj.uniqueItems, cells = obj.matrixCells;
        obj.matrixCells = null;
        Util_Util.copy(lab, obj);
        lab.alongLine = ThemeLabelAlongLine.fromObj(obj);
        lab.background = ThemeLabelBackground.fromObj(obj);
        if (itemsL) {
            lab.items = [];
            for (var i = 0, len = itemsL.length; i < len; i++) {
                lab.items.push(ThemeLabelItem.fromObj(itemsL[i]));
            }
        }
        if (itemsU) {
            lab.uniqueItems = [];
            for (let j = 0, uniqueLen = itemsU.length; j < uniqueLen; j++) {
                lab.uniqueItems.push(ThemeUniqueItem.fromObj(itemsU[j]));
            }
        }
        if (cells) {
            lab.matrixCells = [];
            for (let i = 0, len = cells.length; i < len; i++) {
                //TODO
                //lab.matrixCells.push(LabelMatrixCell.fromObj(cells[i]));
            }
        }
        lab.offset = ThemeOffset.fromObj(obj);
        lab.text = ThemeLabelText.fromObj(obj);
        return lab;
    }

}


;// CONCATENATED MODULE: ./src/common/iServer/ThemeUnique.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/







/**
 * @class ThemeUnique
 * @deprecatedclass SuperMap.ThemeUnique
 * @category  iServer Map Theme
 * @classdesc 单值专题图。单值专题图是利用不同的颜色或符号（线型、填充）表示图层中某一属性信息的不同属性值，属性值相同的要素具有相同的渲染风格。单值专题图多用于具有分类属性的地图上，
 * 比如土壤类型分布图、土地利用图、行政区划图等。单值专题图着重表示现象质的差别，一般不表示数量的特征。尤其是有交叉或重叠现象时，此类不推荐使用，例如：民族分布区等。
 * @extends {CommonTheme}
 * @param {Object} options - 参数。
 * @param {Array.<ThemeUniqueItem>} options.items - 子项类数组。
 * @param {string} options.uniqueExpression - 指定单值专题图的字段或字段表达式。
 * @param {ServerStyle} [options.defaultStyle] - 未参与单值专题图制作的对象的显示风格。
 * @param {ColorGradientType} [options.colorGradientType=ColorGradientType.YELLOW_RED] - 渐变颜色枚举类。
 * @param {ThemeMemoryData} [options.memoryData] - 专题图内存数据。
 * @usage
 */
class ThemeUnique extends Theme_Theme {

    constructor(options) {
        super("UNIQUE", options);
        /**
         * @member {ServerStyle} ThemeUnique.prototype.defaultStyle
         * @description 未参与单值专题图制作的对象的显示风格。
         *              通过单值专题图子项数组 （items）可以指定某些要素参与单值专题图制作，对于那些没有被包含的要素，即不参加单值专题表达的要素，使用该风格显示。
         */
        this.defaultStyle = new ServerStyle();

        /**
         * @member {Array.<ThemeUniqueItem>} ThemeUnique.prototype.items
         * @description 单值专题图子项类数组。
         *              单值专题图是将专题值相同的要素归为一类，为每一类设定一种渲染风格，其中每一类就是一个专题图子项。比如，利用单值专题图制作行政区划图，
         *              Name 字段代表省/直辖市名，该字段用来做专题变量，如果该字段的字段值总共有5种不同值，则该行政区划图有 5 个专题图子项。
         */
        this.items = null;

        /**
         * @member {string} ThemeUnique.prototype.uniqueExpression
         * @description 用于制作单值专题图的字段或字段表达式。
         *              该字段值的数据类型可以为数值型或字符型。如果设置字段表达式，只能是相同数据类型字段间的运算。
         */
        this.uniqueExpression = null;

        /**
         * @member {ColorGradientType} [ThemeUnique.prototype.colorGradientType=ColorGradientType.YELLOW_RED]
         * @description 渐变颜色枚举类。
         *              渐变色是由起始色根据一定算法逐渐过渡到终止色的一种混合型颜色。
         *              该类作为单值专题图参数类、分段专题图参数类的属性，负责设置单值专题图、分段专题图的配色方案，在默认情况下专题图所有子项会根据这个配色方案完成填充。
         *              但如果为某几个子项的风格进行单独设置后（设置了 ThemeUniqueItem 或 ThemeRangeItem 类中Style属性），
         *              该配色方案对于这几个子项将不起作用。
         */
        this.colorGradientType = ColorGradientType.YELLOW_RED;

        if (options) {
            Util_Util.extend(this, options);
        }

        this.CLASS_NAME = "SuperMap.ThemeUnique";
    }

    /**
     * @function ThemeUnique.prototype.destroy
     * @override
     */
    destroy() {
        super.destroy();
        var me = this;
        me.uniqueExpression = null;
        me.colorGradientType = null;
        if (me.items) {
            if (me.items.length > 0) {
                for (var item in me.items) {
                    me.items[item].destroy();
                    me.items[item] = null;
                }
            }
            me.items = null;
        }

        if (me.defaultStyle) {
            me.defaultStyle.destroy();
            me.defaultStyle = null;
        }
    }


    /**
     * @function ThemeUnique.prototype.toServerJSONObject
     * @description 转换成对应的 JSON 格式对象。
     * @returns {Object} 对应的 JSON 格式对象。
     */
    toServerJSONObject() {
        var obj = {};
        obj = Util_Util.copyAttributes(obj, this);
        if (obj.defaultStyle) {
            if (obj.defaultStyle.toServerJSONObject) {
                obj.defaultStyle = obj.defaultStyle.toServerJSONObject();
            }
        }
        if (obj.items) {
            var items = [],
                len = obj.items.length;
            for (var i = 0; i < len; i++) {
                items.push(obj.items[i].toServerJSONObject());
            }
            obj.items = items;
        }
        return obj;
    }

    /**
     * @function ThemeUnique.fromObj
     * @description 从传入对象获取单值专题图类。
     * @param {Object} obj - 传入对象。
     * @returns {ThemeUnique} ThemeUnique 对象。
     */
    static fromObj(obj) {
        var res = new ThemeUnique();
        var uItems = obj.items;
        var len = uItems ? uItems.length : 0;
        Util_Util.extend(res, obj);
        res.items = [];
        res.defaultStyle = ServerStyle.fromJson(obj.defaultStyle);
        for (var i = 0; i < len; i++) {
            res.items.push(ThemeUniqueItem.fromObj(uItems[i]));
        }
        return res;
    }

}


;// CONCATENATED MODULE: ./src/common/iServer/ThemeGraphAxes.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/




/**
 * @class ThemeGraphAxes
 * @deprecatedclass SuperMap.ThemeGraphAxes
 * @category  iServer Map Theme
 * @classdesc 统计专题图坐标轴样式类。
 * @param {Object} options - 参数。
 * @param {ServerColor} [options.axesColor=(0, 0, 0)] - 坐标轴颜色。
 * @param {boolean} [options.axesDisplayed=false] - 是否显示坐标轴。
 * @param {boolean} [options.axesGridDisplayed=false] - 是否在统计图坐标轴上显示网格。
 * @param {boolean} [options.axesTextDisplayed=false] - 是否显示坐标轴的文本标注。
 * @param {ServerTextStyle} [options.axesTextStyle] - 统计符号的最大最小尺寸。
 * @usage
 */
class ThemeGraphAxes {

    constructor(options) {

        /**
         * @member {ServerColor} [ThemeGraphAxes.prototype.axesColor=(0, 0, 0)]
         * @description 坐标轴颜色。当 axesDisplayed = true 时有效。
         */
        this.axesColor =  new ServerColor(0, 0, 0);

        /**
         * @member {boolean} [ThemeGraphAxes.prototype.axesDisplayed=false]
         * @description 是否显示坐标轴。<br>
         *              由于饼状图和环状图无坐标轴，故该属性以及所有与坐标轴设置相关的属性都不适用于它们。并且只有当该值为 true 时，其它设置坐标轴的属性才起作用。
         */
        this.axesDisplayed = false;

        /**
         * @member {boolean} [ThemeGraphAxes.prototype.axesGridDisplayed=false]
         * @description 是否在统计图坐标轴上显示网格。
         */
        this.axesGridDisplayed = false;

        /**
         * @member {boolean} [ThemeGraphAxes.prototype.axesTextDisplayed=false]
         * @description 是否显示坐标轴的文本标注。
         */
        this.axesTextDisplayed = false;

        /**
         * @member {ServerTextStyle} ThemeGraphAxes.prototype.axesTextStyle
         * @description 坐标轴文本风格。当 axesTextDisplayed = true 时有效。
         */
        this.axesTextStyle =  new ServerTextStyle();

        if (options) {
            Util_Util.extend(this, options);
        }

        this.CLASS_NAME = "SuperMap.ThemeGraphAxes";
    }

    /**
     * @function ThemeGraphAxes.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        var me = this;
        if (me.axesColor) {
            me.axesColor.destroy();
            me.axesColor = null;
        }
        me.axesDisplayed = null;
        me.axesGridDisplayed = null;
        me.axesTextDisplayed = null;
        if (me.axesTextStyle) {
            me.axesTextStyle.destroy();
            me.axesTextStyle = null;
        }
    }

    /**
     * @function ThemeGraphAxes.fromObj
     * @description 从传入对象获取统计专题图坐标轴样式类。
     * @param {Object} obj - 传入对象。
     * @returns {ThemeGraphAxes} ThemeGraphAxes 对象。
     */
    static fromObj(obj) {
        if (!obj) {
            return;
        }
        var res = new ThemeGraphAxes();
        Util_Util.copy(res, obj);
        res.axesColor = ServerColor.fromJson(obj.axesColor);
        res.axesTextStyle = ServerTextStyle.fromObj(obj.axesTextStyle);
        return res;
    }

}


;// CONCATENATED MODULE: ./src/common/iServer/ThemeGraphSize.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


/**
 * @class ThemeGraphSize
 * @deprecatedclass SuperMap.ThemeGraphSize
 * @category  iServer Map Theme
 * @classdesc 统计专题图符号尺寸类。
 * @param {Object} options - 参数。
 * @param {number} [options.maxGraphSize=0] - 统计图中显示的最大图表尺寸基准值。
 * @param {number} [options.minGraphSize=0] - 统计图中显示的最小图表尺寸基准值。
 * @usage
 */
class ThemeGraphSize {

    constructor(options) {
        /**
         * @member {number} [ThemeGraphSize.prototype.maxGraphSize=0]
         * @description 获取或设置统计图中显示的最大图表尺寸基准值，单位为像素。
         */
        this.maxGraphSize = 0;

        /**
         * @member {number} [ThemeGraphSize.prototype.minGraphSize=0]
         * @description 获取或设置统计图中显示的最小图表尺寸基准值，单位为像素。
         */
        this.minGraphSize = 0;

        if (options) {
            Util_Util.extend(this, options);
        }

       this.CLASS_NAME = "SuperMap.ThemeGraphSize";
    }

    /**
     * @function ThemeGraphSize.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        var me = this;
        me.maxGraphSize = null;
        me.minGraphSize = null;
    }

    /**
     * @function ThemeGraphSize.fromObj
     * @description 从传入对象获统计专题图符号尺寸类。
     * @param {Object} obj - 传入对象。
     * @returns {ThemeGraphSize}  ThemeGraphSize 对象。
     */
    static fromObj(obj) {
        var res = new ThemeGraphSize();
        Util_Util.copy(res, obj);
        return res;
    }

}


;// CONCATENATED MODULE: ./src/common/iServer/ThemeGraphText.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/




/**
 * @class ThemeGraphText
 * @deprecatedclass SuperMap.ThemeGraphText
 * @category  iServer Map Theme
 * @classdesc 统计图文字标注风格类。
 * @param {Object} options - 可选参数。
 * @param {boolean} [options.graphTextDisplayed=false] - 是否显示统计图上的文字标注。
 * @param {ThemeGraphTextFormat} [options.graphTextFormat=ThemeGraphTextFormat.CAPTION] - 统计专题图文本显示格式。
 * @param {ServerTextStyle} [options.graphTextStyle] - 统计图上的文字标注风格。
 * @usage
 */
class ThemeGraphText {

    constructor(options) {

        /**
         * @member {boolean} [ThemeGraphText.prototype.graphTextDisplayed=false]
         * @description 是否显示统计图上的文字标注。
         */
        this.graphTextDisplayed = false;

        /**
         * @member {ThemeGraphTextFormat} [ThemeGraphText.prototype.graphTextFormat=ThemeGraphTextFormat.CAPTION]
         * @description 统计专题图文本显示格式。
         *              文本显示格式包括百分数、真实数值、标题、标题+百分数、标题+真实数值。
         */
        this.graphTextFormat = ThemeGraphTextFormat.CAPTION;

        /**
         * @member {ServerTextStyle} ThemeGraphText.prototype.graphTextStyle
         * @description 统计图上的文字标注风格。
         */
        this.graphTextStyle =  new ServerTextStyle();

        if (options) {
            Util_Util.extend(this, options);
        }

        this.CLASS_NAME = "SuperMap.ThemeGraphText";
    }

    /**
     * @function ThemeGraphText.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        var me = this;
        me.graphTextDisplayed = null;
        me.graphTextFormat = null;
        if (me.graphTextStyle) {
            me.graphTextStyle.destroy();
            me.graphTextStyle = null;
        }
    }

    /**
     * @function ThemeGraphText.fromObj
     * @description 从传入对象获取统计图文字标注风格类。
     * @param {Object} obj - 传入对象。
     * @returns {ThemeGraphText} ThemeGraphText 对象。
     */
    static fromObj(obj) {
        var res = new ThemeGraphText();
        Util_Util.copy(res, obj);
        res.graphTextStyle = ServerTextStyle.fromObj(obj.graphTextStyle);
        return res;

    }

}


;// CONCATENATED MODULE: ./src/common/iServer/ThemeGraphItem.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/



/**
 * @class ThemeGraphItem
 * @deprecatedclass SuperMap.ThemeGraphItem
 * @category  iServer Map Theme
 * @classdesc 统计专题图子项类。
 * @param {Object} options - 参数。
 * @param {string} [options.caption] - 专题图子项的名称。
 * @param {string} options.graphExpression - 统计专题图的专题变量。
 * @param {Array.<number>} [options.memoryDoubleValues] - 内存数组方式制作专题图时的值数组。
 * @param {ServerStyle} [options.uniformStyle] - 统计专题图子项的显示风格。
 * @usage
 */
class ThemeGraphItem {

    constructor(options) {

        /**
         * @member {string} [ThemeGraphItem.prototype.caption]
         * @description 专题图子项的名称。
         */
        this.caption = null;

        /**
         * @member {string} ThemeGraphItem.prototype.graphExpression
         * @description 统计专题图的专题变量。专题变量可以是一个字段或字段表达式。字段必须为数值型；表达式只能为数值型的字段间的运算。
         */
        this.graphExpression = null;

        /**
         * @member {Array.<number>} [ThemeGraphItem.prototype.memoryDoubleValues]
         * @description 内存数组方式制作专题图时的值数组。<br>
         *              内存数组方式制作专题图时，只对 SmID 值在键数组（{@link ThemeGraph#memoryKeys}）中的记录制作专题图。
         *              值数组的数值个数必须与键数组中数值的个数一致。值数组中的值将代替原来的专题值来制作统计专题图。
         *              比如：利用面积字段和周长字段（即有两个统计专题图子项 ）作为专题变量制作统计专题图。
         */
        this.memoryDoubleValues = null;

        /**
         * @member {ServerStyle} [ThemeGraphItem.prototype.uniformStyle]
         * @description 统计专题图子项的显示风格。
         *              每一个统计专题图子项都对应一种显示风格。
         */
        this.uniformStyle = new ServerStyle();

        if (options) {
            Util_Util.extend(this, options);
        }

        this.CLASS_NAME = "SuperMap.ThemeGraphItem";
    }

    /**
     * @function ThemeGraphItem.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        var me = this;
        me.caption = null;
        me.graphExpression = null;
        me.memoryDoubleValues = null;
        me.uniformStyle = null;
    }

    /**
     * @function ThemeGraphItem.fromObj
     * @description 从传入对象获取统计专题图子项类。
     * @param {Object} obj - 传入对象。
     * @returns {ThemeGraphItem} ThemeGraphItem 对象。
     */
    static fromObj(obj) {
        if (!obj) {
            return;
        }
        var res = new ThemeGraphItem();
        Util_Util.copy(res, obj);
        res.uniformStyle = ServerStyle.fromJson(obj.uniformStyle);
        return res;
    }

}


;// CONCATENATED MODULE: ./src/common/iServer/ThemeGraph.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/










/**
 * @class ThemeGraph
 * @deprecatedclass SuperMap.ThemeGraph
 * @category  iServer Map Theme
 * @classdesc 统计专题图类。
 * @extends {CommonTheme}
 * @param {Object} options - 参数。
 * @param {Array.<ThemeGraphItem>} options.items - 统计专题图子项集合。
 * @param {number}  [options.barWidth=0] - 柱状专题图中每一个柱的宽度。
 * @param {GraduatedMode} [options.graduatedMode=GraduatedMode.CONSTANT] - 统计图中地理要素的值与图表尺寸间的映射关系。
 * @param {ThemeGraphAxes} [options.graphAxes] - 统计图中坐标轴样式相关信息。
 * @param {ThemeGraphSize} [options.graphSize=0] - 统计符号的最大最小尺寸。
 * @param {boolean} [options.graphSizeFixed=false] - 缩放地图时统计图符号是否固定大小。
 * @param {ThemeGraphText} [options.graphText] - 统计图上的文字是否可见以及文字标注风格。
 * @param {GraphAxesTextDisplayMode} [options.graphAxesTextDisplayMode=GraphAxesTextDisplayMode.NONE] - 统计专题图坐标轴文本显示模式。
 * @param {ThemeGraphType} [options.graphType=ThemeGraphType.AREA] - 统计专题图类型。
 * @param {Array.<number>} [options.memoryKeys] - 以内存数组方式制作专题图时的键数组。
 * @param {boolean} [options.negativeDisplayed=false] - 专题图中是否显示属性为负值的数据。
 * @param {ThemeOffset} [options.offset] - 统计图相对于要素内点的偏移量。
 * @param {boolean} [options.overlapAvoided=true] - 统计图是否采用避让方式显示。
 * @param {number} [options.roseAngle=0] - 统计图中玫瑰图或三维玫瑰图用于等分的角度。
 * @param {number} [options.startAngle=0] - 饼状统计图扇形的起始角度。
 * @usage
 */
class ThemeGraph extends Theme_Theme {

    constructor(options) {
        super("GRAPH", options);
        /**
         * @member {number} [ThemeGraph.prototype.barWidth=0]
         * @description 柱状专题图中每一个柱的宽度。使用地图坐标单位。
         *              只有选择的统计图类型为柱状图（柱状图、三维柱状图、堆叠柱状图、三维堆叠柱状图）时，此项才可设置。
         */
        this.barWidth = 0;

        /**
         * @member {GraduatedMode} [ThemeGraph.prototype.graduatedMode=GraduatedMode.CONSTANT]
         * @description 统计图中地理要素的值与图表尺寸间的映射关系（常数、对数、平方根），即分级方式。
         *              分级主要是为了减少制作统计专题图中数据大小之间的差异，使得统计图的视觉效果比较好，同时不同类别之间的比较也还是有意义的。
         *              提供三种分级模式：常数、对数和平方根，对于有值为负数的字段，不可以采用对数和平方根的分级方式。不同的等级方式用于确定符号大小的数值是不相同的。
         */
        this.graduatedMode = GraduatedMode.CONSTANT;

        /**
         * @member {ThemeGraphAxes} ThemeGraph.prototype.graphAxes
         * @description 用于设置统计图中坐标轴样式相关信息，如坐标轴颜色、是否显示、坐标文本样式等。
         */
        this.graphAxes = new ThemeGraphAxes();

        /**
         * @member {ThemeGraphSize} [ThemeGraph.prototype.graphSize=0]
         * @description 用于设置统计符号的最大最小尺寸。
         */
        this.graphSize = new ThemeGraphSize();

        /**
         * @member {boolean} [ThemeGraph.prototype.graphSizeFixed=false]
         * @description 缩放地图时统计图符号是否固定大小。即统计图符号将随地图缩放。
         */
        this.graphSizeFixed = false;

        /**
         * @member {ThemeGraphText} ThemeGraph.prototype.graphText
         * @description 统计图上的文字是否可见以及文字标注风格。
         */
        this.graphText =  new ThemeGraphText();

        /**
         * @member {ThemeGraphType} [ThemeGraph.prototype.graphType=ThemeGraphType.AREA]
         * @description 统计专题图类型。SuperMap 提供了多种类型的统计图，
         *              分别为面积图、阶梯图、折线图、点状图、柱状图、三维柱状图、饼图、三维饼图、玫瑰图、三维玫瑰图、堆叠柱状图、三维堆叠柱状图、环状图。默认为面积图。
         */
        this.graphType = ThemeGraphType.AREA;

        /**
         * @member {GraphAxesTextDisplayMode} [ThemeGraph.prototype.graphAxesTextDisplayMode=GraphAxesTextDisplayMode.NONE]
         * @description 统计专题图坐标轴文本显示模式。
         */
        this.graphAxesTextDisplayMode = GraphAxesTextDisplayMode.NONE;

        /**
         * @member {Array.<ThemeGraphItem>} ThemeGraph.prototype.items
         * @description 统计专题图子项集合。
         *              统计专题图可以基于多个变量，反映多种属性，即可以将多个专题变量的值绘制在一个统计图上。每一个专题变量对应的统计图即为一个专题图子项。
         *              对于每个专题图子项可以为其设置标题、风格，甚至可以将该子项再制作成范围分段专题图。
         */
        this.items = null;

        /**
         * @member {Array.<number>} ThemeGraph.prototype.memoryKeys
         * @description 以内存数组方式制作专题图时的键数组。
         *              键数组内的数值代表 SmID 值，它与 {@link ThemeGraphItem} 类中的值数组（{@link ThemeGraphItem#memoryDoubleValues}）要关联起来应用。
         *              键数组中数值的个数必须要与值数组的数值个数一致。值数组中的值将代替原来的专题值来制作统计专题图。
         *              目前所有的专题图都支持以内存数组的方式制作专题图，但统计专题图与其他专题图指定内存数组的方式不同，
         *              统计专题图使用 memoryKeys 指定内存数组，而其他专题图则使用 memoryData 来指定内存数组。
         * @example
         *  memoryKeys 的使用方法如下：
         *  function addThemeGraph() {
         *      removeTheme();
         *       //创建统计专题图对象，ThemeGraph 必设 items。
         *       //专题图参数 ThemeParameters 必设 theme（即以设置好的分段专题图对象）、dataSourceName 和 datasetName
         *      var style1 = new ServerStyle({
         *                   fillForeColor: new ServerColor(92,73,234),
         *                   lineWidth: 0.1
         *               }),
         *               style2 = new ServerStyle({
         *                   fillForeColor: new ServerColor(211,111,240),
         *                   lineWidth: 0.1
         *               }),
         *               item1 = new ThemeGraphItem({
         *                   memoryDoubleValues:[1.18,0.95,0.37,1.31,0.8,1.5],
         *                  caption: "1992-1995人口增长率",
         *                  graphExpression: "Pop_Rate95",
         *                   uniformStyle: style1
         *               }),
         *               item2 = new ThemeGraphItem({
         *               //以内存数组方式制作专题图时的值数组
         *                   memoryDoubleValues:[2.71,0,0.74,3.1,2.2,3.5],
         *                   caption: "1995-1999人口增长率",  //专题图子项的名称
         *                   graphExpression: "Pop_Rate99",  //统计专题图的专题变量
         *                   uniformStyle: style2      //统计专题图子项的显示风格
         *               }),
         *               themeGraph  = new ThemeGraph({
         *               //以内存数组方式制作专题图时的键数组，键数组内的数值代表 SmID 值
         *                    memoryKeys:[1,2,4,8,10,12],
         *                   items: new Array(item1,item2),
         *                   barWidth: 0.03,
         *                    //统计图中地理要素的值与图表尺寸间的映射关系为平方根
         *                   graduatedMode: GraduatedMode.SQUAREROOT,
         *                   //graphAxes用于设置统计图中坐标轴样式相关信息
         *                   graphAxes: new ThemeGraphAxes({
         *                       axesDisplayed: true
         *                   }),
         *                   graphSize: new ThemeGraphSize({
         *                       maxGraphSize: 1,
         *                       minGraphSize: 0.35
         *                   }),
         *                   //统计图上的文字是否可见以及文字标注风格
         *                   graphText: new ThemeGraphText({
         *                       graphTextDisplayed: true,
         *                       graphTextFormat: ThemeGraphTextFormat.VALUE,
         *                       graphTextStyle: new ServerTextStyle({
         *                           sizeFixed: true,
         *                           fontHeight: 9,
         *                           fontWidth: 5
         *                       })
         *                   }),
         *                   //统计专题图类型为三维柱状图
         *                   graphType: ThemeGraphType.BAR3D
         *               }),
         *                   //专题图参数对象
         *               themeParameters = new ThemeParameters({
         *                   themes: [themeGraph],
         *                   dataSourceNames: ["Jingjin"],
         *                   datasetNames: ["BaseMap_R"]
         *               }),
         *                   //与服务端交互
         *               themeService=new ThemeService(url);
         *       themeService.processAsync(themeParameters, ThemeCompleted);
         *   }
         */
        this.memoryKeys = null;

        /**
         * @member {boolean} [ThemeGraph.prototype.negativeDisplayed=false]
         * @description 专题图中是否显示属性为负值的数据。true 表示显示；false 不显示。
         */
        this.negativeDisplayed = false;

        /**
         * @member {ThemeOffset} ThemeGraph.prototype.offset
         * @description 用于设置统计图相对于要素内点的偏移量。
         */
        this.offset = new ThemeOffset();

        /**
         * @member {boolean} ThemeGraph.prototype.overlapAvoided
         * @description 统计图是否采用避让方式显示。<br>
         *              1.对数据集制作统计专题图:当统计图采用避让方式显示时，如果 overlapAvoided 为 true，则在统计图重叠度很大的情况下，
         *              会出现无法完全避免统计图重叠的现象；如果 overlapAvoided 为 false，会过滤掉一些统计图，从而保证所有的统计图均不重叠。<br>
         *              2.对数据集同时制作统计专题图和标签专题图：当统计图不显示子项文本时，标签专题图的标签即使和统计图重叠，两者也都可正常显示；
         *              当统计图显示子项文本时，如果统计图中的子项文本和标签专题图中的标签不重叠，则两者均正常显示；如果重叠，则会过滤掉统计图的子项文本，只显示标签。
         */
        this.overlapAvoided = true;

        /**
         * @member {number} [ThemeGraph.prototype.roseAngle=0]
         * @description 统计图中玫瑰图或三维玫瑰图用于等分的角度，默认为 0 度，精确到 0.1 度。在角度为0或者大于 360 度的情况下均使用 360 度来等分制作统计图的字段数。
         */
        this.roseAngle = 0;

        /**
         * @member {number} [ThemeGraph.prototype.startAngle=0]
         * @description 饼状统计图扇形的起始角度。精确到 0.1 度，以水平方向为正向。只有选择的统计图类型为饼状图（饼图、三维饼图、玫瑰图、三维玫瑰图）时，此项才可设置。
         */
        this.startAngle = 0;

        if (options) {
            Util_Util.extend(this, options);
        }

        this.CLASS_NAME = "SuperMap.ThemeGraph";
    }


    /**
     * @function ThemeGraph.prototype.destroy
     * @override
     */
    destroy() {
        super.destroy();
        var me = this;
        me.barWidth = null;
        me.graduatedMode = null;
        if (me.graphAxes) {
            me.graphAxes.destroy();
            me.graphAxes = null;
        }
        if (me.graphSize) {
            me.graphSize.destroy();
            me.graphSize = null;
        }
        me.graphSizeFixed = null;
        if (me.graphText) {
            me.graphText.destroy();
            me.graphText = null;
        }
        me.graphType = null;
        if (me.items) {
            for (var i = 0, items = me.items, len = items.length; i < len; i++) {
                items[i].destroy();
            }
            me.items = null;
        }
        me.memoryKeys = null;
        me.negativeDisplayed = null;
        if (me.offset) {
            me.offset.destroy();
            me.offset = null;
        }
        me.overlapAvoided = null;
        me.roseAngle = null;
        me.startAngle = null;
        me.graphAxesTextDisplayMode = null;
    }

    /**
     * @function ThemeGraph.prototype.toJSON
     * @description 将 ThemeGraph 对象转化为 JSON 字符串。
     * @returns {string} 返回转换后的 JSON 字符串。
     */
    toJSON() {
        return Util_Util.toJSON(this.toServerJSONObject());
    }

    /**
     * @function ThemeGraph.prototype.toServerJSONObject
     * @description 转换成对应的 JSON 格式对象。
     * @returns {Object} 对应的 JSON 格式对象。
     */
    toServerJSONObject() {
        var obj = {};
        obj.type = this.type;
        if (this.graphText) {
            obj.graphTextDisplayed = this.graphText.graphTextDisplayed;
            obj.graphTextFormat = this.graphText.graphTextFormat;
            obj.graphTextStyle = this.graphText.graphTextStyle;
        }
        if (this.graphAxes) {
            obj.axesColor = this.graphAxes.axesColor;
            obj.axesDisplayed = this.graphAxes.axesDisplayed;
            obj.axesGridDisplayed = this.graphAxes.axesGridDisplayed;
            obj.axesTextDisplayed = this.graphAxes.axesTextDisplayed;
            obj.axesTextStyle = this.graphAxes.axesTextStyle;
        }
        if (this.graphSize) {
            obj.maxGraphSize = this.graphSize.maxGraphSize;
            obj.minGraphSize = this.graphSize.minGraphSize;
        }
        if (this.offset) {
            obj.offsetFixed = this.offset.offsetFixed;
            obj.offsetX = this.offset.offsetX;
            obj.offsetY = this.offset.offsetY;
        }
        obj.barWidth = this.barWidth;
        obj.graduatedMode = this.graduatedMode;
        obj.graphSizeFixed = this.graphSizeFixed;
        obj.graphType = this.graphType;
        obj.graphAxesTextDisplayMode = this.graphAxesTextDisplayMode;
        obj.items = this.items;
        obj.memoryKeys = this.memoryKeys;
        obj.negativeDisplayed = this.negativeDisplayed;
        obj.overlapAvoided = this.overlapAvoided;
        obj.roseAngle = this.roseAngle;
        obj.startAngle = this.startAngle;
        return obj;
    }

    /**
     * @function ThemeGraph.fromObj
     * @description 从传入对象获取统计专题图类。
     * @param {Object} obj - 传入对象。
     * @returns {ThemeGraph} ThemeGraph 对象。
     */
    static fromObj(obj) {
        var res = new ThemeGraph();
        var itemsG = obj.items;
        var len = itemsG ? itemsG.length : 0;
        Util_Util.copy(res, obj);
        res.items = [];
        res.graphAxes = ThemeGraphAxes.fromObj(obj);
        res.graphSize = ThemeGraphSize.fromObj(obj);
        res.graphText = ThemeGraphText.fromObj(obj);
        res.offset = ThemeOffset.fromObj(obj);
        for (var i = 0; i < len; i++) {
            res.items.push(ThemeGraphItem.fromObj(itemsG[i]));
        }
        return res;
    }

}

;// CONCATENATED MODULE: ./src/common/iServer/ThemeDotDensity.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/




/**
 * @class ThemeDotDensity
 * @deprecatedclass SuperMap.ThemeDotDensity
 * @category  iServer Map Theme
 * @classdesc 点密度专题图。点密度专题图用一定大小、形状相同的点表示现象分布范围、数量特征和分布密度。点的多少和所代表的意义由地图的内容确定。
 *              点密度专题图利用图层的某一数值属性信息（专题值）映射为不同等级，每一级别使用不同数量或表现为密度的点符号来表示。
 *              该专题值在各个分区内的分布情况，体现不同区域的相对数量差异。多用于具有数量特征的地图上，
 *              比如表示不同地区的粮食产量、GDP、人口等的分级，主要针对区域或面状的要素，因而，点密度专题图适用于面数据集。
 *              注意：点密度专题图中点的分布是随机的，并不代表实际的分布位置。即使在相关设置完全相同的情况下，
 *              每次制作出的专题图，点的数量相同，但点的位置都有差异。
 * @extends {CommonTheme}
 * @param {Object} options - 参数。
 * @param {string} options.dotExpression - 创建点密度专题图的字段或字段表达式。
 * @param {ServerStyle} [options.style] - 点密度专题图中点的风格。
 * @param {number} [options.value] - 专题图中每一个点所代表的数值。
 * @param {ThemeMemoryData} [options.memoryData] - 专题图内存数据。
 * @usage
 */
class ThemeDotDensity extends Theme_Theme {

    constructor(options) {
        super("DOTDENSITY", options);
        /**
         * @member {string} ThemeDotDensity.prototype.dotExpression
         * @description 创建点密度专题图的字段或字段表达式。点的数目或密集程度的来源。
         */
        this.dotExpression = null;

        /**
         * @member {ServerStyle} ThemeDotDensity.prototype.style
         * @description 点密度专题图中点的风格。
         */
        this.style =  new ServerStyle();

        /**
         * @member {number} ThemeDotDensity.prototype.value
         * @description 专题图中每一个点所代表的数值。<br>
         *              点值的确定与地图比例尺以及点的大小有关。地图比例尺越大，相应的图面范围也越大，
         *              点相应就可以越多，此时点值就可以设置相对小一些。点形状越大，
         *              点值相应就应该设置的小一些。点值过大或过小都是不合适的。
         */
        this.value = null;

        if (options) {
            Util_Util.extend(this, options);
        }
        this.CLASS_NAME = "SuperMap.ThemeDotDensity";
    }

    /**
     * @function ThemeDotDensity.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        var me = this;
        me.dotExpression = null;
        me.value = null;

        if (me.style) {
            me.style.destroy();
            me.style = null;
        }
    }


    /**
     * @function ThemeDotDensity.prototype.toServerJSONObject
     * @description 转换成对应的 JSON 格式对象。
     * @returns {Object} 对应的 JSON 格式对象。
     */
    toServerJSONObject() {
        var obj = {};
        obj = Util_Util.copyAttributes(obj, this);
        if (obj.style) {
            if (obj.style.toServerJSONObject) {
                obj.style = obj.style.toServerJSONObject();
            }
        }
        return obj;
    }

    /**
     * @function ThemeDotDensity.fromObj
     * @description 从传入对象获取点密度专题图中点的风格。
     * @param {Object} obj - 传入对象。
     * @returns {ThemeDotDensity} ThemeDotDensity 对象。
     */
    static fromObj(obj) {
        if (!obj) {
            return;
        }
        var res = new ThemeDotDensity();
        Util_Util.copy(res, obj);
        res.style = ServerStyle.fromJson(obj.style);
        return res;
    }


}



;// CONCATENATED MODULE: ./src/common/iServer/ThemeGraduatedSymbolStyle.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/



/**
 * @class ThemeGraduatedSymbolStyle
 * @deprecatedclass SuperMap.ThemeGraduatedSymbolStyle
 * @category  iServer Map Theme
 * @classdesc 等级符号专题图正负零值显示风格类。
 * @param {Object} options - 参数。
 * @param {boolean} [options.negativeDisplayed=false] - 是否显示负值。
 * @param {ServerStyle} [options.negativeStyle] - 负值的等级符号风格。
 * @param {ServerStyle} [options.positiveStyle] - 正值的等级符号风格。
 * @param {boolean} [options.zeroDisplayed=false] - 是否显示 0 值。
 * @param {ServerStyle} [options.zeroStyle] - 0 值的等级符号风格。
 * @usage
 */
class ThemeGraduatedSymbolStyle {

    constructor(options) {
        /**
         * @member {boolean} [ThemeGraduatedSymbolStyle.prototype.negativeDisplayed=false]
         * @description 是否显示负值。
         */
        this.negativeDisplayed = false;

        /**
         * @member {ServerStyle} [ThemeGraduatedSymbolStyle.prototype.negativeStyle]
         * @description 负值的等级符号风格。
         */
        this.negativeStyle = new ServerStyle();

        /**
         * @member {ServerStyle} [ThemeGraduatedSymbolStyle.prototype.positiveStyle]
         * @description 正值的等级符号风格。
         */
        this.positiveStyle = new ServerStyle();

        /**
         * @member {boolean} [ThemeGraduatedSymbolStyle.prototype.zeroDisplayed=false]
         * @description 是否显示 0 值。
         */
        this.zeroDisplayed = false;

        /**
         * @member {ServerStyle} ThemeGraduatedSymbolStyle.prototype.zeroStyle
         * @description 0 值的等级符号风格。
         */
        this.zeroStyle = new ServerStyle();

        if (options) {
            Util_Util.extend(this, options);
        }

        this.CLASS_NAME = "SuperMap.ThemeGraduatedSymbolStyle";
    }

    /**
     * @function ThemeGraduatedSymbolStyle.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        var me = this;
        me.negativeDisplayed = null;
        me.negativeStyle = null;
        me.positiveStyle = null;
        me.zeroDisplayed = null;
        me.zeroStyle = null;
    }

    /**
     * @function ThemeGraduatedSymbolStyle.fromObj
     * @description 从传入对象获取等级符号专题图正负零值显示风格类。
     * @param {Object} obj - 传入对象。
     * @returns {ThemeGraduatedSymbolStyle} ThemeGraduatedSymbolStyle 对象。
     */
    static fromObj(obj) {
        if (!obj) {
            return;
        }
        var res = new ThemeGraduatedSymbolStyle();
        Util_Util.copy(res, obj);
        res.negativeStyle = ServerStyle.fromJson(obj.negativeStyle);
        res.positiveStyle = ServerStyle.fromJson(obj.positiveStyle);
        res.zeroStyle = ServerStyle.fromJson(obj.zeroStyle);
        return res;
    }

}




;// CONCATENATED MODULE: ./src/common/iServer/ThemeGraduatedSymbol.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/






/**
 * @class ThemeGraduatedSymbol
 * @deprecatedclass SuperMap.ThemeGraduatedSymbol
 * @category  iServer Map Theme
 * @classdesc 等级符号专题图。
 * @extends {CommonTheme}
 * @param {Object} options - 参数。
 * @param {ThemeGraduatedSymbolStyle} options.style - 等级符号专题图正负零值显示风格类。
 * @param {string} options.expression - 等级符号专题图的字段或字段表达式。
 * @param {number} [options.baseValue=0] - 等级符号专题图的基准值，单位同专题变量的单位。
 * @param {GraduatedMode} [options.graduatedMode=GraduatedMode.CONSTANT] - 等级符号专题图分级模式。
 * @param {ThemeOffset} [options.offset] - 指定等级符号专题图中标记文本相对于要素内点的偏移量对象。
 * @param {ThemeMemoryData} [options.memoryData] - 专题图内存数据。
 * @usage
 */
class ThemeGraduatedSymbol extends Theme_Theme {

    constructor(options) {
        super("GRADUATEDSYMBOL", options);
        /**
         * @member {number} [ThemeGraduatedSymbol.prototype.baseValue=0]
         * @description 等级符号专题图的基准值，单位同专题变量的单位。<br>
         *              依据此值系统会自动根据分级方式计算其余值对应的符号大小，每个符号的显示大小等于
         *              ThemeValueSection.positiveStyle（或 zeroStyle，negativeStyle）.markerSize * value / basevalue，
         *              其中 value 是 expression 所指定字段对应的值经过分级计算之后的值。默认值为0，建议通过多次尝试设置该值才能达到较好的显示效果。
         */
        this.baseValue = 0;

        /**
         * @member {string} ThemeGraduatedSymbol.prototype.expression
         * @description 用于创建等级符号专题图的字段或字段表达式，字段或字段表达式应为数值型。
         */
        this.expression = null;

        /**
         * @member {GraduatedMode} [ThemeGraduatedSymbol.prototype.graduatedMode=GraduatedMode.CONSTANT]
         * @description 等级符号专题图分级模式。<br>
         *              分级主要是为了减少制作等级符号专题图中数据大小之间的差异。如果数据之间差距较大，则可以采用对数或者平方根的分级方式来进行，
         *              这样就减少了数据之间的绝对大小的差异，使得等级符号图的视觉效果比较好，同时不同类别之间的比较也是有意义的。
         *              有三种分级模式：常数、对数和平方根，对于有值为负数的字段，在用对数或平方根方式分级时，默认对负数取正。
         *              不同的分级模式用于确定符号大小的数值是不相同的：常数按照字段的原始数据进行；对数则是对每条记录对应的专题变量取自然对数；
         *              平方根则是对其取平方根，然后用最终得到的结果来确定其等级符号的大小。
         */
        this.graduatedMode = GraduatedMode.CONSTAN;

        /**
         * @member {ThemeOffset} [ThemeGraduatedSymbol.prototype.offset]
         * @description 用于设置等级符号图相对于要素内点的偏移量。
         */
        this.offset =  new ThemeOffset();

        /**
         * @member {ThemeGraduatedSymbolStyle} ThemeGraduatedSymbol.prototype.style
         * @description 用于设置等级符号图正负和零值显示风格。
         */
        this.style =  new ThemeGraduatedSymbolStyle();

        if (options) {
            Util_Util.extend(this, options);
        }

        this.CLASS_NAME = "SuperMap.ThemeGraduatedSymbol";
    }

    /**
     * @function ThemeGraduatedSymbol.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        super.destroy();
        var me = this;
        me.expression = null;
        me.graduatedMode = GraduatedMode.CONSTANT;
        if (me.offset) {
            me.offset.destroy();
            me.offset = null;
        }
        if (me.style) {
            me.style.destroy();
            me.style = null;
        }
    }


    /**
     * @function ThemeGraduatedSymbol.prototype.toJSON
     * @description 将 themeLabel 对象转化为 JSON 字符串。
     * @returns {string} 返回转换后的 JSON 字符串。
     */
    toJSON() {
        return Util_Util.toJSON(this.toServerJSONObject());
    }


    /**
     * @function ThemeGraduatedSymbol.prototype.toServerJSONObject
     * @description 转换成对应的 JSON 格式对象。
     * @returns {Object} 对应的 JSON 格式对象。
     */
    toServerJSONObject() {
        var obj = {};
        obj.type = this.type;
        obj.memoryData = this.memoryData;
        obj.baseValue = this.baseValue;
        obj.expression = this.expression;
        obj.graduatedMode = this.graduatedMode;
        if (this.offset) {
            obj.offsetFixed = this.offset.offsetFixed;
            obj.offsetX = this.offset.offsetX;
            obj.offsetY = this.offset.offsetY;
        }
        if (this.style) {
            obj.negativeStyle = this.style.negativeStyle;
            obj.negativeDisplayed = this.style.negativeDisplayed;
            obj.positiveStyle = this.style.positiveStyle;
            obj.zeroDisplayed = this.style.zeroDisplayed;
            obj.zeroStyle = this.style.zeroStyle;
        }
        return obj;
    }

    /**
     * @function ThemeGraduatedSymbol.fromObj
     * @description 从传入对象获取等级符号专题图。
     * @param {Object} obj - 传入对象。
     * @returns {ThemeGraduatedSymbol} 等级符号专题图对象。
     */
    static fromObj(obj) {
        if (!obj) {
            return;
        }
        var res = new ThemeGraduatedSymbol();
        Util_Util.copy(res, obj);
        res.offset = ThemeOffset.fromObj(obj);
        res.style = ThemeGraduatedSymbolStyle.fromObj(obj);
        return res;
    }

}


;// CONCATENATED MODULE: ./src/common/iServer/ThemeRangeItem.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/



/**
 * @class ThemeRangeItem
 * @deprecatedclass SuperMap.ThemeRangeItem
 * @category  iServer Map Theme
 * @classdesc 范围分段专题图子项类。在分段专题图中，字段值按照某种分段模式被分成多个范围段，
 * 每个范围段即为一个子项，同一范围段的要素属于同一个分段专题图子项。
 * 每个子项都有其分段起始值、终止值、名称和风格等。每个分段所表示的范围为[start, end)。
 * @param {Object} options - 参数。
 * @param {string} [options.caption] - 子项的标题。
 * @param {number} [options.end=0] - 子项的终止值。
 * @param {number} [options.start=0] - 子项的起始值。
 * @param {ServerStyle} options.style - 子项的风格。
 * @param {boolean} [options.visible=true] - 子项是否可见。
 * @usage
 */
class ThemeRangeItem {

    constructor(options) {
        /**
         * @member {string} [ThemeRangeItem.prototype.caption]
         * @description 分段专题图子项的标题。
         */
        this.caption = null;

        /**
         * @member {number} [ThemeRangeItem.prototype.end=0]
         * @description 分段专题图子项的终止值，即该段专题值范围的最大值。<br>
         *              如果该子项是分段中最后一个子项，则该终止值应大于分段字段（ThemeRange 类的 rangeExpression 属性）的最大值，若该终止值小于分段字段最大值，
         *              则剩余部分由内部随机定义其颜色；如果不是最后一项，该终止值必须与其下一子项的起始值相同，否则系统抛出异常；
         *              如果设置了范围分段模式和分段数，则会自动计算每段的范围 [start, end)，故无需设置 [start, end)；当然可以设置，那么结果就会按您设置的值对分段结果进行调整。
         */
        this.end = 0;

        /**
         * @member {number} [ThemeRangeItem.prototype.start=0]
         * @description 分段专题图子项的起始值，即该段专题值范围的最小值。<br>
         *              如果该子项是分段中第一个子项，那么该起始值就是分段的最小值；如果子项的序号大于等于 1 的时候，该起始值必须与前一子项的终止值相同，否则系统会抛出异常。
         *              如果设置了范围分段模式和分段数，则会自动计算每段的范围 [start, end)，故无需设置 [start, end)；当然可以设置，那么结果就会按您设置的值对分段结果进行调整。
         */
        this.start = 0;

        /**
         * @member {ServerStyle} ThemeRangeItem.prototype.style
         * @description 分段专题图子项的风格。
         *              每一个分段专题图子项都对应一种显示风格。
         */
        this.style = new ServerStyle();

        /**
         * @member {boolean} [ThemeRangeItem.prototype.visible=true]
         * @description 分段专题图子项是否可见。
         */
        this.visible = true;

        if (options) {
            Util_Util.extend(this, options);
        }

        this.CLASS_NAME = "SuperMap.ThemeRangeItem";
    }

    /**
     * @function ThemeRangeItem.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        var me = this;
        me.caption = null;
        me.end = null;
        me.start = null;

        if (me.style) {
            me.style.destroy();
            me.style = null;
        }
        me.visible = null;
    }

    /**
     * @function ThemeRangeItem.prototypetoServerJSONObject
     * @description 转换成对应的 JSON 格式对象。
     * @returns {Object} 对应的 JSON 格式对象。
     */
    toServerJSONObject() {
        var obj = {};
        obj = Util_Util.copyAttributes(obj, this);
        if (obj.style) {
            if (obj.style.toServerJSONObject) {
                obj.style = obj.style.toServerJSONObject();
            }
        }
        return obj;
    }

    /**
     * @function ThemeRangeItem.fromObj
     * @description 从传入对象获取范围分段专题图子项类。
     * @param {Object} obj - 传入对象。
     * @returns {ThemeRangeItem} ThemeRangeItem 对象。
     */
    static fromObj(obj) {
        if (!obj) {
            return;
        }
        var res = new ThemeRangeItem();
        Util_Util.copy(res, obj);
        res.style = ServerStyle.fromJson(obj.style);
        return res;
    }
}


;// CONCATENATED MODULE: ./src/common/iServer/ThemeRange.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/





/**
 * @class ThemeRange
 * @deprecatedclass SuperMap.ThemeRange
 * @category  iServer Map Theme
 * @classdesc 范围分段专题图。
 * 范围分段专题图是按照指定的分段方法（如：等距离分段法）对字段的属性值进行分段，使用不同的颜色或符号（线型、填充）表示不同范围段落的属性值在整体上的分布情况，体现区域的差异。
 * 在分段专题图中，专题值按照某种分段方式被分成多个范围段，要素根据各自的专题值被分配到其中一个范围段中，在同一个范围段中的要素使用相同的颜色，填充，符号等风格进行显示。
 * 分段专题图所基于的专题变量必须为数值型，分段专题图一般用来反映连续分布现象的数量或程度特征，如降水量的分布，土壤侵蚀强度的分布等。
 * @extends {CommonTheme}
 * @param {Object} options - 参数。
 * @param {Array.<ThemeRangeItem>} options.items - 子项数组。
 * @param {string} options.rangeExpression - 分段字段表达式。
 * @param {number} options.rangeParameter - 分段参数。
 * @param {RangeMode} [options.rangeMode=RangeMode.EQUALINTERVAL] - 分段模式。
 * @param {ColorGradientType} [options.colorGradientType=ColorGradientType.YELLOW_RED] - 渐变颜色枚举类。
 * @param {ThemeMemoryData} [options.memoryData] - 专题图内存数据。
 * @usage
 */
class ThemeRange extends Theme_Theme {

    constructor(options) {
        super("RANGE", options);
        /**
         * @member {string} ThemeRange.prototype.precision
         * @description 精准度。
         */
        this.precision = '1.0E-12';

        /**
         * @member {Array.<ThemeRangeItem>} ThemeRange.prototype.items
         * @description 分段专题图子项数组。<br>
         *              在分段专题图中，字段值按照某种分段模式被分成多个范围段，每个范围段即为一个子项，同一范围段的要素属于同一个分段专题图子项。
         *              每个子项都有其分段起始值、终止值、名称和风格等。每个分段所表示的范围为 [start, end)。
         *              如果设置了范围分段模式和分段数，则会自动计算每段的范围 [start, end)，故无需设置 [start, end)；当然可以设置，那么结果就会按照您设置的值对分段结果进行调整。
         */
        this.items = null;

        /**
         * @member {string} ThemeRange.prototype.rangeExpression
         * @description 分段字段表达式。<br>
         *              由于范围分段专题图基于各种分段方法根据一定的距离进行分段，因而范围分段专题图所基于的字段值的数据类型必须为数值型。对于字段表达式，只能为数值型的字段间的运算。
         */
        this.rangeExpression = null;

        /**
         * @member {RangeMode} [ThemeRange.prototype.rangeMode=RangeMode.EQUALINTERVAL]
         * @description 分段专题图的分段模式。<br>
         *              在分段专题图中，作为专题变量的字段或表达式的值按照某种分段方式被分成多个范围段。
         *              目前 SuperMap 提供的分段方式包括：等距离分段法、平方根分段法、标准差分段法、对数分段法、等计数分段法和自定义距离法，
         *              显然这些分段方法根据一定的距离进行分段，因而范围分段专题图所基于的专题变量必须为数值型。
         */
        this.rangeMode = RangeMode.EQUALINTERVAL;

        /**
         * @member {number} ThemeRange.prototype.rangeParameter
         * @description 分段参数。
         *              当分段模式为等距离分段法，平方根分段，对数分段法，等计数分段法其中一种模式时，该参数用于设置分段个数；当分段模式为标准差分段法时，
         *              该参数不起作用；当分段模式为自定义距离时，该参数用于设置自定义距离。
         */
        this.rangeParameter = 0;

        /**
         * @member {ColorGradientType} [ThemeRange.prototype.colorGradientType=ColorGradientType.YELLOW_RED]
         * @description 渐变颜色枚举类。<br>
         *              渐变色是由起始色根据一定算法逐渐过渡到终止色的一种混合型颜色。
         *              该类作为单值专题图参数类、分段专题图参数类的属性，负责设置单值专题图、分段专题图的配色方案，在默认情况下专题图所有子项会根据这个配色方案完成填充。但如果为某几个子项的风格进行单独设置后（设置了 {@link ThemeUniqueItem} 或 {@link ThemeRangeItem} 类中Style属性），
         *              该配色方案对于这几个子项将不起作用。
         */
        this.colorGradientType = ColorGradientType.YELLOW_RED;

        if (options) {
            Util_Util.extend(this, options);
        }

        this.CLASS_NAME = "SuperMap.ThemeRange";
    }


    /**
     * @function ThemeRange.prototype.destroy
     * @override
     */
    destroy() {
        super.destroy();
        var me = this;
        if (me.items) {
            if (me.items.length > 0) {
                for (var item in me.items) {
                    me.items[item].destroy();
                    me.items[item] = null;
                }
            }
            me.items = null;
        }
        me.rangeExpression = null;
        me.rangeMode = null;
        me.rangeParameter = null;
        me.colorGradientType = null;
    }

    /**
     * @function ThemeRange.fromObj
     * @description 从传入对象获取范围分段专题图类。
     * @param {Object} obj - 传入对象。
     * @returns {ThemeRange} ThemeRange 对象。
     */
    static fromObj(obj) {
        if (!obj) {
            return;
        }
        var res = new ThemeRange();
        Util_Util.copy(res, obj);
        var itemsR = obj.items;
        var len = itemsR ? itemsR.length : 0;
        res.items = [];
        for (var i = 0; i < len; i++) {
            res.items.push(ThemeRangeItem.fromObj(itemsR[i]));
        }
        return res;
    }

}


;// CONCATENATED MODULE: ./src/common/iServer/UGCLayer.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/



/**
 * @class UGCLayer
 * @deprecatedclass SuperMap.UGCLayer
 * @category  iServer Map Layer
 * @classdesc SuperMap 图层类。
 * @param {Object} options - 参数。
 * @param {Bounds} options.bounds - 图层范围。
 * @param {string} options.name - 图层的名称。
 * @param {UGCLayerType} options.type  - 图层类型。
 * @param {string} [options.caption] - 图层的标题。
 * @param {string} [options.description] - 图层的描述信息。
 * @param {boolean} [options.queryable] - 图层中的对象是否可以查询。
 * @param {boolean} [options.subUGCLayers] - 是否允许图层的符号大小随图缩放。
 * @param {boolean} [options.visible=false] - 地图对象在同一范围内时，是否重叠显示。
 * @usage
 */
class UGCLayer {

    constructor(options) {
        options =  options || {};
        /**
         * @member {Bounds} UGCLayer.prototype.bounds
         * @description 图层范围。
         */
        this.bounds = null;

        /**
         * @member {string} [UGCLayer.prototype.caption]
         * @description 图层的标题。默认情况下图层的标题与图层的名称一致。在图例、图层控制列表中显示的图层名称就是该图层的标题值。
         */
        this.caption = null;

        /**
         * @member {string} UGCLayer.prototype.description
         * @description 图层的描述信息。
         */
        this.description = null;

        /**
         * @member {string} UGCLayer.prototype.name
         * @description 图层的名称。图层的名称在图层所在的地图中唯一标识此图层。该属性区分大小写。
         */
        this.name = null;

        /**
         * @member {boolean} UGCLayer.prototype.queryable
         * @description 图层中的对象是否可以查询。
         */
        this.queryable = null;

        /**
         * @member {Array} UGCLayer.prototype.subLayers
         * @description 子图层集。
         */
        this.subLayers = null;

        /**
         * @member {UGCLayerType} UGCLayer.prototype.type
         * @description 图层类型。
         */
        this.type = null;

        /**
         * @member {boolean} UGCLayer.prototype.visible
         * @description 地图对象在同一范围内时，是否重叠显示。
         */
        this.visible = null;

        Util_Util.extend(this, options);

        this.CLASS_NAME = "SuperMap.UGCLayer";
    }

    /**
     * @function UGCLayer.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        var me = this;
        Util_Util.reset(me);
    }

    /**
     * @function UGCLayer.prototype.fromJson
     * @description 将服务端 JSON 对象转换成当前客户端对象。
     * @param {Object} jsonObject - 要转换的 JSON 对象。
     */
    fromJson(jsonObject) {
        jsonObject = jsonObject ? jsonObject : {};
        Util_Util.extend(this, jsonObject);
        var b = this.bounds;
        if (b) {
            this.bounds = new Bounds(b.leftBottom.x, b.leftBottom.y, b.rightTop.x, b.rightTop.y);
        }
    }


    /**
     * @function UGCLayer.prototype.toServerJSONObject
     * @description 转换成对应的 JSON 格式对象。
     * @returns {Object} 对应的 JSON 格式对象。
     */
    toServerJSONObject() {
        var jsonObject = {};
        jsonObject = Util_Util.copyAttributes(jsonObject, this);
        if (jsonObject.bounds) {
            if (jsonObject.bounds.toServerJSONObject) {
                jsonObject.bounds = jsonObject.bounds.toServerJSONObject();
            }
        }
        return jsonObject;
    }

}

;// CONCATENATED MODULE: ./src/common/iServer/UGCMapLayer.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/



/**
 * @class UGCMapLayer
 * @deprecatedclass SuperMap.UGCMapLayer
 * @category  iServer Map Layer
 * @classdesc SuperMap 地图图层类。
 * @extends {UGCLayer}
 * @param {Object} options - 可选参数。
 * @param {boolean} [options.completeLineSymbolDisplayed] - 是否显示完整线型。
 * @param {number} [options.maxScale] - 地图最大比例尺。
 * @param {number} [options.minScale] - 地图最小比例尺。
 * @param {number} [options.minVisibleGeometrySize] - 几何对象的最小可见大小，以像素为单位。
 * @param {number} [options.opaqueRate] - 图层的不透明度。
 * @param {boolean} [options.symbolScalable] - 是否允许图层的符号大小随图缩放。
 * @param {number} [options.symbolScale] - 图层的符号缩放基准比例尺。
 * @param {boolean} [options.overlapDisplayed=false] - 地图对象在同一范围内时，是否重叠显示。
 * @param {OverlapDisplayedOptions} [options.overlapDisplayedOptions] - 地图的压盖过滤显示选项，当overlapDisplayed 为 false 时有效。
 * @usage
 */
class UGCMapLayer extends UGCLayer {

    constructor(options) {
        options = options || {};
        super(options);
        /**
         * @member {boolean} UGCMapLayer.prototype.completeLineSymbolDisplayed
         * @description 是否显示完整线型。
         */
        this.completeLineSymbolDisplayed = null;

        /**
         * @member {number} UGCMapLayer.prototype.maxScale
         * @description 地图最大比例尺。
         */
        this.maxScale = null;

        /**
         * @member {number} UGCMapLayer.prototype.minScale
         * @description 地图最小比例尺。
         */
        this.minScale = null;

        /**
         * @member {number} UGCMapLayer.prototype.minVisibleGeometrySize
         * @description 几何对象的最小可见大小，以像素为单位。
         */
        this.minVisibleGeometrySize = null;

        /**
         * @member {number} UGCMapLayer.prototype.opaqueRate
         * @description 图层的不透明度。
         */
        this.opaqueRate = null;
        /**
         * @member {boolean} UGCMapLayer.prototype.symbolScalable
         * @description 是否允许图层的符号大小随图缩放。
         */
        this.symbolScalable = null;

        /**
         * @member {number} UGCMapLayer.prototype.symbolScale
         * @description 图层的符号缩放基准比例尺。
         */
        this.symbolScale = null;

        /**
         * @member {boolean} [UGCMapLayer.prototype.overlapDisplayed=false]
         * @description 地图对象在同一范围内时，是否重叠显示。
         */
        this.overlapDisplayed = null;

        /**
         * @member {OverlapDisplayedOptions} UGCMapLayer.prototype.overlapDisplayedOptions
         * @description 地图的压盖过滤显示选项，当 overlapDisplayed 为 false 时有效。
         */
        this.overlapDisplayedOptions = null;

        this.CLASS_NAME = "SuperMap.UGCMapLayer";
    }

    /**
     * @function UGCMapLayer.prototype.destroy
     * @override
     */
    destroy() {
        super.destroy();
        Util_Util.reset(this);
    }


    /**
     * @function UGCMapLayer.prototype.fromJson
     * @description 将服务端 JSON 对象转换成当前客户端对象。
     * @param {Object} jsonObject - 要转换的 JSON 对象。
     */
    fromJson(jsonObject) {
        super.fromJson(jsonObject);
    }


    /**
     * @function UGCMapLayer.prototype.toServerJSONObject
     * @description 转换成对应的 JSON 格式对象。
     * @returns {Object} 对应的 JSON 格式对象。
     */
    toServerJSONObject() {
        return super.toServerJSONObject();
    }

}


;// CONCATENATED MODULE: ./src/common/iServer/JoinItem.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


/**
 * @class JoinItem
 * @deprecatedclass SuperMap.JoinItem
 * @category iServer Data FeatureResults
 * @classdesc 连接信息类。
 * 该类用于矢量数据集与外部表的连接。外部表可以为另一个矢量数据集（其中纯属性数据集中没有空间几何信息）所对应的 DBMS 表，也可以是用户自建的业务表。
 * 需要注意的是，矢量数据集与外部表必须属于同一数据源。表之间的联系的建立有两种方式，一种是连接（join），一种是关联（link）。
 * 连接，实际上是依据相同的字段将一个外部表追加到指定的表；而关联是基于一个相同的字段定义了两个表格之间的联系，但不是实际的追加。
 * 用于连接两个表的字段的名称不一定相同，但类型必须一致。当两个表格之间建立了连接，通过对主表进行操作，可以对外部表进行查询，制作专题图以及分析等。
 * 当两个表格之间是一对一或多对一的关系时，可以使用 join 连接。当为多对一的关系时，允许指定多个字段之间的关联。
 *（注意：JoinItem 目前支持左连接和内连接，不支持全连接和右连接，UDB 引擎不支持内连接。并且用于建立连接的两个表必须在同一个数据源下。)
 * @param {Object} options - 参数。
 * @param {string} options.foreignTableName - 外部表的名称。
 * @param {string} options.joinFilter - 矢量数据集与外部表之间的连接表达式，即设定两个表之间关联的字段。
 * @param {JoinType} options.joinType - 两个表之间连接类型。
 * @example 下面以 SQL 查询说明 joinItem 的使用方法：
 *(start code)
 *   function queryBySQL() {
     *       // 设置与外部表的连接信息
     *       var joinItem = new JoinItem({
     *           foreignTableName: "foreignTable",
     *           joinFilter: "foreignTable.CONTINENT = Countries.CONTINENT",
     *           joinType: "LEFTJOIN"
     *       })
     *       var queryParam, queryBySQLParams, queryBySQLService;
     *       // 设置查询参数，在查询参数中添加joinItem关联条件信息
     *       queryParam = new FilterParameter({
     *            name: "Countries@World",
     *            joinItems: [joinItem]
     *         }),
     *       queryBySQLParams = new QueryBySQLParameters({
     *             queryParams: [queryParam]
     *         }),
     *       queryBySQLService = new QueryBySQLService(url);
     *       queryBySQLService.processAsync(queryBySQLParams, processCompleted);
     *  }
 *  function processCompleted(queryEventArgs) {//todo}
 *  function processFailed(e) {//todo}
 * (end)
 * @usage
 */
class JoinItem {

    constructor(options) {
        /**
         * @member {string} JoinItem.prototype.foreignTableName
         * @description 外部表的名称。
         * 如果外部表的名称是以 “表名@数据源名” 命名方式，则该属性只需赋值表名。
         * 例如：外部表 Name@changchun，Name 为表名，changchun 为数据源名称，则该属性的赋值应为：Name。
         */
        this.foreignTableName = null;

        /**
         * @member {string} JoinItem.prototype.joinFilter
         * @description 矢量数据集与外部表之间的连接表达式，即设定两个表之间关联的字段。
         * 例如，将房屋面数据集（Building）的 district 字段与房屋拥有者的纯属性数据集（Owner）的 region 字段相连接，
         * 两个数据集对应的表名称分别为 Table_Building 和 Table_Owner，
         * 则连接表达式为 Table_Building.district = Table_Owner.region。
         * 当有多个字段相连接时，用 AND 将多个表达式相连。
         */
        this.joinFilter = null;

        /**
         * @member {JoinType} JoinItem.prototype.joinType
         * @description 两个表之间连接类型。
         * 连接类型决定了对两个表进行连接查询后返回的记录的情况。
         */
        this.joinType = null;

        if (options) {
            Util_Util.extend(this, options);
        }
        this.CLASS_NAME = "SuperMap.JoinItem";
    }


    /**
     * @function JoinItem.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        var me = this;
        me.foreignTableName = null;
        me.joinFilter = null;
        me.joinType = null;
    }

    /**
     * @function JoinItem.prototype.toServerJSONObject
     * @description 转换成对应的 JSON 格式对象。
     */
    toServerJSONObject() {
        var dataObj = {};
        dataObj = Util_Util.copyAttributes(dataObj, this);
        //joinFilter基本是个纯属性对象，这里不再做转换
        return dataObj;
    }
}

;// CONCATENATED MODULE: ./src/common/iServer/DatasetInfo.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/



/**
 * @class DatasetInfo
 * @deprecatedclass SuperMap.DatasetInfo
 * @category  iServer Data Dataset
 * @classdesc 数据集信息类。
 * 数据集一般为存储在一起的相关数据的集合；根据数据类型的不同，分为矢量数据集、栅格数据集（griddataset）和
 * 影像数据集（image dataset），以及为了处理特定问题而设计的数据集，如拓扑数据集，网络数据集等。
 * 数据集是 GIS 数据组织的最小单位。其中矢量数据集是由同种类型空间要素组成的集合，
 * 所以也可以称为要素集。根据要素的空间特征的不同，矢量数据集又分为点数据集，
 * 线数据集，面数据集等，各矢量数据集是空间特征和性质相同的数据组织起来的集合。
 * 目前版本支持的数据集主要有点数据集，线数据集，面数据集，文本数据集，复合数据集（CAD 数据集）、
 * 网络数据集，栅格数据集（grid dataset）和影像数据集（image dataset）。
 * @param {Object} options - 参数。
 * @param {Bounds} [options.bounds] - 数据集范围。
 * @param {string} [options.dataSourceName] - 数据源名称。
 * @param {string} [options.description] - 数据集的描述信息。
 * @param {string} [options.encodeType] - 数据集存储时的压缩编码方式。
 * @param {boolean} [options.isReadOnly] - 数据集是否为只读。
 * @param {string} options.name - 数据集名称。
 * @param {Object} [options.prjCoordSys] - 数据集的投影信息。如：prjCoordSys={"epsgCode":3857}。
 * @param {string} [options.tableName] - 表名。
 * @param {string} options.type - 数据集类型。主要有点数据集，线数据集，面数据集，文本数据集，复合数据集（CAD 数据集）、网络数据集，栅格数据集（grid dataset）和影像数据集（image dataset）。
 * @usage
 */
class DatasetInfo {


    constructor(options) {
        options = options || {};

        /**
         * @member {Bounds} [DatasetInfo.prototype.bounds]
         * @description 数据集范围，该字段只读。
         */
        this.bounds = null;

        /**
         * @member {string} [DatasetInfo.prototype.dataSourceName]
         * @description 数据源名称，该字段只读。
         */
        this.dataSourceName = null;

        /**
         * @member {string} [DatasetInfo.prototype.description]
         * @description 数据集的描述信息。
         */
        this.description = null;

        /**
         * @member {string} [DatasetInfo.prototype.encodeType]
         * @description 数据集存储时的压缩编码方式，该字段只读。
         */
        this.encodeType = null;

        /**
         * @member {boolean} [DatasetInfo.prototype.isReadOnly]
         * @description 数据集是否为只读。
         */
        this.isReadOnly = null;

        /**
         * @member {string} DatasetInfo.prototype.name
         * @description 数据集名称，该字段必须且只读。
         */
        this.name = null;

        /**
         * @member {Object} [DatasetInfo.prototype.prjCoordSys]
         * @description 数据集的投影信息。
         */
        this.prjCoordSys = null;

        /**
         * @member {string} [DatasetInfo.prototype.tableName]
         * @description 表名，该字段只读。
         */
        this.tableName = null;

        /**
         * @member {string} DatasetInfo.prototype.type
         * @description 数据集类型，该字段必设。主要有点数据集，线数据集，面数据集，文本数据集，复合数据集（CAD 数据集）、网络数据集，栅格数据集（grid dataset）和影像数据集（image dataset）。
         */
        this.type = null;

        Util_Util.extend(this, options);

        var b = this.bounds;
        if (b) {
            this.bounds = new Bounds(b.leftBottom.x, b.leftBottom.y, b.rightTop.x, b.rightTop.y);
        }
        this.CLASS_NAME = "SuperMap.DatasetInfo";
    }

    /**
     * @function DatasetInfo.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        Util_Util.reset(this);
    }

    /**
     * @function DatasetInfo.prototype.toServerJSONObject
     * @description 转换成对应的 JSON 格式对象。
     * @returns {Object} JSON 对象。
     */
    toServerJSONObject() {
        var dataObj = {};
        dataObj = Util_Util.copyAttributes(dataObj, this);
        if (dataObj.bounds) {
            if (dataObj.bounds.toServerJSONObject) {
                dataObj.bounds = dataObj.bounds.toServerJSONObject();
            }
        }
        return dataObj;
    }
}

;// CONCATENATED MODULE: ./src/common/iServer/UGCSubLayer.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/





/**
 * @class UGCSubLayer
 * @deprecatedclass SuperMap.UGCSubLayer
 * @category  iServer Map Layer
 * @classdesc 地图服务图层属性信息类。影像图层（Image）、专题图层（ServerTheme）、栅格图层（Grid）、矢量图层（Vector）等图层均继承该类。
 * @extends {UGCMapLayer}
 * @param {Object} options - 参数。
 * @param {DatasetInfo} options.datasetInfo - 数据集信息。
 * @param {string} [options.displayFilter] - 图层显示过滤条件。
 * @param {JoinItem} [options.joinItems] - 连接信息类。
 * @param {string} [options.representationField] - 存储制图表达信息的字段。
 * @param {LayerType} [options.ugcLayerType] - 图层类型。
 * @usage
 */
class UGCSubLayer extends UGCMapLayer {


    constructor(options) {
        options = options || {};
        super(options);
        /**
         * @member {DatasetInfo} UGCSubLayer.prototype.datasetInfo
         * @description 数据集信息。
         */
        this.datasetInfo = null;

        /**
         * @member {string} UGCSubLayer.prototype.displayFilter
         * @description 图层显示过滤条件。
         */
        this.displayFilter = null;

        /**
         * @member {JoinItem} UGCSubLayer.prototype.joinItems
         * @description 连接信息类。
         */
        this.joinItems = null;

        /**
         * @member {string} UGCSubLayer.prototype.representationField
         * @description 存储制图表达信息的字段。
         */
        this.representationField = null;

        /**
         * @member {LayerType} UGCSubLayer.prototype.ugcLayerType
         * @description 图层类型。
         */
        this.ugcLayerType = null;

        this.CLASS_NAME = "SuperMap.UGCSubLayer";
    }


    /**
     * @function UGCSubLayer.prototype.fromJson
     * @description 将服务端 JSON 对象转换成当前客户端对象。
     * @param {Object} jsonObject - 要转换的 JSON 对象。
     */
    fromJson(jsonObject) {
        super.fromJson(jsonObject);
        if (this.datasetInfo) {
            this.datasetInfo = new DatasetInfo(this.datasetInfo);
        }
        if (this.joinItems && this.joinItems.length) {
            var newJoinItems = [];
            for (var i = 0; i < this.joinItems.length; i++) {
                newJoinItems[i] = new JoinItem(this.joinItems[i]);
            }
            this.joinItems = newJoinItems;
        }
    }

    /**
     * @function UGCSubLayer.prototype.destroy
     * @override
     */
    destroy() {
        super.destroy();
        Util_Util.reset(this);
    }


    /**
     * @function UGCSubLayer.prototype.toServerJSONObject
     * @description 转换成对应的 JSON 格式对象。
     * @returns {Object} 对应的 JSON 格式对象。
     */
    toServerJSONObject() {
        var jsonObject = super.toServerJSONObject();
        if (jsonObject.joinItems) {
            var joinItems = [];
            for (var i = 0; i < jsonObject.joinItems.length; i++) {
                if (jsonObject.joinItems[i].toServerJSONObject) {
                    joinItems[i] = jsonObject.joinItems[i].toServerJSONObject();
                }

            }
            jsonObject.joinItems = joinItems;
        }
        if (jsonObject.datasetInfo) {
            if (jsonObject.datasetInfo.toServerJSONObject) {
                jsonObject.datasetInfo = jsonObject.datasetInfo.toServerJSONObject();
            }
        }
        return jsonObject;
    }

}


;// CONCATENATED MODULE: ./src/common/iServer/ServerTheme.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/










/**
 * @class ServerTheme
 * @deprecatedclass SuperMap.ServerTheme
 * @category  iServer Map Theme
 * @classdesc SuperMap 专题图图层类。
 * @extends {UGCSubLayer}
 * @param {CommonTheme} theme - 专题图对象。
 * @param {LonLat} themeElementPosition - 专题图元素位置。
 * @usage
 */
class ServerTheme extends UGCSubLayer {

    constructor(options) {
        options = options || {};
        super(options);

        /**
         * @member {CommonTheme} ServerTheme.prototype.theme
         * @description 专题图对象。
         */
        this.theme = null;

        /**
         * @member {LonLat} ServerTheme.prototype.themeElementPosition
         * @description 专题图元素位置。
         */
        this.themeElementPosition = null;

        this.CLASS_NAME = "SuperMap.ServerTheme";

    }


    /**
     * @function ServerTheme.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     * @override
     */
    destroy() {
        super.destroy();
        Util_Util.reset(this);
    }


    /**
     * @function ServerTheme.prototype.fromJson
     * @description 将服务端 JSON 对象转换成当前客户端对象。
     * @param {Object} jsonObject - 要转换的 JSON 对象。
     */
    fromJson(jsonObject) {
        super.fromJson(jsonObject);
        var themeObj = this.theme;
        var themeT = themeObj && themeObj.type;
        switch (themeT) {
            case 'LABEL':
                this.theme = ThemeLabel.fromObj(themeObj);
                break;
            case 'UNIQUE':
                this.theme = ThemeUnique.fromObj(themeObj);
                break;
            case 'GRAPH':
                this.theme = ThemeGraph.fromObj(themeObj);
                break;
            case 'DOTDENSITY':
                this.theme = ThemeDotDensity.fromObj(themeObj);
                break;
            case 'GRADUATEDSYMBOL':
                this.theme = ThemeGraduatedSymbol.fromObj(themeObj);
                break;
            case 'RANGE':
                this.theme = ThemeRange.fromObj(themeObj);
                break;
            default:
                break;
        }
        if (this.themeElementPosition) {
            //待测试
            this.themeElementPosition = new LonLat(this.themeElementPosition.x, this.themeElementPosition.y);
        }
    }

    /**
     * @function ServerTheme.prototype.toServerJSONObject
     * @description 转换成对应的 JSON 格式对象。
     */
    toServerJSONObject() {
        //普通属性直接赋值
        var jsonObject = super.toServerJSONObject();

        if (jsonObject.themeElementPosition) {
            if (jsonObject.themeElementPosition.toServerJSONObject) {
                jsonObject.themeElementPosition = jsonObject.themeElementPosition.toServerJSONObject();
            }
        }
        if (jsonObject.theme) {
            if (jsonObject.theme.toServerJSONObject) {
                jsonObject.theme = jsonObject.theme.toServerJSONObject();
            }
        }
        return jsonObject;
    }

}


;// CONCATENATED MODULE: ./src/common/iServer/ColorDictionary.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/



/**
 * @class ColorDictionary
 * @deprecatedclass SuperMap.ColorDictionary
 * @category  iServer Map Theme
 * @classdesc 颜色对照表类。颜色对照表中的键名为具体的高程值，键值表示该高程值要显示的颜色。
 * 对于栅格图层中高程值小于颜色对照表中高程最小值的点使用颜色对照表中高程最小值对应的颜色，
 * 对于栅格图层中高程值大于颜色对照表中高程最大值的点使用颜色对照表中高程最大值对应的颜色，
 * 对于栅格图层中高程值在颜色对照表中没有对应颜色的点，则查找颜色对照表中与当前高程值相邻的两个高程对应的颜色，
 * 然后通过渐变运算要显示的颜色。如果设置了颜色对照表的话，则颜色表设置无效。
 * @param {Object} options - 参数。
 * @param {number} options.elevation - 高程值。
 * @param {ServerColor} options.color - 服务端颜色类。
 * @usage
 */
class ColorDictionary {


    constructor(options) {
        options = options || {};

        /**
         * @member {number} ColorDictionary.prototype.elevation
         * @description 高程值。
         */
        this.elevation = null;

        /**
         * @member {ServerColor} ColorDictionary.prototype.color
         * @description 服务端颜色类。
         */
        this.color = null;

        Util_Util.extend(this, options);

        var me = this,
            c = me.color;
        if (c) {
            me.color = new ServerColor(c.red, c.green, c.blue);
        }

        this.CLASS_NAME = "SuperMap.ColorDictionary";
    }

    /**
     * @function ColorDictionary.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        Util_Util.reset(this);
    }

    /**
     * @function ColorDictionary.prototype.toServerJSONObject
     * @description 转换成对应的 JSON 格式对象。
     * @returns {Object} JSON 对象。
     */
    toServerJSONObject() {
        var dataObj = {};
        dataObj = Util_Util.copyAttributes(dataObj, this);
        return dataObj;
    }
}



;// CONCATENATED MODULE: ./src/common/iServer/Grid.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/






/**
 * @class Grid
 * @deprecatedclass SuperMap.Grid
 * @category iServer Map Layer
 * @classdesc SuperMap 栅格图层类。
 * @extends {UGCSubLayer}
 * @param {Object} options - 可选参数。
 * @param {Array.<Object>} [options.colorDictionary] - 颜色对照表对象。
 * @param {number} [options.brightness] - Grid 图层的亮度。
 * @param {ColorGradientType} [options.colorGradientType] - 颜色渐变枚举。
 * @param {ServerColor} [options.colors] - 颜色表对象。
 * @param {number} [options.contrast] - Grid 图层的对比度。
 * @param {GridType} [options.gridType] - 格网类型。
 * @param {number} [options.horizontalSpacing] - 格网水平间隔大小。
 * @param {boolean} [options.sizeFixed] - 格网是否固定大小，如果不固定大小，则格网随着地图缩放。
 * @param {ServerStyle} [options.solidStyle] - 格网实线的样式。
 * @param {ServerColor} [options.specialColor] - 栅格数据集无值数据的颜色。
 * @param {number} [options.specialValue] - 图层的特殊值。
 * @param {boolean} [options.specialValueTransparent] - 图层的特殊值（specialValue）所处区域是否透明。
 * @param {number} [options.verticalSpacing] - 格网垂直间隔大小。
 * @usage
 */
class Grid extends UGCSubLayer {


    constructor(options) {
        options = options || {};
        super(options);

        /**
         * @member {Array.<ColorDictionary>} Grid.prototype.colorDictionarys
         * @description 颜色对照表对象。
         */
        this.colorDictionarys = null;

        /**
         * @member {number} Grid.prototype.brightness
         * @description Grid 图层的亮度。
         */
        this.brightness = null;

        /**
         * @member {ColorGradientType} Grid.prototype.colorGradientType
         * @description 渐变颜色枚举值。
         */
        this.colorGradientType = null;

        /**
         * @member {ServerColor} Grid.prototype.colors
         * @description 颜色表对象。
         */
        this.colors = null;

        /**
         * @member {number} Grid.prototype.contrast
         * @description Grid 图层的对比度。
         */
        this.contrast = null;

        /**
         * @member {ServerStyle} Grid.prototype.dashStyle
         * @description 栅格数据集特殊值数据的颜色。
         */
        this.dashStyle = null;

        /**
         * @member {GridType} Grid.prototype.gridType
         * @description 格网类型。
         */
        this.gridType = null;

        /**
         * @member {number} Grid.prototype.horizontalSpacing
         * @description 格网水平间隔大小。
         */
        this.horizontalSpacing = null;

        /**
         * @member {boolean} Grid.prototype.sizeFixed
         * @description 格网是否固定大小，如果不固定大小，则格网随着地图缩放。
         */
        this.sizeFixed = null;

        /**
         * @member {ServerStyle} Grid.prototype.solidStyle
         * @description 格网实线的样式。
         */
        this.solidStyle = null;

        /**
         * @member {ServerColor} Grid.prototype.specialColor
         * @description 栅格数据集无值数据的颜色。
         */
        this.specialColor = null;

        /**
         * @member {number} Grid.prototype.specialValue
         * @description 图层的特殊值。
         */
        this.specialValue = null;

        /**
         * @member {boolean} Grid.prototype.specialValueTransparent
         * @description 图层的特殊值（specialValue）所处区域是否透明。
         */
        this.specialValueTransparent = null;

        /**
         * @member {number} Grid.prototype.verticalSpacing
         * @description 格网垂直间隔大小。
         */
        this.verticalSpacing = null;


        this.CLASS_NAME = "SuperMap.Grid";
    }

    /**
     * @function Grid.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        super.destroy();
        Util_Util.reset(this);
    }

    /**
     * @function Grid.prototype.fromJson
     * @description 将服务端 JSON 对象转换成当前客户端对象。
     * @param {Object} jsonObject - 要转换的 JSON 对象。
     */
    fromJson(jsonObject) {
        super.fromJson(jsonObject);
        if (this.specialColor) {
            this.specialColor = new ServerColor(this.specialColor.red,
                this.specialColor.green,
                this.specialColor.blue);
        }
        if (this.colors) {
            var colors = [],
                color;
            for (var i in this.colors) {
                color = this.colors[i];
                colors.push(new ServerColor(color.red, color.green, color.blue));
            }
            this.colors = colors;
        }
        if (this.dashStyle) {
            this.dashStyle = new ServerStyle(this.dashStyle);
        }
        if (this.solidStyle) {
            this.solidStyle = new ServerStyle(this.solidStyle);
        }
        if (this.colorDictionary) {
            var colorDics = [],
                colorDic;
            for (var key in this.colorDictionary) {
                colorDic = this.colorDictionary[key];
                colorDics.push(new ColorDictionary({elevation: key, color: colorDic}));
            }
            this.colorDictionarys = colorDics;
        }
        delete this.colorDictionary;
    }

    /**
     * @function Grid.prototype.toServerJSONObject
     * @description 转换成对应的 JSON 对象。
     * @returns JSON 对象。
     */
    toServerJSONObject() {
        var jsonObject = super.toServerJSONObject();

        if (jsonObject.dashStyle) {
            if (jsonObject.dashStyle.toServerJSONObject) {
                jsonObject.dashStyle = jsonObject.dashStyle.toServerJSONObject();
            }
        }
        if (jsonObject.solidStyle) {
            if (jsonObject.solidStyle.toServerJSONObject) {
                jsonObject.solidStyle = jsonObject.solidStyle.toServerJSONObject();
            }
        }
        return jsonObject;
    }

}


;// CONCATENATED MODULE: ./src/common/iServer/Image.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/




/**
 * @class UGCImage
 * @deprecatedclass SuperMap.Image
 * @category iServer Map Layer
 * @classdesc SuperMap 影像图层类
 * @extends {UGCSubLayer}
 * @param {Object} options - 可选参数。
 * @param {ColorSpaceType} [options.colorSpaceType] - 返回影像图层的色彩显示模式。
 * @param {number} [options.brightness] - 影像图层的亮度。
 * @param {Array.<number>} [options.displayBandIndexes] - 返回当前影像图层显示的波段索引。
 * @param {number} [options.contrast] - 影像图层的对比度。
 * @param {boolean} [options.transparent] - 是否背景透明。
 * @param {ServerColor} [options.transparentColor] - 返回背景透明色。
 * @param {number} [options.transparentColorTolerance] - 背景透明色容限。
 * @usage
 * @private
 */
class UGCImage extends UGCSubLayer {


    constructor(options) {
        options = options || {};
        super(options);
        /**
         * @member {number} UGCImage.prototype.brightness
         * @description 影像图层的亮度。
         */
        this.brightness = null;

        /**
         * @member {ColorSpaceType} UGCImage.prototype.colorSpaceType
         * @description 返回影像图层的色彩显示模式。
         */
        this.colorSpaceType = null;

        /**
         * @member {number} UGCImage.prototype.contrast
         * @description 影像图层的对比度。
         */
        this.contrast = null;

        /**
         * @member {Array.<number>} UGCImage.prototype.displayBandIndexes
         * @description 返回当前影像图层显示的波段索引。
         */
        this.displayBandIndexes = null;

        /**
         * @member {boolean} UGCImage.prototype.transparent
         * @description 是否背景透明。
         */
        this.transparent = null;

        /**
         * @member {ServerColor} UGCImage.prototype.transparentColor
         * @description 返回背景透明色。
         */
        this.transparentColor = null;

        /**
         * @member {number} UGCImage.prototype.transparentColorTolerance
         * @description 背景透明色容限。
         */
        this.transparentColorTolerance = null;

        this.CLASS_NAME = "SuperMap.Image";
    }

    /**
     * @function UGCImage.prototype.destroy
     * @override
     */
    destroy() {
        super.destroy();
        Util_Util.reset(this);
    }

    /**
     * @function UGCImage.prototype.fromJson
     * @description 将服务端 JSON 对象转换成当前客户端对象。
     * @param {Object} jsonObject - 要转换的 JSON 对象。
     */
    fromJson(jsonObject) {
        super.fromJson(jsonObject);
        if (this.transparentColor) {
            this.transparentColor = new ServerColor(this.transparentColor.red,
                this.transparentColor.green,
                this.transparentColor.blue);
        }
    }

    /**
     * @function UGCImage.prototype.toServerJSONObject
     * @description 转换成对应的 JSON 格式对象。
     */
    toServerJSONObject() {
        return super.toServerJSONObject();
    }


}

;// CONCATENATED MODULE: ./src/common/iServer/Vector.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/




/**
 * @class Vector
 * @deprecatedclass SuperMap.Vector
 * @category  iServer Map Layer
 * @classdesc SuperMap 矢量图层类。
 * @extends {UGCSubLayer}
 * @param {Object} options - 可选参数。
 * @param {ServerStyle} [options.style] - 矢量图层的风格。
 * @usage
 */

class iServer_Vector_Vector extends UGCSubLayer {

    constructor(options) {
        options = options || {};
        super(options);
        /**
         * @member {ServerStyle} Vector.prototype.style
         * @description 矢量图层的风格。
         */
        this.style = null;

        this.CLASS_NAME = "SuperMap.Vector";
    }

    /**
     * @function Vector.prototype.destroy
     * @description 销毁对象，将其属性置空。
     * @override
     */
    destroy() {
        super.destroy();
        Util_Util.reset(this);
    }

    /**
     * @function Vector.prototype.fromJson
     * @description 将服务端 JSON 对象转换成当前客户端对象。
     * @param {Object} jsonObject - 要转换的 JSON 对象。
     */
    fromJson(jsonObject) {
        super.fromJson(jsonObject);
        var sty = this.style;
        if (sty) {
            this.style = new ServerStyle(sty);
        }
    }

    /**
     * @function Vector.prototype.toServerJSONObject
     * @description 转换成对应的 JSON 格式对象。
     * @returns {Object} 对应的 JSON 格式对象
     */
    toServerJSONObject() {
        var jsonObject = super.toServerJSONObject();
        if (jsonObject.style) {
            if (jsonObject.style.toServerJSONObject) {
                jsonObject.style = jsonObject.style.toServerJSONObject();
            }
        }
        return jsonObject;
    }
}


;// CONCATENATED MODULE: ./src/common/iServer/GetLayersInfoService.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/







/**
 * @class GetLayersInfoService
 * @deprecatedclass SuperMap.GetLayersInfoService
 * @category iServer Map Layer
 * @classdesc 获取图层信息服务类构造函数。
 * @extends {CommonServiceBase}
 * @param {string} url - 服务地址。请求地图服务,URL 应为：
 *        http://{服务器地址}:{服务端口号}/iserver/services/{地图服务名}/rest/maps/{地图名}；
 *        如 http://localhost:8090/iserver/services/map-world/rest/maps/World 。
 *        如果查询临时图层的信息，请指定完成的url，包含临时图层ID信息，如：
 *        http://localhost:8090/iserver/services/map-world/rest/maps/World/tempLayersSet/resourceID
 * @param {Object} options - 参数。
 * @param {DataFormat} [options.format=DataFormat.GEOJSON] - 查询结果返回格式，目前支持 iServerJSON 和 GeoJSON 两种格式。参数格式为 "ISERVER"，"GEOJSON"。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @param {boolean} options.isTempLayers - 当前url对应的图层是否是临时图层。
 * @usage
 */
class GetLayersInfoService extends CommonServiceBase {


    constructor(url, options) {
        super(url, options);
        /**
         * @member {boolean} GetLayersInfoService.prototype.isTempLayers
         * @description 当前url对应的图层是否是临时图层。
         */
        this.isTempLayers = false;
        if (options) {
            Util_Util.extend(this, options);
        }
        this.CLASS_NAME = "SuperMap.GetLayersInfoService";
    }

    /**
     * @function GetLayersInfoService.prototype.destroy
     * @override
     */
    destroy() {
        super.destroy();
        Util_Util.reset(this);
    }

    /**
     * @function GetLayersInfoService.prototype.processAsync
     * @description 负责将客户端的更新参数传递到服务端。
     * @returns {Promise} Promise 对象。
     */
    processAsync(callback) {
        var me = this,
            method = "GET";
        if (!me.isTempLayers) {
            me.url = Util_Util.urlPathAppend(me.url, 'layers');
        }
        return me.request({
            method: method,
            params: null,
            scope: me,
            success: callback,
            failure: callback
        });
    }

    /**
     * @function GetLayersInfoService.prototype.transformResult
     * @description 状态完成时转换结果。
     * @param {Object} result - 服务器返回的结果对象。
     * @param {Object} options - 请求参数。
     * @return {Object} 转换结果。
     */
    transformResult(result, options) {
        var me = this, existRes, layers, len;
        result = Util_Util.transformResult(result);
        existRes = !!result && result.length > 0;
        layers = existRes ? result[0].subLayers.layers : null;
        len = layers ? layers.length : 0;
        me.handleLayers(len, layers);
        return { result: result[0], options };
    }

    /**
     * TODO 专题图时候可能会用到
     * @function GetLayersInfoService.prototype.handleLayers
     * @description 处理 iServer 新增图层组数据 (subLayers.layers 中可能还会含有 subLayers.layers)
     * @param {number} len - subLayers.layers的长度
     * @param {Array.<number>} layers - subLayers.layers的长度数组
     */
    handleLayers(len, layers) {
        var me = this, tempLayer;
        if (len) {
            for (var i = 0; i < len; i++) {
                if (layers[i].subLayers && layers[i].subLayers.layers && layers[i].subLayers.layers.length > 0) {
                    me.handleLayers(layers[i].subLayers.layers.length, layers[i].subLayers.layers);
                } else {
                    var type = layers[i].ugcLayerType;
                    switch (type) {
                        case 'THEME':
                            tempLayer = new ServerTheme();
                            tempLayer.fromJson(layers[i]);
                            layers[i] = tempLayer;
                            break;
                        case 'GRID':
                            tempLayer = new Grid();
                            tempLayer.fromJson(layers[i]);
                            layers[i] = tempLayer;
                            break;
                        case 'IMAGE':
                            tempLayer = new UGCImage();
                            tempLayer.fromJson(layers[i]);
                            layers[i] = tempLayer;
                            break;
                        case 'VECTOR':
                            tempLayer = new iServer_Vector_Vector();
                            tempLayer.fromJson(layers[i]);
                            layers[i] = tempLayer;
                            break;
                        default:
                            break;
                    }
                }

            }
        }
    }
}

;// CONCATENATED MODULE: ./src/common/iServer/GetLayersLegendInfoService.js
/* Copyright© 2000 - 2022 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/



/**
 * @class GetLayersLegendInfoService
 * @deprecatedclass SuperMap.GetLayersLegendInfoService
 * @category iServer Map Layer
 * @classdesc 获取图例信息服务类构造函数。
 * @version 11.1.1
 * @extends {CommonServiceBase}
 * @param {string} url - 服务地址。请求地图服务,URL 应为：
 *        http://{服务器地址}:{服务端口号}/iserver/services/{地图服务名}/rest/maps/{地图名}；
 *        如 http://localhost:8090/iserver/services/map-world/rest/maps/World 。
 * @param {Object} options - 参数。
 * @param {DataFormat} [options.format=DataFormat.GEOJSON] - 查询结果返回格式，目前支持 iServerJSON 和 GeoJSON 两种格式。参数格式为 "ISERVER"，"GEOJSON"。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @usage
 */
class GetLayersLegendInfoService extends CommonServiceBase {


    constructor(url, options) {
        super(url, options);
        if (options) {
            Util_Util.extend(this, options);
        }
        this.CLASS_NAME = "SuperMap.GetLayersLegendInfoService";
    }

    /**
     * @function GetLayersLegendInfoService.prototype.destroy
     * @override
     */
    destroy() {
        super.destroy();
        Util_Util.reset(this);
    }

    /**
     * @function GetLayersLegendInfoService.prototype.processAsync
     * @description 负责将客户端的更新参数传递到服务端。
     */
    processAsync(params, callback) {
        var me = this,
          method = "GET";
        me.url = Util_Util.urlPathAppend(me.url, "/legend");
        return me.request({
          method: method,
          params: params,
          scope: me,
          success: callback,
          failure: callback
        });
    }

}

;// CONCATENATED MODULE: ./src/common/iServer/SetLayerInfoService.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/



/**
 * @class SetLayerInfoService
 * @deprecatedclass SuperMap.SetLayerInfoService
 * @category  iServer Map TempLayersSet
 * @classdesc 设置图层信息服务类。可以实现临时图层中子图层的修改
 *            该类负责将图层设置参数传递到服务端，并获取服务端返回的结果信息。
 * @extends {CommonServiceBase}
 * @param {string} url - 服务地址。请求地图服务，URL 应为：
 *                 http://{服务器地址}:{服务端口号}/iserver/services/{地图服务名}/rest/maps/{地图名}/tempLayersSet/{tempLayerID}/Rivers@World@@World"；
 * @param {Object} options - 参数。
 * @param {DataFormat} [options.format=DataFormat.GEOJSON] - 查询结果返回格式，目前支持 iServerJSON 和 GeoJSON 两种格式。参数格式为 "ISERVER"，"GEOJSON"。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @usage
 */
class SetLayerInfoService extends CommonServiceBase {


    constructor(url, options) {
        super(url, options);
        if (options) {
            Util_Util.extend(this, options);
        }
        this.CLASS_NAME = "SuperMap.SetLayerInfoService";
    }

    /**
     * @override
     */
    destroy() {
        super.destroy();
        Util_Util.reset(this);
    }

    /**
     * @function SetLayerInfoService.prototype.processAsync
     * @description 负责将客户端的更新参数传递到服务端。
     * @param {Object} params - 修改后的图层资源信息。
     *        该参数可以使用获取图层信息服务<{@link GetLayersInfoService}>返回图层信息，解析结果result.subLayers.layers[i]，然后对其属性进行修改来获取。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    processAsync(params, callback) {
        if (!params) {
            return;
        }
        var me = this;
        var jsonParamsStr = Util_Util.toJSON(params);
        return me.request({
            method: "PUT",
            data: jsonParamsStr,
            scope: me,
            success: callback,
            failure: callback
        });
    }
}


;// CONCATENATED MODULE: ./src/common/iServer/SetLayersInfoService.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/



/**
 * @class SetLayersInfoService
 * @deprecatedclass SuperMap.SetLayersInfoService
 * @category  iServer Map TempLayersSet
 * @classdesc  设置图层信息服务类。可以实现创建新的临时图层和对现有临时图层的修改，
 *             当 isTempLayers 为 false的时候执行创建临时图层。当 isTempLayers 为 ture 并且临时图层资源 resourceID 被设置有效时执行对临时图层的编辑。
 *             该类负责将图层设置参数传递到服务端，并获取服务端返回的结果信息。
 * @extends {CommonServiceBase}
 * @param url - {string} 服务地址。请求地图服务,URL 应为：
 *              http://{服务器地址}:{服务端口号}/iserver/services/{地图服务名}/rest/maps/{地图名}；
 * @param {Object} options - 参数。
 * @param {string} options.resourceID - 图层资源ID，临时图层的资源ID标记。
 * @param {boolean} options.isTempLayers - 当前url对应的图层是否是临时图层。
 * @param {DataFormat} [options.format=DataFormat.GEOJSON] - 查询结果返回格式，目前支持 iServerJSON 和 GeoJSON 两种格式。参数格式为 "ISERVER"，"GEOJSON"。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @usage
 */
class SetLayersInfoService extends CommonServiceBase {


    constructor(url, options) {
        super(url, options);
        /**
         * @member {string} SetLayersInfoService.prototype.resourceID
         * @description 图层资源ID，临时图层的资源ID标记。
         */
        this.resourceID = null;

        /**
         * @function {boolean} SetLayersInfoService.prototype.isTempLayers
         * @description 当前url对应的图层是否是临时图层。
         */
        this.isTempLayers = false;

        if (options) {
            Util_Util.extend(this, options);
        }

        this.CLASS_NAME = "SuperMap.SetLayersInfoService";
    }

    /**
     * @override
     */
    destroy() {
        super.destroy();
        Util_Util.reset(this);
    }

    /**
     * @function SetLayersInfoService.prototype.processAsync
     * @description 负责将客户端的更新参数传递到服务端。
     * @param {Object} params - 修改后的图层资源信息。该参数可以使用获取图层信息服务 <{@link GetLayersInfoService}>返回图层信息，然后对其属性进行修改来获取。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    processAsync(params, callback) {
        if (!params) {
            return;
        }
        var jsonParams,
            subLayers = [],
            me = this,
            method = "";


        //创建临时图层和设置修改临时图层信息对应不同的资源URL
        if (me.isTempLayers) {
            me.url = Util_Util.urlPathAppend(me.url, "tempLayersSet/" + me.resourceID);
            method = "PUT";
        } else {
            me.url = Util_Util.urlPathAppend(me.url, "tempLayersSet");
            method = "POST";
        }
        if (!params.subLayers) {
            params.subLayers = {layers: []}
        }
        if (!params.subLayers.layers) {
            params.subLayers.layers = [];
        }
        var layers = params.subLayers.layers,
            len = layers.length;
        for (let i in layers) {
            if (layers[i].ugcLayerType === "GRID") {
                var colorDictionary = {};
                var colorDics = layers[i].colorDictionarys;
                for (var j in colorDics) {
                    var key = colorDics[j].elevation;
                    colorDictionary[key] = colorDics[j].color;
                }
            }
            layers[i].colorDictionary = colorDictionary;
            delete layers[i].colorDictionarys;
        }

        for (let i = 0; i < len; i++) {
            if (layers[i].toJsonObject) {
                //将图层信息转换成服务端能识别的简单json对象
                subLayers.push(layers[i].toJsonObject());
            } else {
                subLayers.push(layers[i]);
            }
        }
        jsonParams = Util_Util.extend(jsonParams, params);
        jsonParams.subLayers = {"layers": subLayers};
        jsonParams.object = null;
        var jsonParamsStr = Util_Util.toJSON([jsonParams]);
        return me.request({
            method: method,
            data: jsonParamsStr,
            scope: me,
            success: callback,
            failure: callback
        });
    }

}


;// CONCATENATED MODULE: ./src/common/iServer/SetLayerStatusParameters.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


/**
 * @class SetLayerStatusParameters
 * @deprecatedclass SuperMap.SetLayerStatusParameters
 * @category  iServer Map TempLayersSet
 * @classdesc 子图层显示控制参数类，该类存储了各子图层是否可见的状态。
 *            注意在 SuperMap iClient 系列产品中所说的图层与 SuperMap Deskpro 的地图对应，子图层与 SuperMap Deskpro 的图层对应。
 * @param {Object} options - 参数。
 * @param {Array.<LayerStatus>} options.layerStatusList - 获取或设置图层可见状态（{@link LayerStatus}）集合，
 *                                                                 集合中的每个 {@link LayerStatus} 对象代表一个子图层的可视状态。
 * @param {number} [options.holdTime=15] - 获取或设置资源在服务端保存的时间。
 * @param {string} [options.resourceID] - 获取或设置资源服务 ID。
 * @usage
 */
class SetLayerStatusParameters {

    constructor(options) {
        /**
         * @member {Array.<LayerStatus>} SetLayerStatusParameters.prototype.layerStatusList
         * @description 获取或设置图层可见状态（{@link LayerStatus}）集合，集合中的每个 {@link LayerStatus} 对象代表一个子图层的可视状态。
         */
        this.layerStatusList = [];

        /**
         * @member {number} [SetLayerStatusParameters.prototype.holdTime=15]
         * @description 获取或设置资源在服务端保存的时间。单位为分钟。
         */
        this.holdTime = 15;

        /**
         * @member {string} SetLayerStatusParameters.prototype.resourceID
         * @description 获取或设置资源服务ID。如果设置该参数则会在指定的 TempLayer 中进行图层的显示控制；
         *              如果不设置该参数，则会首先创建一个 TempLayer ，然后在新创建的 TempLayer 中进行图层的显示控制。
         */
        this.resourceID = null;

        if (options) {
            Util_Util.extend(this, options);
        }


    }

    /**
     * @function SetLayerStatusParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        var me = this;
        me.layerStatusList = null;
        me.holdTime = null;
        me.resourceID = null;
    }

    /**
     * @function SetLayerStatusParameters.prototype.toJSON
     * @description 生成 JSON。
     * @returns {Object} 对应的 JSON 对象。
     */
    toJSON() {
        var json = '{';
        json += '"layers":[';
        var v = [];
        for (var i = 0, len = this.layerStatusList.length; i < len; i++) {
            v.push(this.layerStatusList[i].toJSON());
        }

        json += v;
        json += ']';
        json += '}';

        return json;
    }

}

;// CONCATENATED MODULE: ./src/common/iServer/SetLayerStatusService.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/




/**
 * @class SetLayerStatusService
 * @deprecatedclass SuperMap.SetLayerStatusService
 * @category  iServer Map TempLayersSet
 * @classdesc  子图层显示控制服务类。该类负责将子图层显示控制参数传递到服务端，并获取服务端返回的图层显示状态。
 *             用户获取服务端返回的各子图层显示状态有两种方式：
 *             一种是通过监听 SetLayerEvent.PROCESS_COMPLETE 事件；
 *             一种是使用 AsyncResponder 类实现异步处理。
 * @extends {CommonServiceBase}
 * @param {string} url - 服务地址。请求地图服务，URL 应为：
 *                       http://{服务器地址}:{服务端口号}/iserver/services/{地图服务名}/rest/maps/{地图名}；
 * @param {Object} options - 参数。
 * @param {DataFormat} [options.format=DataFormat.GEOJSON] - 查询结果返回格式，目前支持 iServerJSON 和 GeoJSON 两种格式。参数格式为 "ISERVER"，"GEOJSON"。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @usage
 */
class SetLayerStatusService extends CommonServiceBase {



    constructor(url, options) {
        super(url, options);
        this.lastparams = null;

        this.mapUrl = url;
        if (options) {
            Util_Util.extend(this, options);
        }
        this.CLASS_NAME = "SuperMap.SetLayerStatusService";
    }

    /**
     * @override
     */
    destroy() {
        super.destroy();
        Util_Util.reset(this);
    }


    /**
     * @function SetLayerStatusService.prototype.processAsync
     * @description 负责将客户端的更新参数传递到服务端。
     * @param {Object} params - 修改后的图层资源信息。该参数可以使用获取图层信息服务{@link SetLayerStatusParameters}
     *                          返回图层信息，然后对其属性进行修改来获取。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    processAsync(params, callback) {
        if (!(params instanceof SetLayerStatusParameters)) {
            return;
        }
        var me = this,
            method = "POST";
        me.url = me.mapUrl;

        if (params.resourceID == null) {
            me.url = Util_Util.urlPathAppend(me.url, 'tempLayersSet');
            me.lastparams = params;

            return me.request({
                method: method,
                scope: me,
                success: me.createTempLayerComplete.bind(me, callback),
                failure: callback
            });
        } else {
            me.url = Util_Util.urlPathAppend(me.url, "tempLayersSet/" + params.resourceID);
            me.url = Util_Util.urlAppend(me.url, "elementRemain=true&reference=" + params.resourceID + "&holdTime=" + params.holdTime.toString());

            var jsonParameters = '[{';

            jsonParameters += '"type":"UGC",';
            if (params.layerStatusList != null && params.layerStatusList.length > 0) {
                jsonParameters += '"subLayers":' + params.toJSON();
            }
            jsonParameters += ',"visible":' + true + ',';
            jsonParameters += '"name":"' + this.getMapName(this.mapUrl) + '"';

            jsonParameters += '}]';

            return me.request({
                method: "PUT",
                data: jsonParameters,
                scope: me,
                success: callback,
                failure: callback
            });
        }
    }

    /**
     * @function SetLayerStatusService.prototype.createTempLayerComplete
     * @description 设置完成，执行此方法。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @param {Object} result - 服务器返回的结果对象，记录设置操作是否成功。
     * @returns {Promise} Promise 对象。
     */
    createTempLayerComplete(callback, result) {
        var me = this;
        result.result = Util_Util.transformResult(result.result);
        if (result.result.succeed) {
            me.lastparams.resourceID = result.result.newResourceID;
        }

        return me.processAsync(me.lastparams, callback);
    }

    /**
     * @function SetLayerStatusService.prototype.getMapName
     * @description 获取地图名称。
     * @param {Object} url - 服务地址。
     */
    getMapName(url) {
        var mapUrl = url;
        if (mapUrl.charAt(mapUrl.length - 1) === "/") {
            mapUrl = mapUrl.substr(0, mapUrl.length - 1);
        }
        var index = mapUrl.lastIndexOf("/");
        var mapName = mapUrl.substring(index + 1, mapUrl.length);
        return mapName;
    }

    /**
     * @function SetLayerStatusService.prototype.transformResult
     * @description 状态完成时转换结果。
     * @param {Object} result - 服务器返回的结果对象，记录设置操作是否成功。
     * @param {Object} options - 请求参数。
     * @return {Object} 转换结果。
     */
    transformResult(result, options) {
      var me = this;
      result = Util_Util.transformResult(result);
      if (result != null && me.lastparams != null && me.lastparams.resourceID != null) {
          result.newResourceID = me.lastparams.resourceID;
      }
      return { result, options };
    }
}


;// CONCATENATED MODULE: ./src/common/iServer/LayerInfoService.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/







/**
 * @class LayerInfoService
 * @category  iServer Map Layer
 * @classdesc 图层信息服务类。
 * @extends {ServiceBase}
 * @example
 *      new LayerInfoService(url).getLayersInfo(function(result){
 *           //doSomething
 *      })
 * @param {string} url - 服务地址。请求地图服务，URL 应为：
 *                       http://{服务器地址}:{服务端口号}/iserver/services/{地图服务名}/rest/maps/{地图名}/tempLayersSet/{tempLayerID}/Rivers@World@@World"。
 * @param {Object} options - 参数。
 * @param {string} [options.proxy] - 服务代理地址。
 * @param {boolean} [options.withCredentials=false] - 请求是否携带cookie。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @usage
 */
class LayerInfoService_LayerInfoService {

    constructor(url, options) {
      this.url = url;
      this.options = options || {};
    }

    /**
     * @function LayerInfoService.prototype.getLayersInfo
     * @description 获取图层信息服务。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    getLayersInfo(callback) {
        var me = this;
        var getLayersInfoService = new GetLayersInfoService(me.url, {
            proxy: me.options.proxy,
            withCredentials: me.options.withCredentials,
            crossOrigin: me.options.crossOrigin,
            headers: me.options.headers
        });
        return getLayersInfoService.processAsync(callback);
    }

    /**
     * @function LayerInfoService.prototype.getLayersLegendInfo
     * @version 11.1.1
     * @description 获取地图的图例信息。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    getLayersLegendInfo(params, callback) {
      var me = this;
      var getLayersLegendInfoService = new GetLayersLegendInfoService(me.url, {
          proxy: me.options.proxy,
          withCredentials: me.options.withCredentials,
          crossOrigin: me.options.crossOrigin,
          headers: me.options.headers
      });
      return getLayersLegendInfoService.processAsync(params, callback);
    }

    /**
     * @function LayerInfoService.prototype.setLayerInfo
     * @description 设置图层信息服务。可以实现临时图层中子图层的修改。
     * @param {SetLayerInfoParameters} params - 设置图层信息参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    setLayerInfo(params, callback) {
        if (!params) {
            return;
        }
        var me = this,
            resourceID = params.resourceID,
            tempLayerName = params.tempLayerName,
            layerInfoParams = params.layerInfo;
        if (!resourceID || !tempLayerName) {
            return;
        }
        var url = Util_Util.urlPathAppend(me.url, "tempLayersSet/" + resourceID + "/" + tempLayerName);
        var setLayerInfoService = new SetLayerInfoService(url, {
            proxy: me.options.proxy,
            withCredentials: me.options.withCredentials,
            crossOrigin: me.options.crossOrigin,
            headers: me.options.headers
        });
        return setLayerInfoService.processAsync(layerInfoParams, callback);
    }

    /**
     * @function LayerInfoService.prototype.setLayersInfo
     * @description 设置图层信息服务。可以创建新的临时图层和修改现有的临时图层。
     * @param {SetLayersInfoParameters} params - 设置图层信息参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    setLayersInfo(params, callback) {
        if (!params) {
            return;
        }
        var me = this,
            resourceID = params.resourceID,
            isTempLayers = params.isTempLayers ? params.isTempLayers : false,
            layersInfo = params.layersInfo;
        if ((isTempLayers && !resourceID) || !layersInfo) {
            return;
        }
        var setLayersInfoService = new SetLayersInfoService(me.url, {
            proxy: me.options.proxy,
            withCredentials: me.options.withCredentials,
            crossOrigin: me.options.crossOrigin,
            headers: me.options.headers,
            resourceID: resourceID,
            isTempLayers: isTempLayers
        });
        return setLayersInfoService.processAsync(layersInfo, callback);
    }

    /**
     * @function LayerInfoService.prototype.setLayerStatus
     * @description 子图层显示控制服务。负责将子图层显示控制参数传递到服务端，并获取服务端返回的图层显示状态。
     * @param {SetLayerStatusParameters} params - 子图层显示控制参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    setLayerStatus(params, callback) {
        if (!params) {
            return;
        }
        var me = this;
        var setLayerStatusService = new SetLayerStatusService(me.url, {
            proxy: me.options.proxy,
            withCredentials: me.options.withCredentials,
            crossOrigin: me.options.crossOrigin,
            headers: me.options.headers
        });
        return setLayerStatusService.processAsync(params, callback);
    }
}

;// CONCATENATED MODULE: ./src/mapboxgl/services/LayerInfoService.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/



/**
 * @class LayerInfoService
 * @category  iServer Map Layer
 * @classdesc 图层信息服务类。
 * @modulecategory Services
 * @extends {ServiceBase}
 * @example
 * new LayerInfoService(url).getLayersInfo(function(result){
 *     //doSomething
 * })
 * @param {string} url - 服务地址。请求地图服务,URL 应为：</br>
 *                       http://{服务器地址}:{服务端口号}/iserver/services/{地图服务名}/rest/maps/{地图名}/tempLayersSet/{tempLayerID}/Rivers@World@@World"。
 * @param {Object} options - 参数。
 * @param {string} [options.proxy] - 服务代理地址。
 * @param {boolean} [options.withCredentials=false] - 请求是否携带 cookie。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @usage
 */
class LayerInfoService extends ServiceBase {

    constructor(url, options) {
        super(url, options);
        this._layerInfoService = new LayerInfoService_LayerInfoService(url, options);
    }

    /**
     * @function LayerInfoService.prototype.getLayersInfo
     * @description 获取图层信息服务。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {LayerInfoService} 返回图层信息类。
     */
    getLayersInfo(callback) {
      return this._layerInfoService.getLayersInfo(callback);
    }

    /**
     * @function LayerInfoService.prototype.getLayersLegendInfo
     * @description 获取地图的图例信息。
     * @version 11.1.1
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    getLayersLegendInfo(params, callback) {
      return this._layerInfoService.getLayersLegendInfo(params, callback);
    }

    /**
     * @function LayerInfoService.prototype.setLayerInfo
     * @description 设置图层信息服务。可以实现临时图层中子图层的修改。
     * @param {SetLayerInfoParameters} params - 设置图层信息参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    setLayerInfo(params, callback) {
      return this._layerInfoService.setLayerInfo(params, callback);
    }

    /**
     * @function LayerInfoService.prototype.setLayersInfo
     * @description 设置图层信息服务。可以实现创建新的临时图层和对现有临时图层的修改。
     * @param {SetLayersInfoParameters} params - 设置图层信息参数类,包括临时图层。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    setLayersInfo(params, callback) {
      return this._layerInfoService.setLayersInfo(params, callback);
    }

    /**
     * @function LayerInfoService.prototype.setLayerStatus
     * @description 子图层显示控制服务。负责将子图层显示控制参数传递到服务端，并获取服务端返回的图层显示状态。
     * @param {SetLayerStatusParameters} params - 子图层显示控制参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    setLayerStatus(params, callback) {
      return this._layerInfoService.setLayerStatus(params, callback);
    }
}

;// CONCATENATED MODULE: ./src/common/iServer/MapService.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/



/**
 * @class MapService
 * @deprecatedclass SuperMap.MapService
 * @category iServer Map
 * @classdesc 地图信息服务类。
 * @extends {CommonServiceBase}
 * @example
 * var myMapService = new MapService(url);
 *
 * @param {string} url - 服务地址。如：http://localhost:8090/iserver/services/map-world/rest/maps/World+Map 。
 * @param {Object} options - 参数。
 * @param {DataFormat} [options.format=DataFormat.GEOJSON] - 查询结果返回格式，目前支持 iServerJSON 和 GeoJSON 两种格式。参数格式为 "ISERVER"，"GEOJSON"。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @usage
 */
class MapService_MapService extends CommonServiceBase {


    constructor(url, options) {
        super(url, options);
        /**
         * @member {string} MapService.prototype.projection
         * @description 根据投影参数获取地图状态信息。如"EPSG:4326"
         */
        this.projection = null;

        this.CLASS_NAME = "SuperMap.MapService";
        if (options) {
            Util_Util.extend(this, options);
        }
        var me = this;

        if (me.projection) {
            var arr = me.projection.split(":");
            if (arr instanceof Array) {
                if (arr.length === 2) {
                    me.url = Util_Util.urlAppend(me.url,`prjCoordSys=${encodeURIComponent(`{\"epsgCode\":"${arr[1]}"}`)}`)
                }
                if (arr.length === 1) {
                    me.url = Util_Util.urlAppend(me.url,`prjCoordSys=${encodeURIComponent(`{\"epsgCode\":"${arr[0]}"}`)}`)
                }
            }
        }
    }

    /**
     * @function MapService.prototype.destroy
     * @description 释放资源，将引用的资源属性置空。
     */
    destroy() {
        super.destroy();
    }

    /**
     * @function MapService.prototype.processAsync
     * @description 负责将客户端的设置的参数传递到服务端，与服务端完成异步通讯。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    processAsync(callback) {
        var me = this;
        return me.request({
            method: "GET",
            scope: me,
            success: callback,
            failure: callback
        });
    }

    /**
     * @function MapService.prototype.transformResult
     * @description 状态完成时转换结果。
     * @param {Object} result - 服务器返回的结果对象。
     * @param {Object} options - 请求参数。
     * @return {Object} 转换结果。
     */
    transformResult(result, options) {
        result = Util_Util.transformResult(result);
        var codeStatus = (result.code >= 200 && result.code < 300) || result.code == 0 || result.code === 304;
        var isCodeValid = result.code && codeStatus;
        if (!result.code || isCodeValid) {
            return {result: result, options};
        } else {
            ////在没有token是返回的是200，但是其实是没有权限，所以这里也应该是触发失败事件
            return {error: result, options};
        }
    }
}


;// CONCATENATED MODULE: ./src/common/iServer/TilesetsService.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/



/**
 * @class TilesetsService
 * @deprecatedclass SuperMap.TilesetsService
 * @category  iServer Map Tilesets
 * @classdesc 切片列表信息查询服务类；即查询切片地图服务的切片列表，返回切片集名称、地图切片元数据信息、切片版本集信息。
 * @extends {CommonServiceBase}
 * @param {string} url - 服务地址。URL 应为：
 *                       http://{服务器地址}:{服务端口号}/iserver/services/{服务名}/rest/maps/map；
 *                       例如: "http://localhost:8090/iserver/services/test/rest/maps/tianlocal"。
 * @param {Object} options - 参数。
 * @param {DataFormat} [options.format=DataFormat.GEOJSON] - 查询结果返回格式，目前支持 iServerJSON 和 GeoJSON 两种格式。参数格式为 "ISERVER"，"GEOJSON"。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @usage
 */
class TilesetsService extends CommonServiceBase {

    constructor(url, options) {
        super(url, options);
        this.CLASS_NAME = "SuperMap.TilesetsService";
    }

    /**
     * @override
     */
    destroy() {
        super.destroy();
    }

    /**
     * @function TilesetsService.prototype.processAsync
     * @description 负责将客户端的查询参数传递到服务端。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    processAsync(callback) {
        if (!this.url) {
            return;
        }
        var me = this;
        me.url = Util_Util.urlPathAppend(me.url, 'tilesets');
        return me.request({
            method: "GET",
            scope: me,
            success: callback,
            failure: callback
        });
    }
}

;// CONCATENATED MODULE: ./src/mapboxgl/services/MapService.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/





/**
 * @class MapService
 * @category  iServer Map
 * @classdesc 地图信息服务类。
 * @modulecategory Services
 * @extends {ServiceBase}
 * @param {string} url - 服务地址。
 * @param {Object} options - 参数。
 * @param {string} [options.proxy] - 服务代理地址。
 * @param {boolean} [options.withCredentials=false] - 请求是否携带 cookie。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @example
 * new MapService(url)
 *  .getMapInfo(function(result){
 *     //doSomething
 * })
 * @usage
 */
class MapService extends ServiceBase {

    constructor(url, options) {
        super(url, options);
    }

    /**
     * @function MapService.prototype.getMapInfo
     * @description 地图信息查询服务。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    getMapInfo(callback) {
        var me = this;
        var getMapStatusService = new MapService_MapService(me.url, {
            proxy: me.options.proxy,
            withCredentials: me.options.withCredentials,
            crossOrigin: me.options.crossOrigin,
            headers: me.options.headers,
            projection: me.options.projection
        });
        return getMapStatusService.processAsync(callback);
    }

    /**
     * @function MapService.prototype.getWKT
     * @description 获取WKT。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    getWKT(callback) {
      var me = this;
      var getMapStatusService = new MapService_MapService(`${me.url}/prjCoordSys.wkt`, {
          proxy: me.options.proxy,
          withCredentials: me.options.withCredentials,
          withoutFormatSuffix: true,
          crossOrigin: me.options.crossOrigin,
          headers: me.options.headers,
          projection: me.options.projection
      });
      return getMapStatusService.processAsync(callback);
    }

    /**
     * @function MapService.prototype.getTilesets
     * @description 切片列表信息查询服务。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    getTilesets(callback) {
        var me = this;
        var tilesetsService = new TilesetsService(me.url, {
            proxy: me.options.proxy,
            withCredentials: me.options.withCredentials,
            crossOrigin: me.options.crossOrigin,
            headers: me.options.headers
        });
        return tilesetsService.processAsync(callback);
    }
}

;// CONCATENATED MODULE: ./src/common/iServer/MeasureParameters.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/



/**
 * @class MeasureParameters
 * @deprecatedclass SuperMap.MeasureParameters
 * @category iServer Map Measure
 * @classdesc 量算参数类。
 * @param {GeoJSONObject} geometry - 要量算的几何对象。
 * @param {Object} options - 可选参数。
 * @param {Unit} [options.unit=Unit.METER] - 量算单位。
 * @param {string} [options.prjCoordSys] - 用来指定该量算操作所使用的投影。
 * @param {string} [options.distanceMode="Geodesic"] - 用来指定量算的方式为按球面长度 'Geodesic' 或者平面长度 'Planar' 来计算。
 * @usage
 */
class MeasureParameters {



    constructor(geometry, options) {
        if (!geometry) {
            return;
        }
        /**
         * @member {GeoJSONObject} MeasureParameters.prototype.geometry
         * @description 要量算的几何对象。<br>
         * 点类型可以是：{@link GeometryPoint}|{@link L.Marker}|{@link L.CircleMarker}|{@link L.Circle}|{@link L.GeoJSON}|{@link ol.geom.Point}|{@link ol.format.GeoJSON}|{@link GeoJSONObject}。<br>
         * 线类型可以是：{@link GeometryLineString}|{@link GeometryLinearRing}|{@link L.Polyline}|{@link L.GeoJSON}|{@link ol.geom.LineString}|{@link ol.format.GeoJSON}|{@link GeoJSONObject}。<br>
         * 面类型可以是：{@link GeometryPolygon}|{@link L.Polygon}|{@link L.GeoJSON}|{@link ol.geom.Polygon}|{@link ol.format.GeoJSON}|{@link GeoJSONObject}。
         */
        this.geometry = geometry;

        /**
         * @member {Unit} [MeasureParameters.prototype.unit=Unit.METER]
         * @description 量算单位。即量算结果以米为单位。
         */
        this.unit = Unit.METER;

        /**
         * @member {string} [MeasureParameters.prototype.prjCoordSys]
         * @description 用来指定该量算操作所使用的投影。
         */
        this.prjCoordSys = null;

        /**
         * @member {string} [MeasureParameters.prototype.distanceMode="Geodesic"]
         * @description 用来指定量算的方式为按球面长度 'Geodesic' 或者平面长度 'Planar' 来计算。
         * @example
         * var param = new MeasureParameters(getmetry,{distanceMode:'Planar'});
         */
        this.distanceMode = null;
        if (options) {
            Util_Util.extend(this, options);
        }
        this.CLASS_NAME = "SuperMap.MeasureParameters";
    }

    /**
     * @function MeasureParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        var me = this;
        me.geometry = null;
        me.unit = null;
        me.prjCoordSys = null;
    }
}

;// CONCATENATED MODULE: ./src/common/iServer/MeasureService.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/






/**
 * @class MeasureService
 * @deprecatedclass SuperMap.MeasureService
 * @category iServer Map Measure
 * @classdesc 量算服务类。
 *            该类负责将量算参数传递到服务端，并获取服务端返回的量算结果。
 * @extends {CommonServiceBase}
 * @example
 * var myMeasuerService = new MeasureService(url, {
 *      measureMode: MeasureMode.DISTANCE
 * });
 * @param {string} url - 服务地址。如：http://localhost:8090/iserver/services/map-world/rest/maps/World+Map 。
 * @param {Object} options - 参数。
 * @param {DataFormat} [options.format=DataFormat.GEOJSON] - 查询结果返回格式，目前支持 iServerJSON 和 GeoJSON 两种格式。参数格式为 "ISERVER"，"GEOJSON"。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @param {MeasureMode} options.measureMode - 量算模式，包括距离量算模式和面积量算模式。
 * @usage
 */
class MeasureService_MeasureService extends CommonServiceBase {


    constructor(url, options) {
        super(url, options);
        /**
         * @member {MeasureMode} [MeasureService.prototype.measureMode=MeasureMode.DISTANCE]
         * @description 量算模式，包括距离量算模式和面积量算模式。
         */
        this.measureMode = MeasureMode.DISTANCE;

        if (options) {
            Util_Util.extend(this, options);
        }
        this.CLASS_NAME = "SuperMap.MeasureService";
    }

    /**
     * @override
     */
    destroy() {
        super.destroy();
        var me = this;
        me.measureMode = null;
    }

    /**
     * @function MeasureService.prototype.processAsync
     * @description 负责将客户端的量算参数传递到服务端。
     * @param {MeasureParameters} params - 量算参数。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    processAsync(params, callback) {
        if (!(params instanceof MeasureParameters)) {
            return;
        }
        var me = this,
            geometry = params.geometry,
            pointsCount = 0,
            point2ds = null;
        if (!geometry) {
            return;
        }
        me.url = Util_Util.urlPathAppend(me.url, me.measureMode === MeasureMode.AREA ? 'area' : 'distance');
        var serverGeometry = ServerGeometry.fromGeometry(geometry);
        if (!serverGeometry) {
            return;
        }
        pointsCount = serverGeometry.parts[0];
        point2ds = serverGeometry.points.splice(0, pointsCount);

        var prjCoordSysTemp, prjCodeTemp, paramsTemp;
        if (params.prjCoordSys) {
            if (typeof (params.prjCoordSys) === "object") {
                prjCodeTemp = params.prjCoordSys.projCode;
                prjCoordSysTemp = '{"epsgCode"' + prjCodeTemp.substring(prjCodeTemp.indexOf(":"), prjCodeTemp.length) + "}";
            } else if (typeof (params.prjCoordSys) === "string") {
                prjCoordSysTemp = '{"epsgCode"' + params.prjCoordSys.substring(params.prjCoordSys.indexOf(":"), params.prjCoordSys.length) + "}";
            }
            paramsTemp = {
                "point2Ds": Util_Util.toJSON(point2ds),
                "unit": params.unit,
                "prjCoordSys": prjCoordSysTemp,
                "distanceMode": params.distanceMode || 'Geodesic'
            };
        } else {
            paramsTemp = {"point2Ds": Util_Util.toJSON(point2ds), "unit": params.unit, "distanceMode": params.distanceMode || 'Geodesic'};
        }

        return me.request({
            method: "GET",
            params: paramsTemp,
            scope: me,
            success: callback,
            failure: callback
        });
    }
}

;// CONCATENATED MODULE: ./src/mapboxgl/services/MeasureService.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/






/**
 * @class MeasureService
 * @category  iServer Map Measure
 * @classdesc 量算服务类。
 * @modulecategory Services
 * @extends {ServiceBase}
 * @param {string} url - 服务地址。如：http://localhost:8090/iserver/services/map-world/rest/maps/World+Map。
 * @param {Object} options - 参数。
 * @param {string} [options.proxy] - 服务代理地址。
 * @param {boolean} [options.withCredentials=false] - 请求是否携带 cookie。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @param {MeasureMode} [options.measureMode=MeasureMode.DISTANCE] - 量算模式，包括距离量算模式和面积量算模式。
 * @usage
 */
class MeasureService extends ServiceBase {

    constructor(url, options) {
        super(url, options);
    }

    /**
     * @function MeasureService.prototype.measureDistance
     * @description 距离量算。
     * @param {MeasureParameters} params - 量算参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    measureDistance(params, callback) {
        return this.measure(params, 'DISTANCE', callback);
    }

    /**
     * @function MeasureService.prototype.measureArea
     * @description 面积量算。
     * @param {MeasureParameters} params - 量算参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    measureArea(params, callback) {
        return this.measure(params, 'AREA', callback);
    }

    /**
     * @function MeasureService.prototype.measure
     * @description 量算。
     * @param {MeasureParameters} params - 量算参数类。
     * @param {string} type - 量算类型。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {MeasureService} 量算服务。
     */
    measure(params, type, callback) {
        var me = this;
        var measureService = new MeasureService_MeasureService(me.url, {
            proxy: me.options.proxy,
            withCredentials: me.options.withCredentials,
            crossOrigin: me.options.crossOrigin,
            headers: me.options.headers,
            measureMode: type
        });
        return measureService.processAsync(me._processParam(params), callback);
    }

    _processParam(params) {
        if (params && !(params.geometry instanceof Geometry_Geometry)) {

            params.geometry = core_Util_Util.toSuperMapGeometry(params.geometry);
        }
        return params;

    }

}

;// CONCATENATED MODULE: ./src/common/iServer/NetworkAnalystServiceBase.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/




/**
 * @class NetworkAnalystServiceBase
 * @deprecatedclass SuperMap.NetworkAnalystServiceBase
 * @category iServer Core
 * @classdesc 网络分析服务基类。
 * @extends {CommonServiceBase}
 * @param {string} url - 服务地址。
 * @param {Object} options - 可选参数。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @usage
 */
class NetworkAnalystServiceBase extends CommonServiceBase {

    constructor(url, options) {
        super(url, options);
        /**
         * @member {DataFormat} [NetworkAnalystServiceBase.prototype.format=DataFormat.GEOJSON]
         * @description 查询结果返回格式，目前支持 iServerJSON 和 GeoJSON 两种格式，参数格式为 "ISERVER","GEOJSON"
         */
        this.format = DataFormat.GEOJSON;

        this.CLASS_NAME = "SuperMap.NetworkAnalystServiceBase";
    }

    /**
     * @function NetworkAnalystServiceBase.prototype.destroy
     * @description 释放资源，将引用的资源属性置空。
     */
    destroy() {
        super.destroy();
        this.format = null;
    }

    /**
     * @function NetworkAnalystServiceBase.prototype.transformResult
     * @description 状态完成时转换结果。
     * @param {Object} result - 服务器返回的结果对象。
     * @param {Object} options - 请求参数。
     * @return {Object} 转换结果。
     */
    transformResult(result, options) {
        var me = this, analystResult;
        result = Util_Util.transformResult(result);
        if (result && me.format === DataFormat.GEOJSON && typeof me.toGeoJSONResult === 'function') {
            analystResult = me.toGeoJSONResult(result);
        }
        if (!analystResult) {
            analystResult = result;
        }
        return { result: analystResult, options };
    }

    /**
     * @function NetworkAnalystServiceBase.prototype.toGeoJSONResult
     * @description 将含有 geometry 的数据转换为 GeoJSON 格式。只处理结果中的路由，由子类实现。
     * @param {Object} result - 服务器返回的结果对象。
     * @returns {GeoJSONObject} GeoJSON 对象。
     */
    toGeoJSONResult(result) { // eslint-disable-line no-unused-vars
        return null;
    }
}

;// CONCATENATED MODULE: ./src/common/iServer/BurstPipelineAnalystParameters.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


/**
 * @class BurstPipelineAnalystParameters
 * @deprecatedclass SuperMap.BurstPipelineAnalystParameters
 * @category iServer NetworkAnalyst BurstAnalyse
 * @classdesc 爆管分析参数类。
 * @param {Object} options - 参数。
 * @param {Array.<number>} options.sourceNodeIDs - 指定的设施点 ID 数组。
 * @param {number} [options.edgeID] - 指定的弧段ID，edgeID 与 nodeID 必须指定一个。
 * @param {number} [options.nodeID] - 指定的结点ID，edgeID 与 nodeID 必须指定一个。
 * @param {boolean} [options.isUncertainDirectionValid=false] - 指定不确定流向是否有效。
 * @usage
 */
class BurstPipelineAnalystParameters {


    constructor(options) {
        var me = this;
        /**
         * @member {Array.<number>} BurstPipelineAnalystParameters.prototype.sourceNodeIDs
         * @description 指定的设施点 ID 数组。
         */
        this.sourceNodeIDs = null;

        /**
         * @member {number} [BurstPipelineAnalystParameters.prototype.edgeID]
         * @description 指定的弧段 ID，edgeID 与 nodeID 必须指定一个。
         */
        this.edgeID = null;

        /**
         * @member {number} [BurstPipelineAnalystParameters.prototype.nodeID]
         * @description 指定的结点 ID，edgeID 与 nodeID 必须指定一个。
         */
        this.nodeID = null;

        /**
         * @member {boolean} [BurstPipelineAnalystParameters.prototype.isUncertainDirectionValid=false]
         * @description 指定不确定流向是否有效。
         * 指定为 true，表示不确定流向有效，遇到不确定流向时分析继续进行。
         * 指定为 false，表示不确定流向无效，遇到不确定流向将停止在该方向上继续查找。
         */
        this.isUncertainDirectionValid = false;

        Util_Util.extend(me, options);

        this.CLASS_NAME = "SuperMap.BurstPipelineAnalystParameters";
    }

    /**
     * @function BurstPipelineAnalystParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        var me = this;
        me.sourceNodeIDs = null;
        me.edgeID = null;
        me.nodeID = null;
        me.isUncertainDirectionValid = null;
    }


}

;// CONCATENATED MODULE: ./src/common/iServer/BurstPipelineAnalystService.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/




/**
 * @class BurstPipelineAnalystService
 * @deprecatedclass SuperMap.BurstPipelineAnalystService
 * @category iServer NetworkAnalyst BurstAnalyse
 * @classdesc 爆管分析服务类。即将给定弧段或节点作为爆管点来进行分析，返回关键结点 ID 数组、普通结点 ID 数组及其上下游弧段 ID 数组。
 * @extends {NetworkAnalystServiceBase}
 * @param {string} url - 网络分析服务地址。请求网络分析服务，URL应为：
 *                       http://{服务器地址}:{服务端口号}/iserver/services/{网络分析服务名}/rest/networkanalyst/{网络数据集@数据源}，
 *                       例如: "http://localhost:8090/iserver/services/test/rest/networkanalyst/WaterNet@FacilityNet"。
 * @param {Object} options - 参数。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @usage
 */
class BurstPipelineAnalystService extends NetworkAnalystServiceBase {

    constructor(url, options) {
        super(url, options);
        this.CLASS_NAME = "SuperMap.BurstPipelineAnalystService";
    }

    /**
     * @function BurstPipelineAnalystService.prototype.destroy
     * @override
     */
    destroy() {
        super.destroy();
    }

    /**
     * @function BurstPipelineAnalystService.prototype.processAsync
     * @description 负责将客户端的查询参数传递到服务端。
     * @params {BurstPipelineAnalystParameters} params - 爆管分析参数类
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    processAsync(params, callback) {
        if (!(params instanceof BurstPipelineAnalystParameters)) {
            return null;
        }
        var me = this, jsonObject;
        me.url = Util_Util.urlPathAppend(me.url, 'burstAnalyse');
        jsonObject = {
            sourceNodeIDs: params.sourceNodeIDs,
            isUncertainDirectionValid: params.isUncertainDirectionValid
        };

        //必传参数不正确，就终止
        if (params.edgeID !== null && params.nodeID !== null) {
            throw new Error('edgeID and nodeID cannot be null at the same time.');
        }
        if (params.edgeID === null && params.nodeID === null) {
            throw new Error('edgeID and nodeID cannot be null at the same time.');
        }
        if (params.edgeID !== null) {
            jsonObject.edgeID = params.edgeID;
        } else {
            jsonObject.nodeID = params.nodeID;
        }

        return me.request({
            method: "GET",
            params: jsonObject,
            scope: me,
            success: callback,
            failure: callback
        });
    }
}

;// CONCATENATED MODULE: ./src/common/iServer/TransportationAnalystResultSetting.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


/**
 * @class TransportationAnalystResultSetting
 * @deprecatedclass SuperMap.TransportationAnalystResultSetting
 * @category  iServer NetworkAnalyst
 * @classdesc 交通网络分析结果参数类。通过该类设置交通网络分析返回的结果，包括是否返回图片、是否返回弧段空间信息、是否返回结点空间信息等。
 * @param {Object} options - 可选参数。
 * @param {boolean} [options.returnEdgeFeatures=false] - 是否在分析结果中包含弧段要素集合。
 * @param {boolean} [options.returnEdgeGeometry=false] - 返回的弧段要素集合中是否包含几何对象信息。
 * @param {boolean} [options.returnEdgeIDs=false] - 返回结果中是否包含经过弧段 ID 集合。
 * @param {boolean} [options.returnNodeFeatures=false] - 是否在分析结果中包含结点要素集合。
 * @param {boolean} [options.returnNodeGeometry=false] - 返回的结点要素集合中是否包含几何对象信息。
 * @param {boolean} [options.returnNodeIDs=false] - 返回结果中是否包含经过结点 ID 集合。
 * @param {boolean} [options.returnPathGuides=false] - 返回分析结果中是否包含行驶导引集合。
 * @param {boolean} [options.returnRoutes=false] - 返回分析结果中是否包含路由对象的集合。
 * @usage
 */
class TransportationAnalystResultSetting {

    constructor(options) {
        if (!options) {
            return;
        }

        /**
         * @member {boolean} TransportationAnalystResultSetting.prototype.returnEdgeFeatures
         * @description 是否在分析结果中包含弧段要素集合。弧段要素包括弧段的空间信息和属性信息。
         */
        this.returnEdgeFeatures = false;

        /**
         * @member {boolean} [TransportationAnalystResultSetting.prototype.returnEdgeGeometry=false]
         * @description 返回的弧段要素集合中是否包含几何对象信息。
         */
        this.returnEdgeGeometry = false;

        /**
         * @member {boolean} [TransportationAnalystResultSetting.prototype.returnEdgeIDs=false]
         * @description 返回结果中是否包含经过弧段 ID 集合。
         */
        this.returnEdgeIDs = false;

        /**
         * @member {boolean} [TransportationAnalystResultSetting.prototype.returnNodeFeatures=false]
         * @description 是否在分析结果中包含结点要素集合。
         * 结点要素包括结点的空间信息和属性信息。其中返回的结点要素是否包含空间信息可通过 returnNodeGeometry 字段设置。
         */
        this.returnNodeFeatures = false;

        /**
         * @member {boolean} [TransportationAnalystResultSetting.prototype.returnNodeGeometry=false]
         * @description 返回的结点要素集合中是否包含几何对象信息。
         */
        this.returnNodeGeometry = false;

        /**
         * @member {boolean} [TransportationAnalystResultSetting.prototype.returnNodeIDs=false]
         * @description 返回结果中是否包含经过结点 ID 集合。
         */
        this.returnNodeIDs = false;

        /**
         * @member {boolean} TransportationAnalystResultSetting.prototype.returnPathGuides
         * @description 返回分析结果中是否包含行驶导引集合。
         */
        this.returnPathGuides = false;

        /**
         * @member {boolean} TransportationAnalystResultSetting.prototype.returnRoutes
         * @description 返回分析结果中是否包含路由对象的集合。
         */
        this.returnRoutes = false;

        Util_Util.extend(this, options);

        this.CLASS_NAME = "SuperMap.TransportationAnalystResultSetting";
    }

    /**
     * @function TransportationAnalystResultSetting.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        var me = this;
        me.returnEdgeFeatures = null;
        me.returnEdgeGeometry = null;
        me.returnEdgeIDs = null;
        me.returnNodeFeatures = null;
        me.returnNodeGeometry = null;
        me.returnNodeIDs = null;
        me.returnPathGuides = null;
        me.returnRoutes = null;
    }

}

;// CONCATENATED MODULE: ./src/common/iServer/TransportationAnalystParameter.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/



/**
 * @class TransportationAnalystParameter
 * @deprecatedclass SuperMap.TransportationAnalystParameter
 * @category  iServer NetworkAnalyst
 * @classdesc 交通网络分析通用参数类。该类主要用来提供交通网络分析所需的通用参数。
 * 通过本类可以设置障碍边、障碍点、权值字段信息的名称标识、转向权值字段等信息，还可以对分析结果包含的内容进行一些设置。
 * @param {Object} options - 参数。
 * @param {Array.<number>} options.barrierEdgeIDs - 网络分析中障碍弧段的 ID 数组。
 * @param {Array.<number>} options.barrierNodeIDs - 网络分析中障碍点的 ID 数组。
 * @param {string} options.turnWeightField - 转向权重字段的名称。
 * @param {TransportationAnalystResultSetting} options.resultSetting - 分析结果返回内容。
 * @param {Array.<GeometryPoint|L.Point|L.LatLng|ol.geom.Point|mapboxgl.LngLat|mapboxgl.Point|Array.<number>>} [options.barrierPoints] - 网络分析中 Point2D 类型的障碍点数组。
 * @param {string} [options.weightFieldName] - 阻力字段的名称。
 * @usage
 */
class TransportationAnalystParameter {

    constructor(options) {

        if (!options) {
            return;
        }
        /**
         * @member {Array.<number>} TransportationAnalystParameter.prototype.barrierEdgeIDs
         * @description 网络分析中障碍弧段的 ID 数组。弧段设置为障碍边之后，表示双向都不通。
         */
        this.barrierEdgeIDs = null;

        /**
         * @member {Array.<number>} TransportationAnalystParameter.prototype.barrierNodeIDs
         * @description 网络分析中障碍点的 ID 数组。结点设置为障碍点之后，表示任何方向都不能通过此结点。
         */
        this.barrierNodeIDs = null;

        /**
         * @member {Array.<GeometryPoint|L.Point|L.LatLng|ol.geom.Point|mapboxgl.LngLat|mapboxgl.Point|Array.<number>>}  TransportationAnalystParameter.prototype.barrierPoints
         * @description 网络分析中 Point2D 类型的障碍点数组。障碍点表示任何方向都不能通过此点。</br>
         * 当各网络分析参数类中的 isAnalyzeById 属性设置为 false 时，该属性才生效。
         */
        this.barrierPoints = null;

        /**
         * @member {string} [TransportationAnalystParameter.prototype.weightFieldName]
         * @description 阻力字段的名称，标识了进行网络分析时所使用的阻力字段，例如表示时间、长度等的字段都可以用作阻力字段。
         * 该字段默值为服务器发布的所有耗费字段的第一个字段。
         */
        this.weightFieldName = null;

        /**
         * @member {string} TransportationAnalystParameter.prototype.turnWeightField
         * @description 转向权重字段的名称。
         */
        this.turnWeightField = null;

        /**
         *  @member {TransportationAnalystResultSetting} TransportationAnalystParameter.prototype.resultSetting
         *  @description 分析结果返回内容。
         */
        this.resultSetting = new TransportationAnalystResultSetting();

        Util_Util.extend(this, options);

        this.CLASS_NAME = "SuperMap.TransportationAnalystParameter";
    }

    /**
     * @function TransportationAnalystParameter.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        var me = this;
        me.barrierEdgeIDs = null;
        me.barrierNodeIDs = null;
        me.weightFieldName = null;
        me.turnWeightField = null;
        if (me.resultSetting) {
            me.resultSetting.destroy();
            me.resultSetting = null;
        }
        if (me.barrierPoints && me.barrierPoints.length) {
            for (var i in me.barrierPoints) {
                me.barrierPoints[i].destroy();
            }
        }
        me.barrierPoints = null;
    }

}

;// CONCATENATED MODULE: ./src/common/iServer/ComputeWeightMatrixParameters.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/



/**
 * @class ComputeWeightMatrixParameters
 * @deprecatedclass SuperMap.ComputeWeightMatrixParameters
 * @category iServer NetworkAnalyst WeightMatrix
 * @classdesc 耗费矩阵分析参数类。根据交通网络分析参数中的耗费字段返回一个耗费矩阵。该矩阵是一个二维数组，用来存储任意两点间的资源消耗。
 * @param {Object} options - 参数。
 * @param {boolean} [options.isAnalyzeById=false] - 是否通过节点 ID 指定路径分析的结点。
 * @param {Array.<GeometryPoint|L.LatLng|L.Point|ol.geom.Point|mapboxgl.LngLat|Array.<number>>} options.nodes - 要计算耗费矩阵的点数组。
 * @param {TransportationAnalystParameter} [options.parameter] - 交通网络分析通用参数。
 * @usage
 */
class ComputeWeightMatrixParameters {


    constructor(options) {
        /**
         * @member {boolean} [ComputeWeightMatrixParameters.prototype.isAnalyzeById=false]
         * @description 是否通过节点 ID 指定路径分析的结点，即通过坐标点指定。
         */
        this.isAnalyzeById = false;

        /**
         * @member {Array.<GeometryPoint|L.LatLng|L.Point|ol.geom.Point|mapboxgl.LngLat|Array.<number>>} ComputeWeightMatrixParameters.prototype.nodes
         * @description 要计算耗费矩阵的点数组。
         *              当 {@link ComputeWeightMatrixParameters.isAnalyzeById} = false 时，nodes 应为点的坐标数组；
         *              当 {@link ComputeWeightMatrixParameters.isAnalyzeById} = true 时，nodes 应为点的 ID 数组。
         */
        this.nodes = null;

        /**
         * @member {TransportationAnalystParameter} ComputeWeightMatrixParameters.prototype.parameter
         * @description 交通网络分析通用参数。
         */
        this.parameter = new TransportationAnalystParameter();

        Util_Util.extend(this, options);

        this.CLASS_NAME = "SuperMap.ComputeWeightMatrixParameters";
    }

    /**
     * @function ComputeWeightMatrixParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        var me = this;
        me.isAnalyzeById = null;
        me.nodes = null;
        if (me.parameter) {
            me.parameter.destroy();
            me.parameter = null;
        }
    }
}

;// CONCATENATED MODULE: ./src/common/iServer/ComputeWeightMatrixService.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/




/**
 * @class ComputeWeightMatrixService
 * @deprecatedclass SuperMap.ComputeWeightMatrixService
 * @category  iServer NetworkAnalyst WeightMatrix
 * @classdesc 耗费矩阵分析服务类。
 *            耗费矩阵是根据交通网络分析参数中的耗费字段来计算一个二维数组，
 *            用来存储指定的任意两点间的资源消耗。
 *            耗费矩阵分析结果通过该类支持的事件的监听函数参数获取
 * @extends {NetworkAnalystServiceBase}
 * @example
 * var mycomputeWeightMatrixService = new ComputeWeightMatrixService(url);
 * @param {string} url - 耗费矩阵分析服务地址。请求服务的URL应为：
 *                       http://{服务器地址}:{服务端口号}/iserver/services/{网络分析服务名}/rest/networkanalyst/{网络数据集@数据源}；
 *                       例如："http://localhost:8090/iserver/services/components-rest/rest/networkanalyst/RoadNet@Changchun"。
 * @param {Object} options - 参数。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @usage
 */
class ComputeWeightMatrixService extends NetworkAnalystServiceBase {

    constructor(url, options) {
        super(url, options);
        this.CLASS_NAME = "SuperMap.ComputeWeightMatrixService";
    }


    /**
     * @function ComputeWeightMatrixService.prototype.destroy
     * @override
     */
    destroy() {
        super.destroy();
    }


    /**
     * @function ComputeWeightMatrixService.prototype.processAsync
     * @description 负责将客户端的查询参数传递到服务端。
     * @param {ComputeWeightMatrixParameters} params - 耗费矩阵分析参数类
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    processAsync(params, callback) {
        if (!(params instanceof ComputeWeightMatrixParameters)) {
            return;
        }
        var me = this,
            jsonObject;
        me.url = Util_Util.urlPathAppend(me.url, 'weightmatrix');
        jsonObject = {
            parameter: Util_Util.toJSON(params.parameter),
            nodes: me.getJson(params.isAnalyzeById, params.nodes)
        };
        return me.request({
            method: "GET",
            params: jsonObject,
            scope: me,
            success: callback,
            failure: callback
        });
    }

    /**
     * @function ComputeWeightMatrixService.prototype.getJson
     * @description 将对象转化为JSON字符串。
     * @param {boolean} isAnalyzeById - 是否通过id分析
     * @param {Array.<ComputeWeightMatrixParameters>} params - 分析参数数组
     * @returns {string} 转化后的JSON字符串。
     */
    getJson(isAnalyzeById, params) {
        var jsonString = "[",
            len = params ? params.length : 0;

        if (isAnalyzeById === false) {
            for (let i = 0; i < len; i++) {
                if (i > 0) {
                    jsonString += ",";
                }
                jsonString += '{"x":' + params[i].x + ',"y":' + params[i].y + '}';
            }
        } else if (isAnalyzeById === true) {
            for (let i = 0; i < len; i++) {
                if (i > 0) {
                    jsonString += ",";
                }
                jsonString += params[i];
            }
        }
        jsonString += ']';
        return jsonString;
    }
}

;// CONCATENATED MODULE: ./src/common/iServer/FacilityAnalystStreamParameters.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


/**
 * @class FacilityAnalystStreamParameters
 * @deprecatedclass SuperMap.FacilityAnalystStreamParameters
 * @category iServer NetworkAnalyst UpstreamCirticalFaclilities
 * @classdesc 上游/下游关键设施查找资源参数类。
 * @param {Object} options - 参数。
 * @param {Array.<number>} options.sourceNodeIDs - 指定的设施点 ID 数组。
 * @param {number} options.queryType - 分析类型，只能是 0 (上游关键设施查询) 或者是 1（下游关键设施查询）。
 * @param {number} [options.edgeID] - 指定的弧段 ID，edgeID 与 nodeID 必须指定一个。
 * @param {number} [options.nodeID] - 指定的结点 ID，edgeID 与 nodeID 必须指定一个。
 * @param {boolean} [options.isUncertainDirectionValid=false] - 指定不确定流向是否有效。
 * @usage
 */
class FacilityAnalystStreamParameters {


    constructor(options) {
        /**
         * @member {Array.<number>} [FacilityAnalystStreamParameters.prototype.sourceNodeIDs]
         * @description 指定的设施点 ID 数组。
         */
        this.sourceNodeIDs = null;

        /**
         * @member {number} [FacilityAnalystStreamParameters.prototype.edgeID]
         * @description 指定的弧段 ID，edgeID 与 nodeID 必须指定一个。
         */
        this.edgeID = null;

        /**
         * @member {number} [FacilityAnalystStreamParameters.prototype.nodeID]
         * @description 指定的结点 ID，edgeID 与 nodeID 必须指定一个。
         */
        this.nodeID = null;

        /**
         * @member {boolean} [FacilityAnalystStreamParameters.prototype.isUncertainDirectionValid=false]
         * @description 指定不确定流向是否有效。指定为 true，表示不确定流向有效，遇到不确定流向时分析继续进行；
         *              指定为 false，表示不确定流向无效，遇到不确定流向将停止在该方向上继续查找。
         */
        this.isUncertainDirectionValid = false;

        /**
         * @member {number} FacilityAnalystStreamParameters.prototype.queryType
         * @description 分析类型，只能是 0 (上游关键设施查询) 或者是 1（下游关键设施查询）。
         */
        this.queryType = null;
        Util_Util.extend(this, options);
        this.CLASS_NAME = "SuperMap.FacilityAnalystStreamParameters";
    }


    /**
     * @function FacilityAnalystStreamParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        var me = this;
        me.edgeID = null;
        me.nodeID = null;
        me.weightName = null;
        me.isUncertainDirectionValid = null;
        me.type = null;
    }

}

;// CONCATENATED MODULE: ./src/common/iServer/FacilityAnalystStreamService.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/




/**
 * @class FacilityAnalystStreamService
 * @deprecatedclass SuperMap.FacilityAnalystStreamService
 * @category iServer NetworkAnalyst UpstreamCirticalFaclilities
 * @classdesc 上游/下游 关键设施查找资源服务类：即查找给定弧段或节点的上游/下游中的关键设施结点，返回关键结点 ID 数组及其下游弧段 ID 数组。
 * @extends NetworkAnalystServiceBase
 * @param {string} url - 服务地址。请求网络分析服务，URL应为：
 *                       http://{服务器地址}:{服务端口号}/iserver/services/{网络分析服务名}/rest/networkanalyst/{网络数据集@数据源}；
 *                       例如: "http://localhost:8090/iserver/services/test/rest/networkanalyst/WaterNet@FacilityNet";
 * @param {Object} options - 参数。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @usage
 */
class FacilityAnalystStreamService extends NetworkAnalystServiceBase {

    constructor(url, options) {
        super(url, options);
        this.CLASS_NAME = "SuperMap.FacilityAnalystStreamService";
    }


    /**
     * @function FacilityAnalystStreamService.prototype.destroy
     * @override
     */
    destroy() {
        super.destroy();
    }


    /**
     * @function FacilityAnalystStreamService.prototype.processAsync
     * @description 负责将客户端的查询参数传递到服务端。
     * @param {FacilityAnalystStreamParameters} params - 上游/下游关键设施查找资源参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    processAsync(params, callback) {
        if (!(params instanceof FacilityAnalystStreamParameters)) {
            return;
        }
        var me = this,
            jsonObject;
        //URL 通过参数类型来判断是 上游 还是下游 查询
        if (params.queryType === 0) {
            me.url = Util_Util.urlPathAppend(me.url, 'upstreamcirticalfaclilities');
        } else if (params.queryType === 1) {
            me.url = Util_Util.urlPathAppend(me.url, 'downstreamcirticalfaclilities');
        } else {
            return;
        }

        jsonObject = {
            sourceNodeIDs: params.sourceNodeIDs,
            isUncertainDirectionValid: params.isUncertainDirectionValid
        };

        if (params.edgeID !== null && params.nodeID !== null) {
            return;
        }
        if (params.edgeID === null && params.nodeID === null) {
            return;
        }
        if (params.edgeID !== null) {
            jsonObject.edgeID = params.edgeID;
        } else {
            jsonObject.nodeID = params.nodeID;
        }

        return me.request({
            method: "GET",
            params: jsonObject,
            scope: me,
            success: callback,
            failure: callback
        });
    }

}

;// CONCATENATED MODULE: ./src/common/iServer/TraceAnalystParameters.js
/* Copyright© 2000 - 2022 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/
 

 /**
  * @class TraceAnalystParameters
  * @deprecatedclass SuperMap.TraceAnalystParameters
  * @category iServer NetworkAnalyst TraceAnalystService
  * @classdesc 上游/下游追踪分析参数类。
  * @version 11.1.1
  * @param {Object} options - 参数。
  * @param {number} options.traceType - 分析类型，只能是 0 (上游追踪分析) 或者是 1 (下游追踪分析)。
  * @param {number} [options.edgeID] - 【与nodeID必填一项】需查找上游设施的弧段 ID 。
  * @param {number} [options.nodeID] - 【与edgeID必填一项】需查找上游设施的结点 ID 。
  * @param {string} [options.weightName] - 权重字段。
  * @param {boolean} [options.returnFeatures=true] - 是否返回结果要素的详细描述信息。若为 false，只返回结果要素的 ID 集合。
  * @param {boolean} [options.isUncertainDirectionValid=true] - 指定不确定流向是否有效。true表示不确定流向有效，遇到不确定流向时分析继续进行；false表示不确定流向无效，遇到不确定流向将停止在该方向上继续查找。
  * @param {boolean} [options.withIndex=true] - 当使用 FlatGeobuf 表述时该参数可选。表示返回的表述为 FlatGeobuf 的结果是否包含空间索引，默认为true。
  * @usage
  */
 class TraceAnalystParameters {
 
 
     constructor(options) {
         /**
          * @member {number} [TraceAnalystParameters.prototype.edgeID]
          * @description 指定的弧段 ID，edgeID 与 nodeID 必须指定一个。
          */
         this.edgeID = null;
 
         /**
          * @member {number} [TraceAnalystParameters.prototype.nodeID]
          * @description 指定的结点 ID，edgeID 与 nodeID 必须指定一个。
          */
         this.nodeID = null;
 
         /**
          * @member {string} [TraceAnalystParameters.prototype.weightName]
          * @description 权重字段。
          */
         this.weightName = null;

         /**
          * @member {boolean} [TraceAnalystParameters.prototype.returnFeatures=true]
          * @description 是否返回结果要素的详细描述信息。若为 false，只返回结果要素的 ID 集合。
          */
         this.returnFeatures = true;
 
         /**
          * @member {boolean} [TraceAnalystParameters.prototype.isUncertainDirectionValid=false]
          * @description 指定不确定流向是否有效。指定为 true，表示不确定流向有效，遇到不确定流向时分析继续进行；
          *              指定为 false，表示不确定流向无效，遇到不确定流向将停止在该方向上继续查找。
          */
         this.isUncertainDirectionValid = true;
 
         /**
          * @member {number} TraceAnalystParameters.prototype.traceType
          * @description 分析类型，只能是 0 (上游追踪分析) 或者是 1（下游追踪分析）。
          */
         this.traceType = null;

         /**
          * @member {boolean} TraceAnalystParameters.prototype.withIndex
          * @description 当使用 FlatGeobuf 表述时该参数可选。表示返回的表述为 FlatGeobuf 的结果是否包含空间索引，默认为true。
          */
         this.withIndex = null;
         Util_Util.extend(this, options);
         this.CLASS_NAME = "SuperMap.TraceAnalystParameters";
     }
 
 
     /**
      * @function TraceAnalystParameters.prototype.destroy
      * @description 释放资源，将引用资源的属性置空。
      */
     destroy() {
         var me = this;
         me.edgeID = null;
         me.nodeID = null;
         me.weightName = null;
         me.returnFeatures = null;
         me.isUncertainDirectionValid = null;
         me.type = null;
         me.withIndex = null;
     }
 
 }
 
;// CONCATENATED MODULE: ./src/common/iServer/TraceAnalystService.js
/* Copyright© 2000 - 2022 SuperMap Software Co.Ltd. All rights reservceTypeed.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/
 
 
 
 
 
 /**
  * @class TraceAnalystService
  * @deprecatedclass SuperMap.TraceAnalystService
  * @category iServer NetworkAnalyst TraceAnalystService
  * @classdesc 上游/下游 追踪分析服务类；即查找给定弧段或节点的上游/下游弧段和结点。
  * @version 11.1.1
  * @extends NetworkAnalystServiceBase
  * @param {string} url - 服务地址。请求网络分析服务，URL应为：
  *                       http://{服务器地址}:{服务端口号}/iserver/services/{网络分析服务名}/rest/networkanalyst/{网络数据集@数据源}；
  *                       例如: "http://localhost:8090/iserver/services/test/rest/networkanalyst/WaterNet@FacilityNet";
  * @param {Object} options - 参数。
  * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
  * @param {Object} [options.headers] - 请求头。
  * @usage
  */
 class TraceAnalystService extends NetworkAnalystServiceBase {
 
     constructor(url, options) {
         super(url, options);
         this.CLASS_NAME = "SuperMap.TraceAnalystService";
     }

 
     /**
      * @function TraceAnalystService.prototype.destroy
      * @override
      */
     destroy() {
         super.destroy();
     }
 
 
     /**
      * @function TraceAnalystService.prototype.processAsync
      * @description 负责将客户端的查询参数传递到服务端。
      * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
      * @param {TraceAnalystParameters} params - 上游/下游追踪分析参数类。
      */
     processAsync(params, callback) {
         if (!(params instanceof TraceAnalystParameters)) {
             return;
         }
         var me = this,
             jsonObject;
         //URL 通过参数类型来判断是 上游 还是下游 追踪分析
         if (params.traceType === 0) {
             me.url = Util_Util.urlPathAppend(me.url, 'traceup');
         } else if (params.traceType === 1) {
             me.url = Util_Util.urlPathAppend(me.url, 'tracedown');
         } else {
             return;
         }
 
         jsonObject = {
            weightName: params.weightName,
            isUncertainDirectionValid: params.isUncertainDirectionValid,
            returnFeatures: params.returnFeatures
         };
 
         if (params.edgeID !== null && params.nodeID !== null) {
             return;
         }
         if (params.edgeID === null && params.nodeID === null) {
             return;
         }
         if (params.edgeID !== null) {
             jsonObject.edgeID = params.edgeID;
         } else {
             jsonObject.nodeID = params.nodeID;
         }
 
         return me.request({
             method: "GET",
             params: jsonObject,
             scope: me,
             success: callback,
             failure: callback
         });
     }

      /**
     * @function FindClosestFacilitiesService.prototype.toGeoJSONResult
     * @description 将含有 geometry 的数据转换为 GeoJSON 格式。
     * @param {Object} result - 服务器返回的结果对象。
     */
    toGeoJSONResult(result) {
      if (!result) {
        return null;
      }
      var geoJSONFormat = new GeoJSON();
      if (result.edgesFeatures) {
        result.edgesFeatures = geoJSONFormat.toGeoJSON(result.edgesFeatures);
      }
      if (result.nodesFeatures) {
        result.nodesFeatures = geoJSONFormat.toGeoJSON(result.nodesFeatures);
      }
      return result;
    }
 
 }
 
;// CONCATENATED MODULE: ./src/common/iServer/ConnectedEdgesAnalystParameters.js
/* Copyright© 2000 - 2022 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


/**
 * @class ConnectedEdgesAnalystParameters
 * @deprecatedclass SuperMap.ConnectedEdgesAnalystParameters
 * @category iServer NetworkAnalyst ConnectedEdges
 * @classdesc 连通性分析参数类。
 * @version 11.1.1
 * @param {Object} options - 参数。
 * @param {boolean} [options.connected] - 查询是否相连通的弧段。为 true 时，查询相连通的弧段；为 false 时，查询不连通的弧段。
 * @param {boolean} [options.returnFeatures=true] - 是否返回结果要素的详细描述信息。若为 false，只返回结果要素的 ID 集合。
 * @param {Array.<number>} [options.edgeIDs] - 分析结果的连通弧段 ID 的集合。
 * @param {Array.<number>} [options.nodeIDs] - 分析结果的连通结点 ID 的集合。
 * @param {boolean} [options.withIndex=true] - 当使用 FlatGeobuf 表述时该参数可选。表示返回的表述为 FlatGeobuf 的结果是否包含空间索引，默认为true。
 * @usage
 */
class ConnectedEdgesAnalystParameters {

    constructor(options) {
        /**
         * @member {boolean} [ConnectedEdgesAnalystParameters.prototype.connected]
         * @description 查询是否相连通的弧段。为 true 时，查询相连通的弧段；为 false 时，查询不连通的弧段。
         */
        this.connected = null;

        /**
         * @member {boolean} [ConnectedEdgesAnalystParameters.prototype.returnFeatures=true]
         * @description 是否返回结果要素的详细描述信息。若为 false，只返回结果要素的 ID 集合。
         */
        this.returnFeatures = true;

        /**
         * @member {Array.<number>} [ConnectedEdgesAnalystParameters.prototype.edgeIDs]
         * @description 分析结果的连通弧段 ID 的集合。
         */
        this.edgeIDs = null;

        /**
         * @member {Array.<number>} [ConnectedEdgesAnalystParameters.prototype.nodeIDs]
         * @description 分析结果的连通结点 ID 的集合。
         */
        this.nodeIDs = null;

        /**
         * @member {boolean} [ConnectedEdgesAnalystParameters.prototype.withIndex]
         * @description 当使用 FlatGeobuf 表述时该参数可选。表示返回的表述为 FlatGeobuf 的结果是否包含空间索引，默认为true。
         */
        this.withIndex = null;

        Util_Util.extend(this, options);
        this.CLASS_NAME = "SuperMap.ConnectedEdgesAnalystParameters";
    }


    /**
     * @function ConnectedEdgesAnalystParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        var me = this;
        me.edgeIDs = null;
        me.nodeIDs = null;
        me.connected = null;
        me.returnFeatures = null;
        me.withIndex = null;
    }

}

;// CONCATENATED MODULE: ./src/common/iServer/ConnectedEdgesAnalystService.js
/* Copyright© 2000 - 2022 SuperMap Software Co.Ltd. All rights reservceTypeed.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/




 
 /**
  * @class ConnectedEdgesAnalystService
  * @deprecatedclass SuperMap.ConnectedEdgesAnalystService
  * @category iServer NetworkAnalyst UpstreamCirticalFaclilities
  * @classdesc 连通性分析服务类，查找与给定结点或者弧段相连通的弧段。
  * @version 11.1.1
  * @extends NetworkAnalystServiceBase
  * @param {string} url - 服务地址。请求网络分析服务，URL应为：
  *                       http://{服务器地址}:{服务端口号}/iserver/services/{网络分析服务名}/rest/networkanalyst/{网络数据集@数据源}；
  *                       例如: "http://localhost:8090/iserver/services/test/rest/networkanalyst/WaterNet@FacilityNet";
  * @param {Object} options - 参数。
  * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
  * @param {Object} [options.headers] - 请求头。
  * @usage
  */
 class ConnectedEdgesAnalystService extends NetworkAnalystServiceBase {
 
     constructor(url, options) {
         super(url, options);
         this.CLASS_NAME = "SuperMap.ConnectedEdgesAnalystService";
     }

 
     /**
      * @function ConnectedEdgesAnalystService.prototype.destroy
      * @override
      */
     destroy() {
         super.destroy();
     }
 
 
     /**
      * @function ConnectedEdgesAnalystService.prototype.processAsync
      * @description 负责将客户端的查询参数传递到服务端。
      * @param {ConnectedEdgesAnalystParameters} params - 上游/下游追踪分析参数类。
      * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
      * @returns {Promise} Promise 对象。
      */
     processAsync(params, callback) {
         if (!(params instanceof ConnectedEdgesAnalystParameters)) {
             return;
         }
         var me = this,
             jsonObject;
         me.url = Util_Util.urlPathAppend(me.url, 'connectededges');
 
         jsonObject = {
            connected: params.connected,
            returnFeatures: params.returnFeatures
         };
         if (params.edgeIDs !== null && params.nodeIDs !== null) {
             return;
         }
         if (params.edgeIDs === null && params.nodeIDs === null) {
             return;
         }
         if (params.edgeIDs !== null) {
             jsonObject.edgeIDs = params.edgeIDs;
         } else {
             jsonObject.nodeIDs = params.nodeIDs;
         }
 
         return me.request({
             method: "GET",
             params: jsonObject,
             scope: me,
             success: callback,
             failure: callback
         });
     }

    /**
     * @function FindClosestFacilitiesService.prototype.toGeoJSONResult
     * @description 将含有 geometry 的数据转换为 GeoJSON 格式。
     * @param {Object} result - 服务器返回的结果对象。
     */
    toGeoJSONResult(result) {
      if (!result) {
        return null;
      }
      var geoJSONFormat = new GeoJSON();
      if (result.edgesFeatures) {
        result.edgesFeatures = geoJSONFormat.toGeoJSON(result.edgesFeatures);
      }
      if (result.nodesFeatures) {
        result.nodesFeatures = geoJSONFormat.toGeoJSON(result.nodesFeatures);
      }
      return result;
    }
 
 }
 
;// CONCATENATED MODULE: ./src/common/iServer/FindClosestFacilitiesParameters.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/



/**
 * @class FindClosestFacilitiesParameters
 * @deprecatedclass SuperMap.FindClosestFacilitiesParameters
 * @category iServer NetworkAnalyst ClosestFacility
 * @classdesc 最近设施分析参数类。
 * @param {Object} options - 参数。
 * @param {GeometryPoint|L.LatLng|L.Point|ol.geom.Point|mapboxgl.LngLat|mapboxgl.Point|Array.<number>} options.event - 事件点，一般为需要获得服务设施服务的事件位置。
 * @param {Array.<GeometryPoint|L.LatLng|L.Point|ol.geom.Point|mapboxgl.LngLat|mapboxgl.Point|Array.<number>>}  options.facilities - 设施点集合，一般为提供服务的服务设施位置。
 * @param {number} [options.expectFacilityCount=1] - 要查找的设施点数量。
 * @param {boolean} [options.fromEvent=false] - 是否从事件点到设施点进行查找。
 * @param {boolean} [options.isAnalyzeById=false] - 事件点和设施点是否通过节点 ID 号来指定。
 * @param {number} [options.maxWeight=0] - 权值的最大限值。单位与该类中 parameter 字段（交通网络分析通用参数）中设置的耗费字段一致。
 * @param {TransportationAnalystParameter} [options.parameter] - 交通网络分析通用参数。
 * @usage
 */
class FindClosestFacilitiesParameters {


    constructor(options) {
        /**
         * @member {GeometryPoint|L.LatLng|L.Point|ol.geom.Point|mapboxgl.LngLat|mapboxgl.Point|Array.<number>} FindClosestFacilitiesParameters.prototype.event
         * @description 事件点，一般为需要获得服务设施服务的事件位置。
         *              可以通过两种方式赋予事件点：当该类中字段 isAnalyzeById = true 时，应输入事件点 ID 号；当 isAnalyzeById = false 时，应输入事件点坐标。
         */
        this.event = null;

        /**
         * @member {number} [FindClosestFacilitiesParameters.prototype.expectFacilityCount=1]
         * @description 要查找的设施点数量。
         */
        this.expectFacilityCount = 1;

        /**
         * @member {Array.<GeometryPoint|L.LatLng|L.Point|ol.geom.Point|mapboxgl.LngLat|mapboxgl.Point|Array.<number>>} [FindClosestFacilitiesParameters.prototype.facilities=false]
         * @description 设施点集合，一般为提供服务的服务设施位置。
         *              可以通过两种方式赋予设施点：当该类中字段 isAnalyzeById = true 时，应输入设施点 ID 号；当 isAnalyzeById = false 时，应输入设施点坐标。
         */
        this.facilities = null;

        /**
         * @member {boolean} [FindClosestFacilitiesParameters.prototype.fromEvent=false]
         * @description 是否从事件点到设施点进行查找。最近设施分析主要是通过设施点和事件点之间最优的路线来分析在一定范围内哪个或哪些设施与事件点有最优路线的关系。
         *              这个行走线路是通过网络图层进行网络分析算法计算出来的两点间的最优路线。由于存在从 A 点到 B 点与从 B 点到 A 点的耗费不一样的情况，因此起止点不同可能会得到不同的最优路线。因此在进行最近设施分析之前，需要设置获取的最优路线的方向，即是以事件点作为起点到最近设施点的方向分析，还是以最近设施点为起点到事件点的方向分析。如果需要以事件点作为起点到设施点方向进行查找，设置该字段值为 true；设置为 false，表示从设施点到事件点进行查找。
         */
        this.fromEvent = false;

        /**
         * @member {boolean} [FindClosestFacilitiesParameters.prototype.isAnalyzeById=false]
         * @description 事件点和设施点是否通过节点 ID 号来指定，设置为 false，表示通过坐标点指定事件点和设施点。
         */
        this.isAnalyzeById = false;

        /**
         * @member {number} [FindClosestFacilitiesParameters.prototype.maxWeight=0]
         * @description 权值的最大限值。单位与该类中 parameter 字段（交通网络分析通用参数）中设置的耗费字段一致。
         *              例如事件发生点是一起交通事故，要求查找在 10 分钟内能到达的最近医院，超过 10 分钟能到达的都不予考虑。
         *              那么需要将网络分析参数中 parameter.weightFieldName 设置为表示时间的字段，然后设置查找范围的半径值为10。
         */
        this.maxWeight = 0;

        /**
         * @member {TransportationAnalystParameter} [FindClosestFacilitiesParameters.prototype.parameter]
         * @description 交通网络分析通用参数。通过本类可以设置障碍边、障碍点、权值字段信息的名称标识、转向权值字段等信息。
         *              它为 TransportationAnalystParameter 类型，虽然为可选参数，但是如果不设置其中的 resultSetting 字段，
         *              则返回结果空间信息等都为空。
         */
        this.parameter = new TransportationAnalystParameter();
        Util_Util.extend(this, options);

        this.CLASS_NAME = "SuperMap.FindClosestFacilitiesParameters";
    }

    /**
     * @function FindClosestFacilitiesParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        var me = this;
        me.event = null;
        me.expectFacilityCount = null;
        me.facilities = null;
        me.fromEvent = null;
        me.isAnalyzeById = null;
        me.maxWeight = null;
        if (me.parameter) {
            me.parameter.destroy();
            me.parameter = null;
        }
    }

}

;// CONCATENATED MODULE: ./src/common/iServer/FindClosestFacilitiesService.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/





/**
 * @class FindClosestFacilitiesService
 * @deprecatedclass SuperMap.FindClosestFacilitiesService
 * @category  iServer NetworkAnalyst ClosestFacility
 * @classdesc 最近设施分析服务类。
 *            最近设施分析是指在网络上给定一个事件点和一组设施点，
 *            查找从事件点到设施点(或从设施点到事件点)以最小耗费能到达的最佳路径。
 *            该类负责将客户端指定的最近设施分析参数传递给服务端，并接收服务端返回的结果数据。
 *            最近设施分析结果通过该类支持的事件的监听函数参数获取
 * @extends {NetworkAnalystServiceBase}
 * @example
 * var myfindClosestFacilitiesService = new FindClosestFacilitiesService(url);
 * @param {string} url - 服务地址。请求网络分析服务，URL应为：
 *                       http://{服务器地址}:{服务端口号}/iserver/services/{网络分析服务名}/rest/networkanalyst/{网络数据集@数据源}；
 *                       例如:"http://localhost:8090/iserver/services/components-rest/rest/networkanalyst/RoadNet@Changchun"。
 * @param {Object} options - 参数。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @usage
 */
class FindClosestFacilitiesService extends NetworkAnalystServiceBase {
    constructor(url, options) {
        super(url, options);

        this.CLASS_NAME = "SuperMap.FindClosestFacilitiesService";
    }

    /**
     * @function FindClosestFacilitiesService.prototype.destroy
     * @override
     */
    destroy() {
        super.destroy();
    }

    /**
     * @function FindClosestFacilitiesService.prototype.processAsync
     * @description 负责将客户端的查询参数传递到服务端。
     * @param {FindClosestFacilitiesParameters} params - 最近设施分析服务参数类
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    processAsync(params, callback) {
        if (!(params instanceof FindClosestFacilitiesParameters)) {
            return;
        }
        var me = this,
            jsonObject;
        me.url = Util_Util.urlPathAppend(me.url, 'closestfacility');
        jsonObject = {
            expectFacilityCount: params.expectFacilityCount,
            fromEvent: params.fromEvent,
            maxWeight: params.maxWeight,
            parameter: Util_Util.toJSON(params.parameter),
            event: Util_Util.toJSON(params.event),
            facilities: me.getJson(params.isAnalyzeById, params.facilities)
        };
        return me.request({
            method: "GET",
            params: jsonObject,
            scope: me,
            success: callback,
            failure: callback
        });
    }

    /**
     * @function FindClosestFacilitiesService.prototype.getJson
     * @description 将对象转化为JSON字符串。
     * @param {boolean} isAnalyzeById - 是否通过ID来分析
     * @param {Array.<Object>} params - 分析参数数组
     * @returns {Object} 转化后的JSON字符串。
     */
    getJson(isAnalyzeById, params) {
        var jsonString = "[",
            len = params ? params.length : 0;

        if (isAnalyzeById === false) {
            for (let i = 0; i < len; i++) {
                if (i > 0) {
                    jsonString += ",";
                }
                jsonString += '{"x":' + params[i].x + ',"y":' + params[i].y + '}';
            }
        } else if (isAnalyzeById === true) {
            for (let i = 0; i < len; i++) {
                if (i > 0) {
                    jsonString += ",";
                }
                jsonString += params[i];
            }
        }
        jsonString += ']';
        return jsonString;
    }

    /**
     * @function FindClosestFacilitiesService.prototype.toGeoJSONResult
     * @description 将含有 geometry 的数据转换为 GeoJSON 格式。
     * @param {Object} result - 服务器返回的结果对象。
     */
    toGeoJSONResult(result) {
        if (!result || !result.facilityPathList) {
            return result;
        }

        var geoJSONFormat = new GeoJSON();
        result.facilityPathList.map(function (path) {
            if (path.route) {
                path.route = geoJSONFormat.toGeoJSON(path.route);
            }
            if (path.pathGuideItems) {
                path.pathGuideItems = geoJSONFormat.toGeoJSON(path.pathGuideItems);

            }
            if (path.edgeFeatures) {
                path.edgeFeatures = geoJSONFormat.toGeoJSON(path.edgeFeatures);
            }
            if (path.nodeFeatures) {
                path.nodeFeatures = geoJSONFormat.toGeoJSON(path.nodeFeatures);
            }
            return path;
        });
        return result;
    }

}

;// CONCATENATED MODULE: ./src/common/iServer/FindLocationParameters.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


/**
 * @class FindLocationParameters
 * @deprecatedclass SuperMap.FindLocationParameters
 * @category iServer NetworkAnalyst Location
 * @classdesc 选址分区分析参数类。
 * @param {Object} options - 参数。
 * @param {string} options.turnWeightField - 转向权值字段的名称。
 * @param {string} options.weightName - 阻力字段的名称，标识了进行网络分析时所使用的阻力字段。
 * @param {Array.<SupplyCenter>} options.supplyCenters - 资源供给中心集合。
 * @param {number} [options.expectedSupplyCenterCount=1] - 期望用于最终设施选址的资源供给中心数量。
 * @param {boolean} [options.isFromCenter=false] - 是否从中心点开始分配资源。
 * @usage
 */
class FindLocationParameters {


    constructor(options) {
        /**
         * @member {number} [FindLocationParameters.prototype.expectedSupplyCenterCount=1]
         * @description 期望用于最终设施选址的资源供给中心数量。
         *              当输入值为 0 时，最终设施选址的资源供给中心数量默认为覆盖分析区域内的所需最少的供给中心数。
         */
        this.expectedSupplyCenterCount = null;

        /**
         * @member {boolean} [FindLocationParameters.prototype.isFromCenter=false]
         * @description 是否从中心点开始分配资源。
         *              由于网路数据中的弧段具有正反阻力，即弧段的正向阻力值与其反向阻力值可能不同，
         *              因此，在进行分析时，从资源供给中心开始分配资源到需求点与从需求点向资源供给中心分配这两种分配形式下，所得的分析结果会不同。
         */
        this.isFromCenter = false;


        /**
         * @member {Array.<SupplyCenter>} FindLocationParameters.prototype.supplyCenters
         * @description 资源供给中心集合。
         *              资源供给中心是提供资源和服务的设施，对应于网络结点，
         *              资源供给中心的相关信息包括资源量、最大阻力值、资源供给中心类型，资源供给中心在网络中所处结点的 ID 等，以便在进行选址分区分析时使用。
         */
        this.supplyCenters = null;

        /**
         * @member {string} FindLocationParameters.prototype.turnWeightField
         * @description 转向权值字段的名称。
         */
        this.turnWeightField = null;

        /**
         * @member {string} FindLocationParameters.prototype.weightName
         * @description 阻力字段的名称，标识了进行网络分析时所使用的阻力字段。
         */
        this.weightName = null;
        Util_Util.extend(this, options);
        this.CLASS_NAME = "SuperMap.FindLocationParameters";
    }

    /**
     * @function FindLocationParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        var me = this;
        me.expectedSupplyCenterCount = null;
        me.isFromCenter = null;
        me.turnWeightField = null;
        me.weightName = null;
        if (me.supplyCenters) {
            for (var i = 0, supplyCenters = me.supplyCenters, len = supplyCenters.length; i < len; i++) {
                supplyCenters[i].destroy();
            }
            me.supplyCenters = null;
        }
    }


}

;// CONCATENATED MODULE: ./src/common/iServer/FindLocationService.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/





/**
 * @class FindLocationService
 * @deprecatedclass SuperMap.FindLocationService
 * @category iServer NetworkAnalyst Location
 * @classdesc 选址分区分析服务类。
 *            选址分区分析是为了确定一个或多个待建设施的最佳或最优位置，使得设施可以用一种最经济有效的方式为需求方提供服务或者商品。
 *            选址分区不仅仅是一个选址过程，还要将需求点的需求分配到相应的新建设施的服务区中，因此称之为选址与分区。
 *            选址分区分析结果通过该类支持的事件的监听函数参数获取
 * @extends {NetworkAnalystServiceBase}
 * @example
 * (start code)
 * var findLocationService = new FindLocationService(url);
 * (end)
 * @param {string} url - 服务地址。
 *                       如 http://localhost:8090/iserver/services/transportationanalyst-sample/rest/networkanalyst/RoadNet@Changchun 。
 * @param {Object} options - 参数。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @usage
 */
class FindLocationService extends NetworkAnalystServiceBase {

    constructor(url, options) {
        super(url, options);

        this.CLASS_NAME = "SuperMap.FindLocationService";
    }

    /**
     * @function FindLocationService.prototype.destroy
     * @override
     */
    destroy() {
        super.destroy();
    }

    /**
     * @function FindLocationService.prototype.processAsync
     * @description 负责将客户端的查询参数传递到服务端。
     * @param {FindLocationParameters} params - 选址分区分析服务参数类
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    processAsync(params, callback) {
        if (!(params instanceof FindLocationParameters)) {
            return;
        }
        var me = this,
            jsonObject;
        me.url = Util_Util.urlPathAppend(me.url, 'location');
        jsonObject = {
            isFromCenter: params.isFromCenter,
            expectedSupplyCenterCount: params.expectedSupplyCenterCount,
            weightName: params.weightName,
            turnWeightField: params.turnWeightField,
            returnEdgeFeature: true,
            returnEdgeGeometry: true,
            returnNodeFeature: true,
            mapParameter: Util_Util.toJSON(params.mapParameter),
            supplyCenters: me.getCentersJson(params.supplyCenters)
        };
        return me.request({
            method: "GET",
            params: jsonObject,
            scope: me,
            success: callback,
            failure: callback
        });
    }

    /**
     * @function FindLocationService.prototype.getCentersJson
     * @description 将数组对象转化为JSON字符串。
     * @param {Array} params - 需要转换的参数
     * @returns {string} 转化后的JSON字符串。
     */
    getCentersJson(params) {
        var json = "[",
            len = params ? params.length : 0;
        for (var i = 0; i < len; i++) {
            if (i > 0) {
                json += ",";
            }
            json += Util_Util.toJSON(params[i]);
        }
        json += "]";
        return json;
    }

    /**
     * @function FindLocationService.prototype.toGeoJSONResult
     * @description 将含有 geometry 的数据转换为 GeoJSON 格式。
     * @param {Object} result - 服务器返回的结果对象。
     */
    toGeoJSONResult(result) {
        if (!result) {
            return null;
        }
        var geoJSONFormat = new GeoJSON();
        if (result.demandResults) {
            result.demandResults = geoJSONFormat.toGeoJSON(result.demandResults);
        }
        if (result.supplyResults) {
            result.supplyResults = geoJSONFormat.toGeoJSON(result.supplyResults);
        }

        return result;
    }

}

;// CONCATENATED MODULE: ./src/common/iServer/FindMTSPPathsParameters.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/



/**
 * @class FindMTSPPathsParameters
 * @deprecatedclass SuperMap.FindMTSPPathsParameters
 * @category iServer NetworkAnalyst MTSPPath
 * @classdesc 多旅行商分析参数类。
 * @param {Object} options - 参数。
 * @param {Array.<GeometryPoint|L.LatLng|L.Point|ol.geom.Point|mapboxgl.LngLat|mapboxgl.Point|Array.<number>>} options.centers - 配送中心集合。
 * @param {Array.<GeometryPoint|L.LatLng|L.Point|ol.geom.Point|mapboxgl.LngLat|mapboxgl.Point|Array.<number>>} options.nodes - 配送目标集合。
 * @param {boolean} [options.hasLeastTotalCost=false] - 配送模式是否为总花费最小方案。
 * @param {boolean} [options.isAnalyzeById=false] - 是否通过节点 ID 号来指定配送中心点和配送目的点，即通过坐标点指定。
 * @param {TransportationAnalystParameter} [options.parameter] - 交通网络分析通用参数。
 * @usage
 */
class FindMTSPPathsParameters {


    constructor(options) {
        /**
         * @member {Array.<GeometryPoint|L.LatLng|L.Point|ol.geom.Point|mapboxgl.LngLat|mapboxgl.Point|Array.<number>>} FindMTSPPathsParameters.prototype.centers
         * @description 配送中心集合。
         *              当 FindMTSPPathsParameters.isAnalyzeById = false 时，centers 应为点的坐标数组；
         *              当 FindMTSPPathsParameters.isAnalyzeById = true 时，centers 应为点的 ID 数组。
         */
        this.centers = null;

        /**
         * @member {boolean} [FindMTSPPathsParameters.prototype.hasLeastTotalCost=false]
         * @description 配送模式是否为总花费最小方案。
         *              若为 true，则按照总花费最小的模式进行配送，此时可能会出现某几个配送中心点配送的花费较多而其他配送中心点的花费很少的情况。
         *              若为 false，则为局部最优，此方案会控制每个配送中心点的花费，使各个中心点花费相对平均，此时总花费不一定最小。
         */
        this.hasLeastTotalCost = false;

        /**
         * @member {boolean} [FindMTSPPathsParameters.prototype.isAnalyzeById=false]
         * @description 是否通过节点 ID 号来指定配送中心点和配送目的点，即通过坐标点指定。
         */
        this.isAnalyzeById = false;

        /**
         * @member {Array.<GeometryPoint|L.LatLng|L.Point|ol.geom.Point|mapboxgl.LngLat|mapboxgl.Point|Array.<number>>} FindMTSPPathsParameters.prototype.nodes
         * @description 配送目标集合。
         *              当 FindMTSPPathsParameters.isAnalyzeById = false 时，nodes 应为点的坐标数组；
         *              当 FindMTSPPathsParameters.isAnalyzeById = true 时，nodes 应为点的 ID 数组。
         */
        this.nodes = null;

        /**
         * @member {TransportationAnalystParameter} [FindMTSPPathsParameters.prototype.parameter]
         * @description 交通网络分析通用参数。
         *              通过本类可以设置障碍边、障碍点、权值字段信息的名称标识、转向权值字段等信息。
         *              TransportationAnalystParameter 类型，它虽然为可选参数，但是如果不设置其中的 resultSetting 字段，则返回结果空间信息等都为空。
         */
        this.parameter = new TransportationAnalystParameter();
        Util_Util.extend(this, options);

        this.CLASS_NAME = "SuperMap.FindMTSPPathsParameters";
    }

    /**
     * @function FindMTSPPathsParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        var me = this;
        me.centers = null;
        me.hasLeastTotalCost = null;
        me.isAnalyzeById = null;
        me.nodes = null;
        me.maxWeight = null;
        if (me.parameter) {
            me.parameter.destroy();
            me.parameter = null;
        }
    }

}

;// CONCATENATED MODULE: ./src/common/iServer/FindMTSPPathsService.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/





/**
 * @class FindMTSPPathsService
 * @deprecatedclass SuperMap.FindMTSPPathsService
 * @category  iServer NetworkAnalyst MTSPPath
 * @classdesc 多旅行商分析服务类
 *            多旅行商分析也称为物流配送，是指在网络数据集中，给定 M 个配送中心点和 N 个配送目的地（M，N 为大于零的整数）。
 *            查找经济有效的配送路径，并给出相应的行走路线。
 *            物流配送功能就是解决如何合理分配配送次序和送货路线，使配送总花费达到最小或每个配送中心的花费达到最小。
 *            该类负责将客户端指定的多旅行商分析参数传递给服务端，并接收服务端返回的结果数据。
 *            多旅行商分析结果通过该类支持的事件的监听函数参数获取。
 * @extends {NetworkAnalystServiceBase}
 * @example
 * var myFindMTSPPathsService = new FindMTSPPathsService(url);
 * @param {string} url - 服务地址。请求网络分析服务，URL应为：
 *                       http://{服务器地址}:{服务端口号}/iserver/services/网络分析服务名}/rest/networkanalyst/{网络数据集@数据源}；
 *                       例如:"http://localhost:8090/iserver/services/components-rest/rest/networkanalyst/RoadNet@Changchun"。
 * @param {Object} options - 互服务时所需可选参数。如：
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @usage
 */
class FindMTSPPathsService extends NetworkAnalystServiceBase {

    constructor(url, options) {
        super(url, options);

        this.CLASS_NAME = "SuperMap.FindMTSPPathsService";
    }

    /**
     * @function FindMTSPPathsService.prototype.destroy
     * @override
     */
    destroy() {
        super.destroy();
    }

    /**
     * @function FindMTSPPathsService..prototype.processAsync
     * @description 负责将客户端的查询参数传递到服务端。
     * @param {FindMTSPPathsParameters} params - 多旅行商分析服务参数类
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    processAsync(params, callback) {
        if (!(params instanceof FindMTSPPathsParameters)) {
            return;
        }
        var me = this,
            jsonObject,
            //end = me.url.substr(me.url.length - 1, 1),
            centers = me.getJson(params.isAnalyzeById, params.centers),
            nodes = me.getJson(params.isAnalyzeById, params.nodes);
        me.url = Util_Util.urlPathAppend(me.url, 'mtsppath');
        jsonObject = {
            centers: centers,
            nodes: nodes,
            parameter: Util_Util.toJSON(params.parameter),
            hasLeastTotalCost: params.hasLeastTotalCost
        };
        return me.request({
            method: "GET",
            params: jsonObject,
            scope: me,
            success: callback,
            failure: callback
        });
    }

    /**
     * @function FindMTSPPathsService.prototype.getJson
     * @description 将对象转化为JSON字符串。
     * @param {boolean} isAnalyzeById - 是否通过id分析
     * @param {Array} params - 需要转换的数字
     * @returns {Object} 转化后的JSON字符串。
     */
    getJson(isAnalyzeById, params) {
        var jsonString = "[",
            len = params ? params.length : 0;

        if (isAnalyzeById === false) {
            for (let i = 0; i < len; i++) {
                if (i > 0) {
                    jsonString += ",";
                }
                jsonString += '{"x":' + params[i].x + ',"y":' + params[i].y + '}';
            }
        } else if (isAnalyzeById === true) {
            for (let i = 0; i < len; i++) {
                if (i > 0) {
                    jsonString += ",";
                }
                jsonString += params[i];
            }
        }
        jsonString += ']';
        return jsonString;
    }

    /**
     * @function FindMTSPPathsService.prototype.toGeoJSONResult
     * @description 将含有 geometry 的数据转换为 GeoJSON 格式。
     * @param {Object} result - 服务器返回的结果对象。
     */
    toGeoJSONResult(result) {
        if (!result || !result.pathList) {
            return null;
        }
        var geoJSONFormat = new GeoJSON();
        result.pathList.map(function (path) {
            if (path.route) {
                path.route = geoJSONFormat.toGeoJSON(path.route);
            }
            if (path.pathGuideItems) {
                path.pathGuideItems = geoJSONFormat.toGeoJSON(path.pathGuideItems);
            }
            if (path.edgeFeatures) {
                path.edgeFeatures = geoJSONFormat.toGeoJSON(path.edgeFeatures);
            }
            if (path.nodeFeatures) {
                path.nodeFeatures = geoJSONFormat.toGeoJSON(path.nodeFeatures);
            }
            return path;
        });
        return result;
    }

}

;// CONCATENATED MODULE: ./src/common/iServer/FindPathParameters.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/



/**
 * @class FindPathParameters
 * @deprecatedclass SuperMap.FindPathParameters
 * @category  iServer NetworkAnalyst Path
 * @classdesc 最佳路径分析参数类。最佳路径是在网络数据集中指定一些结点，按照顺序访问结点从而求解起止点之间阻抗最小的路径。
 * 例如如果要顺序访问 1、2、3、4 四个结点，则需要分别找到1、2结点间的最佳路径 R1—2，2、3 间的最佳路径 R2—3 和 3、4 结点间的最佳路径 R3—4，
 * 顺序访问 1、2、3、4 四个结点的最佳路径就是 R = R1—2 + R2—3 + R3—4。
 * 阻抗就是指从一点到另一点的耗费，在实际应用中我们可以将距离、时间、花费等作为阻抗条件。
 * 阻抗最小也就可以理解为从一点到另一点距离最短、时间最少、花费最低等。当两点间距离最短时为最短路径，它是最佳路径问题的一个特例。
 * 阻抗值通过 {@link TransportationAnalystParameter#weightFieldName}设置。
 * 计算最佳路径除了受阻抗影响外，还受转向字段的影响。转向值通过 {@link TransportationAnalystParameter#turnWeightField} 设置。
 *
 * @param {Object} options - 参数。
 * @param {Array.<GeometryPoint|L.LatLng|L.Point|ol.geom.Point|mapboxgl.LngLat|mapboxgl.Point|Array.<number>>} options.nodes - 最佳路径分析经过的结点或设施点数组。该字段至少包含两个点。
 * @param {boolean} [options.isAnalyzeById=false] - 是否通过节点 ID 指定路径分析的结点。
 * @param {boolean} [options.hasLeastEdgeCount=false] - 是否按照弧段数最少的进行最佳路径分析。
 * @param {TransportationAnalystParameter} [options.parameter] - 交通网络分析通用参数。
 * @usage
 */
class FindPathParameters {

    constructor(options) {

        /**
         * @member {boolean} [FindPathParameters.prototype.isAnalyzeById=false]
         * @description 是否通过节点 ID 指定路径分析的结点。
         *              指定路径分析经过的结点或设施点有两种方式：输入结点 ID 号或直接输入点坐标。
         *              当该字段为 true 时，表示通过结点 ID 指定途经点，即 FindPathParameters.nodes = [ID1,ID2,...]；
         *              反之表示通过结点坐标指定途经点，即 FindPathParameters.nodes = [{x1,y1},{x2,y2},...] 。
         */
        this.isAnalyzeById = false;

        /**
         * @member {boolean} [FindPathParameters.prototype.hasLeastEdgeCount=false]
         * @description 是否按照弧段数最少的进行最佳路径分析。
         *              true 表示按照弧段数最少进行分析，返回弧段数最少的路径中一个阻抗最小的最佳路径；
         *              false 表示直接返回阻抗最小的路径，而不考虑弧段的多少。
         */
        this.hasLeastEdgeCount = null;

        /**
         * @member {Array.<GeometryPoint|L.LatLng|L.Point|ol.geom.Point|mapboxgl.LngLat|mapboxgl.Point|Array.<number>>} FindPathParameters.prototype.nodes
         * @description 最佳路径分析经过的结点或设施点数组，必设字段。该字段至少包含两个点。
         *              当 FindPathParameters.isAnalyzeById = false 时，nodes 应为点的坐标数组；
         *              当 FindPathParameters.isAnalyzeById = true 时，nodes 应为点的 ID 数组。
         */
        this.nodes = null;

        /**
         * @member {TransportationAnalystParameter} FindPathParameters.prototype.parameter
         * @description 交通网络分析通用参数。
         */
        this.parameter = new TransportationAnalystParameter();
        Util_Util.extend(this, options);

        this.CLASS_NAME = "SuperMap.FindPathParameters";
    }


    /**
     * @function FindPathParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        var me = this;
        me.isAnalyzeById = null;
        me.hasLeastEdgeCount = null;
        me.nodes = null;
        if (me.parameter) {
            me.parameter.destroy();
            me.parameter = null;
        }
    }

}

;// CONCATENATED MODULE: ./src/common/iServer/FindPathService.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/





/**
 * @class FindPathService
 * @deprecatedclass SuperMap.FindPathService
 * @category iServer NetworkAnalyst Path
 * @classdesc 最佳路径分析服务类。
 *            最佳路径是在网络数据集中指定一些节点，按照节点的选择顺序，
 *            顺序访问这些节点从而求解起止点之间阻抗最小的路经。
 *            该类负责将客户端指定的最佳路径分析参数传递给服务端，并接收服务端返回的结果数据。
 *            最佳路径分析结果通过该类支持的事件的监听函数参数获取
 * @extends {NetworkAnalystServiceBase}
 * @example
 * var myFindPathService = new FindPathService(url);
 * @param {string} url - 服务地址。请求网络分析服务，URL应为：
 *                       http://{服务器地址}:{服务端口号}/iserver/services/{网络分析服务名}/rest/networkanalyst/{网络数据集@数据源}；
 *                       例如:"http://localhost:8090/iserver/services/components-rest/rest/networkanalyst/RoadNet@Changchun"。
 * @param {Object} options - 参数。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @usage
 */
class FindPathService extends NetworkAnalystServiceBase {

    constructor(url, options) {
        super(url, options);

        this.CLASS_NAME = "SuperMap.FindPathService";
    }

    /**
     * @function FindPathService.prototype.destroy
     * @override
     */
    destroy() {
        super.destroy();
    }

    /**
     * @function FindPathService.prototype.processAsync
     * @description 负责将客户端的查询参数传递到服务端。
     * @param {FindPathParameters} params - 最佳路径分析服务参数类
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    processAsync(params, callback) {
        if (!(params instanceof FindPathParameters)) {
            return;
        }
        var me = this, jsonObject;
        me.url = Util_Util.urlPathAppend(me.url, 'path');
        jsonObject = {
            hasLeastEdgeCount: params.hasLeastEdgeCount,
            parameter: Util_Util.toJSON(params.parameter),
            nodes: me.getJson(params.isAnalyzeById, params.nodes)
        };
        return me.request({
            method: "GET",
            params: jsonObject,
            scope: me,
            success: callback,
            failure: callback
        });
    }

    /**
     * @function FindPathService.prototype.getJson
     * @description 将对象转化为JSON字符串。
     * @param {boolean} isAnalyzeById - 是否通过id分析
     * @param {Array} params - 需要转换的数字
     * @returns {Object} 转化后的JSON字符串。
     */
    getJson(isAnalyzeById, params) {
        var jsonString = "[",
            len = params ? params.length : 0;

        if (isAnalyzeById === false) {
            for (let i = 0; i < len; i++) {
                if (i > 0) {
                    jsonString += ",";
                }
                jsonString += '{"x":' + params[i].x + ',"y":' + params[i].y + '}';
            }
        } else if (isAnalyzeById === true) {
            for (let i = 0; i < len; i++) {
                if (i > 0) {
                    jsonString += ",";
                }
                jsonString += params[i];
            }
        }
        jsonString += ']';
        return jsonString;
    }

    /**
     * @function FindMTSPPathsService.prototype.toGeoJSONResult
     * @description 将含有 geometry 的数据转换为 GeoJSON 格式。
     * @param {Object} result - 服务器返回的结果对象。
     */
    toGeoJSONResult(result) {
        if (!result || !result.pathList || result.pathList.length < 1) {
            return null;
        }
        var geoJSONFormat = new GeoJSON();
        result.pathList.forEach(function (path) {
            if (path.route) {
                path.route = geoJSONFormat.toGeoJSON(path.route);
            }
            if (path.pathGuideItems) {
                path.pathGuideItems = geoJSONFormat.toGeoJSON(path.pathGuideItems);

            }
            if (path.edgeFeatures) {
                path.edgeFeatures = geoJSONFormat.toGeoJSON(path.edgeFeatures);
            }
            if (path.nodeFeatures) {
                path.nodeFeatures = geoJSONFormat.toGeoJSON(path.nodeFeatures);
            }
        });
        return result;
    }

}

;// CONCATENATED MODULE: ./src/common/iServer/FindServiceAreasParameters.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/



/**
 * @class FindServiceAreasParameters
 * @deprecatedclass SuperMap.FindServiceAreasParameters
 * @category iServer NetworkAnalyst ServiceArea
 * @classdesc 服务区分析参数类。
 *            服务区分析是以指定服务站点为中心，在一定服务范围内查找网络上服务站点能够提供服务的区域范围。
 *            例如：计算某快餐店能够在30分钟内送达快餐的区域。
 * @param {Object} options - 参数。
 * @param {Array.<number>} options.weights - 每个服务站点提供服务的阻力半径，超过这个阻力半径的区域不予考虑，其单位与阻力字段一致。
 * @param {Array.<GeometryPoint|L.LatLng|L.Point|ol.geom.Point|mapboxgl.LngLat|mapboxgl.Point|Array.<number>>} options.centers - 服务站点数组。
 * @param {boolean} [options.isAnalyzeById=false] - 是否通过节点 ID 指定路径分析的结点。
 * @param {boolean} [options.isCenterMutuallyExclusive=false] - 是否中心点互斥。
 * @param {boolean} [options.isFromCenter=false] - 是否从中心点开始分析。
 * @param {TransportationAnalystParameter} [options.parameter] - 交通网络分析通用参数。
 * @usage
 */
class FindServiceAreasParameters {


    constructor(options) {
        /**
         * @member {boolean} [FindServiceAreasParameters.prototype.isAnalyzeById=false]
         * @description 是否通过节点 ID 指定路径分析的结点。
         *              指定路径分析经过的结点或设施点有两种方式：输入结点 ID 号或直接输入点坐标。
         *              当该字段为 true 时，表示通过结点 ID 指定途经点，即 FindServiceAreasParameters.centers = [ID1,ID2,...]；
         *              反之表示通过结点坐标指定途经点，即 FindServiceAreasParameters.centers = [{x1,y1},{x2,y2},...]。
         */
        this.isAnalyzeById = false;

        /**
         * @member {boolean} [FindServiceAreasParameters.prototype.isCenterMutuallyExclusive=false]
         * @description 是否中心点互斥，即按照中心点的距离进行判断是否要进行互斥处理。
         *              若分析出的服务区有重叠的部分，则通过设置该参数进行互斥处理。
         */
        this.isCenterMutuallyExclusive = false;

        /**
         * @member {Array.<GeometryPoint|L.LatLng|L.Point|ol.geom.Point|mapboxgl.LngLat|mapboxgl.Point|Array.<number>>} FindServiceAreasParameters.prototype.centers
         * @description 服务站点数组。
         *              当该类的 iSAnalyzeById = true 时，通过结点 ID 号指定服务站点；当 iSAnalyzeById = false 时，通过点坐标指定服务站点。
         */
        this.centers = null;

        /**
         * @member {boolean} [FindServiceAreasParameters.prototype.isFromCenter=false]
         * @description 是否从中心点开始分析。
         *              从中心点开始分析和不从中心点开始分析，体现了服务中心和需要该服务的需求地的关系模式。
         *              从中心点开始分析，是一个服务中心向服务需求地提供服务；
         *              而不从中心点开始分析，是一个服务需求地主动到服务中心获得服务。
         */
        this.isFromCenter = false;

        /**
         * APIProperty: weights
         * @member {Array.<number>} FindServiceAreasParameters.prototype.weights
         * @description 每个服务站点提供服务的阻力半径，即超过这个阻力半径的区域不予考虑，其单位与阻力字段一致。
         *              该字段为一个数组，数组长度跟服务中心个数一致，按照索引顺序与站点一一对应，每个元素表示了在对每个服务中心进行服务区分析时，所用的服务半径。
         */
        this.weights = null;

        /**
         * @member {TransportationAnalystParameter} FindServiceAreasParameters.prototype.parameter
         * @description 交通网络分析通用参数。
         */
        this.parameter = new TransportationAnalystParameter();

        Util_Util.extend(this, options);

        this.CLASS_NAME = "SuperMap.FindServiceAreasParameters";
    }

    /**
     * @function FindServiceAreasParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        var me = this;
        me.isAnalyzeById = null;
        me.isCenterMutuallyExclusive = null;
        me.centers = null;
        me.isFromCenter = null;
        me.weights = null;
        if (me.parameter) {
            me.parameter.destroy();
            me.parameter = null;
        }
    }

}

;// CONCATENATED MODULE: ./src/common/iServer/FindServiceAreasService.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/





/**
 * @class FindServiceAreasService
 * @deprecatedclass SuperMap.FindServiceAreasService
 * @category iServer NetworkAnalyst ServiceArea
 * @classdesc 服务区分析服务类。
 *            服务区分析是以指定服务站点为中心，
 *            在一定服务范围内查找网络上服务站点能够提供服务的区域范围。
 *            该类负责将客户端指定的服务区分析参数传递给服务端，并接收服务端返回的结果数据。
 *            服务区分析结果通过该类支持的事件的监听函数参数获取
 * @extends {NetworkAnalystServiceBase}
 * @example
 * var myFindServiceAreasService = new FindServiceAreasService(url);
 * @param {string} url - 服务地址。请求网络分析服务，URL应为：
 *                       http://{服务器地址}:{服务端口号}/iserver/services/{网络分析服务名}/rest/networkanalyst/{网络数据集@数据源}；
 *                       例如:"http://localhost:8090/iserver/services/components-rest/rest/networkanalyst/RoadNet@Changchun"。
 * @param {Object} options - 互服务时所需可选参数。如：
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @usage
 */
class FindServiceAreasService extends NetworkAnalystServiceBase {

    constructor(url, options) {
        super(url, options);

        this.CLASS_NAME = "SuperMap.FindServiceAreasService";
    }

    /**
     * @function FindServiceAreasService.prototype.destroy
     * @override
     */
    destroy() {
        super.destroy();
    }

    /**
     * @function FindServiceAreasService.prototype.processAsync
     * @description 负责将客户端的查询参数传递到服务端。
     * @param {FindServiceAreasParameters} params - 服务区分析服务参数类
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    processAsync(params, callback) {
        if (!(params instanceof FindServiceAreasParameters)) {
            return;
        }
        var me = this, jsonObject;
        me.url = Util_Util.urlPathAppend(me.url, 'servicearea');
        jsonObject = {
            isFromCenter: params.isFromCenter,
            isCenterMutuallyExclusive: params.isCenterMutuallyExclusive,
            parameter: Util_Util.toJSON(params.parameter),
            centers: me.getJson(params.isAnalyzeById, params.centers),
            weights: me.getJson(true, params.weights)
        };
        return me.request({
            method: "GET",
            params: jsonObject,
            scope: me,
            success: callback,
            failure: callback
        });
    }

    /**
     * @function FindServiceAreasService.prototype.getJson
     * @description 将对象转化为JSON字符串。
     * @param {boolean} isAnalyzeById - 是否通过id分析
     * @param {Array} params - 需要转换的数字
     * @returns {Object} 转化后的JSON字符串。
     */
    getJson(isAnalyzeById, params) {
        var jsonString = "[",
            len = params ? params.length : 0;

        if (isAnalyzeById === false) {
            for (let i = 0; i < len; i++) {
                if (i > 0) {
                    jsonString += ",";
                }
                jsonString += '{"x":' + params[i].x + ',"y":' + params[i].y + '}';
            }
        } else if (isAnalyzeById === true) {
            for (let i = 0; i < len; i++) {
                if (i > 0) {
                    jsonString += ",";
                }
                jsonString += params[i];
            }
        }
        jsonString += ']';
        return jsonString;
    }

    /**
     * @function FindServiceAreasService.prototype.toGeoJSONResult
     * @description 将含有 geometry 的数据转换为 GeoJSON 格式。
     * @param {Object} result - 服务器返回的结果对象。
     */
    toGeoJSONResult(result) {
        if (!result || !result.serviceAreaList) {
            return result;
        }
        var geoJSONFormat = new GeoJSON();
        result.serviceAreaList.map(function (serviceArea) {
            if (serviceArea.serviceRegion) {
                serviceArea.serviceRegion = geoJSONFormat.toGeoJSON(serviceArea.serviceRegion);
            }
            if (serviceArea.edgeFeatures) {
                serviceArea.edgeFeatures = geoJSONFormat.toGeoJSON(serviceArea.edgeFeatures);
            }
            if (serviceArea.nodeFeatures) {
                serviceArea.nodeFeatures = geoJSONFormat.toGeoJSON(serviceArea.nodeFeatures);
            }
            if (serviceArea.routes) {
                serviceArea.routes = geoJSONFormat.toGeoJSON(serviceArea.routes);
            }
            return serviceArea;
        });

        return result;
    }

}

;// CONCATENATED MODULE: ./src/common/iServer/FindTSPPathsParameters.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/



/**
 * @class FindTSPPathsParameters
 * @deprecatedclass SuperMap.FindTSPPathsParameters
 * @category iServer NetworkAnalyst TSPPath
 * @classdesc 旅行商分析参数类。
 * 旅行商分析是路径分析的一种，它从起点开始（默认为用户指定的第一点）查找能够遍历所有途经点且花费最小的路径。
 * 旅行商分析也可以指定到达的终点，这时查找从起点能够遍历所有途经点最后到达终点，且花费最小的路径。
 * 旅行商分析和最佳路径分析都是在网络中寻找遍历所有站点的最经济的路径，区别是在遍历网络所有站点的过程中对结点访问顺序不同。
 * 最佳路径分析必须按照指定顺序对站点进行访问，而旅行商分析是无序的路径分析。
 * @param {Object} options - 参数。
 * @param {boolean} [options.endNodeAssigned=false] - 是否指定终止点，将指定的途经点的最后一个点作为终止点。true 表示指定终止点，则旅行商必须最后一个访问终止点。
 * @param {boolean} [options.isAnalyzeById=false] - 是否通过节点 ID 号来指定配送中心点和配送目的点。
 * @param {Array.<GeometryPoint|L.LatLng|L.Point|ol.geom.Point|mapboxgl.LngLat|mapboxgl.Point|Array.<number>>} options.nodes - 配送目标集合。
 * @param {TransportationAnalystParameter} [options.parameter] - 交通网络分析通用参数。
 * @usage
 */
class FindTSPPathsParameters {


    constructor(options) {
        /**
         * @member {boolean} [FindTSPPathsParameters.prototype.endNodeAssigned=false]
         * @description 是否指定终止点，将指定的途经点的最后一个点作为终止点。
         *              true 表示指定终止点，则旅行商必须最后一个访问终止点。
         */
        this.endNodeAssigned = false;

        /**
         * @member {boolean} [FindTSPPathsParameters.prototype.isAnalyzeById=false]
         * @description 是否通过节点 ID 号来指定途经点。
         */
        this.isAnalyzeById = false;

        /**
         * @member {Array.<GeometryPoint|L.LatLng|L.Point|ol.geom.Point|mapboxgl.LngLat|mapboxgl.Point|Array.<number>>} FindTSPPathsParameters.prototype.nodes
         * @description 旅行商分析途经点数组。
         *              当 FindTSPPathsParameters.isAnalyzeById = false 时，nodes 应为点的坐标数组；
         *              当 FindTSPPathsParameters.isAnalyzeById = true 时，nodes 应为点的 ID 数组。
         */
        this.nodes = null;

        /**
         * @member {TransportationAnalystParameter} [FindTSPPathsParameters.prototype.parameter]
         * @description 交通网络分析通用参数。通过本类可以设置障碍边、障碍点、权值字段信息的名称标识、转向权值字段等信息。
         *              TransportationAnalystParameter 类型，它虽然为可选参数，但是如果不设置其中的 resultSetting
         *              字段，则返回结果空间信息等都为空。
         */
        this.parameter = new TransportationAnalystParameter();
        Util_Util.extend(this, options);

        this.CLASS_NAME = "SuperMap.FindTSPPathsParameters";
    }

    /**
     * @function FindTSPPathsParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        var me = this;
        me.endNodeAssigned = null;
        me.isAnalyzeById = null;
        me.nodes = null;
        if (me.parameter) {
            me.parameter.destroy();
            me.parameter = null;
        }
    }

}

;// CONCATENATED MODULE: ./src/common/iServer/FindTSPPathsService.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/





/**
 * @class FindTSPPathsService
 * @deprecatedclass SuperMap.FindTSPPathsService
 * @category  iServer NetworkAnalyst TSPPath
 * @classdesc 旅行商分析服务类
 *            旅行商分析是路径分析的一种，它从起点开始（默认为用户指定的第一点）查找能够遍历所有途经点且花费最小的路径。
 *            旅行商分析也可以指定到达的终点，这时查找从起点能够遍历所有途经点最后到达终点，且花费最小的路径。
 *            该类负责将客户端指定的旅行商分析参数传递给服务端，并接收服务端返回的结果数据。
 *            旅行商分析结果通过该类支持的事件的监听函数参数获取
 * @extends {NetworkAnalystServiceBase}
 * @example
 * (start code)
 * var myFindTSPPathsService = new FindTSPPathsService(url);
 * (end)
 * @param {string} url - 网络分析服务地址。请求网络分析服务，URL应为：
 *                       http://{服务器地址}:{服务端口号}/iserver/services/{网络分析服务名}/rest/networkanalyst/{网络数据集@数据源}；
 *                       例如:"http://localhost:8090/iserver/services/components-rest/rest/networkanalyst/RoadNet@Changchun"。
 * @param {Object} options - 参数。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @usage
 */
class FindTSPPathsService extends NetworkAnalystServiceBase {

    constructor(url, options) {
        super(url, options);

        this.CLASS_NAME = "SuperMap.FindTSPPathsService";
    }

    /**
     * @function FindTSPPathsService.prototype.destroy
     * @override
     */
    destroy() {
        super.destroy();
    }

    /**
     * @function FindTSPPathsService.prototype.processAsync
     * @description 负责将客户端的查询参数传递到服务端。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @param {FindTSPPathsParameters} params - 旅行商分析服务参数类。
     * @returns {Promise} Promise 对象。
     */
    processAsync(params, callback) {
        if (!(params instanceof FindTSPPathsParameters)) {
            return;
        }
        var me = this, jsonObject;
        me.url = Util_Util.urlPathAppend(me.url, 'tsppath');
        jsonObject = {
            parameter: Util_Util.toJSON(params.parameter),
            endNodeAssigned: params.endNodeAssigned,
            nodes: me.getNodesJson(params)
        };
        return me.request({
            method: "GET",
            params: jsonObject,
            scope: me,
            success: callback,
            failure: callback
        });
    }

    /**
     * @function FindTSPPathsService.prototype.getNodesJson
     * @description 将节点对象转化为JSON字符串。
     * @param {FindTSPPathsParameters} params - 旅行商分析服务参数类。
     * @returns {string} 转化后的JSON字符串。
     */
    getNodesJson(params) {
        var jsonParameters = "", nodesString, i, len, nodes;
        if (params.isAnalyzeById === false) {
            for (nodesString = "[", i = 0, nodes = params.nodes, len = nodes.length; i < len; i++) {
                if (i > 0) {
                    nodesString += ",";
                }
                nodesString += '{"x":' + nodes[i].x + ',"y":' + nodes[i].y + '}';
            }
            nodesString += ']';
            jsonParameters += nodesString;
        } else if (params.isAnalyzeById === true) {
            let nodeIDsString = "[", nodes = params.nodes, len = nodes.length;
            for (let i = 0; i < len; i++) {
                if (i > 0) {
                    nodeIDsString += ",";
                }
                nodeIDsString += nodes[i];
            }
            nodeIDsString += ']';
            jsonParameters += nodeIDsString;
        }
        return jsonParameters;
    }

    /**
     * @function FindTSPPathsService.prototype.toGeoJSONResult
     * @description 将含有 geometry 的数据转换为 GeoJSON 格式。
     * @param {Object} result - 服务器返回的结果对象。
     */
    toGeoJSONResult(result) {
        if (!result || !result.tspPathList) {
            return null;
        }
        var geoJSONFormat = new GeoJSON();
        result.tspPathList.forEach(function (path) {
            if (path.route) {
                path.route = geoJSONFormat.toGeoJSON(path.route);
            }
            if (path.pathGuideItems) {
                path.pathGuideItems = geoJSONFormat.toGeoJSON(path.pathGuideItems);
            }
            if (path.edgeFeatures) {
                path.edgeFeatures = geoJSONFormat.toGeoJSON(path.edgeFeatures);
            }
            if (path.nodeFeatures) {
                path.nodeFeatures = geoJSONFormat.toGeoJSON(path.nodeFeatures);
            }
        });
        return result;
    }

}

;// CONCATENATED MODULE: ./src/common/iServer/UpdateEdgeWeightParameters.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


/**
 * @class UpdateEdgeWeightParameters
 * @deprecatedclass SuperMap.UpdateEdgeWeightParameters
 * @category  iServer NetworkAnalyst EdgeWeight
 * @classdesc 边的耗费权重更新服务参数类。
 * @param {Object} options - 参数。
 * @param {string} options.edgeId - 所在边的 ID。
 * @param {string} options.fromNodeId - 起始转向点的 ID。
 * @param {string} options.toNodeId - 终止转向点的 ID。
 * @param {string} options.weightField - 边的耗费字段。
 * @param {string} options.edgeWeight - 耗费权重。
 * @usage
 */
class UpdateEdgeWeightParameters {

    constructor(options) {
        if (!options) {
            return;
        }
        /**
         * @member {string} UpdateEdgeWeightParameters.prototype.edgeId
         * @description 所在边的 ID。
         */
        this.edgeId = "";

        /**
         * @member {string} UpdateEdgeWeightParameters.prototype.fromNodeId
         * @description 起始转向点的 ID。
         */
        this.fromNodeId = "";

        /**
         * @member {string} UpdateEdgeWeightParameters.prototype.toNodeId
         * @description 终止转向点的 ID。
         */
        this.toNodeId = "";

        /**
         * @member {string} UpdateEdgeWeightParameters.prototype.weightField
         * @description 边的耗费字段。
         */
        this.weightField = "";

        /**
         * @member {string} UpdateEdgeWeightParameters.prototype.edgeWeight
         * @description 耗费权重。
         */
        this.edgeWeight = "";

        Util_Util.extend(this, options);

        this.CLASS_NAME = "SuperMap.UpdateEdgeWeightParameters";
    }


    /**
     * @function UpdateEdgeWeightParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        this.edgeId = null;
        this.fromNodeId = null;
        this.toNodeId = null;
        this.weightField = null;
        this.edgeWeight = null;
    }

}

;// CONCATENATED MODULE: ./src/common/iServer/UpdateEdgeWeightService.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/




/**
 * @class UpdateEdgeWeightService
 * @deprecatedclass SuperMap.UpdateEdgeWeightService
 * @category  iServer NetworkAnalyst EdgeWeight
 * @classdesc 更新边的边的耗费权重服务
 * @extends {NetworkAnalystServiceBase}
 * @example
 *(start code)
 * var updateEdgeWeightService = new UpdateEdgeWeightService(url);
 * (end)
 * @param {string} url - 服务地址。如：http://localhost:8090/iserver/services/transportationanalyst-sample/rest/networkanalyst/RoadNet@Changchun 。
 * @param {Object} options - 参数。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @usage
 */
class UpdateEdgeWeightService extends NetworkAnalystServiceBase {

    constructor(url, options) {
        super(url, options);
        this.CLASS_NAME = "SuperMap.UpdateEdgeWeightService";
    }

    /**
     * @override
     */
    destroy() {
        super.destroy();
    }

    /**
     * @function UpdateEdgeWeightService.prototype.processAsync
     * @description 开始异步执行边的边的耗费权重的更新
     * @param {UpdateEdgeWeightParameters} params - 边的耗费权重更新服务参数类
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     * @example
     * (code)
     *  var updateEdgeWeightParam=new SuperMapUpdateEdgeWeightParameters({
     *          edgeId:"20",
     *          fromNodeId:"26",
     *          toNodeId:"109",
     *          weightField:"time",
     *          edgeWeight:"25"
     *      });
     *  updateEdgeWeightService.processAsync(updateEdgeWeightParam);
     * (end)
     */
    processAsync(params, callback) {
        if (!(params instanceof UpdateEdgeWeightParameters)) {
            return;
        }

        var me = this;
        var paramStr = me.parse(params);
        me.url = Util_Util.urlPathAppend(me.url, paramStr);
        var data = params.edgeWeight ? params.edgeWeight : null;
        return me.request({
            method: "PUT",
            scope: me,
            data: data,
            success: callback,
            failure: callback
        });
    }

    /**
    * @function UpdateEdgeWeightService.prototype.parse
    * @description 将更新服务参数解析为用‘/’做分隔的字符串
    */
    parse(params) {
        if (!params) {
            return;
        }
        var paramStr = "";
        for (var attr in params) {
            if (params[attr] === "" || params[attr] === "edgeWeight") {
                continue;
            }
            switch (attr) {
                case "edgeId":
                    paramStr += "/edgeweight/" + params[attr];
                    break;
                case "fromNodeId":
                    paramStr += "/fromnode/" + params[attr];
                    break;
                case "toNodeId":
                    paramStr += "/tonode/" + params[attr];
                    break;
                case "weightField":
                    paramStr += "/weightfield/" + params[attr];
                    break;
                default :
                    break;
            }
        }
        return paramStr;
    }

}

;// CONCATENATED MODULE: ./src/common/iServer/UpdateTurnNodeWeightParameters.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


/**
 * @class UpdateTurnNodeWeightParameters
 * @deprecatedclass SuperMap.UpdateTurnNodeWeightParameters
 * @category  iServer NetworkAnalyst TurnNodeWeight
 * @classdesc 转向耗费权重更新服务参数类。
 * @param {Object} options - 参数。
 * @param {string} options.nodeId - 转向结点的  ID。
 * @param {string} options.fromEdgeId - 起始边的  ID。
 * @param {string} options.toEdgeId - 终止边的  ID。
 * @param {string} options.weightField - 转向结点的耗费字段。
 * @param {string} options.turnNodeWeight - 耗费权重。
 * @usage
 */
class UpdateTurnNodeWeightParameters {

    constructor(options) {
        if (!options) {
            return;
        }
        /**
         * @member {string} UpdateTurnNodeWeightParameters.prototype.nodeId
         * @description 转向结点的  ID。
         */
        this.nodeId = "";

        /**
         * @member {string} UpdateTurnNodeWeightParameters.prototype.fromEdgeId
         * @description 起始边的  ID。
         */
        this.fromEdgeId = "";

        /**
         * @member {string} UpdateTurnNodeWeightParameters.prototype.toEdgeId
         * @description 终止边的  ID。
         */
        this.toEdgeId = "";

        /**
         * @member {string} UpdateTurnNodeWeightParameters.prototype.weightField
         * @description 转向结点的耗费字段。
         */
        this.weightField = "";

        /**
         * @member {string} UpdateTurnNodeWeightParameters.prototype.turnNodeWeight
         * @description 耗费权重。
         */
        this.turnNodeWeight = "";
        Util_Util.extend(this, options);
        this.CLASS_NAME = "SuperMap.UpdateTurnNodeWeightParameters";
    }

    /**
     * @function UpdateTurnNodeWeightParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        this.nodeId = null;
        this.fromEdgeId = null;
        this.toEdgeId = null;
        this.weightField = null;
        this.turnNodeWeight = null;
    }

}

;// CONCATENATED MODULE: ./src/common/iServer/UpdateTurnNodeWeightService.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/




/**
 * @class UpdateTurnNodeWeightService
 * @deprecatedclass SuperMap.UpdateTurnNodeWeightService
 * @category  iServer NetworkAnalyst TurnNodeWeight
 * @classdesc 转向耗费权重更新服务类
 * @extends {NetworkAnalystServiceBase}
 * @example
 * var UpdateTurnNodeWeightService = new UpdateTurnNodeWeightService(url);
 * @param {string} url - 服务地址。如:
 *                       http://localhost:8090/iserver/services/transportationanalyst-sample/rest/networkanalyst/RoadNet@Changchun 。
 * @param {Object} options - 参数。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @usage
 */
class UpdateTurnNodeWeightService extends NetworkAnalystServiceBase {

    constructor(url, options) {
        super(url, options);
        this.CLASS_NAME = "SuperMap.UpdateTurnNodeWeightService";
    }

    /**
     * @override
     */
    destroy() {
        super.destroy();
    }

    /**
     * @function UpdateTurnNodeWeightService.prototype.processAsync
     * @description 开始异步执行转向耗费权重的更新
     * @param {UpdateTurnNodeWeightParameters} params - 转向耗费权重更新服务参数类
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     * @example
     * (code)
     *  var updateTurnNodeWeightParam=new UpdateTurnNodeWeightParameters({
     *           nodeId:"106",
     *           fromEdgeId:"6508",
     *           toEdgeId:"6504",
     *           weightField:"TurnCost",
     *           turnNodeWeight:"50"
     *       });
     *  updateTurnNodeWeightService.processAsync(updateTurnNodeWeightParam);
     * (end)
     **/
    processAsync(params, callback) {
        if (!(params instanceof UpdateTurnNodeWeightParameters)) {
            return;
        }
        var me = this;
        var paramStr = me.parse(params);
        me.url = Util_Util.urlPathAppend(me.url, paramStr);
        var data = params.turnNodeWeight ? params.turnNodeWeight : null;
        return me.request({
            method: "PUT",
            scope: me,
            data: data,
            success: callback,
            failure: callback
        });
    }

    /**
     * @function UpdateTurnNodeWeightService.prototype.parse
     * @description 将更新服务参数解析为用‘/’做分隔的字符串
     */
    parse(params) {
        if (!params) {
            return;
        }
        var paramStr = "";
        for (var attr in params) {
            if (params[attr] === "" || params[attr] === "turnNodeWeight") {
                continue;
            }
            switch (attr) {
                case "nodeId":
                    paramStr += "/turnnodeweight/" + params[attr];
                    break;
                case "fromEdgeId":
                    paramStr += "/fromedge/" + params[attr];
                    break;
                case "toEdgeId":
                    paramStr += "/toedge/" + params[attr];
                    break;
                case "weightField":
                    paramStr += "/weightfield/" + params[attr];
                    break;
                default :
                    break;
            }
        }
        return paramStr;
    }

}

;// CONCATENATED MODULE: ./src/common/iServer/NetworkAnalystService.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/















/**
 * @class NetworkAnalystService
 * @category  iServer NetworkAnalyst
 * @classdesc 网络分析服务类。
 * @extends {ServiceBase}
 * @example
 * new NetworkAnalystService(url)
 *  .findPath(params,function(result){
 *     //doSomething
 * })
 * @param {string} url - 服务地址。请求网络分析服务，URL应为：</br>
 *                       http://{服务器地址}:{服务端口号}/iserver/services/{网络分析服务名}/rest/networkanalyst/{网络数据集@数据源}。
 *                       例如: "http://localhost:8090/iserver/services/test/rest/networkanalyst/WaterNet@FacilityNet"。
 * @param {Object} options - 参数。 
 * @param {string} [options.proxy] - 服务代理地址。
 * @param {boolean} [options.withCredentials=false] - 请求是否携带 cookie。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @usage
 */
class NetworkAnalystService_NetworkAnalystService {

    constructor(url, options) {
        this.url = url;
        this.options = options || {};
    }

    /**
     * @function NetworkAnalystService.prototype.burstPipelineAnalyst
     * @description 爆管分析服务:即将给定弧段或节点作为爆管点来进行分析，返回关键结点 ID 数组，普通结点 ID 数组及其上下游弧段 ID 数组。
     * @param {BurstPipelineAnalystParameters} params - 爆管分析服务参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    burstPipelineAnalyst(params, callback) {
        var me = this;
        var burstPipelineAnalystService = new BurstPipelineAnalystService(me.url, {
            proxy: me.options.proxy,
            withCredentials: me.options.withCredentials,
            crossOrigin: me.options.crossOrigin,
            headers: me.options.headers
        });
        return burstPipelineAnalystService.processAsync(params, callback);
    }

    /**
     * @function NetworkAnalystService.prototype.computeWeightMatrix
     * @description 耗费矩阵分析服务:根据交通网络分析参数中的耗费字段返回一个耗费矩阵。该矩阵是一个二维数组，用来存储任意两点间的资源消耗。
     * @param {ComputeWeightMatrixParameters} params - 耗费矩阵分析服务参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    computeWeightMatrix(params, callback) {
        var me = this;
        var computeWeightMatrixService = new ComputeWeightMatrixService(me.url, {
            proxy: me.options.proxy,
            withCredentials: me.options.withCredentials,
            crossOrigin: me.options.crossOrigin,
            headers: me.options.headers
        });
        return computeWeightMatrixService.processAsync(params, callback);
    }

    /**
     * @function NetworkAnalystService.prototype.findClosestFacilities
     * @description 最近设施分析服务:指在网络上给定一个事件点和一组设施点，查找从事件点到设施点(或从设施点到事件点)以最小耗费能到达的最佳路径。
     * @param {FindClosestFacilitiesParameters} params - 最近设施分析服务参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @param {DataFormat} [resultFormat=DataFormat.GEOJSON] - 返回结果类型。
     * @returns {Promise} Promise 对象。
     */
    findClosestFacilities(params, callback, resultFormat) {
        var me = this;
        var findClosestFacilitiesService = new FindClosestFacilitiesService(me.url, {
            proxy: me.options.proxy,
            withCredentials: me.options.withCredentials,
            crossOrigin: me.options.crossOrigin,
            headers: me.options.headers,
            format: me._processFormat(resultFormat)
        });
        return findClosestFacilitiesService.processAsync(params, callback);
    }

    /**
     * @function NetworkAnalystService.prototype.traceAnalyst
     * @description 上游/下游 追踪分析服务:查找给定弧段或节点的上游/下游弧段和结点。
     * @param {TraceAnalystParameters} params - 上游/下游 追踪分析服务参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @param {DataFormat} [resultFormat=DataFormat.GEOJSON] - 返回的结果类型。
     * @returns {Promise} Promise 对象。
     */
      traceAnalyst(params, callback, resultFormat) {
        var me = this;
        var traceAnalystService = new TraceAnalystService(me.url, {
            proxy: me.options.proxy,
            withCredentials: me.options.withCredentials,
            crossOrigin: me.options.crossOrigin,
            headers: me.options.headers,
            format: me._processFormat(resultFormat)
        });
        return traceAnalystService.processAsync(params, callback);
      }
  
      /**
       * @function NetworkAnalystService.prototype.connectedEdgesAnalyst
       * @description 连通性分析服务。
       * @param {ConnectedEdgesAnalystParameters} params - 连通性分析服务参数类。
       * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
       * @param {DataFormat} [resultFormat=DataFormat.GEOJSON] - 返回的结果类型。
       * @returns {Promise} Promise 对象。
       */
      connectedEdgesAnalyst(params, callback, resultFormat) {
        var me = this;
        var connectedEdgesAnalystService = new ConnectedEdgesAnalystService(me.url, {
            proxy: me.options.proxy,
            withCredentials: me.options.withCredentials,
            crossOrigin: me.options.crossOrigin,
            headers: me.options.headers,
            format: me._processFormat(resultFormat)
        });
        return connectedEdgesAnalystService.processAsync(params, callback);
      }

    /**
     * @function NetworkAnalystService.prototype.streamFacilityAnalyst
     * @description 上游/下游 关键设施查找资源服务：查找给定弧段或节点的上游/下游中的关键设施结点，返回关键结点 ID 数组及其下游弧段 ID 数组。
     * @param {FacilityAnalystStreamParameters} params - 上游/下游 关键设施查找资源服务参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @param {DataFormat} [resultFormat=DataFormat.GEOJSON] - 返回结果类型。
     * @returns {Promise} Promise 对象。
     */
    streamFacilityAnalyst(params, callback, resultFormat) {
        var me = this;
        var facilityAnalystStreamService = new FacilityAnalystStreamService(me.url, {
            proxy: me.options.proxy,
            withCredentials: me.options.withCredentials,
            crossOrigin: me.options.crossOrigin,
            headers: me.options.headers,
            format: me._processFormat(resultFormat)
        });
        return facilityAnalystStreamService.processAsync(params, callback);
    }

    /**
     * @function NetworkAnalystService.prototype.findLocation
     * @description 选址分区分析服务：确定一个或多个待建设施的最佳或最优位置。
     * @param {FindLocationParameters} params - 选址分区分析服务参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @param {DataFormat} [resultFormat=DataFormat.GEOJSON] - 返回结果类型。
     * @returns {Promise} Promise 对象。
     */
    findLocation(params, callback, resultFormat) {
        var me = this;
        var findLocationService = new FindLocationService(me.url, {
            proxy: me.options.proxy,
            withCredentials: me.options.withCredentials,
            crossOrigin: me.options.crossOrigin,
            headers: me.options.headers,
            format: me._processFormat(resultFormat)
        });
        return findLocationService.processAsync(params, callback);
    }

    /**
     * @function NetworkAnalystService.prototype.findPath
     * @description 最佳路径分析服务:在网络数据集中指定一些节点，按照节点的选择顺序，顺序访问这些节点从而求解起止点之间阻抗最小的路经。
     * @param {FindPathParameters} params - 最佳路径分析服务参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @param {DataFormat} [resultFormat=DataFormat.GEOJSON] - 返回结果类型。
     * @returns {Promise} Promise 对象。
     */
    findPath(params, callback, resultFormat) {
        var me = this;
        var findPathService = new FindPathService(me.url, {
            proxy: me.options.proxy,
            withCredentials: me.options.withCredentials,
            crossOrigin: me.options.crossOrigin,
            headers: me.options.headers,
            format: me._processFormat(resultFormat)
        });
        return findPathService.processAsync(params, callback);
    }

    /**
     * @function NetworkAnalystService.prototype.findTSPPaths
     * @description 旅行商分析服务:路径分析的一种，它从起点开始（默认为用户指定的第一点）查找能够遍历所有途经点且花费最小的路径。
     * @param {FindTSPPathsParameters} params - 旅行商分析服务参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @param {DataFormat} [resultFormat=DataFormat.GEOJSON] - 返回结果类型。
     * @returns {Promise} Promise 对象。
     */
    findTSPPaths(params, callback, resultFormat) {
        var me = this;
        var findTSPPathsService = new FindTSPPathsService(me.url, {
            proxy: me.options.proxy,
            withCredentials: me.options.withCredentials,
            crossOrigin: me.options.crossOrigin,
            headers: me.options.headers,
            format: me._processFormat(resultFormat)
        });
        return findTSPPathsService.processAsync(params, callback);
    }

    /**
     * @function NetworkAnalystService.prototype.findMTSPPaths
     * @description 多旅行商分析服务:也称为物流配送，是指在网络数据集中，给定 M 个配送中心点和 N 个配送目的地（M，N 为大于零的整数）。查找经济有效的配送路径，并给出相应的行走路线。
     * @param {FindMTSPPathsParameters} params - 多旅行商分析服务参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @param {DataFormat} [resultFormat=DataFormat.GEOJSON] - 返回结果类型。
     * @returns {Promise} Promise 对象。
     */
    findMTSPPaths(params, callback, resultFormat) {
        var me = this;
        var findMTSPPathsService = new FindMTSPPathsService(me.url, {
            proxy: me.options.proxy,
            withCredentials: me.options.withCredentials,
            crossOrigin: me.options.crossOrigin,
            headers: me.options.headers,
            format: me._processFormat(resultFormat)
        });
        return findMTSPPathsService.processAsync(params, callback);
    }

    /**
     * @function NetworkAnalystService.prototype.findServiceAreas
     * @description 服务区分析服务：以指定服务站点为中心，在一定服务范围内查找网络上服务站点能够提供服务的区域范围。
     * @param {FindServiceAreasParameters} params - 服务区分析服务参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @param {DataFormat} [resultFormat=DataFormat.GEOJSON] - 返回结果类型。
     * @returns {Promise} Promise 对象。
     */
    findServiceAreas(params, callback, resultFormat) {
        var me = this;
        var findServiceAreasService = new FindServiceAreasService(me.url, {
            proxy: me.options.proxy,
            withCredentials: me.options.withCredentials,
            crossOrigin: me.options.crossOrigin,
            headers: me.options.headers,
            format: me._processFormat(resultFormat)
        });
        return findServiceAreasService.processAsync(params, callback);
    }

    /**
     * @function NetworkAnalystService.prototype.updateEdgeWeight
     * @description 更新边的耗费权重服务。
     * @param {UpdateEdgeWeightParameters} params - 更新边的耗费权重服务参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    updateEdgeWeight(params, callback) {
        var me = this;
        var updateEdgeWeightService = new UpdateEdgeWeightService(me.url, {
            proxy: me.options.proxy,
            withCredentials: me.options.withCredentials,
            crossOrigin: me.options.crossOrigin,
            headers: me.options.headers
        });
        return updateEdgeWeightService.processAsync(params, callback);
    }

    /**
     * @function NetworkAnalystService.prototype.updateTurnNodeWeight
     * @description 转向耗费权重更新服务。
     * @param {UpdateTurnNodeWeightParameters} params - 转向耗费权重更新服务参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    updateTurnNodeWeight(params, callback) {
        var me = this;
        var updateTurnNodeWeightService = new UpdateTurnNodeWeightService(me.url, {
            proxy: me.options.proxy,
            withCredentials: me.options.withCredentials,
            crossOrigin: me.options.crossOrigin,
            headers: me.options.headers
        });
        return updateTurnNodeWeightService.processAsync(params, callback);
    }

    _processFormat(resultFormat) {
        return (resultFormat) ? resultFormat : DataFormat.GEOJSON;
    }
}

;// CONCATENATED MODULE: ./src/mapboxgl/services/NetworkAnalystService.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/






/**
 * @class NetworkAnalystService
 * @category  iServer NetworkAnalyst
 * @classdesc 网络分析服务类。
 * @modulecategory Services
 * @extends {ServiceBase}
 * @example
 * new NetworkAnalystService(url)
 *  .findPath(params,function(result){
 *     //doSomething
 * })
 * @param {string} url - 服务地址。请求网络分析服务，URL应为：</br>
 *                       http://{服务器地址}:{服务端口号}/iserver/services/{网络分析服务名}/rest/networkanalyst/{网络数据集@数据源}。
 *                       例如: "http://localhost:8090/iserver/services/test/rest/networkanalyst/WaterNet@FacilityNet"。
 * @param {Object} options - 参数。
 * @param {string} [options.proxy] - 服务代理地址。
 * @param {boolean} [options.withCredentials=false] - 请求是否携带 cookie。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @usage
 */
class NetworkAnalystService extends ServiceBase {

    constructor(url, options) {
        super(url, options);
        this._networkAnalystService = new NetworkAnalystService_NetworkAnalystService(url, options);
    }

    /**
     * @function NetworkAnalystService.prototype.burstPipelineAnalyst
     * @description 爆管分析服务:即将给定弧段或节点作为爆管点来进行分析，返回关键结点 ID 数组，普通结点 ID 数组及其上下游弧段 ID 数组。
     * @param {BurstPipelineAnalystParameters} params - 爆管分析服务参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    burstPipelineAnalyst(params, callback) {
      params = this._processParams(params);
      return this._networkAnalystService.burstPipelineAnalyst(params, callback);
    }

    /**
     * @function NetworkAnalystService.prototype.computeWeightMatrix
     * @description 耗费矩阵分析服务:根据交通网络分析参数中的耗费字段返回一个耗费矩阵。该矩阵是一个二维数组，用来存储任意两点间的资源消耗。
     * @param {ComputeWeightMatrixParameters} params - 耗费矩阵分析服务参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    computeWeightMatrix(params, callback) {
        params = this._processParams(params);
        return this._networkAnalystService.computeWeightMatrix(params, callback);
    }

    /**
     * @function NetworkAnalystService.prototype.findClosestFacilities
     * @description 最近设施分析服务:指在网络上给定一个事件点和一组设施点，查找从事件点到设施点(或从设施点到事件点)以最小耗费能到达的最佳路径。
     * @param {FindClosestFacilitiesParameters} params - 最近设施分析服务参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @param {DataFormat} [resultFormat=DataFormat.GEOJSON] - 返回结果类型。
     * @returns {Promise} Promise 对象。
     */
    findClosestFacilities(params, callback, resultFormat) {
      params = this._processParams(params);
      return this._networkAnalystService.findClosestFacilities(params, callback, resultFormat);
    }

    /**
     * @function NetworkAnalystService.prototype.traceAnalyst
     * @description 上游/下游 追踪分析服务:查找给定弧段或节点的上游/下游弧段和结点。
     * @version 11.1.1
     * @param {TraceAnalystParameters} params - 上游/下游 追踪分析服务参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @param {DataFormat} [resultFormat=DataFormat.GEOJSON] - 返回的结果类型。
     * @returns {Promise} Promise 对象。
     */
    traceAnalyst(params, callback, resultFormat) {
      params = this._processParams(params);
      return this._networkAnalystService.traceAnalyst(params, callback, resultFormat);
    }

    /**
     * @function NetworkAnalystService.prototype.connectedEdgesAnalyst
     * @description 连通性分析服务。
     * @version 11.1.1
     * @param {ConnectedEdgesAnalystParameters} params - 连通性分析服务参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @param {DataFormat} [resultFormat=DataFormat.GEOJSON] - 返回的结果类型。
     * @returns {Promise} Promise 对象。
     */
    connectedEdgesAnalyst(params, callback, resultFormat) {
      params = this._processParams(params);
      return this._networkAnalystService.connectedEdgesAnalyst(params, callback, resultFormat);
    }
    /**
     * @function NetworkAnalystService.prototype.streamFacilityAnalyst
     * @description 上游/下游 关键设施查找资源服务：查找给定弧段或节点的上游/下游中的关键设施结点，返回关键结点 ID 数组及其下游弧段 ID 数组。
     * @param {FacilityAnalystStreamParameters} params - 上游/下游 关键设施查找资源服务参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @param {DataFormat} [resultFormat=DataFormat.GEOJSON] - 返回结果类型。
     * @returns {Promise} Promise 对象。
     */
    streamFacilityAnalyst(params, callback, resultFormat) {
      params = this._processParams(params);
      return this._networkAnalystService.streamFacilityAnalyst(params, callback, resultFormat);
    }

    /**
     * @function NetworkAnalystService.prototype.findLocation
     * @description 选址分区分析服务：确定一个或多个待建设施的最佳或最优位置。
     * @param {FindLocationParameters} params - 选址分区分析服务参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @param {DataFormat} [resultFormat=DataFormat.GEOJSON] - 返回结果类型。
     * @returns {Promise} Promise 对象。
     */
    findLocation(params, callback, resultFormat) {
      params = this._processParams(params);
      return this._networkAnalystService.findLocation(params, callback, resultFormat);
    }

    /**
     * @function NetworkAnalystService.prototype.findPath
     * @description 最佳路径分析服务:在网络数据集中指定一些节点，按照节点的选择顺序，顺序访问这些节点从而求解起止点之间阻抗最小的路经。
     * @param {FindPathParameters} params - 最佳路径分析服务参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @param {DataFormat} [resultFormat=DataFormat.GEOJSON] - 返回结果类型。
     * @returns {Promise} Promise 对象。
     */
    findPath(params, callback, resultFormat) {
      params = this._processParams(params);
      return this._networkAnalystService.findPath(params, callback, resultFormat);
    }

    /**
     * @function NetworkAnalystService.prototype.findTSPPaths
     * @description 旅行商分析服务:路径分析的一种，它从起点开始（默认为用户指定的第一点）查找能够遍历所有途经点且花费最小的路径。
     * @param {FindTSPPathsParameters} params - 旅行商分析服务参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @param {DataFormat} [resultFormat=DataFormat.GEOJSON] - 返回结果类型。
     * @returns {Promise} Promise 对象。
     */
    findTSPPaths(params, callback, resultFormat) {
      params = this._processParams(params);
      return this._networkAnalystService.findTSPPaths(params, callback, resultFormat);
    }

    /**
     * @function NetworkAnalystService.prototype.findMTSPPaths
     * @description 多旅行商分析服务:也称为物流配送，是指在网络数据集中，给定 M 个配送中心点和 N 个配送目的地（M，N 为大于零的整数）。查找经济有效的配送路径，并给出相应的行走路线。
     * @param {FindMTSPPathsParameters} params - 多旅行商分析服务参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @param {DataFormat} [resultFormat=DataFormat.GEOJSON] - 返回结果类型。
     * @returns {Promise} Promise 对象。
     */
    findMTSPPaths(params, callback, resultFormat) {
      params = this._processParams(params);
      return this._networkAnalystService.findMTSPPaths(params, callback, resultFormat);
    }

    /**
     * @function NetworkAnalystService.prototype.findServiceAreas
     * @description 服务区分析服务：以指定服务站点为中心，在一定服务范围内查找网络上服务站点能够提供服务的区域范围。
     * @param {FindServiceAreasParameters} params - 服务区分析服务参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @param {DataFormat} [resultFormat=DataFormat.GEOJSON] - 返回结果类型。
     * @returns {Promise} Promise 对象。
     */
    findServiceAreas(params, callback, resultFormat) {
      params = this._processParams(params);
      return this._networkAnalystService.findServiceAreas(params, callback, resultFormat);
    }

    /**
     * @function NetworkAnalystService.prototype.updateEdgeWeight
     * @description 更新边的耗费权重服务。
     * @param {UpdateEdgeWeightParameters} params - 更新边的耗费权重服务参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    updateEdgeWeight(params, callback) {
      return this._networkAnalystService.updateEdgeWeight(params, callback);
    }

    /**
     * @function NetworkAnalystService.prototype.updateTurnNodeWeight
     * @description 转向耗费权重更新服务。
     * @param {UpdateTurnNodeWeightParameters} params - 转向耗费权重更新服务参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    updateTurnNodeWeight(params, callback) {
      return this._networkAnalystService.updateTurnNodeWeight(params, callback);
    }

    /**
     * @description 所有 Point 考虑 mapboxgl.lnglat、mapboxgl.Point、[]三种形式。
     * @param {Object} params - 待转换参数。
     * @returns {Object}
     * @private
     */
    _processParams(params) {
        if (!params) {
            return {};
        }
        var me = this;
        if (params.centers && core_Util_Util.isArray(params.centers)) {
            params.centers.map(function (point, key) {
                params.centers[key] = me._toPointObject(point);
                return params.centers[key];
            });
        }

        if (params.nodes && core_Util_Util.isArray(params.nodes)) {
            params.nodes.map(function (point, key) {
                params.nodes[key] = me._toPointObject(point);
                return params.nodes[key];
            });
        }

        if (params.event) {
            params.event = me._toPointObject(params.event);
        }

        if (params.facilities && core_Util_Util.isArray(params.facilities)) {
            params.facilities.map(function (point, key) {
                params.facilities[key] = me._toPointObject(point);
                return params.facilities[key];
            });
        }
        if (params.parameter && params.parameter.barrierPoints) {
            var barrierPoints = params.parameter.barrierPoints;
            if (core_Util_Util.isArray(barrierPoints)) {
                barrierPoints.map(function (point, key) {
                    params.parameter[key] = me._toPointObject(point);
                    return params.parameter.barrierPoints[key];
                });
            } else {
                params.parameter.barrierPoints = [(barrierPoints instanceof (external_mapboxgl_default()).LngLat) ? {
                    x: barrierPoints.lng,
                    y: barrierPoints.lat
                } : barrierPoints];
            }
        }
        return params;

    }

    _toPointObject(point) {
        if (core_Util_Util.isArray(point)) {
            return {
                x: point[0],
                y: point[1]
            };
        }
        if (point instanceof (external_mapboxgl_default()).LngLat) {
            return {
                x: point.lng,
                y: point.lat
            };
        }
        return (point instanceof (external_mapboxgl_default()).Point) ? {
            x: point.x,
            y: point.y
        } : point;

    }

    _processFormat(resultFormat) {
        return (resultFormat) ? resultFormat : DataFormat.GEOJSON;
    }
}

;// CONCATENATED MODULE: ./src/common/iServer/FacilityAnalyst3DParameters.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


/**
 * @class FacilityAnalyst3DParameters
 * @deprecatedclass SuperMap.FacilityAnalyst3DParameters
 * @category  iServer FacilityAnalyst3D
 * @classdesc 最近设施分析参数基类。最近设施分析是指在网络上给定一个事件点和一组设施点，查找从事件点到设施点（或从设施点到事件点）以最小耗费能到达的最佳路径。
 * 设施点一般为学校、超市、加油站等服务设施；事件点为需要服务设施的事件位置。例如事件发生点是一起交通事故，要求查找在 10 分钟内能到达的最近医院，
 * 超过 10 分钟能到达的都不予考虑。此例中，事故发生地即是一个事件点，周边的医院则是设施点。最近设施查找实际上也是一种路径分析，因此对路径分析起作用的障碍边、障碍点、转向表、耗费等属性在最近设施分析时同样可设置。
 * @param {Object} options - 参数。
 * @param {string} options.weightName - 指定的权值字段信息对象的名称。
 * @param {number} [options.edgeID] - 指定的弧段 ID，edgeID 与 nodeID 必须指定一个。
 * @param {number} [options.nodeID] - 指定的结点 ID，edgeID 与 nodeID 必须指定一个。
 * @param {boolean} [options.isUncertainDirectionValid=false] - 指定不确定流向是否有效。指定为 true，表示不确定流向有效，遇到不确定流向时分析继续进行；
 *                                                      指定为 false，表示不确定流向无效，遇到不确定流向将停止在该方向上继续查找。
 * @usage
 */
class FacilityAnalyst3DParameters {


    constructor(options) {
        /**
         * @member {number} [FacilityAnalyst3DParameters.prototype.edgeID]
         * @description 指定的弧段 ID，edgeID 与 nodeID 必须指定一个。
         */
        this.edgeID = null;

        /**
         * @member {number} [FacilityAnalyst3DParameters.prototype.nodeID]
         * @description 指定的结点 ID，edgeID 与 nodeID 必须指定一个。
         */
        this.nodeID = null;

        /**
         * @member {string} FacilityAnalyst3DParameters.prototype.weightName
         * @description 指定的权值字段信息对象的名称。
         */
        this.weightName = null;

        /**
         * @member {boolean} [FacilityAnalyst3DParameters.prototype.isUncertainDirectionValid=false]
         * @description 指定不确定流向是否有效。指定为 true，表示不确定流向有效，遇到不确定流向时分析继续进行；
         *              指定为 false，表示不确定流向无效，遇到不确定流向将停止在该方向上继续查找。
         */
        this.isUncertainDirectionValid = false;
        Util_Util.extend(this, options);
        this.CLASS_NAME = "SuperMap.FacilityAnalyst3DParameters";

    }

    /**
     * @function FacilityAnalyst3DParameters.prototype.destroy
     * @description 释放资源，将资源的属性置空。
     */
    destroy() {
        var me = this;
        me.edgeID = null;
        me.nodeID = null;
        me.weightName = null;
        me.isUncertainDirectionValid = null;
    }
}

;// CONCATENATED MODULE: ./src/common/iServer/FacilityAnalystSinks3DParameters.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


/**
 * @class FacilityAnalystSinks3DParameters
 * @deprecatedclass SuperMap.FacilityAnalystSinks3DParameters
 * @category  iServer FacilityAnalyst3D Sinks
 * @classdesc 最近设施分析参数类(汇查找资源)。最近设施分析是指在网络上给定一个事件点和一组设施点，查找从事件点到设施点(或从设施点到事件点)以最小耗费能到达的最佳路径。
 *            设施点一般为学校、超市、加油站等服务设施；事件点为需要服务设施的事件位置。例如事件发生点是一起交通事故，要求查找在10分钟内能到达的最近医院，超过10分钟能到达的都不予考虑。此例中，事故发生地即是一个事件点，周边的医院则是设施点。最近设施查找实际上也是一种路径分析，因此对路径分析起作用的障碍边、障碍点、转向表、耗费等属性在最近设施分析时同样可设置。
 * @extends {FacilityAnalyst3DParameters}
 * @param {Object} options - 参数。
 * @param {string} options.weightName - 指定的权值字段信息对象的名称。
 * @param {number} [options.edgeID] - 指定的弧段 ID，edgeID 与 nodeID 必须指定一个。
 * @param {number} [options.nodeID] - 指定的结点 ID，edgeID 与 nodeID 必须指定一个。
 * @param {boolean} [options.isUncertainDirectionValid=false] - 指定不确定流向是否有效。指定为 true，表示不确定流向有效，遇到不确定流向时分析继续进行；
 * 指定为 false，表示不确定流向无效，遇到不确定流向将停止在该方向上继续查找。
 * @usage
 */
class FacilityAnalystSinks3DParameters extends FacilityAnalyst3DParameters {

    constructor(options) {
        super(options);
        this.CLASS_NAME = "SuperMap.FacilityAnalystSinks3DParameters";
    }


    /**
     * @function FacilityAnalystSinks3DParameters.prototype.destroy
     * @override
     */
    destroy() {
        super.destroy();
    }


}

;// CONCATENATED MODULE: ./src/common/iServer/FacilityAnalystSinks3DService.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/




/**
 * @class FacilityAnalystSinks3DService
 * @deprecatedclass SuperMap.FacilityAnalystSinks3DService
 * @category iServer FacilityAnalyst3D Sinks
 * @classdesc  最近设施分析服务类(汇查找资源)<br>
 *             最近设施分析是指在网络上给定一个事件点和一组设施点，
 *             查找从事件点到设施点(或从设施点到事件点)以最小耗费能到达的最佳路径。
 *             该类负责将客户端指定的最近设施分析参数传递给服务端，并接收服务端返回的结果数据。
 *             最近设施分析结果通过该类支持的事件的监听函数参数获取
 * @extends {CommonServiceBase}
 * @example
 * var myFacilityAnalystSinks3DService = new FacilityAnalystSinks3DService(url);
 * @param {string} url - 网络分析服务地址。请求网络分析服务，URL应为：<br>
 *                       http://{服务器地址}:{服务端口号}/iserver/services/{网络分析服务名}/rest/networkanalyst/{网络数据集@数据源}；<br>
 *                       例如:"http://localhost:8090/iserver/services/components-rest/rest/networkanalyst/RoadNet@Changchun"。<br>
 * @param {Object} options - 参数。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @usage
 */
class FacilityAnalystSinks3DService extends CommonServiceBase {

    constructor(url, options) {
        super(url, options);
        this.CLASS_NAME = "SuperMap.FacilityAnalystSinks3DService";
    }


    /**
     * @function FacilityAnalystSinks3DService.prototype.destroy
     * @override
     */
    destroy() {
        CommonServiceBase.prototype.destroy.apply(this, arguments);
    }


    /**
     * @function FacilityAnalystSinks3DService.prototype.processAsync
     * @description 负责将客户端的查询参数传递到服务端。
     * @param {FacilityAnalystSinks3DParameters} params - 最近设施分析参数类(汇查找资源)
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    processAsync(params, callback) {
        if (!(params instanceof FacilityAnalystSinks3DParameters)) {
            return;
        }
        var me = this, jsonObject;
        me.url = Util_Util.urlPathAppend(me.url, 'sinks');
        jsonObject = {
            edgeID: params.edgeID,
            nodeID: params.nodeID,
            weightName: params.weightName,
            isUncertainDirectionValid: params.isUncertainDirectionValid
        };
        return me.request({
            method: "GET",
            params: jsonObject,
            scope: me,
            success: callback,
            failure: callback
        });
    }

}

;// CONCATENATED MODULE: ./src/common/iServer/FacilityAnalystSources3DParameters.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


/**
 * @class FacilityAnalystSources3DParameters
 * @deprecatedclass SuperMap.FacilityAnalystSources3DParameters
 * @category  iServer FacilityAnalyst3D Sources
 * @classdesc 最近设施分析参数类(源查找资源)。最近设施分析是指在网络上给定一个事件点和一组设施点，查找从事件点到设施点(或从设施点到事件点)以最小耗费能到达的最佳路径。
 *            设施点一般为学校、超市、加油站等服务设施；事件点为需要服务设施的事件位置。例如事件发生点是一起交通事故，要求查找在10分钟内能到达的最近医院，超过10分钟能到达的都不予考虑。此例中，事故发生地即是一个事件点，周边的医院则是设施点。最近设施查找实际上也是一种路径分析，因此对路径分析起作用的障碍边、障碍点、转向表、耗费等属性在最近设施分析时同样可设置。
 * @extends {FacilityAnalyst3DParameters}
 * @param {Object} options - 参数。
 * @param {string} options.weightName - 指定的权值字段信息对象的名称。
 * @param {number} [options.edgeID] - 指定的弧段 ID，edgeID 与 nodeID 必须指定一个。
 * @param {number} [options.nodeID] - 指定的结点 ID，edgeID 与 nodeID 必须指定一个。
 * @param {boolean} [options.isUncertainDirectionValid=false] - 指定不确定流向是否有效。指定为 true，表示不确定流向有效，遇到不确定流向时分析继续进行；
 * 指定为 false，表示不确定流向无效，遇到不确定流向将停止在该方向上继续查找。
 * @usage
 */
class FacilityAnalystSources3DParameters extends FacilityAnalyst3DParameters {


    constructor(options) {
        super(options);
        this.CLASS_NAME = "SuperMap.FacilityAnalystSources3DParameters";
    }

    /**
     * @function FacilityAnalystSources3DParameters.prototype.destroy
     * @override
     */
    destroy() {
        super.destroy();
    }


}

;// CONCATENATED MODULE: ./src/common/iServer/FacilityAnalystSources3DService.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/




/**
 * @class FacilityAnalystSources3DService
 * @deprecatedclass SuperMap.FacilityAnalystSources3DService
 * @category  iServer FacilityAnalyst3D Sources
 * @classdesc 最近设施分析服务类(源查找资源)
 *            最近设施分析是指在网络上给定一个事件点和一组设施点，
 *            查找从事件点到设施点(或从设施点到事件点)以最小耗费能到达的最佳路径。
 *            该类负责将客户端指定的最近设施分析参数传递给服务端，并接收服务端返回的结果数据。
 *            最近设施分析结果通过该类支持的事件的监听函数参数获取。
 * @extends {CommonServiceBase}
 * @param {string} url - 服务地址。请求网络分析服务，URL应为：
 *                       http://{服务器地址}:{服务端口号}/iserver/services/{网络分析服务名}/rest/networkanalyst/{网络数据集@数据源}；
 *                       例如:"http://localhost:8090/iserver/services/components-rest/rest/networkanalyst/RoadNet@Changchun"。
 * @param {Object} options - 参数。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @usage
 */
class FacilityAnalystSources3DService extends CommonServiceBase {

    constructor(url, options) {
        super(url, options);

        this.CLASS_NAME = "SuperMap.FacilityAnalystSources3DService";
    }


    /**
     * @function FacilityAnalystSources3DService.prototype.destroy
     * @override
     */
    destroy() {
        super.destroy();
    }


    /**
     * @function FacilityAnalystSources3DService.prototype.processAsync
     * @description 负责将客户端的查询参数传递到服务端。
     * @param {FacilityAnalystSources3DParameters} params - 最近设施分析参数类（源查找资源）
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    processAsync(params, callback) {
        if (!(params instanceof FacilityAnalystSources3DParameters)) {
            return;
        }
        var me = this, jsonObject;
        me.url = Util_Util.urlPathAppend(me.url, 'sources');
        jsonObject = {
            edgeID: params.edgeID,
            nodeID: params.nodeID,
            weightName: params.weightName,
            isUncertainDirectionValid: params.isUncertainDirectionValid
        };
        return me.request({
            method: "GET",
            params: jsonObject,
            scope: me,
            success: callback,
            failure: callback
        });
    }

}

;// CONCATENATED MODULE: ./src/common/iServer/FacilityAnalystTraceup3DParameters.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


/**
 * @class FacilityAnalystTraceup3DParameters
 * @deprecatedclass SuperMap.FacilityAnalystTraceup3DParameters
 * @category iServer FacilityAnalyst3D TraceUpResult
 * @classdesc 上游追踪资源参数类。
 * @extends {FacilityAnalyst3DParameters}
 * @param {Object} options - 参数。
 * @param {string} options.weightName - 指定的权值字段信息对象的名称。
 * @param {number} [options.edgeID] - 指定的弧段ID，edgeID 与 nodeID 必须指定一个。
 * @param {number} [options.nodeID] - 指定的结点ID，edgeID 与 nodeID 必须指定一个。
 * @param {boolean} [options.isUncertainDirectionValid=false] - 指定不确定流向是否有效。指定为 true，表示不确定流向有效，遇到不确定流向时分析继续进行；
 * 指定为 false，表示不确定流向无效，遇到不确定流向将停止在该方向上继续查找。
 * @usage
 */
class FacilityAnalystTraceup3DParameters extends FacilityAnalyst3DParameters {

    constructor(options) {
        super(options);
        this.CLASS_NAME = "SuperMap.FacilityAnalystTraceup3DParameters";
    }

    /**
     * @function FacilityAnalystTraceup3DParameters.prototype.destroy
     * @override
     */
    destroy() {
        super.destroy();
    }


}

;// CONCATENATED MODULE: ./src/common/iServer/FacilityAnalystTraceup3DService.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/




/**
 * @class FacilityAnalystTraceup3DService
 * @deprecatedclass SuperMap.FacilityAnalystTraceup3DService
 * @category iServer FacilityAnalyst3D TraceUpResult
 * @classdesc 上游追踪资源服务类
 * @extends {CommonServiceBase}
 * @param {string} url - 服务地址。请求网络分析服务，URL应为：
 *                       http://{服务器地址}:{服务端口号}/iserver/services/{网络分析服务名}/rest/networkanalyst/{网络数据集@数据源}；
 *                       例如:"http://localhost:8090/iserver/services/components-rest/rest/networkanalyst/RoadNet@Changchun"。
 * @param {Object} options - 参数。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @usage
 */
class FacilityAnalystTraceup3DService extends CommonServiceBase {
    constructor(url, options) {
        super(url, options);
        this.CLASS_NAME = "SuperMap.FacilityAnalystTraceup3DService";
    }

    /**
     * @function FacilityAnalystTraceup3DService.prototype.destroy
     * @override
     */
    destroy() {
        super.destroy();
    }

    /**
     * @function FacilityAnalystTraceup3DService.prototype.processAsync
     * @description 负责将客户端的查询参数传递到服务端。
     * @param {FacilityAnalystTraceup3DParameters} params - 上游追踪资源参数类
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    processAsync(params, callback) {
        if (!(params instanceof FacilityAnalystTraceup3DParameters)) {
            return;
        }
        var me = this, jsonObject;
        me.url = Util_Util.urlPathAppend(me.url, 'traceupresult');
        jsonObject = {
            edgeID: params.edgeID,
            nodeID: params.nodeID,
            weightName: params.weightName,
            isUncertainDirectionValid: params.isUncertainDirectionValid
        };
        return me.request({
            method: "GET",
            params: jsonObject,
            scope: me,
            success: callback,
            failure: callback
        });
    }

}

;// CONCATENATED MODULE: ./src/common/iServer/FacilityAnalystTracedown3DParameters.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


/**
 * @class FacilityAnalystTracedown3DParameters
 * @deprecatedclass SuperMap.FacilityAnalystTracedown3DParameters
 * @category iServer FacilityAnalyst3D TraceDownResult
 * @classdesc 下游追踪资源参数类。
 * @extends {FacilityAnalyst3DParameters}
 * @param {Object} options - 参数。
 * @param {string} options.weightName - 指定的权值字段信息对象的名称。
 * @param {number} [options.edgeID] - 指定的弧段 ID，edgeID 与 nodeID 必须指定一个。
 * @param {number} [options.nodeID] - 指定的结点 ID，edgeID 与 nodeID 必须指定一个。
 * @param {boolean} [options.isUncertainDirectionValid=false] - 指定不确定流向是否有效。指定为 true，表示不确定流向有效，遇到不确定流向时分析继续进行；
 * 指定为 false，表示不确定流向无效，遇到不确定流向将停止在该方向上继续查找。
 * @usage
 */
class FacilityAnalystTracedown3DParameters extends FacilityAnalyst3DParameters {

    constructor(options) {
        super(options);
        this.CLASS_NAME = "SuperMap.FacilityAnalystTracedown3DParameters";
    }

    /**
     * @function FacilityAnalystTracedown3DParameters.prototype.destroy
     * @override
     */
    destroy() {
        super.destroy();
    }


}

;// CONCATENATED MODULE: ./src/common/iServer/FacilityAnalystTracedown3DService.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/




/**
 * @class FacilityAnalystTracedown3DService
 * @deprecatedclass SuperMap.FacilityAnalystTracedown3DService
 * @category iServer FacilityAnalyst3D TraceDownResult
 * @classdesc 下游追踪资源服务类
 * @extends {CommonServiceBase}
 * @param {string} url - 服务地址。请求网络分析服务，URL应为：
 *                       http://{服务器地址}:{服务端口号}/iserver/services/{网络分析服务名}/rest/networkanalyst/{网络数据集@数据源}；
 *                       例如:"http://localhost:8090/iserver/services/components-rest/rest/networkanalyst/RoadNet@Changchun"。
 * @param {Object} options - 参数。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @usage
 */
class FacilityAnalystTracedown3DService extends CommonServiceBase {

    constructor(url, options) {
        super(url, options);
        this.CLASS_NAME = "SuperMap.FacilityAnalystTracedown3DService";
    }

    /**
     * @function FacilityAnalystTracedown3DService.prototype.destroy
     * @override
     */
    destroy() {
        super.destroy();
    }

    /**
     * @function FacilityAnalystTracedown3DService.prototype.processAsync
     * @description 负责将客户端的查询参数传递到服务端。
     * @param {FacilityAnalystTracedown3DParameters} params - 下游追踪资源参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    processAsync(params, callback) {
        if (!(params instanceof FacilityAnalystTracedown3DParameters)) {
            return;
        }
        var me = this, jsonObject;
        me.url = Util_Util.urlPathAppend(me.url, 'tracedownresult');

        jsonObject = {
            edgeID: params.edgeID,
            nodeID: params.nodeID,
            weightName: params.weightName,
            isUncertainDirectionValid: params.isUncertainDirectionValid
        };
        return me.request({
            method: "GET",
            params: jsonObject,
            scope: me,
            success: callback,
            failure: callback
        });
    }


}

;// CONCATENATED MODULE: ./src/common/iServer/FacilityAnalystUpstream3DParameters.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/



/**
 * @class FacilityAnalystUpstream3DParameters
 * @deprecatedclass SuperMap.FacilityAnalystUpstream3DParameters
 * @category iServer FacilityAnalyst3D UpstreamCirticalFaclilities
 * @classdesc 上游关键设施查找资源参数类。
 * @extends {FacilityAnalyst3DParameters}
 * @param {Object} options - 参数。
 * @param {Array.<number>} options.sourceNodeIDs - 指定的设施点 ID 数组。
 * @param {number} [options.edgeID] - 指定的弧段ID。edgeID 与 nodeID 必须指定一个。
 * @param {number} [options.nodeID] - 指定的结点ID。edgeID 与 edgeID 必须指定一个。
 * @param {boolean} [options.isUncertainDirectionValid=false] - 指定不确定流向是否有效。指定为 true，表示不确定流向有效，遇到不确定流向时分析继续进行；
 * 指定为 false，表示不确定流向无效，遇到不确定流向将停止在该方向上继续查找。
 * @usage
 */
class FacilityAnalystUpstream3DParameters extends FacilityAnalyst3DParameters {


    constructor(options) {
        super(options);
        options = options || {};
        this.sourceNodeIDs = null;
        Util_Util.extend(this, options);
        this.CLASS_NAME = "SuperMap.FacilityAnalystUpstream3DParameters";
    }


    /**
     * @function FacilityAnalystUpstream3DParameters.prototype.destroy
     * @override
     */
    destroy() {
        super.destroy();
        this.sourceNodeIDs = null;
    }


}

;// CONCATENATED MODULE: ./src/common/iServer/FacilityAnalystUpstream3DService.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/




/**
 * @class FacilityAnalystUpstream3DService
 * @deprecatedclass SuperMap.FacilityAnalystUpstream3DService
 * @category  iServer FacilityAnalyst3D UpstreamCirticalFaclilities
 * @classdesc 上游关键设施查找资源服务类
 * @extends {CommonServiceBase}
 * @param {string} url - 服务地址。请求网络分析服务，URL应为：
 *                       http://{服务器地址}:{服务端口号}/iserver/services/{网络分析服务名}/rest/networkanalyst/{网络数据集@数据源}；
 *                       例如:"http://localhost:8090/iserver/services/components-rest/rest/networkanalyst/RoadNet@Changchun"。
 * @param {Object} options - 参数。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @usage
 */
class FacilityAnalystUpstream3DService extends CommonServiceBase {

    constructor(url, options) {
        super(url, options);
        this.CLASS_NAME = "SuperMap.FacilityAnalystUpstream3DService";
    }

    /**
     * @function FacilityAnalystUpstream3DService.prototype.destroy
     * @override
     */
    destroy() {
        super.destroy();
    }

    /**
     * @function FacilityAnalystUpstream3DService.prototype.processAsync
     * @description 负责将客户端的查询参数传递到服务端。
     * @param {FacilityAnalystUpstream3DParameters} params - 上游关键设施查找资源参数类
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    processAsync(params, callback) {
        if (!(params instanceof FacilityAnalystUpstream3DParameters)) {
            return;
        }
        var me = this, jsonObject;
        me.url = Util_Util.urlPathAppend(me.url, 'upstreamcirticalfaclilities');
        jsonObject = {
            sourceNodeIDs: params.sourceNodeIDs,
            edgeID: params.edgeID,
            nodeID: params.nodeID,
            isUncertainDirectionValid: params.isUncertainDirectionValid
        };
        return me.request({
            method: "GET",
            params: jsonObject,
            scope: me,
            success: callback,
            failure: callback
        });
    }
}


;// CONCATENATED MODULE: ./src/common/iServer/NetworkAnalyst3DService.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/
 
 
 
 
 
 
 /**
  * @class NetworkAnalyst3DService
  * @category  iServer FacilityAnalyst3D
  * @classdesc 3D 网络分析服务类。
  * @extends {ServiceBase}
  * @example
  *      new NetworkAnalyst3DService(url).sinksFacilityAnalyst(params,function(result){
  *           //doSomething
  *      })
  * @param {string} url - 网络分析服务地址。请求网络分析服务，URL 应为：
  *                       http://{服务器地址}:{服务端口号}/iserver/services/{网络分析服务名}/rest/networkanalyst/{网络数据集@数据源}；
  *                       例如:"http://localhost:8090/iserver/services/components-rest/rest/networkanalyst/RoadNet@Changchun"。
  * @param {Object} options - 参数。
  * @param {string} [options.proxy] - 服务代理地址。
  * @param {boolean} [options.withCredentials=false] - 请求是否携带 cookie。
  * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
  * @param {Object} [options.headers] - 请求头。
  * @usage
  */
 class NetworkAnalyst3DService_NetworkAnalyst3DService {
 
     constructor(url, options) {
        this.url = url;
        this.options = options || {};
     }
 
     /**
      * @function NetworkAnalyst3DService.prototype.sinksFacilityAnalyst
      * @description 汇查找服务
      * @param {FacilityAnalystSinks3DParameters} params- 最近设施分析参数类（汇查找资源）。
      * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
      * @returns {Promise} Promise 对象。
      */
     sinksFacilityAnalyst(params, callback) {
         var me = this;
         var facilityAnalystSinks3DService = new FacilityAnalystSinks3DService(me.url, {
             proxy: me.options.proxy,
             withCredentials: me.options.withCredentials,
             crossOrigin: me.options.crossOrigin,
             headers: me.options.headers
         });
         return facilityAnalystSinks3DService.processAsync(params, callback);
     }
 
     /**
      * @function NetworkAnalyst3DService.prototype.sourcesFacilityAnalyst
      * @description 源查找服务。
      * @param {FacilityAnalystSources3DParameters} params - 最近设施分析参数类（源查找服务）。
      * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
      * @returns {Promise} Promise 对象。
      */
     sourcesFacilityAnalyst(params, callback) {
         var me = this;
         var facilityAnalystSources3DService = new FacilityAnalystSources3DService(me.url, {
             proxy: me.options.proxy,
             withCredentials: me.options.withCredentials,
             crossOrigin: me.options.crossOrigin,
             headers: me.options.headers
         });
         return facilityAnalystSources3DService.processAsync(params, callback);
     }
 
     /**
      * @function NetworkAnalyst3DService.prototype.traceUpFacilityAnalyst
      * @description 上游追踪资源服务。
      * @param {FacilityAnalystTraceup3DParameters} params - 上游追踪资源参数类。
      * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
      * @returns {Promise} Promise 对象。
      */
 
     traceUpFacilityAnalyst(params, callback) {
         var me = this;
         var facilityAnalystTraceup3DService = new FacilityAnalystTraceup3DService(me.url, {
             proxy: me.options.proxy,
             withCredentials: me.options.withCredentials,
             crossOrigin: me.options.crossOrigin,
             headers: me.options.headers
         });
         return facilityAnalystTraceup3DService.processAsync(params, callback);
     }
 
     /**
      * @function NetworkAnalyst3DService.prototype.traceDownFacilityAnalyst
      * @description 下游追踪资源服务。
      * @param {FacilityAnalystTracedown3DParameters} params - 下游追踪资源服务参数类。
      * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
      * @returns {Promise} Promise 对象。
      */
     traceDownFacilityAnalyst(params, callback) {
         var me = this;
         var facilityAnalystTracedown3DService = new FacilityAnalystTracedown3DService(me.url, {
             proxy: me.options.proxy,
             withCredentials: me.options.withCredentials,
             crossOrigin: me.options.crossOrigin,
             headers: me.options.headers
         });
         return facilityAnalystTracedown3DService.processAsync(params, callback);
     }
 
     /**
      * @function NetworkAnalyst3DService.prototype.upstreamFacilityAnalyst
      * @description 上游关键设施查找服务。
      * @param {FacilityAnalystUpstream3DParameters} params - 上游关键设施查找服务参数类。
      * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
      * @returns {Promise} Promise 对象。
      */
     upstreamFacilityAnalyst(params, callback) {
         var me = this;
         var facilityAnalystUpstream3DService = new FacilityAnalystUpstream3DService(me.url, {
             proxy: me.options.proxy,
             withCredentials: me.options.withCredentials,
             crossOrigin: me.options.crossOrigin,
             headers: me.options.headers
         });
         return facilityAnalystUpstream3DService.processAsync(params, callback);
     }
 }
 
;// CONCATENATED MODULE: ./src/mapboxgl/services/NetworkAnalyst3DService.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/



/**
 * @class NetworkAnalyst3DService
 * @category  iServer FacilityAnalyst3D
 * @classdesc 3D 网络分析服务类。
 * @modulecategory Services
 * @extends {ServiceBase}
 * @example
 * new NetworkAnalyst3DService(url)
 *  .sinksFacilityAnalyst(params,function(result){
 *     //doSomething
 * })
 * @param {string} url - 服务地址。请求网络分析服务，URL应为：</br>
 *                        http://{服务器地址}:{服务端口号}/iserver/services/{网络分析服务名}/rest/networkanalyst/{网络数据集@数据源}。
 *                        例如:"http://localhost:8090/iserver/services/components-rest/rest/networkanalyst/RoadNet@Changchun"。
 * @param {Object} options - 参数。
 * @param {string} [options.proxy] - 服务代理地址。
 * @param {boolean} [options.withCredentials=false] - 请求是否携带 cookie。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @usage
 */
class NetworkAnalyst3DService extends ServiceBase {

    constructor(url, options) {
        super(url, options);
        this._networkAnalyst3DService = new NetworkAnalyst3DService_NetworkAnalyst3DService(url, options);
    }

    /**
     * @function NetworkAnalyst3DService.prototype.sinksFacilityAnalyst
     * @description 汇查找服务。
     * @param {FacilityAnalystSinks3DParameters} params - 最近设施分析参数类（汇查找资源）。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {NetworkAnalyst3DService} 3D 网络分析服务。
     */
    sinksFacilityAnalyst(params, callback) {
      return this._networkAnalyst3DService.sinksFacilityAnalyst(params, callback);
    }

    /**
     * @function NetworkAnalyst3DService.prototype.sourcesFacilityAnalyst
     * @description 源查找服务。
     * @param {FacilityAnalystSources3DParameters} params - 最近设施分析参数类（源查找服务）。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {NetworkAnalyst3DService} 3D 网络分析服务。
     */
    sourcesFacilityAnalyst(params, callback) {
      return this._networkAnalyst3DService.sourcesFacilityAnalyst(params, callback);
    }

    /**
     * @function NetworkAnalyst3DService.prototype.traceUpFacilityAnalyst
     * @description 上游追踪资源服务。
     * @param {FacilityAnalystTraceup3DParameters} params - 上游追踪资源参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {NetworkAnalyst3DService} 3D 网络分析服务。
     */

    traceUpFacilityAnalyst(params, callback) {
      return this._networkAnalyst3DService.traceUpFacilityAnalyst(params, callback);
    }

    /**
     * @function NetworkAnalyst3DService.prototype.traceDownFacilityAnalyst
     * @description 下游追踪资源服务。
     * @param {FacilityAnalystTracedown3DParameters} params - 下游追踪资源服务参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {NetworkAnalyst3DService} 3D 网络分析服务。
     */
    traceDownFacilityAnalyst(params, callback) {
      return this._networkAnalyst3DService.traceDownFacilityAnalyst(params, callback);
    }

    /**
     * @function NetworkAnalyst3DService.prototype.upstreamFacilityAnalyst
     * @description 上游关键设施查找服务。
     * @param {FacilityAnalystUpstream3DParameters} params - 上游关键设施查找服务参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {NetworkAnalyst3DService} 3D 网络分析服务。
     */
    upstreamFacilityAnalyst(params, callback) {
      return this._networkAnalyst3DService.upstreamFacilityAnalyst(params, callback);
    }
}

;// CONCATENATED MODULE: ./src/common/iServer/ProcessingServiceBase.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/





/**
 * @class ProcessingServiceBase
 * @deprecatedclass SuperMap.ProcessingServiceBase
 * @category  iServer Core
 * @classdesc 分布式分析服务基类
 * @extends {CommonServiceBase}
 * @param {string} url - 服务地址。
 * @param {Object} options - 参数。
 * @param {Events} options.events - 处理所有事件的对象。
 * @param {number} options.index - 服务访问地址在数组中的位置。
 * @param {number} options.length - 服务访问地址数组长度。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @usage
 */
class ProcessingServiceBase extends CommonServiceBase {

    constructor(url, options) {
        options = options || {};
        super(url, options);

        this.CLASS_NAME = "SuperMap.ProcessingServiceBase";
    }

    /**
     * @function ProcessingServiceBase.prototype.destroy
     * @override
     */
    destroy() {
        super.destroy();
    }

    /**
     * @function ProcessingServiceBase.prototype.getJobs
     * @description 获取分布式分析任务。
     * @param {string} url - 资源地址。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    getJobs(url, callback) {
        var me = this;
        return FetchRequest.get(SecurityManager.appendCredential(url), null, {
            proxy: me.proxy
        }).then(function (response) {
            return response.json();
        }).then(function (result) {
            const res = { result, object: me, type: 'processCompleted' };
            callback(res);
            return res;
        }).catch(function (e) {
          const res = { error: e, object: me, type: 'processFailed' };
          callback(res);
          return res;
        });
    }

    /**
     * @function ProcessingServiceBase.prototype.addJob
     * @description 添加分布式分析任务。
     * @param {string} url - 资源根地址。
     * @param {Object} params - 创建一个空间分析的请求参数。
     * @param {string} paramType - 请求参数类型。
     * @param {number} seconds - 开始创建后，获取创建成功结果的时间间隔。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @param {RequestCallback} [processRunningCallback] - 回调函数。
     * @returns {Promise} Promise 对象。
     */
    addJob(url, params, paramType, seconds, callback, processRunningCallback) {
        var me = this,
            parameterObject = null;
        if (params && params instanceof paramType) {
            parameterObject = new Object();
            paramType.toObject(params, parameterObject);
        }
        let headers = Object.assign({
          'Content-Type': 'application/x-www-form-urlencoded'
        }, me.headers || {})
        var options = {
            proxy: me.proxy,
            headers,
            withCredentials: me.withCredentials,
            crossOrigin: me.crossOrigin,
            isInTheSameDomain: me.isInTheSameDomain
        };
        return FetchRequest.post(SecurityManager.appendCredential(url), JSON.stringify(parameterObject), options).then(function (response) {
            return response.json();
        }).then(function (result) {
            if (result.succeed) {
                return me.transformResult(result, seconds, callback, processRunningCallback);
            } else {
              result = me.transformErrorResult(result);
              result.options = me;
              result.type = 'processFailed';
              callback(result);
              return result;
            }
        }).catch(function (e) {
            e = me.transformErrorResult({ error: e });
            e.options = me;
            e.type = 'processFailed';
            callback(e);
            return e;
        });
    }

    transformResult(result, seconds, callback, processRunningCallback) {
        result = Util_Util.transformResult(result);
        seconds = seconds || 1000;
        var me = this;
        if (result) {
           return new Promise((resolve) => {
              var id = setInterval(function () {
                FetchRequest.get(SecurityManager.appendCredential(result.newResourceLocation), {
                        _t: new Date().getTime()
                    })
                    .then(function (response) {
                        return response.json();
                    }).then(function (job) {
                        resolve({
                          object: me,
                          id: job.id,
                          state: job.state
                        });
                        processRunningCallback({
                            id: job.id,
                            state: job.state,
                            object: me
                        });
                        if (job.state.runState === 'LOST' || job.state.runState === 'KILLED' || job.state.runState === 'FAILED') {
                            clearInterval(id);
                            const res = {
                              error: job.state.errorMsg,
                              state: job.state.runState,
                              object: me,
                              type: 'processFailed'
                            };
                            resolve(res);
                            callback(res);
                        }
                        if (job.state.runState === 'FINISHED' && job.setting.serviceInfo) {
                            clearInterval(id);
                            const res = {
                              result: job,
                              object: me, 
                              type: 'processCompleted'
                            };
                            resolve(res);
                            callback(res);
                        }
                    }).catch(function (e) {
                        clearInterval(id);
                        const res = {
                          error: e,
                          object: me,
                          type: 'processFailed'
                        };
                        resolve(res);
                        callback(res);
                    });
            }, seconds);
           });
        }
    }
}

;// CONCATENATED MODULE: ./src/common/iServer/DatasourceConnectionInfo.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/

 // eslint-disable-line no-unused-vars

/**
 * @class DatasourceConnectionInfo
 * @deprecatedclass SuperMap.DatasourceConnectionInfo
 * @category  iServer Data Datasource
 * @classdesc 数据源连接信息类。该类包括了进行数据源连接的所有信息，如所要连接的服务器名称、数据库名称、用户名以及密码等。
 *            当保存为工作空间时，工作空间中的数据源的连接信息都将存储到工作空间文件中。对于不同类型的数据源，其连接信息有所区别。
 *            所以在使用该类所包含的成员时，请注意该成员所适用的数据源类型。对于从数据源对象中返回的数据连接信息对象，只有 connect 方法可以被修改，
 *            其他内容是不可以被修改的。对于用户创建的数据源连接信息对象，其内容都可以修改。
 * @param {Object} options - 参数。
 * @param {string} options.alias - 数据源别名。
 * @param {string} options.dataBase - 数据源连接的数据库名。
 * @param {boolean} [options.connect] - 数据源是否自动连接数据。
 * @param {string} [options.driver] - 使用 ODBC(Open Database Connectivity，开放数据库互连)的数据库的驱动程序名。
 * @param {EngineType} [options.engineType] - 数据源连接的引擎类型。
 * @param {boolean} [options.exclusive] - 是否以独占方式打开数据源。
 * @param {boolean} [options.OpenLinkTable] - 是否把数据库中的其他非 SuperMap 数据表作为 LinkTable 打开。
 * @param {string} [options.password] - 登录数据源连接的数据库或文件的密码。
 * @param {boolean} [options.readOnly] - 是否以只读方式打开数据源。
 * @param {string} [options.server] - 数据库服务器名或 SDB 文件名。
 * @param {string} [options.user] - 登录数据库的用户名。
 * @usage
 */
class DatasourceConnectionInfo {


    constructor(options) {

        /**
         * @member {string} DatasourceConnectionInfo.prototype.alias
         * @description 数据源别名。
         */
        this.alias = null;

        /**
         * @member {boolean} [DatasourceConnectionInfo.prototype.connect]
         * @description 数据源是否自动连接数据。
         */
        this.connect = null;

        /**
         * @member {string} DatasourceConnectionInfo.prototype.dataBase
         * @description 数据源连接的数据库名。
         */
        this.dataBase = null;

        /**
         * @member {string} [DatasourceConnectionInfo.prototype.driver]
         * @description 使用 ODBC(Open Database Connectivity，开放数据库互连) 的数据库的驱动程序名。
         * 其中，对于 SQL Server 数据库与 iServer 发布的 WMTS 服务，此为必设参数。
         * 对于 SQL Server 数据库，它使用 ODBC 连接，所设置的驱动程序名为 "SQL Server" 或 "SQL Native Client"；
         * 对于 iServer 发布的 WMTS 服务，设置的驱动名称为 "WMTS"。
         */
        this.driver = null;

        /**
         * @member {EngineType} [DatasourceConnectionInfo.prototype.engineType]
         * @description 数据源连接的引擎类型。
         */
        this.engineType = null;

        /**
         * @member {boolean} [DatasourceConnectionInfo.prototype.exclusive]
         * @description 是否以独占方式打开数据源。
         */
        this.exclusive = null;

        /**
         * @member {boolean} [DatasourceConnectionInfo.prototype.OpenLinkTable]
         * @description 是否把数据库中的其他非 SuperMap 数据表作为 LinkTable 打开。
         */
        this.OpenLinkTable = null;

        /**
         * @member {string} [DatasourceConnectionInfo.prototype.password]
         * @description 登录数据源连接的数据库或文件的密码。
         */
        this.password = null;

        /**
         * @member {boolean} [DatasourceConnectionInfo.prototype.readOnly]
         * @description 是否以只读方式打开数据源。
         */
        this.readOnly = null;

        /**
         * @member {string} [DatasourceConnectionInfo.prototype.server]
         * @description 数据库服务器名、文件名或服务地址。
         * 1.对于 SDB 和 UDB 文件，为其文件的绝对路径。注意：当绝对路径的长度超过 UTF-8 编码格式的 260 字节长度，该数据源无法打开。
         * 2.对于 Oracle 数据库，其服务器名为其 TNS 服务名称。
         * 3.对于 SQL Server 数据库，其服务器名为其系统的 DSN(Database Source Name) 名称。
         * 4.对于 PostgreSQL 数据库，其服务器名为 “IP:端口号”，默认的端口号是 5432。
         * 5.对于 DB2 数据库，已经进行了编目，所以不需要进行服务器的设置。
         * 6.对于 Kingbase 数据库，其服务器名为其 IP 地址。
         * 7.对于 GoogleMaps 数据源，其服务器地址，默认设置为 “{@link http://maps.google.com}”，且不可更改。
         * 8.对于 SuperMapCould 数据源，为其服务地址。
         * 9.对于 MAPWORLD 数据源，为其服务地址，默认设置为 “{@link http://www.tianditu.cn}”，且不可更改。
         * 10.对于 OGC 和 REST 数据源，为其服务地址。
         */
        this.server = null;

        /**
         * @member {string} DatasourceConnectionInfo.prototype.user
         * @description 登录数据库的用户名。
         */
        this.user = null;

        if (options) {
            Util_Util.extend(this, options);
        }

        this.CLASS_NAME = "SuperMap.DatasourceConnectionInfo";
    }

    /**
     * @function DatasourceConnectionInfo.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        var me = this;
        me.alias = null;
        me.connect = null;
        me.dataBase = null;
        me.driver = null;
        me.engineType = null;
        me.exclusive = null;
        me.OpenLinkTable = null;
        me.password = null;
        me.readOnly = null;
        me.server = null;
        me.user = null;
    }

}

;// CONCATENATED MODULE: ./src/common/iServer/OutputSetting.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/




/**
 * @class OutputSetting
 * @deprecatedclass SuperMap.OutputSetting
 * @category  iServer ProcessingService
 * @classdesc 分布式分析输出类型设置类。
 * @param {Object} options - 参数。
 * @param {DatasourceConnectionInfo} options.datasourceInfo - 数据源连接信息。
 * @param {string} [options.datasetName='analystResult'] - 结果数据集名称。
 * @param {OutputType} [options.type=OutputType.UDB] - 输出类型。
 * @param {string} [options.outputPath] - 分析结果输出路径。
 * @usage
 */
class OutputSetting {

    constructor(options) {

        /**
         * @member {OutputType} OutputSetting.prototype.type
         * @description 分布式分析的输出类型。
         */
        this.type = OutputType.UDB;

        /**
         * @member {string} [OutputSetting.prototype.datasetName='analystResult']
         * @description 分布式分析的输出结果数据集名称。
         */
        this.datasetName = "analystResult";

        /**
         * @member {DatasourceConnectionInfo} OutputSetting.prototype.datasourceInfo
         * @description 分布式分析的输出结果数据源连接信息。
         */
        this.datasourceInfo = null;

        /**
         * @member {string} [OutputSetting.prototype.outputPath]
         * @description 分布式分析的分析结果输出路径。
         */
        this.outputPath = "";

        Util_Util.extend(this, options);
        this.CLASS_NAME = "SuperMap.OutputSetting";
    }

    /**
     * @function OutputSetting.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        var me = this;
        me.type = null;
        me.datasetName = null;
        me.outputPath = null;
        if (me.datasourceInfo instanceof DatasourceConnectionInfo) {
            me.datasourceInfo.destroy();
            me.datasourceInfo = null;
        }
    }

}

;// CONCATENATED MODULE: ./src/common/iServer/MappingParameters.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/



/**
 * @class MappingParameters
 * @deprecatedclass SuperMap.MappingParameters
 * @category  iServer ProcessingService
 * @classdesc 分析后结果可视化的参数类。
 * @param {Object} options - 参数。
 * @param {Array.<ThemeGridRangeItem>} [options.items] - 栅格分段专题图子项数组。
 * @param {number} [options.numericPrecision=1] - 精度，此字段用于设置分析结果标签专题图中标签数值的精度，如“1”表示精确到小数点的后一位。
 * @param {RangeMode} [options.rangeMode=RangeMode.EQUALINTERVAL] - 专题图分段模式。
 * @param {number} [options.rangeCount] - 专题图分段个数。
 * @param {ColorGradientType} [options.colorGradientType=ColorGradientType.YELLOW_RED] - 专题图颜色渐变模式。
 * @usage
 */
class MappingParameters {

    constructor(options) {

        /**
         * @member {Array.<ThemeGridRangeItem>} [MappingParameters.prototype.items]
         * @description 栅格分段专题图子项数组。
         */
        this.items = null;

        /**
         * @member {number} [MappingParameters.prototype.numericPrecision=1]
         * @description 精度，此字段用于设置分析结果标签专题图中标签数值的精度，如“1”表示精确到小数点的后一位。
         */
        this.numericPrecision = 1;

        /**
         * @member {RangeMode} [MappingParameters.prototype.RangeMode=RangeMode.EQUALINTERVAL]
         * @description 专题图分段模式。
         */
        this.rangeMode = RangeMode.EQUALINTERVAL;

        /**
         * @member {number} [MappingParameters.prototype.rangeCount]
         * @description 专题图分段个数。
         */
        this.rangeCount = "";

        /**
         * @member {ColorGradientType} [MappingParameters.prototype.colorGradientType=ColorGradientType.YELLOW_RED]
         * @description 专题图颜色渐变模式。
         */
        this.colorGradientType = ColorGradientType.YELLOW_RED;

        Util_Util.extend(this, options);
        this.CLASS_NAME = "SuperMap.MappingParameters";
    }

    /**
     * @function MappingParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        var me = this;
        if (me.items) {
            if (me.items.length > 0) {
                for (var item in me.items) {
                    me.items[item].destroy();
                    me.items[item] = null;
                }
            }
            me.items = null;
        }
        me.numericPrecision = null;
        me.rangeMode = null;
        me.rangeCount = null;
        me.colorGradientType = null;
    }

}

;// CONCATENATED MODULE: ./src/common/iServer/KernelDensityJobParameter.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/






/**
 * @class KernelDensityJobParameter
 * @deprecatedclass SuperMap.KernelDensityJobParameter
 * @category iServer ProcessingService DensityAnalyst
 * @classdesc 核密度分析服务参数类。
 * @param {Object} options - 参数。
 * @param {string} options.datasetName - 数据集名。
 * @param {string} options.fields - 权重索引。
 * @param {(SuperMap.Bounds|L.Bounds|L.LatLngBounds|ol.extent|mapboxgl.LngLatBounds|GeoJSONObject)} [options.query] - 分析范围（默认为全图范围）。
 * @param {number} [options.resolution=80] - 分辨率。
 * @param {number} [options.method=0] - 分析方法。
 * @param {number} [options.meshType=0] - 分析类型。
 * @param {number} [options.radius=300] - 分析的影响半径。
 * @param {AnalystSizeUnit} [options.meshSizeUnit=AnalystSizeUnit.METER] - 网格大小单位。
 * @param {AnalystSizeUnit} [options.radiusUnit=AnalystSizeUnit.METER] - 搜索半径单位。
 * @param {AnalystAreaUnit} [options.areaUnit=AnalystAreaUnit.SQUAREMILE] - 面积单位。
 * @param {OutputSetting} [options.output] - 输出参数设置。
 * @param {MappingParameters} [options.mappingParameters] - 分析后结果可视化的参数类。
 * @usage
 */
class KernelDensityJobParameter {

    constructor(options) {
        if (!options) {
            return;
        }
        /**
         * @member {string} KernelDensityJobParameter.prototype.datasetName
         * @description 数据集名。
         */
        this.datasetName = "";

        /**
         * @member {SuperMap.Bounds|L.Bounds|L.LatLngBounds|ol.extent|mapboxgl.LngLatBounds|GeoJSONObject} [KernelDensityJobParameter.prototype.query]
         * @description 分析范围。
         */
        this.query = "";

        /**
         * @member {number} [KernelDensityJobParameter.prototype.resolution=80]
         * @description 网格大小。
         */
        this.resolution = 80;

        /**
         * @member {number} [KernelDensityJobParameter.prototype.method=0]
         * @description 分析方法。
         */
        this.method = 0;

        /**
         * @member {number} [KernelDensityJobParameter.prototype.meshType=0]
         * @description 分析类型。
         */
        this.meshType = 0;

        /**
         * @member {string} KernelDensityJobParameter.prototype.fields
         * @description 权重索引。
         */
        this.fields = "";

        /**
         * @member {number} [KernelDensityJobParameter.prototype.radius=300]
         * @description 分析的影响半径。
         */
        this.radius = 300;

        /**
         * @member {AnalystSizeUnit} [KernelDensityJobParameter.prototype.meshSizeUnit=AnalystSizeUnit.METER]
         * @description 网格大小单位。
         */
        this.meshSizeUnit = AnalystSizeUnit.METER;

        /**
         * @member {AnalystSizeUnit} [KernelDensityJobParameter.prototype.radiusUnit=AnalystSizeUnit.METER]
         * @description 搜索半径单位。
         */
        this.radiusUnit = AnalystSizeUnit.METER;

        /**
         * @member {AnalystAreaUnit} [KernelDensityJobParameter.prototype.areaUnit=AnalystAreaUnit.SQUAREMILE]
         * @description 面积单位。
         */
        this.areaUnit = AnalystAreaUnit.SQUAREMILE;

        /**
         * @member {OutputSetting} KernelDensityJobParameter.prototype.output
         * @description 输出参数设置类。
         */
        this.output = null;

        /**
         * @member {MappingParameters} [KernelDensityJobParameter.prototype.mappingParameters]
         * @description 分析后结果可视化的参数类。
         */
        this.mappingParameters = null;

        Util_Util.extend(this, options);

        this.CLASS_NAME = "SuperMap.KernelDensityJobParameter";
    }

    /**
     * @function KernelDensityJobParameter.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        this.datasetName = null;
        this.query = null;
        this.resolution = null;
        this.method = null;
        this.radius = null;
        this.meshType = null;
        this.fields = null;
        this.meshSizeUnit = null;
        this.radiusUnit = null;
        this.areaUnit = null;
        if (this.output instanceof OutputSetting) {
            this.output.destroy();
            this.output = null;
        }
        if (this.mappingParameters instanceof MappingParameters) {
            this.mappingParameters.destroy();
            this.mappingParameters = null;
        }
    }

    /**
     * @function KernelDensityJobParameter.toObject
     * @param {KernelDensityJobParameter} kernelDensityJobParameter - 核密度分析服务参数类。
     * @param {KernelDensityJobParameter} tempObj - 核密度分析服务参数对象。
     * @description 将核密度分析服务参数对象转换为 JSON 对象。
     * @returns JSON 对象。
     */
    static toObject(kernelDensityJobParameter, tempObj) {
        for (var name in kernelDensityJobParameter) {
            if (name === "datasetName") {
                tempObj['input'] = tempObj['input'] || {};
                tempObj['input'][name] = kernelDensityJobParameter[name];
                continue;
            }
            if (name === "output") {
                tempObj['output'] = tempObj['output'] || {};
                tempObj['output'] = kernelDensityJobParameter[name];
                continue;
            }

            tempObj['analyst'] = tempObj['analyst'] || {};
            if (name === 'query' && kernelDensityJobParameter[name]) {
                tempObj['analyst'][name] = kernelDensityJobParameter[name].toBBOX();
            } else {
                tempObj['analyst'][name] = kernelDensityJobParameter[name];
            }
            if (name === 'mappingParameters') {
                tempObj['analyst'][name] = tempObj['analyst'][name] || {};
                tempObj['analyst']['mappingParameters'] = kernelDensityJobParameter[name];
            }
        }
    }
}

;// CONCATENATED MODULE: ./src/common/iServer/KernelDensityJobsService.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/




/**
 * @class KernelDensityJobsService
 * @deprecatedclass SuperMap.KernelDensityJobsService
 * @category  iServer ProcessingService DensityAnalyst
 * @classdesc 核密度分析服务类
 * @extends {ProcessingServiceBase}
 * @param {string} url - 服务地址。
 * @param {Object} options - 可选参数。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @usage
 */
class KernelDensityJobsService extends ProcessingServiceBase {

    constructor(url, options) {
        super(url, options);
        this.url = Util_Util.urlPathAppend(this.url, 'spatialanalyst/density');
        this.CLASS_NAME = "SuperMap.KernelDensityJobsService";
    }

    /**
     * @function KernelDensityJobsService.prototype.destroy
     * @override
     */
    destroy() {
        super.destroy();
    }

    /**
     * @function KernelDensityJobsService.prototype.getKernelDensityJobs
     * @description 获取核密度分析任务
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    getKernelDensityJobs(callback) {
      return super.getJobs(this.url, callback);
    }

    /**
     * @function KernelDensityJobsService.prototype.getKernelDensityJobs
     * @description 获取指定id的核密度分析服务
     * @param {string} id - 指定要获取数据的id
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    getKernelDensityJob(id, callback) {
      return super.getJobs(Util_Util.urlPathAppend(this.url, id), callback);
    }

    /**
     * @function KernelDensityJobsService.prototype.addKernelDensityJob
     * @description 新建核密度分析服务
     * @param {KernelDensityJobParameter} params - 核密度分析服务参数类。
     * @param {number} seconds - 开始创建后，获取创建成功结果的时间间隔。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @param {RequestCallback} [processRunningCallback] - 回调函数。
     * @returns {Promise} Promise 对象。
     */
    addKernelDensityJob(params, seconds, callback, processRunningCallback) {
      return super.addJob(this.url, params, KernelDensityJobParameter, seconds, callback, processRunningCallback);
    }

}

;// CONCATENATED MODULE: ./src/common/iServer/SingleObjectQueryJobsParameter.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/





/**
 * @class SingleObjectQueryJobsParameter
 * @deprecatedclass SuperMap.SingleObjectQueryJobsParameter
 * @category  iServer ProcessingService Query
 * @classdesc 单对象空间查询分析任务参数类。
 * @param {Object} options - 参数。
 * @param {string} options.datasetName - 数据集名。
 * @param {string} options.datasetQuery - 查询对象所在的数据集名称。
 * @param {SpatialQueryMode} [options.mode=SpatialQueryMode.CONTAIN] - 空间查询模式。
 * @param {OutputSetting} [options.output] - 输出参数设置。
 * @param {MappingParameters} [options.mappingParameters] - 分析后结果可视化的参数类。
 * @usage
 */
class SingleObjectQueryJobsParameter {

    constructor(options) {
        if (!options) {
            return;
        }
        /**
         * @member {string} SingleObjectQueryJobsParameter.prototype.datasetName
         * @description 数据集名。
         */
        this.datasetName = "";

        /**
         * @member {string} SingleObjectQueryJobsParameter.prototype.datasetQuery
         * @description 查询对象所在的数据集名称。
         */
        this.datasetQuery = "";

        /**
         * @member {string} SingleObjectQueryJobsParameter.prototype.geometryQuery
         * @description 查询对象所在的几何对象。
         */
        this.geometryQuery = "";

        /**
         * @member {SpatialQueryMode} [SingleObjectQueryJobsParameter.prototype.mode=SpatialQueryMode.CONTAIN]
         * @description 空间查询模式 。
         */
        this.mode = SpatialQueryMode.CONTAIN;

        /**
         * @member {OutputSetting} [SingleObjectQueryJobsParameter.prototype.output]
         * @description 输出参数设置类。
         */
        this.output = null;

        /**
         * @member {MappingParameters} [SingleObjectQueryJobsParameter.prototype.mappingParameters]
         * @description 分析后结果可视化的参数类。
         */
        this.mappingParameters = null;

        Util_Util.extend(this, options);

        this.CLASS_NAME = "SuperMap.SingleObjectQueryJobsParameter";
    }

    /**
     * @function SingleObjectQueryJobsParameter.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        this.datasetName = null;
        this.datasetQuery = null;
        this.geometryQuery = null;
        this.mode = null;
        if (this.output instanceof OutputSetting) {
            this.output.destroy();
            this.output = null;
        }
        if (this.mappingParameters instanceof MappingParameters){
            this.mappingParameters.destroy();
            this.mappingParameters = null;
        }
    }

    /**
     * @function SingleObjectQueryJobsParameter.toObject
     * @param {Object} singleObjectQueryJobsParameter - 单对象空间查询分析任务参数。
     * @param {Object} tempObj - 目标对象。
     * @description 生成单对象空间查询分析任务对象。
     */
    static toObject(singleObjectQueryJobsParameter, tempObj) {
        for (var name in singleObjectQueryJobsParameter) {
            if (name === "datasetName") {
                tempObj['input'] = tempObj['input'] || {};
                tempObj['input'][name] = singleObjectQueryJobsParameter[name];
                continue;
            }
            if (name === "output"){
                tempObj['output'] = tempObj['output'] || {};
                tempObj['output'] = singleObjectQueryJobsParameter[name];
                continue;
            }

            tempObj['analyst'] = tempObj['analyst'] || {};
            tempObj['analyst'][name] = singleObjectQueryJobsParameter[name];
            if(name === 'mappingParameters'){
                tempObj['analyst'][name] = tempObj['analyst'][name] || {};
                tempObj['analyst']['mappingParameters'] = singleObjectQueryJobsParameter[name];
            }
        }
    }

}


;// CONCATENATED MODULE: ./src/common/iServer/SingleObjectQueryJobsService.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/




/**
 * @class SingleObjectQueryJobsService
 * @deprecatedclass SuperMap.SingleObjectQueryJobsService
 * @category  iServer ProcessingService Query
 * @classdesc 单对象查询分析服务类
 * @extends {ProcessingServiceBase}
 * @param {string} url - 服务地址。
 * @param {Object} options - 可选参数。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @usage
 */
class SingleObjectQueryJobsService extends ProcessingServiceBase {
    constructor(url, options) {
        super(url, options);
        this.url = Util_Util.urlPathAppend(this.url, 'spatialanalyst/query');
        this.CLASS_NAME = 'SuperMap.SingleObjectQueryJobsService';
    }

    /**
     *@override
     */
    destroy() {
        super.destroy();
    }

    /**
     * @function SingleObjectQueryJobsService.protitype.getQueryJobs
     * @description 获取单对象空间查询分析所有任务
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    getQueryJobs(callback) {
        return super.getJobs(this.url, callback);
    }

    /**
     * @function KernelDensityJobsService.protitype.getQueryJob
     * @description 获取指定id的单对象空间查询分析服务
     * @param {string} id - 指定要获取数据的id
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    getQueryJob(id, callback) {
        return super.getJobs(Util_Util.urlPathAppend(this.url, id), callback);
    }

    /**
     * @function SingleObjectQueryJobsService.protitype.addQueryJob
     * @description 新建单对象空间查询分析服务
     * @param {SingleObjectQueryJobsParameter} params - 创建一个空间分析的请求参数。
     * @param {number} seconds - 开始创建后，获取创建成功结果的时间间隔。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    addQueryJob(params, seconds, callback, processRunningCallback) {
        return super.addJob(this.url, params, SingleObjectQueryJobsParameter, seconds, callback, processRunningCallback);
    }
}


;// CONCATENATED MODULE: ./src/common/iServer/SummaryMeshJobParameter.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/






/**
 * @class SummaryMeshJobParameter
 * @deprecatedclass SuperMap.SummaryMeshJobParameter
 * @category  iServer ProcessingService AggregatePoints
 * @classdesc 点聚合分析任务参数类。
 * @param {Object} options - 参数。
 * @param {string} options.datasetName - 数据集名。
 * @param {string} [options.regionDataset ] - 聚合面数据集（聚合类型为多边形聚合时使用的参数）
 * @param {(SuperMap.Bounds|L.Bounds|L.LatLngBounds|ol.extent|mapboxgl.LngLatBounds|GeoJSONObject)} [options.query] - 分析范围（默认为全图范围）。
 * @param {number} options.fields - 权重索引。
 * @param {number} [options.resolution=100] - 分辨率。
 * @param {StatisticAnalystMode} [options.statisticModes=StatisticAnalystMode.AVERAGE] - 分析模式。
 * @param {number} [options.meshType=0] - 分析类型。
 * @param {SummaryType} [options.type=SummaryType.SUMMARYMESH] - 聚合类型。
 * @param {OutputSetting} [options.output] - 输出参数设置。
 * @param {MappingParameters} [options.mappingParameters] - 分析后结果可视化的参数类。
 * @usage
 */
class SummaryMeshJobParameter {

    constructor(options) {
        if (!options) {
            return;
        }
        /**
         * @member {string} SummaryMeshJobParameter.prototype.datasetName
         * @description 数据集名。
         */
        this.datasetName = "";

        /**
         * @member {string} SummaryMeshJobParameter.prototype.regionDataset
         * @description 聚合面数据集（聚合类型为多边形聚合时使用的参数）。
         */
        this.regionDataset = "";

        /**
         * @member {(SuperMap.Bounds|L.Bounds|L.LatLngBounds|ol.extent|mapboxgl.LngLatBounds|GeoJSONObject)} SummaryMeshJobParameter.prototype.query
         * @description 分析范围（聚合类型为网格面聚合时使用的参数）。
         */
        this.query = "";

        /**
         * @member {number} [SummaryMeshJobParameter.prototype.resolution=100]
         * @description 分辨率（聚合类型为网格面聚合时使用的参数）。
         */
        this.resolution = 100;

        /**
         * @member {number} [SummaryMeshJobParameter.prototype.meshType=0]
         * @description  网格面类型（聚合类型为网格面聚合时使用的参数），取值：0 或 1。
         */
        this.meshType = 0;

        /**
         * @member {StatisticAnalystMode} [SummaryMeshJobParameter.prototype.statisticModes=StatisticAnalystMode.AVERAGE]
         * @description 统计模式。
         */
        this.statisticModes = StatisticAnalystMode.AVERAGE;

        /**
         * @member {number} SummaryMeshJobParameter.prototype.fields
         * @description 权重字段。
         */
        this.fields = "";

        /**
         * @member {SummaryType} [SummaryMeshJobParameter.prototype.type=SummaryType.SUMMARYMESH]
         * @description 聚合类型。
         */
        this.type = SummaryType.SUMMARYMESH;

        /**
         * @member {OutputSetting} [SummaryMeshJobParameter.prototype.output]
         * @description 输出参数设置类。
         */
        this.output = null;

        /**
         * @member {MappingParameters} [SummaryMeshJobParameter.prototype.mappingParameters]
         * @description 分析后结果可视化的参数类。
         */
        this.mappingParameters = null;

        Util_Util.extend(this, options);

        this.CLASS_NAME = "SuperMap.SummaryMeshJobParameter";
    }


    /**
     * @function SummaryMeshJobParameter.prototype.destroy
     * @description 释放资源，将资源的属性置空。
     */
    destroy() {
        this.datasetName = null;
        this.query = null;
        this.resolution = null;
        this.statisticModes = null;
        this.meshType = null;
        this.fields = null;
        this.regionDataset = null;
        this.type = null;
        if (this.output instanceof OutputSetting) {
            this.output.destroy();
            this.output = null;
        }
        if (this.mappingParameters instanceof MappingParameters){
            this.mappingParameters.destroy();
            this.mappingParameters = null;
        }
    }

    /**
     * @function SummaryMeshJobParameter.toObject
     * @param {Object} summaryMeshJobParameter - 点聚合分析任务参数。
     * @param {Object} tempObj - 目标对象。
     * @description 生成点聚合分析任务对象。
     */
    static toObject(summaryMeshJobParameter, tempObj) {
        for (var name in summaryMeshJobParameter) {
            if (name === "datasetName") {
                tempObj['input'] = tempObj['input'] || {};
                tempObj['input'][name] = summaryMeshJobParameter[name];
                continue;
            }
            if (name === "type") {
                tempObj['type'] = summaryMeshJobParameter[name];
                continue;
            }
            if (name === "output") {
                tempObj['output'] = tempObj['output'] || {};
                tempObj['output'] = summaryMeshJobParameter[name];
                continue;
            }
            if (summaryMeshJobParameter.type === 'SUMMARYMESH' && name !== 'regionDataset' || summaryMeshJobParameter.type === 'SUMMARYREGION' && !contains(['meshType', 'resolution', 'query'], name)) {
                tempObj['analyst'] = tempObj['analyst'] || {};
                if (name === 'query' && summaryMeshJobParameter[name]) {
                    tempObj['analyst'][name] = summaryMeshJobParameter[name].toBBOX();
                } else {
                    tempObj['analyst'][name] = summaryMeshJobParameter[name];
                }
                if(name === 'mappingParameters'){
                    tempObj['analyst'][name] = tempObj['analyst'][name] || {};
                    tempObj['analyst']['mappingParameters'] = summaryMeshJobParameter[name];
                }
            }

        }

        function contains(arr, obj) {
            var i = arr.length;
            while (i--) {
                if (arr[i] === obj) {
                    return true;
                }
            }
            return false;
        }
    }

}


;// CONCATENATED MODULE: ./src/common/iServer/SummaryMeshJobsService.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/




/**
 * @class SummaryMeshJobsService
 * @deprecatedclass SuperMap.SummaryMeshJobsService
 * @category  iServer ProcessingService AggregatePoints
 * @classdesc 点聚合分析任务类。
 * @param {string} url - 服务地址。
 * @param {Object} options - 参数。
 * @param {Events} options.events - 处理所有事件的对象。
 * @param {number} options.index - 服务地址在数组中的位置。
 * @param {number} options.length - 服务地址数组长度。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @usage
 */
class SummaryMeshJobsService extends ProcessingServiceBase {
    constructor(url, options) {
        super(url, options);
        this.url = Util_Util.urlPathAppend(this.url, 'spatialanalyst/aggregatepoints');
        this.CLASS_NAME = 'SuperMap.SummaryMeshJobsService';
    }

    /**
     * @override
     */
    destroy() {
        super.destroy();
    }

    /**
     * @function SummaryMeshJobsService.prototype.getSummaryMeshJobs
     * @description 获取点聚合分析任务
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    getSummaryMeshJobs(callback) {
        return super.getJobs(this.url, callback);
    }

    /**
     * @function SummaryMeshJobsService.prototype.getSummaryMeshJob
     * @description 获取指定ip的点聚合分析任务
     * @param {string} id - 指定要获取数据的id
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    getSummaryMeshJob(id, callback) {
        return super.getJobs(Util_Util.urlPathAppend(this.url, id), callback);
    }

    /**
     * @function SummaryMeshJobsService.prototype.addSummaryMeshJob
     * @description 新建点聚合分析服务
     * @param {SummaryMeshJobParameter} params - 创建一个空间分析的请求参数。
     * @param {number} seconds - 开始创建后，获取创建成功结果的时间间隔。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    addSummaryMeshJob(params, seconds, callback, processRunningCallback) {
        return super.addJob(this.url, params, SummaryMeshJobParameter, seconds, callback, processRunningCallback);
    }
}


;// CONCATENATED MODULE: ./src/common/iServer/VectorClipJobsParameter.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/





/**
 * @class VectorClipJobsParameter
 * @deprecatedclass SuperMap.VectorClipJobsParameter
 * @category  iServer ProcessingService VectorClip
 * @classdesc 矢量裁剪分析任务参数类。
 * @param {Object} options - 参数。
 * @param {string} options.datasetName - 数据集名。
 * @param {string} options.datasetOverlay - 裁剪对象数据集。
 * @param {ClipAnalystMode} [options.mode=ClipAnalystMode.CLIP] - 裁剪分析模式。
 * @param {string} [options.geometryClip] - 裁剪几何对象。
 * @param {OutputSetting} [options.output] - 输出参数设置。
 * @param {MappingParameters} [options.mappingParameters] - 分析后结果可视化的参数类。
 * @usage
 */
class VectorClipJobsParameter {

    constructor(options) {
        options = options || {};

        /**
         * @member {string} VectorClipJobsParameter.prototype.datasetName
         * @description 数据集名。
         */
        this.datasetName = "";

        /**
         * @member {string} VectorClipJobsParameter.prototype.datasetOverlay
         * @description 裁剪对象数据集。
         */
        this.datasetVectorClip = "";

        /**
         * @member {string} VectorClipJobsParameter.prototype.geometryClip
         * @description 裁剪几何对象。
         */
        this.geometryClip = "";

        /**
         * @member {ClipAnalystMode} [VectorClipJobsParameter.prototype.mode=ClipAnalystMode.CLIP]
         * @description 裁剪分析模式 。
         */
        this.mode = ClipAnalystMode.CLIP;

        /**
         * @member {OutputSetting} VectorClipJobsParameter.prototype.output
         * @description 输出参数设置类。
         */
        this.output = null;

        /**
         * @member {MappingParameters} [VectorClipJobsParameter.prototype.mappingParameters]
         * @description 分析后结果可视化的参数类。
         */
        this.mappingParameters = null;

        Util_Util.extend(this, options);

        this.CLASS_NAME = "SuperMap.VectorClipJobsParameter";
    }

    /**
     * @function VectorClipJobsParameter.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        this.datasetName = null;
        this.datasetVectorClip = null;
        this.geometryClip = null;
        this.mode = null;
        if (this.output instanceof OutputSetting) {
            this.output.destroy();
            this.output = null;
        }
        if (this.mappingParameters instanceof MappingParameters) {
            this.mappingParameters.destroy();
            this.mappingParameters = null;
        }
    }

    /**
     * @function VectorClipJobsParameter.toObject
     * @param {Object} vectorClipJobsParameter - 区域汇总分析服务参数。
     * @param {Object} tempObj - 目标对象。
     * @description 矢量裁剪分析任务对象。
     */
    static toObject(vectorClipJobsParameter, tempObj) {
        for (var name in vectorClipJobsParameter) {
            if (name === "datasetName") {
                tempObj['input'] = tempObj['input'] || {};
                tempObj['input'][name] = vectorClipJobsParameter[name];
                continue;
            }
            if (name === "output"){
                tempObj['output'] = tempObj['output'] || {};
                tempObj['output'] = vectorClipJobsParameter[name];
                continue;
            }
            tempObj['analyst'] = tempObj['analyst'] || {};
            tempObj['analyst'][name] = vectorClipJobsParameter[name];
            if(name === 'mappingParameters'){
                tempObj['analyst'][name] = tempObj['analyst'][name] || {};
                tempObj['analyst']['mappingParameters'] = vectorClipJobsParameter[name];
            }
        }
    }

}


;// CONCATENATED MODULE: ./src/common/iServer/VectorClipJobsService.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/




/**
 * @class VectorClipJobsService
 * @deprecatedclass SuperMap.VectorClipJobsService
 * @category  iServer ProcessingService VectorClip
 * @classdesc 矢量裁剪分析服务类
 * @extends {ProcessingServiceBase}
 * @param {string} url -服务地址。
 * @param {Object} options - 可选参数。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @usage
 */
class VectorClipJobsService extends ProcessingServiceBase {
    constructor(url, options) {
        super(url, options);
        this.url = Util_Util.urlPathAppend(this.url, 'spatialanalyst/vectorclip');
        this.CLASS_NAME = 'SuperMap.VectorClipJobsService';
    }

    /**
     *@override
     */
    destroy() {
        super.destroy();
    }

    /**
     * @function VectorClipJobsService.protitype.getVectorClipJobs
     * @description 获取矢量裁剪分析所有任务
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    getVectorClipJobs(callback) {
        return super.getJobs(this.url, callback);
    }

    /**
     * @function KernelDensityJobsService.protitype.getVectorClipJob
     * @description 获取指定id的矢量裁剪分析服务
     * @param {string} id - 指定要获取数据的id
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    getVectorClipJob(id, callback) {
        return super.getJobs(Util_Util.urlPathAppend(this.url, id), callback);
    }

    /**
     * @function VectorClipJobsService.protitype.addVectorClipJob
     * @description 新建矢量裁剪分析服务
     * @param {VectorClipJobsParameter} params - 创建一个空间分析的请求参数。
     * @param {number} seconds - 开始创建后，获取创建成功结果的时间间隔。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @param {RequestCallback} [processRunningCallback] - 回调函数。
     * @returns {Promise} Promise 对象。
     */
    addVectorClipJob(params, seconds, callback, processRunningCallback) {
        return super.addJob(this.url, params, VectorClipJobsParameter, seconds, callback, processRunningCallback);
    }
}


;// CONCATENATED MODULE: ./src/common/iServer/OverlayGeoJobParameter.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/




/**
 * @class OverlayGeoJobParameter
 * @deprecatedclass SuperMap.OverlayGeoJobParameter
 * @category iServer ProcessingService OverlayAnalyst
 * @classdesc 叠加分析任务参数类。
 * @param {Object} options - 参数。
 * @param {string} options.datasetName - 数据集名。
 * @param {string} options.datasetOverlay - 叠加对象所在的数据集名称。
 * @param {string} options.srcFields - 输入数据需要保留的字段。
 * @param {string} [options.overlayFields] - 叠加数据需要保留的字段。对分析模式为 clip、update、erase 时，此参数无效。
 * @param {string} [options.mode] - 叠加分析模式。
 * @param {OutputSetting} [options.output] - 输出参数设置。
 * @param {MappingParameters} [options.mappingParameters] - 分析后结果可视化的参数类。
 * @usage
 */
class OverlayGeoJobParameter {

    constructor(options) {
        if (!options) {
            return;
        }
        /**
         * @member {string} OverlayGeoJobParameter.prototype.datasetName
         * @description 数据集名。
         */
        this.datasetName = "";

        /**
         * @member {string} OverlayGeoJobParameter.prototype.datasetOverlay
         * @description 叠加对象所在的数据集名称。
         */
        this.datasetOverlay = "";

        /**
         * @member {string} [OverlayGeoJobParameter.prototype.mode]
         * @description 叠加分析模式。
         */
        this.mode = "";

        /**
         * @member {string} OverlayGeoJobParameter.prototype.srcFields
         * @description 输入数据需要保留的字段。
         */
        this.srcFields = "";

        /**
         * @member {string} OverlayGeoJobParameter.prototype.overlayFields
         * @description 叠加数据需要保留的字段，对分析模式为 clip、update、erase 时，此参数无效。
         */
        this.overlayFields = "";

        /**
         * @member {OutputSetting} [OverlayGeoJobParameter.prototype.output]
         * @description 输出参数设置类。
         */
        this.output = null;

        /**
        * @member {MappingParameters} [OverlayGeoJobParameter.prototype.mappingParameters]
        * @description 分析后结果可视化的参数类。
        */
        this.mappingParameters = null;

        Util_Util.extend(this, options);
        this.CLASS_NAME = "SuperMap.OverlayGeoJobParameter";
    }

    /**
     * @function OverlayGeoJobParameter.prototype.destroy
     * @description 释放资源，将资源的属性置空。
     */
    destroy() {
        this.datasetName = null;
        this.datasetOverlay = null;
        this.mode = null;
        this.srcFields = null;
        this.overlayFields = null;
        if (this.output instanceof OutputSetting) {
            this.output.destroy();
            this.output = null;
        }
        if (this.mappingParameters instanceof MappingParameters) {
            this.mappingParameters.destroy();
            this.mappingParameters = null;
        }
    }

    /**
     * @function OverlayGeoJobParameter.toObject
     * @param {Object} OverlayGeoJobParameter - 点聚合分析任务参数。
     * @param {Object} tempObj - 目标对象。
     * @description 生成点聚合分析任务对象。
     */
    static toObject(OverlayGeoJobParameter, tempObj) {
        for (var name in OverlayGeoJobParameter) {
            if (name == "datasetName") {
                tempObj['input'] = tempObj['input'] || {};
                tempObj['input'][name] = OverlayGeoJobParameter[name];
                continue;
            }
            if (name === "output") {
                tempObj['output'] = tempObj['output'] || {};
                tempObj['output'] = OverlayGeoJobParameter[name];
                continue;
            }

            tempObj['analyst'] = tempObj['analyst'] || {};
            tempObj['analyst'][name] = OverlayGeoJobParameter[name];
            if(name === 'mappingParameters'){
                tempObj['analyst'][name] = tempObj['analyst'][name] || {};
                tempObj['analyst']['mappingParameters'] = OverlayGeoJobParameter[name];
            }
        }
    }

}

;// CONCATENATED MODULE: ./src/common/iServer/OverlayGeoJobsService.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/




/**
 * @class OverlayGeoJobsService
 * @deprecatedclass SuperMap.OverlayGeoJobsService
 * @category iServer ProcessingService OverlayAnalyst
 * @classdesc 叠加分析任务类。
 * @param {string} url - 服务地址。
 * @param {Object} options - 参数。
 * @param {Events} options.events - 处理所有事件的对象。
 * @param {number} options.index - 服务访问地址在数组中的位置。
 * @param {number} options.length - 服务访问地址数组长度。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @usage
 */
class OverlayGeoJobsService extends ProcessingServiceBase {
    constructor(url, options) {
        super(url, options);
        this.url = Util_Util.urlPathAppend(this.url, 'spatialanalyst/overlay');
        this.CLASS_NAME = 'SuperMap.OverlayGeoJobsService';
    }

    /**
     * @override
     */
    destroy() {
        super.destroy();
    }

    /**
     * @function OverlayGeoJobsService.prototype.getOverlayGeoJobs
     * @description 获取叠加分析任务
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    getOverlayGeoJobs(callback) {
        return super.getJobs(this.url, callback);
    }

    /**
     * @function OverlayGeoJobsService.prototype.getOverlayGeoJob
     * @description 获取指定id的叠加分析任务
     * @param {string} id - 指定要获取数据的id
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    getOverlayGeoJob(id, callback) {
        return super.getJobs(Util_Util.urlPathAppend(this.url, id), callback);
    }

    /**
     * @function OverlayGeoJobsService.prototype.addOverlayGeoJob
     * @description 新建点叠加析服务
     * @param {OverlayGeoJobParameter} params - 创建一个叠加分析的请求参数。
     * @param {number} seconds - 开始创建后，获取创建成功结果的时间间隔。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    addOverlayGeoJob(params, seconds, callback, processRunningCallback) {
        return super.addJob(this.url, params, OverlayGeoJobParameter, seconds, callback, processRunningCallback);
    }
}

;// CONCATENATED MODULE: ./src/common/iServer/SummaryRegionJobParameter.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/





/**
 * @class SummaryRegionJobParameter
 * @deprecatedclass SuperMap.SummaryRegionJobParameter
 * @category  iServer ProcessingService SummaryRegion
 * @classdesc 区域汇总分析任务参数类。
 * @param {Object} options - 参数。
 * @param {string} options.datasetName - 数据集名。
 * @param {string} [options.regionDataset] - 汇总数据源（多边形汇总时用到的参数）。
 * @param {(SuperMap.Bounds|L.Bounds|L.LatLngBounds|ol.extent|mapboxgl.LngLatBounds|GeoJSONObject)} [options.query] - 分析范围（默认为全图范围）。
 * @param {string} [options.standardFields] - 标准属性字段名称。
 * @param {string} [options.weightedFields] - 权重字段名称。
 * @param {StatisticAnalystMode} [options.standardStatisticModes] - 标准属性字段的统计模式。standardSummaryFields 为 true 时必填。
 * @param {StatisticAnalystMode} [options.weightedStatisticModes] - 权重字段的统计模式。weightedSummaryFields 为 true 时必填。
 * @param {boolean} [options.sumShape=true] - 是否统计长度或面积。
 * @param {boolean} [options.standardSummaryFields=false] - 是否以标准属性字段统计。
 * @param {boolean} [options.weightedSummaryFields=false] - 是否以权重字段统计。
 * @param {number} [options.resolution=100] - 网格大小。
 * @param {number} [options.meshType=0] - 网格面汇总类型。
 * @param {AnalystSizeUnit} [options.meshSizeUnit=AnalystSizeUnit.METER] - 网格大小单位。
 * @param {SummaryType} [options.type=SummaryType.SUMMARYMESH] - 汇总类型。
 * @param {OutputSetting} [options.output] - 输出参数设置。
 * @param {MappingParameters} [options.mappingParameters] - 分析后结果可视化的参数类。
 * @usage
 */
class SummaryRegionJobParameter {

    constructor(options) {
        if (!options) {
            return;
        }

        /**
         * @member {string} SummaryRegionJobParameter.prototype.datasetName
         * @description 数据集名。
         */
        this.datasetName = "";

        /**
         * @member {string} SummaryRegionJobParameter.prototype.regionDataset
         * @description 汇总数据源（多边形汇总时用到的参数）。
         */
        this.regionDataset = "";

        /**
         * @member {boolean} [SummaryRegionJobParameter.prototype.sumShape=true]
         * @description 是否统计长度或面积。
         */
        this.sumShape = true;

        /**
         * @member {(SuperMap.Bounds|L.Bounds|L.LatLngBounds|ol.extent|mapboxgl.LngLatBounds|GeoJSONObject)} SummaryRegionJobParameter.prototype.query
         * @description 分析范围。
         */
        this.query = "";

        /**
         * @member {boolean} [SummaryRegionJobParameter.prototype.standardSummaryFields=false]
         * @description 是否以标准属字段统计。
         */
        this.standardSummaryFields = false;

        /**
         * @member {string} SummaryRegionJobParameter.prototype.standardFields
         * @description 标准属性字段名称。仅支持系统字段以外的整形、长整形、浮点型的字段的名称。standardSummaryFields 为 true 时必填。
         */
        this.standardFields = "";

        /**
         * @member {StatisticAnalystMode} SummaryRegionJobParameter.prototype.standardStatisticModes
         * @description 标准属性字段的统计模式。standardSummaryFields 为 true 时必填。
         */
        this.standardStatisticModes = "";

        /**
         * @member {boolean} [SummaryRegionJobParameter.prototype.weightedSummaryFields=false]
         * @description 是否以权重字段统计。
         */
        this.weightedSummaryFields = false;

        /**
         * @member {string} SummaryRegionJobParameter.prototype.weightedFields
         * @description 权重字段名称。仅支持系统字段以外的整形、长整形、浮点型的字段的名称。weightedSummaryFields 为 true 时必填。
         */
        this.weightedFields = "";

        /**
         * @member {StatisticAnalystMode} SummaryRegionJobParameter.prototype.weightedStatisticModes
         * @description 以权重字段统计的统计模式。权重字段的统计模式。weightedSummaryFields 为 true 时必填。
         */
        this.weightedStatisticModes = "";

        /**
         * @member {number} [SummaryRegionJobParameter.prototype.meshType=0]
         * @description 网格面汇总类型。
         */
        this.meshType = 0;

        /**
         * @member {number} [SummaryRegionJobParameter.prototype.resolution=100]
         * @description 网格大小。
         */
        this.resolution = 100;

        /**
         * @member {AnalystSizeUnit} [SummaryRegionJobParameter.prototype.meshSizeUnit=AnalystSizeUnit.METER]
         * @description 网格大小单位。
         */
        this.meshSizeUnit = AnalystSizeUnit.METER;

        /**
         * @member {SummaryType} [SummaryRegionJobParameter.prototype.type=SummaryType.SUMMARYMESH]
         * @description 汇总类型。
         */
        this.type = SummaryType.SUMMARYMESH;

        /**
         * @member {OutputSetting} SummaryRegionJobParameter.prototype.output
         * @description 输出参数设置类。
         */
        this.output = null;

        /**
         * @member {MappingParameters} [SummaryRegionJobParameter.prototype.mappingParameters]
         * @description 分析后结果可视化的参数类。
         */
        this.mappingParameters = null;

        Util_Util.extend(this, options);

        this.CLASS_NAME = "SuperMap.SummaryRegionJobParameter";
    }

    /**
     * @function SummaryRegionJobParameter.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        this.datasetName = null;
        this.sumShape = null;
        this.regionDataset = null;
        this.query = null;
        this.standardSummaryFields = null;
        this.standardFields = null;
        this.standardStatisticModes = null;
        this.weightedSummaryFields = null;
        this.weightedFields = null;
        this.weightedStatisticModes = null;
        this.meshType = null;
        this.resolution = null;
        this.meshSizeUnit = null;
        this.type = null;
        if (this.output instanceof OutputSetting) {
            this.output.destroy();
            this.output = null;
        }
        if (this.mappingParameters instanceof MappingParameters){
            this.mappingParameters.destroy();
            this.mappingParameters = null;
        }
    }

    /**
     * @function SummaryRegionJobParameter.toObject
     * @param {Object} summaryRegionJobParameter - 矢量裁剪分析任务参数。
     * @param {Object} tempObj - 目标对象。
     * @description 生成区域汇总分析服务对象。
     */
    static toObject(summaryRegionJobParameter, tempObj) {
        for (var name in summaryRegionJobParameter) {
            if (name === "datasetName") {
                tempObj['input'] = tempObj['input'] || {};
                tempObj['input'][name] = summaryRegionJobParameter[name];
                continue;
            }
            if (name === "type") {
                tempObj['type'] = summaryRegionJobParameter[name];
                continue;
            }
            if (name === "type") {
                tempObj['type'] = summaryRegionJobParameter[name];
                continue;
            }
            if (name === "output") {
                tempObj['output'] = tempObj['output'] || {};
                tempObj['output'] = summaryRegionJobParameter[name];
                continue;
            }
            if (summaryRegionJobParameter.type === "SUMMARYREGION" || summaryRegionJobParameter.type === "SUMMARYMESH" && name !== "regionDataset") {
                tempObj['analyst'] = tempObj['analyst'] || {};
                if (name === 'query' && summaryRegionJobParameter[name]) {
                    tempObj['analyst'][name] = summaryRegionJobParameter[name].toBBOX();
                } else {
                    tempObj['analyst'][name] = summaryRegionJobParameter[name];
                }
                if(name === 'mappingParameters'){
                    tempObj['analyst'][name] = tempObj['analyst'][name] || {};
                    tempObj['analyst']['mappingParameters'] = summaryRegionJobParameter[name];
                }

            }
        }
    }

}


;// CONCATENATED MODULE: ./src/common/iServer/SummaryRegionJobsService.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/




/**
 * @class SummaryRegionJobsService
 * @deprecatedclass SuperMap.SummaryRegionJobsService
 * @category  iServer ProcessingService SummaryRegion
 * @classdesc 区域汇总分析服务类
 * @extends {ProcessingServiceBase}
 * @param {string} url - 服务地址。
 * @param {Object} options - 可选参数。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @usage
 */
class SummaryRegionJobsService extends ProcessingServiceBase {
    constructor(url, options) {
        super(url, options);
        this.url = Util_Util.urlPathAppend(this.url, 'spatialanalyst/summaryregion');
        this.CLASS_NAME = 'SuperMap.SummaryRegionJobsService';
    }

    /**
     *@override
     */
    destroy() {
        super.destroy();
    }

    /**
     * @function SummaryRegionJobsService.prototype.getSummaryRegionJobs
     * @description 获取区域汇总分析任务集合。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    getSummaryRegionJobs(callback) {
      return super.getJobs(this.url, callback);
    }

    /**
     * @function SummaryRegionJobsService.prototype.getSummaryRegionJob
     * @description 获取指定id的区域汇总分析任务。
     * @param {string} id -要获取区域汇总分析任务的id
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    getSummaryRegionJob(id, callback) {
       return super.getJobs(Util_Util.urlPathAppend(this.url, id), callback);
    }

    /**
     * @function SummaryRegionJobsService.prototype.addSummaryRegionJob
     * @description 新建区域汇总任务。
     * @param {SummaryRegionJobParameter} params - 区域汇总分析任务参数类。
     * @param {number} seconds - 创建成功结果的时间间隔。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    addSummaryRegionJob(params, seconds, callback, processRunningCallback) {
        return super.addJob(this.url, params, SummaryRegionJobParameter, seconds, callback, processRunningCallback);
    }
}


;// CONCATENATED MODULE: ./src/common/iServer/BuffersAnalystJobsParameter.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/





/**
 * @class BuffersAnalystJobsParameter
 * @deprecatedclass SuperMap.BuffersAnalystJobsParameter
 * @category iServer ProcessingService BufferAnalyst
 * @classdesc 缓冲区分析任务参数类。
 * @param {Object} options - 参数。
 * @param {string} options.datasetName - 数据集名。
 * @param {(SuperMap.Bounds|L.Bounds|L.LatLngBounds|ol.extent|mapboxgl.LngLatBounds|GeoJSONObject)} [options.bounds] - 分析范围（默认为全图范围）。
 * @param {string} [options.distance='15'] - 缓冲距离，或缓冲区半径。
 * @param {string} [options.distanceField='pickup_latitude'] - 缓冲区分析距离字段。
 * @param {AnalystSizeUnit} [options.distanceUnit=AnalystSizeUnit.METER] - 缓冲距离单位单位。
 * @param {OutputSetting} [options.output] - 输出参数设置。
 * @param {MappingParameters} [options.mappingParameters] - 分析后结果可视化的参数类。
 * @usage
 */
class BuffersAnalystJobsParameter {
    constructor(options) {
        /**
         * @member {string} BuffersAnalystJobsParameter.prototype.datasetName
         * @description 数据集名。
         */
        this.datasetName = '';

        /**
         * @member {(SuperMap.Bounds|L.Bounds|L.LatLngBounds|ol.extent|mapboxgl.LngLatBounds|GeoJSONObject)} BuffersAnalystJobsParameter.prototype.bounds
         * @description 分析范围。
         */
        this.bounds = '';

        /**
         * @member {string} [BuffersAnalystJobsParameter.prototype.distance='15']
         * @description 缓冲距离，或称为缓冲区半径。当缓冲距离字段为空时，此参数有效。
         */
        this.distance = '';

        /**
         * @member {string} [BuffersAnalystJobsParameter.prototype.distanceField='pickup_latitude']
         * @description 缓冲距离字段。
         */
        this.distanceField = '';

        /**
         * @member {AnalystSizeUnit} [BuffersAnalystJobsParameter.prototype.distanceUnit=AnalystSizeUnit.METER]
         * @description 缓冲距离单位。
         */
        this.distanceUnit = AnalystSizeUnit.METER;

        /**
         * @member {string} BuffersAnalystJobsParameter.prototype.dissolveField
         * @description 融合字段，根据字段值对缓冲区结果面对象进行融合。
         */
        this.dissolveField = '';

        /**
         * @member {OutputSetting} [BuffersAnalystJobsParameter.prototype.output]
         * @description 输出参数设置类。
         */
        this.output = null;

        /**
         * @member {MappingParameters} [BuffersAnalystJobsParameter.prototype.mappingParameters]
         * @description 分析后结果可视化的参数类。
         */
        this.mappingParameters = null;

        if (!options) {
            return this;
        }
        Util_Util.extend(this, options);

        this.CLASS_NAME = 'SuperMap.BuffersAnalystJobsParameter';
    }

    /**
     * @function BuffersAnalystJobsParameter.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        this.datasetName = null;
        this.bounds = null;
        this.distance = null;
        this.distanceField = null;
        this.distanceUnit = null;
        this.dissolveField = null;
        if (this.output instanceof OutputSetting) {
            this.output.destroy();
            this.output = null;
        }
        if (this.mappingParameters instanceof MappingParameters) {
            this.mappingParameters.destroy();
            this.mappingParameters = null;
        }
    }

    /**
     * @function BuffersAnalystJobsParameter.toObject
     * @param {BuffersAnalystJobsParameter} BuffersAnalystJobsParameter - 缓冲区分析任务参数。
     * @param {Object} tempObj - 目标对象。
     * @description 生成缓冲区分析任务对象。
     */
    static toObject(BuffersAnalystJobsParameter, tempObj) {
        for (var name in BuffersAnalystJobsParameter) {
            if (name === 'datasetName') {
                tempObj['input'] = tempObj['input'] || {};
                tempObj['input'][name] = BuffersAnalystJobsParameter[name];
                continue;
            }
            if (name === 'output') {
                tempObj['output'] = tempObj['output'] || {};
                tempObj['output'] = BuffersAnalystJobsParameter[name];
                continue;
            }

            tempObj['analyst'] = tempObj['analyst'] || {};
            if (name === 'bounds' && BuffersAnalystJobsParameter[name]) {
                tempObj['analyst'][name] = BuffersAnalystJobsParameter[name].toBBOX();
            } else {
                tempObj['analyst'][name] = BuffersAnalystJobsParameter[name];
            }
            if (name === 'mappingParameters') {
                tempObj['analyst'][name] = tempObj['analyst'][name] || {};
                tempObj['analyst']['mappingParameters'] = BuffersAnalystJobsParameter[name];
            }
        }
    }
}


;// CONCATENATED MODULE: ./src/common/iServer/BuffersAnalystJobsService.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/




/**
 * @class BuffersAnalystJobsService
 * @deprecatedclass SuperMap.BuffersAnalystJobsService
 * @category iServer ProcessingService BufferAnalyst
 * @classdesc 缓冲区分析服务类。
 * @extends {ProcessingServiceBase}
 * @param {string} url - 服务地址。
 * @param {Object} options - 参数。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @usage
 */
class BuffersAnalystJobsService extends ProcessingServiceBase {
    constructor(url, options) {
        super(url, options);
        this.url = Util_Util.urlPathAppend(this.url, 'spatialanalyst/buffers');
        this.CLASS_NAME = 'SuperMap.BuffersAnalystJobsService';
    }

    /**
     *@override
     */
    destroy() {
      super.destroy();
    }

    /**
     * @function BuffersAnalystJobsService.prototype.getBufferJobs
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @description 获取缓冲区分析所有任务
     * @returns {Promise} Promise 对象。
     */
    getBuffersJobs(callback) {
      return super.getJobs(this.url, callback);
    }

    /**
     * @function BuffersAnalystJobsService.prototype.getBufferJob
     * @description 获取指定id的缓冲区分析服务
     * @param {string} id - 指定要获取数据的id。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    getBuffersJob(id, callback) {
        return super.getJobs(Util_Util.urlPathAppend(this.url, id), callback);
    }

    /**
     * @function BuffersAnalystJobsService.prototype.addBufferJob
     * @description 新建缓冲区分析服务
     * @param {BuffersAnalystJobsParameter} params - 创建一个空间分析的请求参数。
     * @param {number} seconds - 开始创建后，获取创建成功结果的时间间隔。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @param {RequestCallback} [processRunningCallback] - 回调函数。
     * @returns {Promise} Promise 对象。
     */
    addBuffersJob(params, seconds, callback, processRunningCallback) {
        return super.addJob(this.url, params, BuffersAnalystJobsParameter, seconds, callback, processRunningCallback);
    }
}


;// CONCATENATED MODULE: ./src/common/iServer/TopologyValidatorJobsParameter.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/





/**
 * @class TopologyValidatorJobsParameter
 * @deprecatedclass SuperMap.TopologyValidatorJobsParameter
 * @category  iServer ProcessingService TopologyValidator
 * @classdesc 拓扑检查分析任务参数类。
 * @param {Object} options - 参数。
 * @param {string} options.datasetName - 数据集名。
 * @param {string} options.datasetTopology -检查对象所在的数据集名称。
 * @param {TopologyValidatorRule} [options.rule=TopologyValidatorRule.REGIONNOOVERLAP] - 拓扑检查规则。
 * @param {string} [options.tolerance] - 容限。
 * @param {OutputSetting} [options.output] - 输出参数设置。
 * @param {MappingParameters} [options.mappingParameters] - 分析后结果可视化的参数类。
 * @usage
 */
class TopologyValidatorJobsParameter {

    constructor(options) {
        if (!options) {
            return;
        }
        /**
         * @member {string} TopologyValidatorJobsParameter.prototype.datasetName
         * @description 数据集名。
         */
        this.datasetName = "";

        /**
         * @member {string} TopologyValidatorJobsParameter.prototype.datasetTopology
         * @description 拓扑检查对象所在的数据集名称。
         */
        this.datasetTopology = "";

        /**
         * @member {string} [TopologyValidatorJobsParameter.prototype.tolerance]
         * @description 容限，指定的拓扑错误检查时使用的容限。
         */
        this.tolerance = "";

        /**
         * @member {TopologyValidatorRule} [TopologyValidatorJobsParameter.prototype.rule=TopologyValidatorRule.REGIONNOOVERLAP]
         * @description 拓扑检查模式。
         */
        this.rule = TopologyValidatorRule.REGIONNOOVERLAP;

        /**
         * @member {OutputSetting} [TopologyValidatorJobsParameter.prototype.output]
         * @description 输出参数设置类。
         */
        this.output = null;

        /**
         * @member {MappingParameters} [TopologyValidatorJobsParameter.prototype.mappingParameters]
         * @description 分析后结果可视化的参数类。
         */
        this.mappingParameters = null;

        Util_Util.extend(this, options);

        this.CLASS_NAME = "SuperMap.TopologyValidatorJobsParameter";
    }

    /**
     * @function TopologyValidatorJobsParameter.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        this.datasetName = null;
        this.datasetTopology = null;
        this.tolerance = null;
        this.rule = null;
        if (this.output instanceof OutputSetting) {
            this.output.destroy();
            this.output = null;
        }
        if (this.mappingParameters instanceof MappingParameters) {
            this.mappingParameters.destroy();
            this.mappingParameters = null;
        }
    }

    /**
     * @function TopologyValidatorJobsParameter.toObject
     * @param {Object} TopologyValidatorJobsParameter -拓扑检查分析任务参数。
     * @param {Object} tempObj - 目标对象。
     * @description 生成拓扑检查分析任务对象。
     */
    static toObject(TopologyValidatorJobsParameter, tempObj) {
        for (var name in TopologyValidatorJobsParameter) {
            if (name === "datasetName") {
                tempObj['input'] = tempObj['input'] || {};
                tempObj['input'][name] = TopologyValidatorJobsParameter[name];
                continue;
            }
            if (name === "output") {
                tempObj['output'] = tempObj['output'] || {};
                tempObj['output'] = TopologyValidatorJobsParameter[name];
                continue;
            }
            tempObj['analyst'] = tempObj['analyst'] || {};
            tempObj['analyst'][name] = TopologyValidatorJobsParameter[name];
            if(name === 'mappingParameters'){
                tempObj['analyst'][name] = tempObj['analyst'][name] || {};
                tempObj['analyst']['mappingParameters'] = TopologyValidatorJobsParameter[name];
            }
        }
    }
}

;// CONCATENATED MODULE: ./src/common/iServer/TopologyValidatorJobsService.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/




/**
 * @class TopologyValidatorJobsService
 * @deprecatedclass SuperMap.TopologyValidatorJobsService
 * @category  iServer ProcessingService TopologyValidator
 * @classdesc 拓扑检查分析服务类
 * @extends {ProcessingServiceBase}
 * @param {string} url - 服务地址。
 * @param {Object} options - 可选参数。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @usage
 */
class TopologyValidatorJobsService extends ProcessingServiceBase {

    constructor(url, options) {
        super(url, options);
        this.url = Util_Util.urlPathAppend(this.url, 'spatialanalyst/topologyvalidator');
        this.CLASS_NAME = "SuperMap.TopologyValidatorJobsService";
    }

    /**
     *@override
     */
    destroy() {
        super.destroy();
    }

    /**
     * @function TopologyValidatorJobsService.protitype.getTopologyValidatorJobs
     * @description 获取拓扑检查分析所有任务
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    getTopologyValidatorJobs(callback) {
        return super.getJobs(this.url, callback);
    }

    /**
     * @function TopologyValidatorJobsService.protitype.getTopologyValidatorJob
     * @description 获取指定id的拓扑检查分析服务
     * @param {string} id - 指定要获取数据的id
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    getTopologyValidatorJob(id, callback) {
        return super.getJobs(Util_Util.urlPathAppend(this.url, id), callback);
    }

    /**
     * @function TopologyValidatorJobsService.protitype.addTopologyValidatorJob
     * @description 新建拓扑检查分析服务
     * @param {TopologyValidatorJobsParameter} params - 拓扑检查分析任务参数类。
     * @param {number} seconds -创建成功结果的时间间隔。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    addTopologyValidatorJob(params, seconds, callback, processRunningCallback) {
        return super.addJob(this.url, params, TopologyValidatorJobsParameter, seconds, callback, processRunningCallback);
    }

}

;// CONCATENATED MODULE: ./src/common/iServer/SummaryAttributesJobsParameter.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/




/**
 * @class SummaryAttributesJobsParameter
 * @deprecatedclass SuperMap.SummaryAttributesJobsParameter
 * @category  iServer ProcessingService SummaryAttributes
 * @classdesc 属性汇总分析任务参数类。
 * @param {Object} options - 参数。
 * @param {string} options.datasetName - 数据集名。
 * @param {string} options.groupField - 分组字段。
 * @param {string} options.attributeField - 属性字段。
 * @param {string} options.statisticModes - 统计模式。
 * @param {OutputSetting} [options.output] -输出参数设置。
 * @param {MappingParameters} [options.mappingParameters] - 分析后结果可视化的参数类。
 * @usage
 */
class SummaryAttributesJobsParameter {

    constructor(options) {
        if (!options) {
            return;
        }
        /**
         * @member {string} SummaryAttributesJobsParameter.prototype.datasetName
         * @description 汇总数据集名称。
         */
        this.datasetName = "";
        /**
         * @member {string} SummaryAttributesJobsParameter.prototype.groupField
         * @description 分组字段。
         */
        this.groupField = "";
        /**
         * @member {string} SummaryAttributesJobsParameter.prototype.attributeField
         * @description 属性字段。
         */
        this.attributeField = "";
        /**
         * @member {string} SummaryAttributesJobsParameter.prototype.statisticModes
         * @description 属性汇总统计模式。
         */
        this.statisticModes = "";
        /**
         * @member {OutputSetting} SummaryAttributesJobsParameter.prototype.output
         * @description 输出参数设置类。
         */
        this.output = null;
        /**
         * @member {MappingParameters} [SummaryAttributesJobsParameter.prototype.mappingParameters]
         * @description 分析后结果可视化的参数类。
         */
        this.mappingParameters = null;

        Util_Util.extend(this, options);
        this.CLASS_NAME = "SuperMap.SummaryAttributesJobsParameter";
    }

    /**
     * @function SummaryAttributesJobsParameter.prototype.destroy
     * @description 释放资源，将资源的属性置空。
     */
    destroy() {
        this.datasetName = null;
        this.groupField = null;
        this.attributeField = null;
        this.statisticModes = null;
        if (this.output instanceof OutputSetting) {
            this.output.destroy();
            this.output = null;
        }
        if (this.mappingParameters instanceof MappingParameters){
            this.mappingParameters.destroy();
            this.mappingParameters = null;
        }
    }

    /**
     * @function SummaryAttributesJobsParameter.toObject
     * @param {Object} SummaryAttributesJobsParameter - 属性汇总任务参数。
     * @param {Object} tempObj - 目标对象。
     * @description 生成属性汇总分析任务对象。
     */
    static toObject(SummaryAttributesJobsParameter, tempObj) {
        for (var name in SummaryAttributesJobsParameter) {
            if (name === "datasetName") {
                tempObj['input'] = tempObj['input'] || {};
                tempObj['input'][name] = SummaryAttributesJobsParameter[name];
                continue;
            }
            if (name === "output") {
                tempObj['output'] = tempObj['output'] || {};
                tempObj['output'] = SummaryAttributesJobsParameter[name];
                continue;
            }

            tempObj['analyst'] = tempObj['analyst'] || {};
            tempObj['analyst'][name] = SummaryAttributesJobsParameter[name];
            if(name === 'mappingParameters'){
                tempObj['analyst'][name] = tempObj['analyst'][name] || {};
                tempObj['analyst']['mappingParameters'] = SummaryAttributesJobsParameter[name];
            }
        }
    }

}

;// CONCATENATED MODULE: ./src/common/iServer/SummaryAttributesJobsService.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/




/**
 * @class SummaryAttributesJobsService
 * @deprecatedclass SuperMap.SummaryAttributesJobsService
 * @category  iServer ProcessingService SummaryAttributes
 * @classdesc 属性汇总分析服务类
 * @extends {ProcessingServiceBase}
 * @param {string} url - 服务地址。
 * @param {Object} options - 可选参数。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @usage
 */
class SummaryAttributesJobsService extends ProcessingServiceBase {

    constructor(url, options) {
        super(url, options);
        this.url = Util_Util.urlPathAppend(this.url, 'spatialanalyst/summaryattributes');
        this.CLASS_NAME = "SuperMap.SummaryAttributesJobsService";
    }

    /**
     *@override
     */
    destroy() {
        super.destroy();
    }

    /**
     * @function SummaryAttributesJobsService.protitype.getSummaryAttributesJobs
     * @description 获取属性汇总分析所有任务
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    getSummaryAttributesJobs (callback){
        return super.getJobs(this.url, callback);
    }

    /**
     * @function SummaryAttributesJobsService.protitype.getSummaryAttributesJob
     * @description 获取指定id的属性汇总分析服务
     * @param {string} id - 指定要获取数据的id
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    getSummaryAttributesJob(id, callback) {
        return super.getJobs(Util_Util.urlPathAppend(this.url, id), callback);
    }

    /**
     * @function SummaryAttributesJobsService.protitype.addSummaryAttributesJob
     * @description 新建属性汇总分析服务
     * @param {SummaryAttributesJobsParameter} params - 属性汇总分析任务参数类。
     * @param {number} seconds - 创建成功结果的时间间隔。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    addSummaryAttributesJob(params, seconds, callback, processRunningCallback) {
        return super.addJob(this.url, params, SummaryAttributesJobsParameter, seconds, callback, processRunningCallback);
    }
}

;// CONCATENATED MODULE: ./src/common/iServer/ProcessingService.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/
 
 
 
 
 
 
 
 
 
 
 
 /**
  * @class ProcessingService
  * @category  iServer ProcessingService
  * @classdesc 分布式分析相关服务类。
  * @extends {ServiceBase}
  * @example
  * new ProcessingService(url,options)
  *  .getKernelDensityJobs(function(result){
  *     //doSomething
  * })
  * @param {string} url - 服务地址。 
  * @param {Object} options - 参数。
  * @param {string} [options.proxy] - 服务代理地址。
  * @param {boolean} [options.withCredentials=false] - 请求是否携带cookie。
  * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
  * @param {Object} [options.headers] - 请求头。
  * @usage
  */
 class ProcessingService_ProcessingService {
 
     constructor(url, options) {
         this.url = url;
         this.options = options || {};
         this.kernelDensityJobs = {};
         this.summaryMeshJobs = {};
         this.queryJobs = {};
         this.summaryRegionJobs = {};
         this.vectorClipJobs = {};
         this.overlayGeoJobs = {};
         this.buffersJobs = {};
         this.topologyValidatorJobs = {};
         this.summaryAttributesJobs = {};
     }
 
     /**
      * @function ProcessingService.prototype.getKernelDensityJobs
      * @description 获取密度分析的列表。
      * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
      * @param {DataFormat} [resultFormat=DataFormat.GEOJSON] - 返回结果类型。
      * @returns {Promise} Promise 对象。
      */
     getKernelDensityJobs(callback, resultFormat) {
         var me = this,
             format = me._processFormat(resultFormat);
         var kernelDensityJobsService = new KernelDensityJobsService(me.url, {
             proxy: me.options.proxy,
             withCredentials: me.options.withCredentials,
             crossOrigin: me.options.crossOrigin,
             headers: me.options.headers,
             format: format
         });
         return kernelDensityJobsService.getKernelDensityJobs(callback);
     }
 
     /**
      * @function ProcessingService.prototype.getKernelDensityJob
      * @description 获取某个密度分析。
      * @param {string} id - 空间分析的ID。 
      * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
      * @param {DataFormat} [resultFormat=DataFormat.GEOJSON] - 返回结果类型。
      * @returns {Promise} Promise 对象。
      */
     getKernelDensityJob(id, callback, resultFormat) {
         var me = this,
             format = me._processFormat(resultFormat);
         var kernelDensityJobsService = new KernelDensityJobsService(me.url, {
             proxy: me.options.proxy,
             withCredentials: me.options.withCredentials,
             crossOrigin: me.options.crossOrigin,
             headers: me.options.headers,
             format: format
         });
         return kernelDensityJobsService.getKernelDensityJob(id, callback);
     }
 
     /**
      * @function ProcessingService.prototype.addKernelDensityJob
      * @description 密度分析。
      * @param {KernelDensityJobParameter} params -密度分析参数类。 
      * @param {RequestCallback} callback 回调函数。 
      * @param {number} [seconds=1000] - 获取创建成功结果的时间间隔。 
      * @param {DataFormat} [resultFormat=DataFormat.GEOJSON] - 返回结果类型。
      * @returns {Promise} Promise 对象。
      */
     addKernelDensityJob(params, callback, seconds, resultFormat) {
         var me = this,
             format = me._processFormat(resultFormat);
         var kernelDensityJobsService = new KernelDensityJobsService(me.url, {
             proxy: me.options.proxy,
             withCredentials: me.options.withCredentials,
             crossOrigin: me.options.crossOrigin,
             headers: me.options.headers,
             format: format
         });
         return kernelDensityJobsService.addKernelDensityJob(params, seconds, callback, function (job) {
          me.kernelDensityJobs[job.id] = job.state;
        });
     }
 
     /**
      * @function ProcessingService.prototype.getKernelDensityJobState
      * @description 获取密度分析的状态。
      * @param {string} id - 密度分析的id。
      * @returns {Object} 密度分析的状态。
      */
     getKernelDensityJobState(id) {
         return this.kernelDensityJobs[id];
     }
 
     /**
      * @function ProcessingService.prototype.getSummaryMeshJobs
      * @description 获取点聚合分析的列表。
      * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
      * @param {DataFormat} [resultFormat=DataFormat.GEOJSON] - 返回结果类型。
      * @returns {Promise} Promise 对象。
      */
     getSummaryMeshJobs(callback, resultFormat) {
         var me = this,
             format = me._processFormat(resultFormat);
         var summaryMeshJobsService = new SummaryMeshJobsService(me.url, {
             proxy: me.options.proxy,
             withCredentials: me.options.withCredentials,
             crossOrigin: me.options.crossOrigin,
             headers: me.options.headers,
             format: format
         });
         return summaryMeshJobsService.getSummaryMeshJobs(callback);
     }
 
     /**
      * @function ProcessingService.prototype.getSummaryMeshJob
      * @description 获取某个点聚合分析。
      * @param {string} id - 空间分析的 ID。 
      * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
      * @param {DataFormat} [resultFormat=DataFormat.GEOJSON] - 返回结果类型。
      * @returns {Promise} Promise 对象。
      */
     getSummaryMeshJob(id, callback, resultFormat) {
         var me = this,
             format = me._processFormat(resultFormat);
         var summaryMeshJobsService = new SummaryMeshJobsService(me.url, {
             proxy: me.options.proxy,
             withCredentials: me.options.withCredentials,
             crossOrigin: me.options.crossOrigin,
             headers: me.options.headers,
             format: format
         });
         return summaryMeshJobsService.getSummaryMeshJob(id, callback);
     }
 
     /**
      * @function ProcessingService.prototype.addSummaryMeshJob
      * @description 点聚合分析。
      * @param {SummaryMeshJobParameter} params - 点聚合分析任务参数类。 
      * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
      * @param {number} [seconds=1000] - 获取创建成功结果的时间间隔。
      * @param {DataFormat} [resultFormat=DataFormat.GEOJSON] - 返回结果类型。
      * @returns {Promise} Promise 对象。
      */
     addSummaryMeshJob(params, callback, seconds, resultFormat) {
         var me = this,
             format = me._processFormat(resultFormat);
         var summaryMeshJobsService = new SummaryMeshJobsService(me.url, {
             proxy: me.options.proxy,
             withCredentials: me.options.withCredentials,
             crossOrigin: me.options.crossOrigin,
             headers: me.options.headers,
             format: format
         });
         return summaryMeshJobsService.addSummaryMeshJob(params, seconds, callback, function (job) {
          me.summaryMeshJobs[job.id] = job.state;
        });
     }
 
     /**
      * @function ProcessingService.prototype.getSummaryMeshJobState
      * @description 获取点聚合分析的状态。
      * @param {string} id - 点聚合分析的 ID。
      * @returns {Object} 点聚合分析的状态。
      */
     getSummaryMeshJobState(id) {
         return this.summaryMeshJobs[id];
     }
 
     /**
      * @function ProcessingService.prototype.getQueryJobs
      * @description 获取单对象查询分析的列表。
      * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
      * @param {DataFormat} [resultFormat=DataFormat.GEOJSON] - 返回结果类型。
      * @returns {Promise} Promise 对象。
      */
     getQueryJobs(callback, resultFormat) {
         var me = this,
             format = me._processFormat(resultFormat);
         var singleObjectQueryJobsService = new SingleObjectQueryJobsService(me.url, {
             proxy: me.options.proxy,
             withCredentials: me.options.withCredentials,
             crossOrigin: me.options.crossOrigin,
             headers: me.options.headers,
             format: format
         });
         return singleObjectQueryJobsService.getQueryJobs(callback);
     }
 
     /**
      * @function ProcessingService.prototype.getQueryJob
      * @description 获取某个单对象查询分析。
      * @param {string} id - 空间分析的 ID。 
      * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
      * @param {DataFormat} [resultFormat=DataFormat.GEOJSON] - 返回结果类型。
      * @returns {Promise} Promise 对象。
      */
     getQueryJob(id, callback, resultFormat) {
         var me = this,
             format = me._processFormat(resultFormat);
         var singleObjectQueryJobsService = new SingleObjectQueryJobsService(me.url, {
             proxy: me.options.proxy,
             withCredentials: me.options.withCredentials,
             crossOrigin: me.options.crossOrigin,
             headers: me.options.headers,
             format: format
         });
         return singleObjectQueryJobsService.getQueryJob(id, callback);
     }
 
     /**
      * @function ProcessingService.prototype.addQueryJob
      * @description 单对象查询分析。
      * @param {SingleObjectQueryJobsParameter} params - 单对象查询分析的请求参数。 
      * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
      * @param {number} [seconds=1000] - 获取创建成功结果的时间间隔。 
      * @param {DataFormat} [resultFormat=DataFormat.GEOJSON] - 返回结果类型。
      * @returns {Promise} Promise 对象。
      */
     addQueryJob(params, callback, seconds, resultFormat) {
         var me = this,
             format = me._processFormat(resultFormat);
         var singleObjectQueryJobsService = new SingleObjectQueryJobsService(me.url, {
             proxy: me.options.proxy,
             withCredentials: me.options.withCredentials,
             crossOrigin: me.options.crossOrigin,
             headers: me.options.headers,
             format: format
         });
         return singleObjectQueryJobsService.addQueryJob(params, seconds, callback, function (job) {
          me.queryJobs[job.id] = job.state;
        });
     }
 
     /**
      * @function ProcessingService.prototype.getQueryJobState
      * @description 获取单对象查询分析的状态。
      * @param {string} id - 单对象查询分析的 ID。
      * @returns {Object} 单对象查询分析的状态。
      */
     getQueryJobState(id) {
         return this.queryJobs[id];
     }
 
     /**
      * @function ProcessingService.prototype.getSummaryRegionJobs
      * @description 获取区域汇总分析的列表。
      * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
      * @param {DataFormat} [resultFormat=DataFormat.GEOJSON] - 返回结果类型。
      * @returns {Promise} Promise 对象。
      */
     getSummaryRegionJobs(callback, resultFormat) {
         var me = this,
             format = me._processFormat(resultFormat);
         var summaryRegionJobsService = new SummaryRegionJobsService(me.url, {
             proxy: me.options.proxy,
             withCredentials: me.options.withCredentials,
             crossOrigin: me.options.crossOrigin,
             headers: me.options.headers,
             format: format
         });
         return summaryRegionJobsService.getSummaryRegionJobs(callback);
     }
 
     /**
      * @function ProcessingService.prototype.getSummaryRegionJob
      * @description 获取某个区域汇总分析。
      * @param {string} id - 区域汇总分析的 ID。 
      * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
      * @param {DataFormat} [resultFormat=DataFormat.GEOJSON] - 返回结果类型。
      * @returns {Promise} Promise 对象。
      */
     getSummaryRegionJob(id, callback, resultFormat) {
         var me = this,
             format = me._processFormat(resultFormat);
         var summaryRegionJobsService = new SummaryRegionJobsService(me.url, {
             proxy: me.options.proxy,
             withCredentials: me.options.withCredentials,
             crossOrigin: me.options.crossOrigin,
             headers: me.options.headers,
             format: format
         });
         return summaryRegionJobsService.getSummaryRegionJob(id, callback);
     }
 
     /**
      * @function ProcessingService.prototype.addSummaryRegionJob
      * @description 区域汇总分析。
      * @param {SummaryRegionJobParameter} params - 区域汇总分析参数类。
      * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
      * @param {number} [seconds=1000] - 获取创建成功结果的时间间隔。
      * @param {DataFormat} [resultFormat=DataFormat.GEOJSON] - 返回结果类型。
      * @returns {Promise} Promise 对象。
      */
     addSummaryRegionJob(params, callback, seconds, resultFormat) {
         var me = this,
             format = me._processFormat(resultFormat);
         var summaryRegionJobsService = new SummaryRegionJobsService(me.url, {
             proxy: me.options.proxy,
             withCredentials: me.options.withCredentials,
             crossOrigin: me.options.crossOrigin,
             headers: me.options.headers,
             format: format
         });
         return summaryRegionJobsService.addSummaryRegionJob(params, seconds, callback, function (job) {
          me.summaryRegionJobs[job.id] = job.state;
      });
     }
 
     /**
      * @function ProcessingService.prototype.getSummaryRegionJobState
      * @description 获取区域汇总分析的状态。
      * @param {string} id - 生成区域汇总分析的 ID。
      * @returns {Object} 区域汇总分析的状态。
      */
     getSummaryRegionJobState(id) {
         return this.summaryRegionJobs[id];
     }
 
     /**
      * @function ProcessingService.prototype.getVectorClipJobs
      * @description 获取矢量裁剪分析的列表。
      * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
      * @param {DataFormat}  [resultFormat=DataFormat.GEOJSON] - 返回结果类型。
      * @returns {Promise} Promise 对象。
      */
     getVectorClipJobs(callback, resultFormat) {
         var me = this,
             format = me._processFormat(resultFormat);
         var vectorClipJobsService = new VectorClipJobsService(me.url, {
             proxy: me.options.proxy,
             withCredentials: me.options.withCredentials,
             crossOrigin: me.options.crossOrigin,
             headers: me.options.headers,
             format: format
         });
         return vectorClipJobsService.getVectorClipJobs(callback);
     }
 
     /**
      * @function ProcessingService.prototype.getVectorClipJob
      * @description 获取某个矢量裁剪分析。
      * @param {string} id - 空间分析的 ID。 
      * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
      * @param {DataFormat}  [resultFormat=DataFormat.GEOJSON] - 返回结果类型。
      * @returns {Promise} Promise 对象。
      */
     getVectorClipJob(id, callback, resultFormat) {
         var me = this,
             format = me._processFormat(resultFormat);
         var vectorClipJobsService = new VectorClipJobsService(me.url, {
             proxy: me.options.proxy,
             withCredentials: me.options.withCredentials,
             crossOrigin: me.options.crossOrigin,
             headers: me.options.headers,
             format: format
         });
         return vectorClipJobsService.getVectorClipJob(id, callback);
     }
 
     /**
      * @function ProcessingService.prototype.addVectorClipJob
      * @description 矢量裁剪分析。
      * @param {VectorClipJobsParameter} params - 矢量裁剪分析请求参数类。 
      * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
      * @param {number} [seconds=1000] - 获取创建成功结果的时间间隔。 
      * @param {DataFormat}  [resultFormat=DataFormat.GEOJSON] - 返回结果类型。
      * @returns {Promise} Promise 对象。
      */
     addVectorClipJob(params, callback, seconds, resultFormat) {
         var me = this,
             format = me._processFormat(resultFormat);
         var vectorClipJobsService = new VectorClipJobsService(me.url, {
             proxy: me.options.proxy,
             withCredentials: me.options.withCredentials,
             crossOrigin: me.options.crossOrigin,
             headers: me.options.headers,
             format: format
         });
         return vectorClipJobsService.addVectorClipJob(params, seconds, callback, function (job) {
          me.vectorClipJobs[job.id] = job.state;
        });
     }
 
     /**
      * @function ProcessingService.prototype.getVectorClipJobState
      * @description 获取矢量裁剪分析的状态。
      * @param {number} id - 矢量裁剪分析的ID。
      * @returns {Object} 矢量裁剪分析的状态。
      */
     getVectorClipJobState(id) {
         return this.vectorClipJobs[id];
     }
 
     /**
      * @function ProcessingService.prototype.getOverlayGeoJobs
      * @description 获取叠加分析的列表。
      * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
      * @param {DataFormat}  [resultFormat=DataFormat.GEOJSON] - 返回结果类型。
      * @returns {Promise} Promise 对象。
      */
     getOverlayGeoJobs(callback, resultFormat) {
         var me = this,
             format = me._processFormat(resultFormat);
         var overlayGeoJobsService = new OverlayGeoJobsService(me.url, {
             proxy: me.options.proxy,
             withCredentials: me.options.withCredentials,
             crossOrigin: me.options.crossOrigin,
             headers: me.options.headers,
             format: format
         });
         return overlayGeoJobsService.getOverlayGeoJobs(callback);
     }
 
     /**
      * @function ProcessingService.prototype.getOverlayGeoJob
      * @description 获取某个叠加分析。
      * @param {string} id - 空间分析的 ID。
      * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
      * @param {DataFormat}  [resultFormat=DataFormat.GEOJSON] - 返回结果类型。
      * @returns {Promise} Promise 对象。
      */
     getOverlayGeoJob(id, callback, resultFormat) {
         var me = this,
             format = me._processFormat(resultFormat);
         var overlayGeoJobsService = new OverlayGeoJobsService(me.url, {
             proxy: me.options.proxy,
             withCredentials: me.options.withCredentials,
             crossOrigin: me.options.crossOrigin,
             headers: me.options.headers,
             format: format
         });
         return overlayGeoJobsService.getOverlayGeoJob(id, callback);
     }
 
     /**
      * @function ProcessingService.prototype.addOverlayGeoJob
      * @description 叠加分析。
      * @param {OverlayGeoJobParameter} params - 叠加分析请求参数类。 
      * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
      * @param {number} [seconds=1000] - 获取创建成功结果的时间间隔。 
      * @param {DataFormat}  [resultFormat=DataFormat.GEOJSON] - 返回结果类型。
      * @returns {Promise} Promise 对象。
      */
     addOverlayGeoJob(params, callback, seconds, resultFormat) {
         var me = this,
             format = me._processFormat(resultFormat);
         var overlayGeoJobsService = new OverlayGeoJobsService(me.url, {
             proxy: me.options.proxy,
             withCredentials: me.options.withCredentials,
             crossOrigin: me.options.crossOrigin,
             headers: me.options.headers,
             format: format
         });
         return overlayGeoJobsService.addOverlayGeoJob(params, seconds, callback, function (job) {
          me.overlayGeoJobs[job.id] = job.state;
        });
     }
 
     /**
      * @function ProcessingService.prototype.getoverlayGeoJobState
      * @description 获取叠加分析的状态。
      * @param {string} id - 叠加分析的 ID。
      * @returns {Object} 叠加分析的状态。
      */
     getoverlayGeoJobState(id) {
         return this.overlayGeoJobs[id];
     }
 
     /**
      * @function ProcessingService.prototype.getBuffersJobs
      * @description 获取缓冲区分析的列表。
      * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
      * @param {DataFormat}  [resultFormat=DataFormat.GEOJSON] - 返回结果类型。
      * @returns {Promise} Promise 对象。
      */
     getBuffersJobs(callback, resultFormat) {
         var me = this,
             format = me._processFormat(resultFormat);
         var buffersAnalystJobsService = new BuffersAnalystJobsService(me.url, {
             proxy: me.options.proxy,
             withCredentials: me.options.withCredentials,
             crossOrigin: me.options.crossOrigin,
             headers: me.options.headers,
             format: format
         });
         return buffersAnalystJobsService.getBuffersJobs(callback);
     }
 
     /**
      * @function ProcessingService.prototype.getBuffersJob
      * @description 获取某个缓冲区分析。
      * @param {string} id - 空间分析的 ID。 
      * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
      * @param {DataFormat}  [resultFormat=DataFormat.GEOJSON] - 返回结果类型。
      * @returns {Promise} Promise 对象。
      */
     getBuffersJob(id, callback, resultFormat) {
         var me = this,
             format = me._processFormat(resultFormat);
         var buffersAnalystJobsService = new BuffersAnalystJobsService(me.url, {
             proxy: me.options.proxy,
             withCredentials: me.options.withCredentials,
             crossOrigin: me.options.crossOrigin,
             headers: me.options.headers,
             format: format
         });
         return buffersAnalystJobsService.getBuffersJob(id, callback);
     }
 
     /**
      * @function ProcessingService.prototype.addBuffersJob
      * @description 缓冲区分析。
      * @param {BuffersAnalystJobsParameter} params - 缓冲区分析请求参数类。 
      * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
      * @param {number} seconds - 获取创建成功结果的时间间隔。 
      * @param {DataFormat}  [resultFormat=DataFormat.GEOJSON] - 返回结果类型。
      * @returns {Promise} Promise 对象。
      */
     addBuffersJob(params, callback, seconds, resultFormat) {
         var me = this,
             format = me._processFormat(resultFormat);
         var buffersAnalystJobsService = new BuffersAnalystJobsService(me.url, {
             proxy: me.options.proxy,
             withCredentials: me.options.withCredentials,
             crossOrigin: me.options.crossOrigin,
             headers: me.options.headers,
             format: format
         });
         return buffersAnalystJobsService.addBuffersJob(params, seconds, callback, function (job) {
          me.buffersJobs[job.id] = job.state;
      });
     }
 
     /**
      * @function ProcessingService.prototype.getBuffersJobState
      * @description 获取缓冲区分析的状态。
      * @param {string} id - 缓冲区分析的 ID。
      * @returns {Object} 缓冲区分析的状态。
      */
     getBuffersJobState(id) {
         return this.buffersJobs[id];
     }
 
     /**
      * @function ProcessingService.prototype.getTopologyValidatorJobs
      * @description 获取拓扑检查分析的列表。
      * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
      * @param {DataFormat}  [resultFormat=DataFormat.GEOJSON] - 返回结果类型。
      * @returns {Promise} Promise 对象。
      */
     getTopologyValidatorJobs(callback, resultFormat) {
         var me = this,
             format = me._processFormat(resultFormat);
         var topologyValidatorJobsService = new TopologyValidatorJobsService(me.url, {
             proxy: me.options.proxy,
             withCredentials: me.options.withCredentials,
             crossOrigin: me.options.crossOrigin,
             headers: me.options.headers,
             format: format
         });
         return topologyValidatorJobsService.getTopologyValidatorJobs(callback);
     }
 
     /**
      * @function ProcessingService.prototype.getTopologyValidatorJob
      * @description 获取某个拓扑检查分析。
      * @param {string} id - 空间分析的 ID。 
      * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
      * @param {DataFormat}  [resultFormat=DataFormat.GEOJSON] - 返回结果类型。
      * @returns {Promise} Promise 对象。
      */
     getTopologyValidatorJob(id, callback, resultFormat) {
         var me = this,
             format = me._processFormat(resultFormat);
         var topologyValidatorJobsService = new TopologyValidatorJobsService(me.url, {
             proxy: me.options.proxy,
             withCredentials: me.options.withCredentials,
             crossOrigin: me.options.crossOrigin,
             headers: me.options.headers,
             format: format
         });
         return topologyValidatorJobsService.getTopologyValidatorJob(id, callback);
     }
 
     /**
      * @function ProcessingService.prototype.addTopologyValidatorJob
      * @description 拓扑检查分析。
      * @param {TopologyValidatorJobsParameter} params - 拓扑检查分析请求参数类。 
      * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
      * @param {number} [seconds=1000] - 获取创建成功结果的时间间隔。 
      * @param {DataFormat}  [resultFormat=DataFormat.GEOJSON] - 返回结果类型。
      * @returns {Promise} Promise 对象。
      */
     addTopologyValidatorJob(params, callback, seconds, resultFormat) {
         var me = this,
             format = me._processFormat(resultFormat);
         var topologyValidatorJobsService = new TopologyValidatorJobsService(me.url, {
             proxy: me.options.proxy,
             withCredentials: me.options.withCredentials,
             crossOrigin: me.options.crossOrigin,
             headers: me.options.headers,
             format: format
         });
         return topologyValidatorJobsService.addTopologyValidatorJob(params, seconds, callback, function (job) {
          me.topologyValidatorJobs[job.id] = job.state;
      });
     }
 
     /**
      * @function ProcessingService.prototype.getTopologyValidatorJobState
      * @description 获取拓扑检查分析的状态。
      * @param {string} id - 拓扑检查分析的 ID。
      * @returns {Object} 拓扑检查分析的状态。
      */
     getTopologyValidatorJobState(id) {
         return this.topologyValidatorJobs[id];
     }
 
     /**
      * @function ProcessingService.prototype.getSummaryAttributesJobs
      * @description 获取属性汇总分析的列表。
      * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
      * @param {DataFormat}  [resultFormat=DataFormat.GEOJSON] - 返回结果类型。
      * @returns {Promise} Promise 对象。
      */
     getSummaryAttributesJobs(callback, resultFormat) {
         var me = this,
             format = me._processFormat(resultFormat);
         var summaryAttributesJobsService = new SummaryAttributesJobsService(me.url, {
             proxy: me.options.proxy,
             withCredentials: me.options.withCredentials,
             crossOrigin: me.options.crossOrigin,
             headers: me.options.headers,
             format: format
         });
         return summaryAttributesJobsService.getSummaryAttributesJobs(callback);
     }
 
     /**
      * @function ProcessingService.prototype.getSummaryAttributesJob
      * @description 获取某个属性汇总分析。
      * @param {string} id - 空间分析的 ID。
      * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
      * @param {DataFormat}  [resultFormat=DataFormat.GEOJSON] - 返回结果类型。
      * @returns {Promise} Promise 对象。
      */
     getSummaryAttributesJob(id, callback, resultFormat) {
         var me = this,
             format = me._processFormat(resultFormat);
         var summaryAttributesJobsService = new SummaryAttributesJobsService(me.url, {
             proxy: me.options.proxy,
             withCredentials: me.options.withCredentials,
             crossOrigin: me.options.crossOrigin,
             headers: me.options.headers,
             format: format
         });
         return summaryAttributesJobsService.getSummaryAttributesJob(id, callback);
     }
 
     /**
      * @function ProcessingService.prototype.addSummaryAttributesJob
      * @description 属性汇总分析。
      * @param {SummaryAttributesJobsParameter} params - 属性汇总分析参数类。 
      * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
      * @param {number} [seconds=1000] - 获取创建成功结果的时间间隔。
      * @param {DataFormat}  [resultFormat=DataFormat.GEOJSON] - 返回结果类型。
      * @returns {Promise} Promise 对象。
      */
     addSummaryAttributesJob(params, callback, seconds, resultFormat) {
         var me = this,
             format = me._processFormat(resultFormat);
         var summaryAttributesJobsService = new SummaryAttributesJobsService(me.url, {
             proxy: me.options.proxy,
             withCredentials: me.options.withCredentials,
             crossOrigin: me.options.crossOrigin,
             headers: me.options.headers,
             format: format
         });
         return summaryAttributesJobsService.addSummaryAttributesJob(params, seconds, callback, function (job) {
          me.summaryAttributesJobs[job.id] = job.state;
      });
     }
 
     /**
      * @function ProcessingService.prototype.getSummaryAttributesJobState
      * @description 获取属性汇总分析的状态。
      * @param {string} id - 属性汇总分析的 ID。 
      * @returns {Object} 属性汇总分析的状态
      */
     getSummaryAttributesJobState(id) {
         return this.summaryAttributesJobs[id];
     }
 
     _processFormat(resultFormat) {
         return (resultFormat) ? resultFormat : DataFormat.GEOJSON;
     }
 }
 
;// CONCATENATED MODULE: ./src/mapboxgl/services/ProcessingService.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/





/**
 * @class ProcessingService
 * @category  iServer ProcessingService
 * @classdesc 分布式分析相关服务类。
 * @modulecategory Services
 * @extends {ServiceBase}
 * @example
 * new ProcessingService(url,options)
 *  .getKernelDensityJobs(function(result){
 *     //doSomething
 * })
 * @param {string} url - 服务地址。
 * @param {Object} options - 参数。
 * @param {string} [options.proxy] - 服务代理地址。
 * @param {boolean} [options.withCredentials=false] - 请求是否携带cookie。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @usage
 */
class ProcessingService extends ServiceBase {

    constructor(url, options) {
        super(url, options);
        this._processingService = new ProcessingService_ProcessingService(url, options);
    }

    /**
     * @function ProcessingService.prototype.getKernelDensityJobs
     * @description 获取密度分析的列表。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @param {DataFormat} [resultFormat=DataFormat.GEOJSON] - 返回结果类型。
     * @returns {Promise} Promise 对象。
     */
    getKernelDensityJobs(callback, resultFormat) {
      return this._processingService.getKernelDensityJobs(callback, resultFormat);
    }

    /**
     * @function ProcessingService.prototype.getKernelDensityJob
     * @description 获取某个密度分析。
     * @param {string} id - 空间分析的ID。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @param {DataFormat} [resultFormat=DataFormat.GEOJSON] - 返回结果类型。
     * @returns {Promise} Promise 对象。
     */
    getKernelDensityJob(id, callback, resultFormat) {
      return this._processingService.getKernelDensityJob(id, callback, resultFormat);
    }

    /**
     * @function ProcessingService.prototype.addKernelDensityJob
     * @description 密度分析。
     * @param {KernelDensityJobParameter} params -密度分析参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @param {number} [seconds=1000] - 获取创建成功结果的时间间隔。
     * @param {DataFormat} [resultFormat=DataFormat.GEOJSON] - 返回结果类型。
     * @returns {Promise} Promise 对象。
     */
    addKernelDensityJob(params, callback, seconds, resultFormat) {
      params = this._processParams(params);
      return this._processingService.addKernelDensityJob(params, callback, seconds, resultFormat);
    }

    /**
     * @function ProcessingService.prototype.getKernelDensityJobState
     * @description 获取密度分析的状态。
     * @param {string} id - 密度分析的id。
     * @returns {Object} 密度分析的状态。
     */
    getKernelDensityJobState(id) {
        return this._processingService.getKernelDensityJobState(id);
    }

    /**
     * @function ProcessingService.prototype.getSummaryMeshJobs
     * @description 获取点聚合分析的列表。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @param {DataFormat} [resultFormat=DataFormat.GEOJSON] - 返回结果类型。
     * @returns {Promise} Promise 对象。
     */
    getSummaryMeshJobs(callback, resultFormat) {
      return this._processingService.getSummaryMeshJobs(callback, resultFormat);
    }

    /**
     * @function ProcessingService.prototype.getSummaryMeshJob
     * @description 获取某个点聚合分析。
     * @param {string} id - 空间分析的 ID。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @param {DataFormat} [resultFormat=DataFormat.GEOJSON] - 返回结果类型。
     * @returns {Promise} Promise 对象。
     */
    getSummaryMeshJob(id, callback, resultFormat) {
      return this._processingService.getSummaryMeshJob(id, callback, resultFormat);
    }

    /**
     * @function ProcessingService.prototype.addSummaryMeshJob
     * @description 点聚合分析。
     * @param {SummaryMeshJobParameter} params - 点聚合分析任务参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @param {number} [seconds=1000] - 获取创建成功结果的时间间隔。
     * @param {DataFormat} [resultFormat=DataFormat.GEOJSON] - 返回结果类型。
     * @returns {Promise} Promise 对象。
     */
    addSummaryMeshJob(params, callback, seconds, resultFormat) {
      params = this._processParams(params);
      return this._processingService.addSummaryMeshJob(params, callback, seconds, resultFormat);
    }

    /**
     * @function ProcessingService.prototype.getSummaryMeshJobState
     * @description 获取点聚合分析的状态。
     * @param {string} id - 点聚合分析的 ID。
     * @returns {Object} 点聚合分析的状态。
     */
    getSummaryMeshJobState(id) {
      return this._processingService.getSummaryMeshJobState(id);
    }

    /**
     * @function ProcessingService.prototype.getQueryJobs
     * @description 获取单对象查询分析的列表。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @param {DataFormat} [resultFormat=DataFormat.GEOJSON] - 返回结果类型。
     * @returns {Promise} Promise 对象。
     */
    getQueryJobs(callback, resultFormat) {
      return this._processingService.getQueryJobs(callback, resultFormat);
    }

    /**
     * @function ProcessingService.prototype.getQueryJob
     * @description 获取某个单对象查询分析。
     * @param {string} id - 空间分析的 ID。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @param {DataFormat} [resultFormat=DataFormat.GEOJSON] - 返回结果类型。
     * @returns {Promise} Promise 对象。
     */
    getQueryJob(id, callback, resultFormat) {
      return this._processingService.getQueryJob(id, callback, resultFormat);
    }

    /**
     * @function ProcessingService.prototype.addQueryJob
     * @description 单对象查询分析。
     * @param {SingleObjectQueryJobsParameter} params - 单对象查询分析的请求参数。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @param {number} [seconds=1000] - 获取创建成功结果的时间间隔。
     * @param {DataFormat} [resultFormat=DataFormat.GEOJSON] - 返回结果类型。
     * @returns {Promise} Promise 对象。
     */
    addQueryJob(params, callback, seconds, resultFormat) {
      params = this._processParams(params);
      return this._processingService.addQueryJob(params, callback, seconds, resultFormat);
    }

    /**
     * @function ProcessingService.prototype.getQueryJobState
     * @description 获取单对象查询分析的状态。
     * @param {string} id - 单对象查询分析的 ID。
     * @returns {Object} 单对象查询分析的状态。
     */
    getQueryJobState(id) {
      return this._processingService.getQueryJobState(id);
    }

    /**
     * @function ProcessingService.prototype.getSummaryRegionJobs
     * @description 获取区域汇总分析的列表。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @param {DataFormat} [resultFormat=DataFormat.GEOJSON] - 返回结果类型。
     * @returns {Promise} Promise 对象。
     */
    getSummaryRegionJobs(callback, resultFormat) {
      return this._processingService.getSummaryRegionJobs(callback, resultFormat);
    }

    /**
     * @function ProcessingService.prototype.getSummaryRegionJob
     * @description 获取某个区域汇总分析。
     * @param {string} id - 区域汇总分析的 ID。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @param {DataFormat} [resultFormat=DataFormat.GEOJSON] - 返回结果类型。
     * @returns {Promise} Promise 对象。
     */
    getSummaryRegionJob(id, callback, resultFormat) {
      return this._processingService.getSummaryRegionJob(id, callback, resultFormat);
    }

    /**
     * @function ProcessingService.prototype.addSummaryRegionJob
     * @description 区域汇总分析。
     * @param {SummaryRegionJobParameter} params - 区域汇总分析参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @param {number} [seconds=1000] - 获取创建成功结果的时间间隔。
     * @param {DataFormat} [resultFormat=DataFormat.GEOJSON] - 返回结果类型。
     * @returns {Promise} Promise 对象。
     */
    addSummaryRegionJob(params, callback, seconds, resultFormat) {
      params = this._processParams(params);
      return this._processingService.addSummaryRegionJob(params, callback, seconds, resultFormat);
    }

    /**
     * @function ProcessingService.prototype.getSummaryRegionJobState
     * @description 获取区域汇总分析的状态。
     * @param {string} id - 生成区域汇总分析的 ID。
     * @returns {Object} 区域汇总分析的状态。
     */
    getSummaryRegionJobState(id) {
      return this._processingService.getSummaryRegionJobState(id);
    }

    /**
     * @function ProcessingService.prototype.getVectorClipJobs
     * @description 获取矢量裁剪分析的列表。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @param {DataFormat}  [resultFormat=DataFormat.GEOJSON] - 返回结果类型。
     * @returns {Promise} Promise 对象。
     */
    getVectorClipJobs(callback, resultFormat) {
      return this._processingService.getVectorClipJobs(callback, resultFormat);
    }

    /**
     * @function ProcessingService.prototype.getVectorClipJob
     * @description 获取某个矢量裁剪分析。
     * @param {string} id - 空间分析的 ID。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @param {DataFormat}  [resultFormat=DataFormat.GEOJSON] - 返回结果类型。
     * @returns {Promise} Promise 对象。
     */
    getVectorClipJob(id, callback, resultFormat) {
      return this._processingService.getVectorClipJob(id, callback, resultFormat);
    }

    /**
     * @function ProcessingService.prototype.addVectorClipJob
     * @description 矢量裁剪分析。
     * @param {VectorClipJobsParameter} params - 矢量裁剪分析请求参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @param {number} [seconds=1000] - 获取创建成功结果的时间间隔。
     * @param {DataFormat}  [resultFormat=DataFormat.GEOJSON] - 返回结果类型。
     * @returns {Promise} Promise 对象。
     */
    addVectorClipJob(params, callback, seconds, resultFormat) {
      params = this._processParams(params);
      return this._processingService.addVectorClipJob(params, callback, seconds, resultFormat);
    }

    /**
     * @function ProcessingService.prototype.getVectorClipJobState
     * @description 获取矢量裁剪分析的状态。
     * @param {number} id - 矢量裁剪分析的ID。
     * @returns {Object} 矢量裁剪分析的状态。
     */
    getVectorClipJobState(id) {
      return this._processingService.getVectorClipJobState(id);
    }

    /**
     * @function ProcessingService.prototype.getOverlayGeoJobs
     * @description 获取叠加分析的列表。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @param {DataFormat}  [resultFormat=DataFormat.GEOJSON] - 返回结果类型。
     * @returns {Promise} Promise 对象。
     */
    getOverlayGeoJobs(callback, resultFormat) {
      return this._processingService.getOverlayGeoJobs(callback, resultFormat);
    }

    /**
     * @function ProcessingService.prototype.getOverlayGeoJob
     * @description 获取某个叠加分析。
     * @param {string} id - 空间分析的 ID。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @param {DataFormat}  [resultFormat=DataFormat.GEOJSON] - 返回结果类型。
     * @returns {Promise} Promise 对象。
     */
    getOverlayGeoJob(id, callback, resultFormat) {
      return this._processingService.getOverlayGeoJob(id, callback, resultFormat);
    }

    /**
     * @function ProcessingService.prototype.addOverlayGeoJob
     * @description 叠加分析。
     * @param {OverlayGeoJobParameter} params - 叠加分析请求参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @param {number} [seconds=1000] - 获取创建成功结果的时间间隔。
     * @param {DataFormat}  [resultFormat=DataFormat.GEOJSON] - 返回结果类型。
     * @returns {Promise} Promise 对象。
     */
    addOverlayGeoJob(params, callback, seconds, resultFormat) {
      params = this._processParams(params);
      return this._processingService.addOverlayGeoJob(params, callback, seconds, resultFormat);
    }

    /**
     * @function ProcessingService.prototype.getoverlayGeoJobState
     * @description 获取叠加分析的状态。
     * @param {string} id - 叠加分析的 ID。
     * @returns {Object} 叠加分析的状态。
     */
    getoverlayGeoJobState(id) {
      return this._processingService.getoverlayGeoJobState(id);
    }

    /**
     * @function ProcessingService.prototype.getBuffersJobs
     * @description 获取缓冲区分析的列表。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @param {DataFormat}  [resultFormat=DataFormat.GEOJSON] - 返回结果类型。
     * @returns {Promise} Promise 对象。
     */
    getBuffersJobs(callback, resultFormat) {
      return this._processingService.getBuffersJobs(callback, resultFormat);
    }

    /**
     * @function ProcessingService.prototype.getBuffersJob
     * @description 获取某个缓冲区分析。
     * @param {string} id - 空间分析的 ID。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @param {DataFormat}  [resultFormat=DataFormat.GEOJSON] - 返回结果类型。
     * @returns {Promise} Promise 对象。
     */
    getBuffersJob(id, callback, resultFormat) {
      return this._processingService.getBuffersJob(id, callback, resultFormat);
    }

    /**
     * @function ProcessingService.prototype.addBuffersJob
     * @description 缓冲区分析。
     * @param {BuffersAnalystJobsParameter} params - 缓冲区分析请求参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @param {number} seconds - 获取创建成功结果的时间间隔。
     * @param {DataFormat}  [resultFormat=DataFormat.GEOJSON] - 返回结果类型。
     * @returns {Promise} Promise 对象。
     */
    addBuffersJob(params, callback, seconds, resultFormat) {
        params = this._processParams(params);
        return this._processingService.addBuffersJob(params, callback, seconds, resultFormat);
    }

    /**
     * @function ProcessingService.prototype.getBuffersJobState
     * @description 获取缓冲区分析的状态。
     * @param {string} id - 缓冲区分析的 ID。
     * @returns {Object} 缓冲区分析的状态。
     */
    getBuffersJobState(id) {
      return this._processingService.getBuffersJobState(id);
    }

    /**
     * @function ProcessingService.prototype.getTopologyValidatorJobs
     * @description 获取拓扑检查分析的列表。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @param {DataFormat}  [resultFormat=DataFormat.GEOJSON] - 返回结果类型。
     * @returns {Promise} Promise 对象。
     */
    getTopologyValidatorJobs(callback, resultFormat) {
      return this._processingService.getTopologyValidatorJobs(callback, resultFormat);
    }

    /**
     * @function ProcessingService.prototype.getTopologyValidatorJob
     * @description 获取某个拓扑检查分析。
     * @param {string} id - 空间分析的 ID。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @param {DataFormat}  [resultFormat=DataFormat.GEOJSON] - 返回结果类型。
     * @returns {Promise} Promise 对象。
     */
    getTopologyValidatorJob(id, callback, resultFormat) {
      return this._processingService.getTopologyValidatorJob(id, callback, resultFormat);
    }

    /**
     * @function ProcessingService.prototype.addTopologyValidatorJob
     * @description 拓扑检查分析。
     * @param {TopologyValidatorJobsParameter} params - 拓扑检查分析请求参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @param {number} [seconds=1000] - 获取创建成功结果的时间间隔。
     * @param {DataFormat}  [resultFormat=DataFormat.GEOJSON] - 返回结果类型。
     * @returns {Promise} Promise 对象。
     */
    addTopologyValidatorJob(params, callback, seconds, resultFormat) {
      params = this._processParams(params);
      return this._processingService.addTopologyValidatorJob(params, callback, seconds, resultFormat);
    }

    /**
     * @function ProcessingService.prototype.getTopologyValidatorJobState
     * @description 获取拓扑检查分析的状态。
     * @param {string} id - 拓扑检查分析的 ID。
     * @returns {Object} 拓扑检查分析的状态。
     */
    getTopologyValidatorJobState(id) {
      return this._processingService.getTopologyValidatorJobState(id);
    }

    /**
     * @function ProcessingService.prototype.getSummaryAttributesJobs
     * @description 获取属性汇总分析的列表。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @param {DataFormat}  [resultFormat=DataFormat.GEOJSON] - 返回结果类型。
     * @returns {Promise} Promise 对象。
     */
    getSummaryAttributesJobs(callback, resultFormat) {
      return this._processingService.getSummaryAttributesJobs(callback, resultFormat);
    }

    /**
     * @function ProcessingService.prototype.getSummaryAttributesJob
     * @description 获取某个属性汇总分析。
     * @param {string} id - 空间分析的 ID。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @param {DataFormat}  [resultFormat=DataFormat.GEOJSON] - 返回结果类型。
     * @returns {Promise} Promise 对象。
     */
    getSummaryAttributesJob(id, callback, resultFormat) {
      return this._processingService.getSummaryAttributesJob(id, callback, resultFormat);
    }

    /**
     * @function ProcessingService.prototype.addSummaryAttributesJob
     * @description 属性汇总分析。
     * @param {SummaryAttributesJobsParameter} params - 属性汇总分析参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @param {number} [seconds=1000] - 获取创建成功结果的时间间隔。
     * @param {DataFormat}  [resultFormat=DataFormat.GEOJSON] - 返回结果类型。
     * @returns {Promise} Promise 对象。
     */
    addSummaryAttributesJob(params, callback, seconds, resultFormat) {
        params = this._processParams(params);
        return this._processingService.addSummaryAttributesJob(params, callback, seconds, resultFormat);
    }

    /**
     * @function ProcessingService.prototype.getSummaryAttributesJobState
     * @description 获取属性汇总分析的状态。
     * @param {string} id - 属性汇总分析的 ID。
     * @returns {Object} 属性汇总分析的状态
     */
    getSummaryAttributesJobState(id) {
      return this._processingService.getSummaryAttributesJobState(id);
    }

    _processFormat(resultFormat) {
        return (resultFormat) ? resultFormat : DataFormat.GEOJSON;
    }

    _processParams(params) {
        if (!params) {
            return {};
        }
        if (params.bounds) {
            params.bounds = core_Util_Util.toSuperMapBounds(params.bounds);
        }
        //这里只允许传端的bounds
        if (params.query) {
            params.query = core_Util_Util.toSuperMapBounds(params.query);
        }
        if (params.geometryQuery) {
            params.geometryQuery = core_Util_Util.toProcessingParam(params.geometryQuery);
        }
        if (params.geometryClip) {
            params.geometryClip = core_Util_Util.toProcessingParam(params.geometryClip);
        }
        return params;
    }
}

;// CONCATENATED MODULE: ./src/common/iServer/QueryServiceBase.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/






/**
 * @class QueryService
 * @deprecatedclass SuperMap.QueryService
 * @category  iServer Map QueryResults
 * @classdesc 查询服务基类。
 * @extends {CommonServiceBase}
 * @param {string} url - 服务地址。请求地图查询服务的 URL 应为：http://{服务器地址}:{服务端口号}/iserver/services/{地图服务名}/rest/maps/{地图名}；
 * @param {Object} options - 参数。
 * @param {DataFormat} [options.format=DataFormat.GEOJSON] - 查询结果返回格式，目前支持 iServerJSON、GeoJSON、FGB 三种格式。参数格式为 "ISERVER"，"GEOJSON"，"FGB"。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @example
 * var myService = new QueryService(url);
 * @usage
 */
class QueryServiceBase extends CommonServiceBase {
    constructor(url, options) {
        super(url, options);

        /**
         * @member {boolean} QueryService.prototype.returnContent
         * @description 是否立即返回新创建资源的表述还是返回新资源的URI。
         */
        this.returnContent = false;

        /**
         * @member {string} QueryService.prototype.format
         * @description 查询结果返回格式，目前支持iServerJSON、GeoJSON、FGB三种格式。参数格式为"ISERVER","GEOJSON","FGB"。
         */
        this.format = DataFormat.GEOJSON;

        this.returnFeatureWithFieldCaption = false;

        if (options) {
            Util_Util.extend(this, options);
        }

        this.CLASS_NAME = "SuperMap.QueryService";
        if (!this.url) {
            return;
        }
        if (options && options.format) {
            this.format = options.format.toUpperCase();
        }
        this.url = Util_Util.urlPathAppend(this.url,'queryResults');
    }

    /**
     * @function QueryServiceBase.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        super.destroy();
        var me = this;
        me.returnContent = null;
        me.format = null;
    }

    /**
     * @function QueryServiceBase.prototype.processAsync
     * @description 负责将客户端的查询参数传递到服务端。
     * @param {QueryParameters} params - 查询参数。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    processAsync(params, callback) {
        if (!(params instanceof QueryParameters)) {
            return;
        }
        var me = this,
            returnCustomResult = null,
            jsonParameters = null;
        me.returnContent = params.returnContent;

        jsonParameters = me.getJsonParameters(params);
       
        if (!me.returnContent) {
            //仅供三维使用 获取高亮图片的bounds
            returnCustomResult = params.returnCustomResult;
            if (returnCustomResult) {
                me.url = Util_Util.urlAppend(me.url, 'returnCustomResult=' + returnCustomResult);
            }
        }
        me.returnFeatureWithFieldCaption = params.returnFeatureWithFieldCaption;
        return me.request({
          method: "POST",
          data: jsonParameters,
          scope: me,
          success: callback,
          failure: callback
        });
    }

    /**
     * @function QueryServiceBase.prototype.transformResult
     * @description 状态完成时转换结果。
     * @param {Object} result - 服务器返回的结果对象。
     * @param {Object} options - 请求参数。
     * @return {Object} 转换结果。
     */
    transformResult(result, options) {
        var me = this;
        result = Util_Util.transformResult(result);
        var geoJSONFormat = new GeoJSON();
        if (result && result.recordsets) {
            for (var i = 0, recordsets = result.recordsets, len = recordsets.length; i < len; i++) {
                if (recordsets[i].features) {
                    if (me.returnFeatureWithFieldCaption === true) {
                        recordsets[i].features.map((feature) => {
                            feature.fieldNames = recordsets[i].fieldCaptions;
                            return feature;
                        })
                    }
                    if (me.format === DataFormat.GEOJSON) {
                        recordsets[i].features = geoJSONFormat.toGeoJSON(recordsets[i].features);
                    }
                }
            }
        }

        return { result, options };
    }

    dataFormat() {
      return [DataFormat.GEOJSON, DataFormat.ISERVER, DataFormat.FGB];
    }

    /**
     * @function QueryServiceBase.prototype.getQueryParameters
     * @description 将 JSON 对象表示的查询参数转化为 QueryParameters 对象。
     * @param {Object} params - JSON 字符串表示的查询参数。
     * @returns {QueryParameters} 返回转化后的 QueryParameters 对象。
     */
    getQueryParameters(params) {
        return new QueryParameters({
            customParams: params.customParams,
            expectCount: params.expectCount,
            networkType: params.networkType,
            queryOption: params.queryOption,
            queryParams: params.queryParams,
            startRecord: params.startRecord,
            prjCoordSys: params.prjCoordSys,
            holdTime: params.holdTime
        });
    }

}

;// CONCATENATED MODULE: ./src/common/iServer/QueryByBoundsParameters.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/



/**
 * @class QueryByBoundsParameters
 * @deprecatedclass SuperMap.QueryByBoundsParameters
 * @category  iServer Map QueryResults
 * @classdesc Bounds 查询参数类。该类用于设置 Bounds 查询的相关参数。
 * @extends {QueryParameters}
 * @param {Object} options - 参数。
 * @param {(SuperMap.Bounds|L.Bounds|L.LatLngBounds|ol.extent|mapboxgl.LngLatBounds|GeoJSONObject)} options.bounds - 指定的查询范围。
 * @param {Array.<FilterParameter>} options.queryParams - 查询过滤条件参数数组。
 * @param {string} [options.customParams] - 自定义参数，供扩展使用。
 * @param {Object} [options.prjCoordSys] -自定义参数，供 SuperMap Online 提供的动态投影查询扩展使用。如 {"epsgCode":3857}。
 * @param {number} [options.expectCount=100000] - 期望返回结果记录个数。
 * @param {GeometryType} [options.networkType=GeometryType.LINE] - 网络数据集对应的查询类型。
 * @param {QueryOption} [options.queryOption=QueryOption.ATTRIBUTEANDGEOMETRY] - 查询结果类型枚举类。
 * @param {number} [options.startRecord=0] - 查询起始记录号。
 * @param {number} [options.holdTime=10] - 资源在服务端保存的时间，单位为分钟。
 * @param {boolean} [options.returnCustomResult=false] - 仅供三维使用。
 * @param {boolean} [options.returnContent=true] - 是否立即返回新创建资源的表述还是返回新资源的 URI。
 * @param {boolean} [options.returnFeatureWithFieldCaption = false] - 返回的查询结果要素字段标识是否为字段别名。为 false 时，返回的是字段名；为 true 时，返回的是字段别名。
 * @usage
 */
class QueryByBoundsParameters extends QueryParameters {

    constructor(options) {
        options = options || {};
        super(options);
        /**
         * @member {boolean} [QueryByBoundsParameters.prototype.returnContent=true]
         * @description 是否立即返回新创建资源的表述还是返回新资源的 URI。
         *              如果为 true，则直接返回新创建资源，即查询结果的表述。
         *              为 false，则返回的是查询结果资源的 URI。
         */
        this.returnContent = true;

        /**
         * @member {(SuperMap.Bounds|L.Bounds|L.LatLngBounds|ol.extent|mapboxgl.LngLatBounds|GeoJSONObject)} QueryByBoundsParameters.prototype.bounds
         * @description 指定的查询范围。
         */
        this.bounds = null;

        Util_Util.extend(this, options);

        this.CLASS_NAME = "SuperMap.QueryByBoundsParameters";
    }

    /**
     * @function QueryByBoundsParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        super.destroy();
        var me = this;
        me.returnContent = null;
        if (me.bounds) {
            me.bounds = null;
        }

    }
}

;// CONCATENATED MODULE: ./src/common/iServer/QueryByBoundsService.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/




/**
 * @class QueryByBoundsService
 * @deprecatedclass SuperMap.QueryByBoundsService
 * @category  iServer Map QueryResults
 * @classdesc Bounds 查询服务类。
 * @augments {QueryService}
 * @example
 * (start end)
 * var myQueryByBoundsService = new QueryByBoundsService(url);
 * function queryCompleted(object){//todo};
 * function queryError(object){//todo};
 * (end)
 * @param {string} url - 服务地址。如访问World Map服务，只需将url设为: http://localhost:8090/iserver/services/map-world/rest/maps/World+Map 即可。
 * @param {Object} options - 参数。
 * @param {DataFormat} [options.format=DataFormat.GEOJSON] - 查询结果返回格式，目前支持 iServerJSON、GeoJSON、FGB 三种格式。参数格式为 "ISERVER"，"GEOJSON"，"FGB"。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @usage
 */
class QueryByBoundsService extends QueryServiceBase {

    constructor(url, options) {
        super(url, options);
        this.CLASS_NAME = "SuperMap.QueryByBoundsService";
    }

    /**
     * @override
     */
    destroy() {
        super.destroy();
    }

    /**
     * @function QueryByBoundsService.prototype.getJsonParameters
     * @description 将查询参数转化为 JSON 字符串。
     *              在本类中重写此方法，可以实现不同种类的查询（sql, geometry, distance, bounds 等）。
     * @param {QueryByBoundsParameters} params - Bounds 查询参数。
     * @returns {Object} 转化后的 JSON 字符串。
     */
    getJsonParameters(params) {
        if (!(params instanceof QueryByBoundsParameters)) {
            return null;
        }
        var me = this,
            jsonParameters = "",
            qp = null,
            bounds = params.bounds;
        qp = me.getQueryParameters(params);
        jsonParameters += "'queryMode':'BoundsQuery','queryParameters':";
        jsonParameters += Util_Util.toJSON(qp);
        jsonParameters += ",'bounds': {'rightTop':{'y':" + bounds.top + ",'x':" +
            bounds.right + "},'leftBottom':{'y':" + bounds.bottom + ",'x':" + bounds.left + "}}";
        jsonParameters = "{" + jsonParameters + "}";
        return jsonParameters;
    }

}


;// CONCATENATED MODULE: ./src/common/iServer/QueryByDistanceParameters.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/



/**
 * @class QueryByDistanceParameters
 * @deprecatedclass SuperMap.QueryByDistanceParameters
 * @category  iServer Map QueryResults
 * @classdesc Distance 查询参数类。
 *            该类用于设置 Distance 查询的相关参数。
 * @extends {QueryParameters}
 * @param {Object} options - 参数。
 * @param {GeoJSONObject} options.geometry - 用于查询的几何对象。
 * @param {Array.<FilterParameter>} options.queryParams - 查询过滤条件参数数组。
 * @param {number} options.distance - 查询距离，单位与所查询图层对应的数据集单位相同。距离查询时，表示距离地物的距离。最近地物查询时，表示搜索的范围。此为必选参数。
 * @param {string} [options.customParams] - 自定义参数，供扩展使用。
 * @param {Object} [options.prjCoordSys] -自定义参数，供 SuperMap Online 提供的动态投影查询扩展使用。如 {"epsgCode":3857}。
 * @param {number} [options.expectCount=100000] - 期望返回结果记录个数。
 * @param {GeometryType} [options.networkType=GeometryType.LINE] - 网络数据集对应的查询类型。
 * @param {QueryOption} [options.queryOption=QueryOption.ATTRIBUTEANDGEOMETRY] - 查询结果类型枚举类。
 * @param {number} [options.startRecord=0] - 查询起始记录号。
 * @param {number} [options.holdTime=10] - 资源在服务端保存的时间，单位为分钟。
 * @param {boolean} [options.returnCustomResult=false] -仅供三维使用。
 * @param {boolean} [options.isNearest=false] - 是否为最近距离查询。
 * @param {boolean} [options.returnContent=true] - 是否立即返回新创建资源的表述还是返回新资源的 URI。
 * @param {boolean} [options.returnFeatureWithFieldCaption = false] - 返回的查询结果要素字段标识是否为字段别名。为 false 时，返回的是字段名；为 true 时，返回的是字段别名。
 * @usage
 */
class QueryByDistanceParameters extends QueryParameters {


    constructor(options) {
        options = options || {};
        super(options);
        /**
         * @member {number} [QueryByDistanceParameters.prototype.distance=0]
         * @description 查询距离，单位与所查询图层对应的数据集单位相同。
         *              距离查询时，表示距离地物的距离。最近地物查询时，表示搜索的范围。
         */

        /**
         * @member {GeoJSONObject} QueryByDistanceParameters.prototype.geometry
         * @description 用于查询的地理对象。<br>
         * 点类型可以是：{@link GeometryPoint}|{@link L.Marker}|{@link L.CircleMarker}|{@link L.Circle}|{@link L.GeoJSON}|{@link ol.geom.Point}|{@link ol.format.GeoJSON}|{@link mapboxgl.LngLat}|{@link mapboxgl.Point}|{@link GeoJSONObject}。<br>
         * 线类型可以是：{@link GeometryLineString}|{@link GeometryLinearRing}|{@link L.Polyline}|{@link L.GeoJSON}|{@link ol.geom.LineString}|{@link ol.format.GeoJSON}|{@link GeoJSONObject}。<br>
         * 面类型可以是：{@link GeometryPolygon}|{@link L.Polygon}|{@link L.GeoJSON}|{@link ol.geom.Polygon}|{@link ol.format.GeoJSON}|{@link mapboxgl.LngLatBounds}|{@link GeoJSONObject}。
         */
        this.geometry = null;

        /**
         * @member {boolean} [QueryByDistanceParameters.prototype.isNearest=false]
         * @description 是否为最近距离查询。<br>
         *               建议该属性与 expectCount（继承自 {@link QueryParameters}）属性联合使用。
         *               当该属性为 true 时，即表示查找最近地物，如果查询结果数大于期望返回的结果记录数（expectCount），
         *               则查找结果为查询总记录中距离中心最近的 expectCount 个地物。
         *               当该属性为不为 true 时，如果查询结果数大于期望返回的结果记录数（expectCount），
         *               则查找结果为从查询总记录中随机抽取的 expectCount 个地物。
         *               目前查询结果不支持按远近距离排序。
         */
        this.isNearest = null;

        /**
         * @member {boolean} [QueryByDistanceParameters.prototype.returnContent=true]
         * @description 是否立即返回新创建资源的表述还是返回新资源的 URI。
         *               如果为 true，则直接返回新创建资源，即查询结果的表述。
         *               为 false，则返回的是查询结果资源的 URI。
         */
        this.returnContent = true;


        Util_Util.extend(this, options);

        this.CLASS_NAME = "SuperMap.QueryByDistanceParameters";
    }

    /**
     * @function QueryByDistanceParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        super.destroy();
        var me = this;
        me.returnContent = null;
        me.distance = null;
        me.isNearest = null;
        if (me.geometry) {
            me.geometry.destroy();
            me.geometry = null;
        }
    }


}

;// CONCATENATED MODULE: ./src/common/iServer/QueryByDistanceService.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/





/**
 * @class QueryByDistanceService
 * @deprecatedclass SuperMap.QueryByDistanceService
 * @category  iServer Map QueryResults
 * @classdesc Distance查询服务类。
 * @extends {QueryServiceBase}
 * @example
 * var myQueryByDistService = new QueryByDistanceService(url);
 * function queryCompleted(object){//todo};
 * function queryError(object){//todo};
 * @param {string} url - 服务地址。如访问World Map服务，只需将url设为：http://localhost:8090/iserver/services/map-world/rest/maps/World+Map 即可。
 * @param {Object} options - 参数。
 * @param {DataFormat} [options.format=DataFormat.GEOJSON] - 查询结果返回格式，目前支持 iServerJSON、GeoJSON、FGB 三种格式。参数格式为 "ISERVER"，"GEOJSON"，"FGB"。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @usage
 */
class QueryByDistanceService extends QueryServiceBase {

    constructor(url, options) {
        super(url, options);
        this.CLASS_NAME = "SuperMap.QueryByDistanceService";
    }

    /**
     * @override
     */
    destroy() {
        super.destroy();
    }

    /**
     * @function QueryByDistanceService.prototype.getJsonParameters
     * @description 将查询参数转化为 JSON 字符串。
     *              在本类中重写此方法，可以实现不同种类的查询（sql, geometry, distance, bounds等）。
     * @param {QueryByDistanceParameters} params - Distance 查询参数类。
     * @returns {Object} 转化后的 JSON 字符串。
     */
    getJsonParameters(params) {
        if (!(params instanceof QueryByDistanceParameters)) {
            return;
        }
        var me = this,
            jsonParameters = "",
            qp = me.getQueryParameters(params);
        var sg = ServerGeometry.fromGeometry(params.geometry);

        jsonParameters += params.isNearest ? "'queryMode':'FindNearest','queryParameters':" : "'queryMode':'DistanceQuery','queryParameters':";
        jsonParameters += Util_Util.toJSON(qp);
        jsonParameters += ",'geometry':" + Util_Util.toJSON(sg) + ",'distance':" + params.distance;
        jsonParameters = "{" + jsonParameters + "}";
        return jsonParameters;
    }

}

;// CONCATENATED MODULE: ./src/common/iServer/QueryBySQLParameters.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/



/**
 * @class QueryBySQLParameters
 * @deprecatedclass SuperMap.QueryBySQLParameters
 * @category  iServer Map QueryResults
 * @classdesc SQL 查询参数类。
 *            该类用于设置 SQL 查询的相关参数。
 * @extends {QueryParameters}
 * @param {Object} options - 参数。
 * @param {Array.<FilterParameter>} options.queryParams - 查询过滤条件参数数组。
 * @param {string} [options.customParams] - 自定义参数，供扩展使用。
 * @param {Object} [options.prjCoordSys] - 自定义参数，供 SuperMap Online 提供的动态投影查询扩展使用。如 {"epsgCode":3857}。
 * @param {number} [options.expectCount=100000] - 期望返回结果记录个数。
 * @param {GeometryType} [options.networkType=GeometryType.LINE] - 网络数据集对应的查询类型。
 * @param {QueryOption} [options.queryOption=QueryOption.ATTRIBUTEANDGEOMETRY] - 查询结果类型枚举类。
 * @param {number} [options.startRecord=0] - 查询起始记录号。
 * @param {number} [options.holdTime=10] - 资源在服务端保存的时间，单位为分钟。
 * @param {boolean} [options.returnCustomResult=false] - 仅供三维使用。
 * @param {boolean} [options.returnContent=true] - 是否立即返回新创建资源的表述还是返回新资源的 URI。
 * @param {boolean} [options.returnFeatureWithFieldCaption = false] - 返回的查询结果要素字段标识是否为字段别名。为 false 时，返回的是字段名；为 true 时，返回的是字段别名。
 * @usage
 */
class QueryBySQLParameters extends QueryParameters {

    constructor(options) {
        options = options || {};
        super(options);
        /**
         * @member {boolean} [QueryBySQLParameters.prototype.returnContent=true]
         * @description 是否立即返回新创建资源的表述还是返回新资源的 URI。
         *              如果为 true，则直接返回新创建资源，即查询结果的表述。
         *              为 false，则返回的是查询结果资源的 URI。
         */
        this.returnContent = true;
        Util_Util.extend(this, options);
        this.CLASS_NAME = "SuperMap.QueryBySQLParameters";
    }

    /**
     * @function QueryBySQLParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        super.destroy();
        var me = this;
        me.returnContent = null;
    }

}

;// CONCATENATED MODULE: ./src/common/iServer/QueryBySQLService.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/




/**
 * @class QueryBySQLService
 * @deprecatedclass SuperMap.QueryBySQLService
 * @category  iServer Map QueryResults
 * @classdesc SQL 查询服务类。在一个或多个指定的图层上查询符合 SQL 条件的空间地物信息。
 * @extends {QueryServiceBase}
 * @example
 * var queryParam = new FilterParameter({
 *     name: "Countries@World.1",
 *     attributeFilter: "Pop_1994>1000000000 and SmArea>900"
 * });
 * var queryBySQLParams = new QueryBySQLParameters({
 *     queryParams: [queryParam]
 * });
 * var myQueryBySQLService = new QueryBySQLService(url);
 * queryBySQLService.processAsync(queryBySQLParams);
 * function queryCompleted(object){//todo};
 * function queryError(object){//todo};
 * @param {string} url - 服务地址。如访问World Map服务，只需将url设为: http://localhost:8090/iserver/services/map-world/rest/maps/World+Map 即可。
 * @param {Object} options - 参数。
 * @param {DataFormat} [options.format=DataFormat.GEOJSON] - 查询结果返回格式，目前支持 iServerJSON、GeoJSON、FGB 三种格式。参数格式为 "ISERVER"，"GEOJSON"，"FGB"。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @usage
 */
class QueryBySQLService extends QueryServiceBase {
    constructor(url, options) {
        super(url, options);
        this.CLASS_NAME = "SuperMap.QueryBySQLService";
    }

    /**
     * @override
     */
    destroy() {
        super.destroy();
    }

    /**
     * @function QueryBySQLService.prototype.getJsonParameters
     * @description 将查询参数转化为 JSON 字符串。
     *              在本类中重写此方法，可以实现不同种类的查询（sql, geometry, distance, bounds等）。
     * @param {QueryBySQLParameters} params - SQL 查询参数类。
     * @returns {Object} 转化后的 JSON 字符串。
     */
    getJsonParameters(params) {
        if (!(params instanceof QueryBySQLParameters)) {
            return;
        }
        var me = this,
            jsonParameters = "",
            qp = null;
        qp = me.getQueryParameters(params);
        jsonParameters += "'queryMode':'SqlQuery','queryParameters':";
        jsonParameters += Util_Util.toJSON(qp);
        jsonParameters = "{" + jsonParameters + "}";
        return jsonParameters;
    }

}


;// CONCATENATED MODULE: ./src/common/iServer/QueryByGeometryParameters.js
 /* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
  * This program are made available under the terms of the Apache License, Version 2.0
  * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/





/**
 * @class QueryByGeometryParameters
 * @deprecatedclass SuperMap.QueryByGeometryParameters
 * @category  iServer Map QueryResults
 * @classdesc Geometry 查询参数类。
 *            该类用于设置 Geometry查询的相关参数。
 * @extends {QueryParameters}
 * @param {Object} options - 参数。
 * @param {Array.<FilterParameter>} options.queryParams - 查询过滤条件参数数组。
 * @param {GeoJSONObject} options.geometry - 查询的几何对象。
 * @param {string} [options.customParams] - 自定义参数，供扩展使用。
 * @param {QueryOption} [options.queryOption=QueryOption.ATTRIBUTEANDGEOMETRY] - 查询结果类型枚举类。
 * @param {Object} [options.prjCoordSys] -自定义参数，供SuperMap Online提供的动态投影查询扩展使用。如 {"epsgCode":3857}。
 * @param {number} [options.expectCount=100000] - 期望返回结果记录个数。
 * @param {GeometryType} [options.networkType=GeometryType.LINE] - 网络数据集对应的查询类型。
 * @param {boolean} [options.returnCustomResult=false] -仅供三维使用。
 * @param {number} [options.startRecord=0] - 查询起始记录号。
 * @param {number} [options.holdTime=10] - 资源在服务端保存的时间，单位为分钟。
 * @param {boolean} [options.returnContent=true] - 是否立即返回新创建资源的表述还是返回新资源的 URI。
 * @param {boolean} [options.returnFeatureWithFieldCaption = false] - 返回的查询结果要素字段标识是否为字段别名。为 false 时，返回的是字段名；为 true 时，返回的是字段别名。
 * @param {SpatialQueryMode} [spatialQueryMode=SpatialQueryMode.INTERSECT] - 空间查询模式。
 * @usage
 */
class QueryByGeometryParameters extends QueryParameters {


    constructor(options) {
        options = options || {};
        super(options);

        /**
         * @member {boolean} [QueryByGeometryParameters.prototype.returnContent=true]
         * @description 是否立即返回新创建资源的表述还是返回新资源的 URI。<br>
         *              如果为 true，则直接返回新创建资源，即查询结果的表述。<br>
         *              为 false，则返回的是查询结果资源的 URI。
         */
        this.returnContent = true;

        /**
         * @member {GeoJSONObject} QueryByGeometryParameters.prototype.geometry
         * @description 用于查询的几何对象。<br>
         * 点类型可以是：{@link GeometryPoint}|{@link L.Marker}|{@link L.CircleMarker}|{@link L.Circle}|{@link L.GeoJSON}|{@link ol.geom.Point}|{@link ol.format.GeoJSON}|{@link mapboxgl.LngLat}|{@link mapboxgl.Point}|{@link GeoJSONObject}。<br>
         * 线类型可以是：{@link GeometryLineString}|{@link GeometryLinearRing}|{@link L.Polyline}|{@link L.GeoJSON}|{@link ol.geom.LineString}|{@link ol.format.GeoJSON}|{@link GeoJSONObject}。<br>
         * 面类型可以是：{@link GeometryPolygon}|{@link L.Polygon}|{@link L.GeoJSON}|{@link ol.geom.Polygon}|{@link ol.format.GeoJSON}|{@link mapboxgl.LngLatBounds}|{@link GeoJSONObject}。
         */
        this.geometry = null;

        /**
         * @member {SpatialQueryMode} [QueryByGeometryParameters.prototype.spatialQueryMode=SpatialQueryMode.INTERSECT]
         * @description 空间查询模式。
         */
        this.spatialQueryMode = SpatialQueryMode.INTERSECT;

        Util_Util.extend(this, options);

        this.CLASS_NAME = "SuperMap.QueryByGeometryParameters";
    }

    /**
     * @function QueryByGeometryParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        super.destroy();
        var me = this;
        me.returnContent = null;
        me.geometry = null;
        me.spatialQueryMode = null;
    }


}

;// CONCATENATED MODULE: ./src/common/iServer/QueryByGeometryService.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/





/**
 * @class QueryByGeometryService
 * @deprecatedclass SuperMap.QueryByGeometryService
 * @category  iServer Map QueryResults
 * @classdesc Geometry查询服务类。
 * @extends {QueryServiceBase}
 * @example
 * var myQueryByGeometryService = new QueryByGeometryService(url);
 * function queryCompleted(object){//todo};
 * function queryError(object){//todo};
 * @param {string} url - 服务地址。如访问World Map服务，只需将url设为: http://localhost:8090/iserver/services/map-world/rest/maps/World+Map 即可。
 * @param {Object} options - 参数。
 * @param {DataFormat} [options.format=DataFormat.GEOJSON] - 查询结果返回格式，目前支持 iServerJSON、GeoJSON、FGB 三种格式。参数格式为 "ISERVER"，"GEOJSON"，"FGB"。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @usage
 */
class QueryByGeometryService extends QueryServiceBase {
    constructor(url, options) {
        super(url, options);
        this.CLASS_NAME = "SuperMap.QueryByGeometryService";
    }

    /**
     * @override
     */
    destroy() {
        super.destroy();
    }

    /**
     * @function QueryByGeometryService.prototype.getJsonParameters
     * @description 将查询参数转化为 JSON 字符串。
     *              在本类中重写此方法，可以实现不同种类的查询（sql, geometry, distance, bounds等）。
     * @param {QueryByGeometryParameters} params - Geometry 查询参数类。
     * @returns {Object} 转化后的 JSON 字符串。
     */
    getJsonParameters(params) {
        if (!(params instanceof QueryByGeometryParameters)) {
            return;
        }
        var me = this,
            jsonParameters = "",
            qp = null,
            geometry = params.geometry,
            sg = ServerGeometry.fromGeometry(geometry);
        qp = me.getQueryParameters(params);
        jsonParameters += "'queryMode':'SpatialQuery','queryParameters':";
        jsonParameters += Util_Util.toJSON(qp) + ",'geometry':" + Util_Util.toJSON(sg)
            + ",'spatialQueryMode':" + Util_Util.toJSON(params.spatialQueryMode);
        jsonParameters = "{" + jsonParameters + "}";
        return jsonParameters;
    }

}


;// CONCATENATED MODULE: ./src/common/iServer/QueryService.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/
 
 
 
 
 
 /**
  * @class QueryService
  * @category  iServer Map QueryResults
  * @classdesc 地图查询服务类。
  *            提供：范围查询，SQL 查询，几何查询，距离查询。
  * @extends {ServiceBase}
  * @param {string} url - 服务地址。
  * @param {Object} options - 参数。
  * @param {string} [options.proxy] - 服务代理地址。
  * @param {boolean} [options.withCredentials=false] - 请求是否携带 cookie。
  * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
  * @param {Object} [options.headers] - 请求头。
  * @example
  * new QueryService(url)
  * .queryByBounds(param,function(result){
  *     //doSomething
  * })
  * @usage
  */
 class QueryService_QueryService {
     constructor(url, options) {
        this.options = options || {};
        this.url = url;
     }
 
     /**
      * @function QueryService.prototype.queryByBounds
      * @description Bounds 查询地图服务。
      * @param {QueryByBoundsParameters} params - Bounds 查询参数类。
      * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
      * @param {DataFormat} [resultFormat=DataFormat.GEOJSON] - 返回结果类型。
      * @returns {Promise} Promise 对象。
      */
     queryByBounds(params, callback, resultFormat) {
         var me = this;
         var queryService = new QueryByBoundsService(me.url, {
             proxy: me.options.proxy,
             withCredentials: me.options.withCredentials,
             crossOrigin: me.options.crossOrigin,
             headers: me.options.headers,
             format: me._processFormat(resultFormat)
         });

         return queryService.processAsync(params, callback);
     }
 
     /**
      * @function QueryService.prototype.queryByDistance
      * @description 地图距离查询服务。
      * @param {QueryByDistanceParameters} params - Distance 查询参数类。
      * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
      * @param {DataFormat} [resultFormat=DataFormat.GEOJSON] - 返回结果类型
      * @returns {Promise} Promise 对象。
      */
     queryByDistance(params, callback, resultFormat) {
         var me = this;
         var queryByDistanceService = new QueryByDistanceService(me.url, {
             proxy: me.options.proxy,
             withCredentials: me.options.withCredentials,
             crossOrigin: me.options.crossOrigin,
             headers: me.options.headers,
             format: resultFormat
         });
 
         return queryByDistanceService.processAsync(params, callback);
     }
 
     /**
      * @function QueryService.prototype.queryBySQL
      * @description 地图 SQL 查询服务。
      * @param {QueryBySQLParameters} params - SQL 查询参数类。
      * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
      * @param {DataFormat} [resultFormat=DataFormat.GEOJSON] - 返回结果类型。
      * @returns {Promise} Promise 对象。
      */
     queryBySQL(params, callback, resultFormat) {
         var me = this;
         var queryBySQLService = new QueryBySQLService(me.url, {
             proxy: me.options.proxy,
             withCredentials: me.options.withCredentials,
             crossOrigin: me.options.crossOrigin,
             headers: me.options.headers,
             format: resultFormat
         });
 
         return queryBySQLService.processAsync(params, callback);
     }
 
     /**
      * @function QueryService.prototype.queryByGeometry
      * @description 地图几何查询服务。
      * @param {QueryByGeometryParameters} params - Geometry 查询参数类。
      * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
      * @param {DataFormat} [resultFormat=DataFormat.GEOJSON] - 返回结果类型。
      * @returns {Promise} Promise 对象。
      */
     queryByGeometry(params, callback, resultFormat) {
         var me = this;
         var queryByGeometryService = new QueryByGeometryService(me.url, {
             proxy: me.options.proxy,
             withCredentials: me.options.withCredentials,
             crossOrigin: me.options.crossOrigin,
             headers: me.options.headers,
             format: resultFormat
         });
 
         return queryByGeometryService.processAsync(params, callback);
     }
 
     _processFormat(resultFormat) {
         return resultFormat ? resultFormat : DataFormat.GEOJSON;
     }
 }
;// CONCATENATED MODULE: ./src/mapboxgl/services/QueryService.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/








/**
 * @class QueryService
 * @category  iServer Map QueryResults
 * @classdesc 地图查询服务类。
 *            提供：范围查询，SQL 查询，几何查询，距离查询。
 * @modulecategory Services
 * @extends {ServiceBase}
 * @param {string} url - 服务地址。
 * @param {Object} options - 参数。
 * @param {string} [options.proxy] - 服务代理地址。
 * @param {boolean} [options.withCredentials=false] - 请求是否携带 cookie。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @example
 * new QueryService(url)
 * .queryByBounds(param,function(result){
 *     //doSomething
 * })
 * @usage
 */
class QueryService extends ServiceBase {
    constructor(url, options) {
        super(url, options);
        this._queryService = new QueryService_QueryService(url, options);
    }

    /**
     * @function QueryService.prototype.queryByBounds
     * @description Bounds 查询地图服务。
     * @param {QueryByBoundsParameters} params - Bounds 查询参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @param {DataFormat} [resultFormat=DataFormat.GEOJSON] - 返回结果类型。
     * @returns {Promise} Promise 对象。
     */
    queryByBounds(params, callback, resultFormat) {
      params = this._processParams(params);
      return this._queryService.queryByBounds(params, callback, resultFormat);
    }

    /**
     * @function QueryService.prototype.queryByDistance
     * @description 地图距离查询服务。
     * @param {QueryByDistanceParameters} params - Distance 查询参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @param {DataFormat} [resultFormat=DataFormat.GEOJSON] - 返回结果类型
     * @returns {Promise} Promise 对象。
     */
    queryByDistance(params, callback, resultFormat) {
      params = this._processParams(params);
      return this._queryService.queryByDistance(params, callback, resultFormat);
    }

    /**
     * @function QueryService.prototype.queryBySQL
     * @description 地图 SQL 查询服务。
     * @param {QueryBySQLParameters} params - SQL 查询参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @param {DataFormat} [resultFormat=DataFormat.GEOJSON] - 返回结果类型。
     * @returns {Promise} Promise 对象。
     */
    queryBySQL(params, callback, resultFormat) {
      params = this._processParams(params);
      return this._queryService.queryBySQL(params, callback, resultFormat);
    }

    /**
     * @function QueryService.prototype.queryByGeometry
     * @description 地图几何查询服务。
     * @param {QueryByGeometryParameters} params - Geometry 查询参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @param {DataFormat} [resultFormat=DataFormat.GEOJSON] - 返回结果类型。
     * @returns {Promise} Promise 对象。
     */
    queryByGeometry(params, callback, resultFormat) {
      params = this._processParams(params);
      return this._queryService.queryByGeometry(params, callback, resultFormat);
    }

    _processParams(params) {
        if (!params) {
            return {};
        }
        params.returnContent = params.returnContent == null ? true : params.returnContent;
        if (params.queryParams && !core_Util_Util.isArray(params.queryParams)) {
            params.queryParams = [params.queryParams];
        }
        if (params.bounds) {
            if (params.bounds instanceof Array) {
                params.bounds = new Bounds(params.bounds[0], params.bounds[1], params.bounds[2], params.bounds[3]);
            }
            if (params.bounds instanceof (external_mapboxgl_default()).LngLatBounds) {
                params.bounds = new Bounds(
                    params.bounds.getSouthWest().lng,
                    params.bounds.getSouthWest().lat,
                    params.bounds.getNorthEast().lng,
                    params.bounds.getNorthEast().lat
                );
            }
        }

        if (params.geometry) {
            if (params.geometry instanceof (external_mapboxgl_default()).LngLat) {
                params.geometry = new Point(params.geometry.lng, params.geometry.lat);
            }

            if (params.geometry instanceof (external_mapboxgl_default()).Point) {
                params.geometry = new Point(params.geometry.x, params.geometry.y);
            }

            if (params.geometry instanceof (external_mapboxgl_default()).LngLatBounds) {
                params.geometry = core_Util_Util.toSuperMapPolygon(params.geometry);
            }

            if (!(params.geometry instanceof Geometry_Geometry)) {
                params.geometry = core_Util_Util.toSuperMapGeometry(params.geometry);
            }
        }
        return params;
    }
}


;// CONCATENATED MODULE: ./src/common/iServer/SpatialAnalystBase.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/





/**
 * @class SpatialAnalystBase
 * @deprecatedclass SuperMap.SpatialAnalystBase
 * @category  iServer Core
 * @classdesc 空间分析服务基类。
 * @param {string} url - 地址。
 * @param {Object} options - 可选参数。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @extends {CommonServiceBase}
 * @usage
 */
class SpatialAnalystBase extends CommonServiceBase {

    constructor(url, options) {
        super(url, options);
        /**
         * @member {DataFormat} [SpatialAnalystBase.prototype.format=DataFormat.GEOJSON]
         * @description 查询结果返回格式，目前支持 iServerJSON、GeoJSON、FGB 三种格式。参数格式为 "ISERVER"，"GEOJSON"，"FGB"。
         */
        this.format = (options && options.format) || DataFormat.GEOJSON;
        this.CLASS_NAME = "SuperMap.SpatialAnalystBase";
    }

    /**
     * @function SpatialAnalystBase.prototype.destroy
     * @override
     */
    destroy() {
        super.destroy();
        this.format = null;
    }

    /**
     * @function SpatialAnalystBase.prototype.transformResult
     * @description 状态完成时转换结果。
     * @param {Object} result - 服务器返回的结果对象。
     * @param {Object} options - 请求参数。
     * @return {Object} 转换结果。
     */
    transformResult(result, options) {
        var me = this, analystResult;
        result = Util_Util.transformResult(result);
        if (result && me.format === DataFormat.GEOJSON && typeof me.toGeoJSONResult === 'function') {
            //批量分析时会返回多个结果
            if (Util_Util.isArray(result)) {
                for (var i = 0; i < result.length; i++) {
                    result[i] = me.toGeoJSONResult(result[i])
                }
                analystResult = result;

            } else {
                analystResult = me.toGeoJSONResult(result);
            }
        }
        if (!analystResult) {
            analystResult = result;
        }
        return { result: analystResult, options };
    }

    /**
     * @function SpatialAnalystBase.prototype.toGeoJSONResult
     * @description 将含有 geometry 的数据转换为 GeoJSON 格式。
     * @param {Object} result - 服务器返回的结果对象。
     *
     */
    toGeoJSONResult(result) {
        if (!result) {
            return null;
        }
        //批量叠加分析时结果这样处理
        if (result.result && result.result.resultGeometry) {
            result = result.result
        }
        var geoJSONFormat = new GeoJSON();
        if (result.recordsets) {
            for (var i = 0, recordsets = result.recordsets, len = recordsets.length; i < len; i++) {
                if (recordsets[i].features) {
                    recordsets[i].features = geoJSONFormat.toGeoJSON(recordsets[i].features);
                }
            }
        } else if (result.recordset && result.recordset.features) {
            result.recordset.features =geoJSONFormat.toGeoJSON(result.recordset.features);
        }
        if (result.resultGeometry) {
            result.resultGeometry = geoJSONFormat.toGeoJSON(result.resultGeometry);
        }
        if (result.regions) {
            result.regions = geoJSONFormat.toGeoJSON(result.regions);
        }

        return result;
    }

}


;// CONCATENATED MODULE: ./src/common/iServer/AreaSolarRadiationParameters.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


/**
 * @class AreaSolarRadiationParameters
 * @deprecatedclass SuperMap.AreaSolarRadiationParameters
 * @category iServer SpatialAnalyst SolarRadiationAnalyst
 * @classdesc 地区太阳辐射参数类。
 * @param {Object} options - 参数。
 * @param {string} options.dataset - 要用来做地区太阳辐射数据源中数据集的名称。该名称用形如"数据集名称@数据源别名"的形式来表示，例如：JingjinTerrain@Jingjin。
 * @param {string} options.targetDatasourceName - 指定的存储结果数据集的数据源名称, 例如："Jingjin"。
 * @param {string} options.totalGridName - 指定地区太阳辐射总辐射量数据集的名称。
 * @param {string} options.diffuseDatasetGridName - 指定地区太阳辐射散射辐射量数据集的名称。
 * @param {string} options.durationDatasetGridName - 指定地区太阳辐射太阳直射持续时间数据集的名称。
 * @param {string} options.directDatasetGridName - 指定地区太阳辐射直射辐射量数据集的名称。
 * @param {number} options.latitude - 待计算区域的纬度值。
 * @param {string} [options.timeMode = 'MULTIDAYS'] - 时间模式。可选值"WITHINDAY"（单日）或"MULTIDAYS"（多日）。
 * @param {number} options.dayStart - 起始日期（年内的第几天）。
 * @param {number} options.dayEnd - 结束日期（年内的第几天）。
 * @param {number} [options.hourStart] - 起始时间（一天中的第几个小时）。
 * @param {number} [options.hourEnd] - 结束时间（一天中的第几个小时）。
 * @param {number} [options.transmittance] - 太阳辐射穿过大气的透射率。
 * @param {number} [options.hourInterval=0.5] - 计算时的小时间隔（设置的越小计算量越大并且计算结果更精确，如果修改此参数，必须使用整数）。
 * @param {number} [options.dayInterval=5] - 计算时的天数间隔（设置的越小计算量越大并且计算结果更精确，必须使用整数）。
 * @param {boolean} [options.deleteExistResultDataset=false] - 如果用户命名的结果数据集名称与已有的数据集重名，是否删除已有的数据集。
 * @usage
 */
class AreaSolarRadiationParameters {

    constructor(options) {
        /**
         *  @member {string} AreaSolarRadiationParameters.prototype.dataset
         *  @description 要用来做地区太阳辐射数据源中数据集的名称。该名称用形如“数据集名称@数据源别名”形式来表示，例如：JingjinTerrain@Jingjin。注：地区太阳辐射数据必须为栅格数据集。
         */
        this.dataset = null;

        /**
         * @member {string} AreaSolarRadiationParameters.prototype.targetDatasourceName
         * @description 指定的存储结果数据集的数据源名称，例如："Jingjin"。
         */
        this.targetDatasourceName = null;

        /**
         * @member {string} AreaSolarRadiationParameters.prototype.totalGridName
         * @description 指定地区太阳辐射总辐射量数据集的名称。
         */
        this.totalGridName = null;

        /**
         * @member {string} AreaSolarRadiationParameters.prototype.diffuseDatasetGridName
         * @description 指定地区太阳辐射散射辐射量数据集的名称。
         */
        this.diffuseDatasetGridName = null;

        /**
         * @member {string} AreaSolarRadiationParameters.prototype.durationDatasetGridName
         * @description  指定地区太阳辐射太阳直射持续时间数据集的名称。
         */
        this.durationDatasetGridName = null;

        /**
         * @member {string} AreaSolarRadiationParameters.prototype.directDatasetGridName
         * @description 指定地区太阳辐射直射辐射量数据集的名称。
         */
        this.directDatasetGridName = null;

        /**
         * @member {number} AreaSolarRadiationParameters.prototype.latitude
         * @description 待计算区域的纬度值。
         */
        this.latitude = null;

        /**
         *  @member {string} [AreaSolarRadiationParameters.prototype.timeMode='MULTIDAYS']
         *  @description 时间模式。可选值"WITHINDAY"（单日）或"MULTIDAYS"（多日）。
         */
        this.timeMode = "MULTIDAYS";

        /**
         *  @member {number} AreaSolarRadiationParameters.prototype.dayStart
         *  @description 起始日期（年内的第几天）。
         */
        this.dayStart = null;

        /**
         *  @member {number} AreaSolarRadiationParameters.prototype.dayEnd
         * @description 结束日期（年内的第几天）。
         */
        this.dayEnd = null;

        /**
         * @member {number} [AreaSolarRadiationParameters.prototype.hourStart]
         * @description 起始时间（一天中的第几个小时）。
         */
        this.hourStart = null;

        /**
         * @member {number} [AreaSolarRadiationParameters.prototype.hourEnd]
         * @description 结束时间（一天中的第几个小时）。
         */
        this.hourEnd = null;

        /**
         * @member {number} [AreaSolarRadiationParameters.prototype.transmittance]
         * @description 太阳辐射穿过大气的透射率。
         */
        this.transmittance = null;

        /**
         *  @member {number} [AreaSolarRadiationParameters.prototype.hourInterval=0.5]
         *  @description 计算时的小时间隔（设置的越小计算量越大并且计算结果更精确, 如果修改此参数，必须使用整数）
         */
        this.hourInterval = null;

        /**
         * @member {number} [AreaSolarRadiationParameters.prototype.dayInterval=5]
         * @description 计算时的天数间隔（设置的越小计算量越大并且计算结果更精确, 必须使用整数）
         */
        this.dayInterval = null;

        /**
         * @member {boolean} [AreaSolarRadiationParameters.prototype.deleteExistResultDataset=false]
         * @description 如果用户命名的结果数据集名称与已有的数据集重名，是否删除已有的数据集。
         */
        this.deleteExistResultDataset = false;

        Util_Util.extend(this, options);

        this.CLASS_NAME = "SuperMap.AreaSolarRadiationParameters";
    }

    /**
     * @function AreaSolarRadiationParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        var me = this;
        me.dataset = null;
        me.zFactor = 1.0;
        me.averageCurvatureName = null;
        me.profileCurvatureName = null;
        me.planCurvatureName = null;
        me.deleteExistResultDataset = true;
    }

    /**
     * @function AreaSolarRadiationParameters.toObject
     * @param {AreaSolarRadiationParameters} param - 地区太阳辐射参数类。
     * @param {AreaSolarRadiationParameters} tempObj - 地区太阳辐射参数对象。
     * @returns {Object} JSON对象。
     * @description 将AreaSolarRadiationParameters对象转换成JSON对象。
     */
    static toObject(param, tempObj) {
        var parameter = {};
        for (var name in param) {
            if (name !== "dataset") {
                var name1 = (name === "latitude" || name === "timeMode" || name === "dayStart");
                var name2 = (name === "dayEnd" || name === "hourStart" || name === "hourEnd");
                var name3 = (name === "transmittance" || name === "hourInterval" || name === "dayInterval");
                if (name1 || name2 || name3) {
                    parameter[name] = param[name];
                } else {
                    tempObj[name] = param[name];
                }
            }
        }
        tempObj["parameter"] = parameter;
    }
}

;// CONCATENATED MODULE: ./src/common/iServer/AreaSolarRadiationService.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/




/**
 * @class AreaSolarRadiationService
 * @deprecatedclass SuperMap.AreaSolarRadiationService
 * @category iServer SpatialAnalyst SolarRadiationAnalyst
 * @classdesc 地区太阳辐射服务类。
 * @param {string} url - 服务的访问地址。如：</br>http://localhost:8090/iserver/services/spatialanalyst-sample/restjsr/spatialanalyst。</br>
 * @param {Object} options - 参数。</br>
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @extends {SpatialAnalystBase}
 * @example 例如：
 * (start code)
 * var myAreaSolarRadiationService = new AreaSolarRadiationService(url);
 * (end)
 * @usage
 */
class AreaSolarRadiationService extends SpatialAnalystBase {

    constructor(url, options) {
        super(url, options);
        this.CLASS_NAME = "SuperMap.AreaSolarRadiationService";
    }

    /**
     * @function AreaSolarRadiationService.prototype.destroy
     * @override
     */
    destroy() {
        super.destroy();
    }

    /**
     * @function AreaSolarRadiationService.prototype.processAsync
     * @description 负责将客户端的查询参数传递到服务端。
     * @param {AreaSolarRadiationParameters} parameter - 地区太阳辐射参数。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    processAsync(parameter, callback) {
        if (!(parameter instanceof AreaSolarRadiationParameters)) {
            return;
        }
        var me = this;
        var parameterObject = {};

        if (parameter instanceof AreaSolarRadiationParameters) {
            me.url = Util_Util.urlPathAppend(me.url, `datasets/${parameter.dataset}/solarradiation`);
        }
        me.url = Util_Util.urlAppend(me.url, 'returnContent=true');
        AreaSolarRadiationParameters.toObject(parameter, parameterObject);
        var jsonParameters = Util_Util.toJSON(parameterObject);

        return me.request({
            method: 'POST',
            data: jsonParameters,
            scope: me,
            success: callback,
            failure: callback
        });
    }
}



;// CONCATENATED MODULE: ./src/common/iServer/BufferDistance.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


/**
 * @class BufferDistance
 * @deprecatedclass SuperMap.BufferDistance
 * @category iServer SpatialAnalyst BufferAnalyst
 * @classdesc 缓冲区分析的缓冲距离类。通过该类可以设置缓冲区分析的缓冲距离，距离可以是数值也可以是数值型的字段表达式。
 * @param {Object} options - 可选参数。
 * @param {string} [options.exp] - 以数值型的字段表达式作为缓冲区分析的距离值。
 * @param {number} [options.value=100] - 以数值作为缓冲区分析的距离值。单位：米。
 * @usage
 */
class BufferDistance {


    constructor(options) {
        /**
         * @member {string} [BufferDistance.prototype.exp]
         * @description 以数值型的字段表达式作为缓冲区分析的距离值。
         */
        this.exp = null;

        /**
         * @member {number} [BufferDistance.prototype.value=100]
         * @description 以数值作为缓冲区分析的距离值。单位：米。
         */
        this.value = 100;

        Util_Util.extend(this, options);

        this.CLASS_NAME = "SuperMap.BufferDistance";
    }

    /**
     * @function BufferDistance.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        this.exp = null;
        this.value = null;
    }


}

;// CONCATENATED MODULE: ./src/common/iServer/BufferSetting.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/




/**
 * @class BufferSetting
 * @deprecatedclass SuperMap.BufferSetting
 * @category iServer SpatialAnalyst BufferAnalyst
 * @classdesc 缓冲区分析通用设置类。
 * @param {Object} options - 可选参数。
 * @param {BufferEndType} [options.endType=BufferEndType.FLAT] - 缓冲区端点枚举值。
 * @param {BufferDistance} [options.leftDistance=100] - 左侧缓冲距离。
 * @param {BufferDistance} [options.rightDistance=100] - 右侧缓冲距离。
 * @param {number} [options.semicircleLineSegment=4] - 圆头缓冲圆弧处线段的个数。
 * @param {BufferRadiusUnit} [options.radiusUnit=BufferRadiusUnit.METER] - 缓冲半径单位。
 * @usage
 */
class BufferSetting {


    constructor(options) {
        /**
         * @member {BufferEndType} [BufferSetting.prototype.endType = BufferEndType.FLAT]
         * @description 缓冲区端点枚举值。分为平头和圆头两种。当设置缓冲区端点为平头时，左侧、右侧缓冲距离需为相同数值。
         */
        this.endType = BufferEndType.FLAT;

        /**
         * @member {BufferDistance} [BufferSetting.prototype.leftDistance=100]
         * @description 左侧缓冲距离。
         * 当为 GeometryBufferAnalyst 时，单位为默认地图的投影系的单位（如3857为米，4326为度），
         * 当为 DatasetBufferAnalyst 时，单位通过{@link BufferSetting.radiusUnit}设置（默认全部为米）。
         */
        this.leftDistance = new BufferDistance();

        /**
         * @member {BufferDistance} [BufferSetting.prototype.rightDistance=100]
         * @description 右侧缓冲距离。
         * 当为 GeometryBufferAnalyst 时，单位为默认地图的投影系的单位（如3857为米，4326为度），
         * 当为 DatasetBufferAnalyst 时，单位通过{@link BufferSetting#radiusUnit}设置（默认全部为米）。
         */
        this.rightDistance = new BufferDistance();

        /**
         * @member {number} [BufferSetting.prototype.semicircleLineSegment=4]
         * @description 圆头缓冲圆弧处线段的个数。即用多少个线段来模拟一个半圆。
         */
        this.semicircleLineSegment = 4;

        /**
         * @member {BufferRadiusUnit} [BufferSetting.prototype.radiusUnit = BufferRadiusUnit.METER]
         * @description 缓冲半径单位，可以是{@link BufferRadiusUnit.METER}、{@link BufferRadiusUnit.MILLIMETER}、
         * {@link BufferRadiusUnit.CENTIMETER}、{@link BufferRadiusUnit.DECIMETER}、{@link BufferRadiusUnit.KILOMETER}、
         * {@link BufferRadiusUnit.FOOT}、{@link BufferRadiusUnit.INCH}、{@link BufferRadiusUnit.MILE}、{@link BufferRadiusUnit.YARD}。
         * 仅对BufferAnalyst有效。
         */
        this.radiusUnit = BufferRadiusUnit.METER;

        if (options) {
            Util_Util.extend(this, options);
        }
        this.CLASS_NAME = "SuperMap.BufferSetting";
    }


    /**
     * @function BufferSetting.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        let me = this;
        me.endType = null;
        if (me.leftDistance) {
            me.leftDistance.destroy();
            me.leftDistance = null;
        }
        if (me.rightDistance) {
            me.rightDistance.destroy();
            me.rightDistance = null;
        }
        me.semicircleLineSegment = null;
        me.radiusUnit = null;
    }
}

;// CONCATENATED MODULE: ./src/common/iServer/BufferAnalystParameters.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/



/**
 * @class BufferAnalystParameters
 * @deprecatedclass SuperMap.BufferAnalystParameters
 * @category iServer SpatialAnalyst BufferAnalyst
 * @classdesc 缓冲区分析参数基类。
 * @param {Object} options - 参数。
 * @param {BufferSetting} [options.bufferSetting] - 设置缓冲区通用参数。为缓冲区分析提供必要的参数信息，包括左缓冲距离、右缓冲距离、端点类型、圆头缓冲圆弧处线段的个数信息。
 * @usage
 */
class BufferAnalystParameters {


    constructor(options) {
        var me = this;
        /**
         * @member {BufferSetting} [BufferAnalystParameters.prototype.bufferSetting]
         * @description 设置缓冲区通用参数。为缓冲区分析提供必要的参数信息，包括左缓冲距离、右缓冲距离、端点类型、圆头缓冲圆弧处线段的个数信息。
         */
        me.bufferSetting = new BufferSetting();
        Util_Util.extend(this, options);
        this.CLASS_NAME = "SuperMap.BufferAnalystParameters";
    }


    /**
     * @function BufferAnalystParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        var me = this;
        if (me.bufferSetting) {
            me.bufferSetting.destroy();
            me.bufferSetting = null;
        }
    }


}

;// CONCATENATED MODULE: ./src/common/iServer/DataReturnOption.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/



/**
 * @class DataReturnOption
 * @deprecatedclass SuperMap.DataReturnOption
 * @category iServer Data Dataset
 * @classdesc 数据返回设置类。
 * @param {Object} options - 参数。
 * @param {number} [options.expectCount=1000] - 设置返回的最大记录数，小于或者等于 0 时表示返回所有记录数。
 * @param {string} [options.dataset] - 设置结果数据集标识，当 dataReturnMode 为 {@link DataReturnMode.DATASET_ONLY}或{@link DataReturnMode.DATASET_AND_RECORDSET}时有效，
 *                                   作为返回数据集的名称。该名称用形如“数据集名称@数据源别名”形式来表示。
 * @param {DataReturnMode} [options.dataReturnMode=DataReturnMode.RECORDSET_ONLY] - 数据返回模式。
 * @param {boolean} [options.deleteExistResultDataset=true] - 如果用户命名的结果数据集名称与已有的数据集重名，是否删除已有的数据集。
 * @usage
 */
class DataReturnOption {


    constructor(options) {

        /**
         * @member {number} [DataReturnOption.prototype.expectCount=1000]
         * @description 设置返回的最大记录数，小于或者等于0时表示返回所有记录数。
         */
        this.expectCount = 1000;

        /**
         * @member {string} [DataReturnOption.prototype.dataset]
         * @description 设置结果数据集标识，当dataReturnMode为 {@link DataReturnMode.DATASET_ONLY}
         * 或{@link DataReturnMode.DATASET_AND_RECORDSET}时有效，
         * 作为返回数据集的名称。该名称用形如"数据集名称@数据源别名"形式来表示。
         */
        this.dataset = null;

        /**
         * @member {DataReturnMode} [DataReturnOption.prototype.dataReturnMode=DataReturnMode.RECORDSET_ONLY]
         * @description 数据返回模式。
         */
        this.dataReturnMode = DataReturnMode.RECORDSET_ONLY;

        /**
         * @member {boolean} [DataReturnOption.prototype.deleteExistResultDataset=true]
         * @description 如果用户命名的结果数据集名称与已有的数据集重名，是否删除已有的数据集。
         */
        this.deleteExistResultDataset = true;

        Util_Util.extend(this, options);
        this.CLASS_NAME = "SuperMap.DataReturnOption";
    }

    /**
     * @function DataReturnOption.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        var me = this;
        me.expectCount = null;
        me.dataset = null;
        me.dataReturnMode = null;
        me.deleteExistResultDataset = null;
    }


}

;// CONCATENATED MODULE: ./src/common/iServer/DatasetBufferAnalystParameters.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/





/**
 * @class DatasetBufferAnalystParameters
 * @deprecatedclass SuperMap.DatasetBufferAnalystParameters
 * @category iServer SpatialAnalyst BufferAnalyst
 * @classdesc 数据集缓冲区分析参数类。
 * @param {Object} options - 参数。
 * @param {string} options.dataset - 要用来做缓冲区分析的数据源中数据集的名称。该名称用形如“数据集名称@数据源别名”形式来表示。
 * @param {FilterParameter} [options.filterQueryParameter] - 设置数据集中几何对象的过滤条件。只有满足此条件的几何对象才参与缓冲区分析。
 * @param {DataReturnOption} [options.resultSetting] - 结果返回设置类。
 * @param {boolean} [options.isAttributeRetained=true] - 是否保留进行缓冲区分析的对象的字段属性。当 isUnion 字段为 false 时该字段有效。
 * @param {boolean} [options.isUnion=false] - 是否将缓冲区与源记录集中的对象合并后返回。对于面对象而言，要求源数据集中的面对象不相交。
 * @param {BufferSetting} [options.bufferSetting] - 设置缓冲区通用参数。
 *
 * @extends {BufferAnalystParameters}
 * @usage
 */
class DatasetBufferAnalystParameters extends BufferAnalystParameters {


    constructor(options) {
        super(options);
        /**
         * @member {string} DatasetBufferAnalystParameters.prototype.dataset
         * @description 要用来做缓冲区分析的数据源中数据集的名称。该名称用形如“数据集名称@数据源别名”形式来表示。
         */
        this.dataset = null;

        /**
         *  @member {FilterParameter} [DatasetBufferAnalystParameters.prototype.filterQueryParameter]
         *  @description 设置数据集中几何对象的过滤条件。只有满足此条件的几何对象才参与缓冲区分析。
         */
        this.filterQueryParameter = new FilterParameter();

        /**
         * @member {DataReturnOption} [DatasetBufferAnalystParameters.prototype.resultSetting]
         * @description 结果返回设置类。
         */
        this.resultSetting = new DataReturnOption();

        /**
         * @member {boolean} [DatasetBufferAnalystParameters.prototype.isAttributeRetained=true]
         * @description 是否保留进行缓冲区分析的对象的字段属性。当 isUnion 字段为 false 时该字段有效。
         */
        this.isAttributeRetained = true;

        /**
         * @member {boolean} [DatasetBufferAnalystParameters.prototype.isUnion=false]
         * @description 是否将缓冲区与源记录集中的对象合并后返回。对于面对象而言，要求源数据集中的面对象不相交。
         */
        this.isUnion = false;

        Util_Util.extend(this, options);

        this.CLASS_NAME = "SuperMap.DatasetBufferAnalystParameters";
    }


    /**
     * @function DatasetBufferAnalystParameters.prototype.destroy
     * @override
     */
    destroy() {
        super.destroy();
        var me = this;
        me.dataset = null;
        if (me.filterQueryParameter) {
            me.filterQueryParameter.destroy();
            me.filterQueryParameter = null;
        }
        if (me.resultSetting) {
            me.resultSetting.destroy();
            me.resultSetting = null;
        }
        me.isAttributeRetained = null;
        me.isUnion = null;
    }

    /**
     * @function DatasetBufferAnalystParameters.toObject
     * @param {DatasetBufferAnalystParameters} datasetBufferAnalystParameters - 数据集缓冲区分析参数类。
     * @param {DatasetBufferAnalystParameters} tempObj - 数据集缓冲区分析参数对象。
     * @description 将数据集缓冲区分析参数对象转换为 JSON 对象。
     * @returns {Object} JSON 对象。
     */
    static toObject(datasetBufferAnalystParameters, tempObj) {
        for (var name in datasetBufferAnalystParameters) {
            if (name === "bufferSetting") {
                datasetBufferAnalystParameters.bufferSetting.radiusUnit = datasetBufferAnalystParameters.bufferSetting.radiusUnit.toUpperCase();
                tempObj.bufferAnalystParameter = datasetBufferAnalystParameters.bufferSetting;
            } else if (name === "resultSetting") {
                tempObj.dataReturnOption = datasetBufferAnalystParameters.resultSetting;
            } else if (name === "dataset") {
                continue;
            } else {
                tempObj[name] = datasetBufferAnalystParameters[name];
            }
        }
    }

}


;// CONCATENATED MODULE: ./src/common/iServer/GeometryBufferAnalystParameters.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/




/**
 * @class GeometryBufferAnalystParameters
 * @deprecatedclass SuperMap.GeometryBufferAnalystParameters
 * @category  iServer SpatialAnalyst BufferAnalyst
 * @classdesc 几何对象缓冲区分析参数类。
 * 对指定的某个几何对象做缓冲区分析。通过该类可以指定要做缓冲区分析的几何对象、缓冲区参数等。
 * @param {Object} options - 参数。
 * @param {GeoJSONObject} options.sourceGeometry - 要做缓冲区分析的几何对象。
 * @param {number} options.sourceGeometrySRID - 缓冲区几何对象投影坐标参数, 如 4326，3857。
 * @param {BufferSetting} [options.bufferSetting] - 设置缓冲区通用参数。
 * @extends {BufferAnalystParameters}
 * @usage
 */
class GeometryBufferAnalystParameters extends BufferAnalystParameters {


    constructor(options) {
        super(options);
        /**
         * @member {GeoJSONObject} GeometryBufferAnalystParameters.prototype.sourceGeometry
         * @description 要做缓冲区分析的几何对象。<br>
         * 点类型可以是：{@link GeometryPoint}|{@link L.Marker}|{@link L.CircleMarker}|{@link L.Circle}|{@link L.GeoJSON}|{@link ol.geom.Point}|{@link ol.format.GeoJSON}。</br>
         * 线类型可以是：{@link GeometryLineString}|{@link GeometryLinearRing}|{@link L.Polyline}|{@link L.GeoJSON}|{@link ol.geom.LineString}|{@link ol.format.GeoJSON}。</br>
         * 面类型可以是：{@link GeometryPolygon}|{@link L.Polygon}|{@link L.GeoJSON}|{@link ol.geom.Polygon}|{@link ol.format.GeoJSON}。
         */
        this.sourceGeometry = null;

        /**
         * @member {number} GeometryBufferAnalystParameters.prototype.sourceGeometrySRID
         * @description 缓冲区几何对象投影坐标参数, 如 4326，3857。
         */
        this.sourceGeometrySRID = null;

        if (options) {
            Util_Util.extend(this, options);
        }
        this.CLASS_NAME = " SuperMap.GeometryBufferAnalystParameters";
    }

    /**
     * @function GeometryBufferAnalystParameters.prototype.destroy
     * @override
     */
    destroy() {
        super.destroy();
        var me = this;
        if (me.sourceGeometry) {
            me.sourceGeometry.destroy();
            me.sourceGeometry = null;
        }
    }

    /**
     * @function GeometryBufferAnalystParameters.toObject
     * @param {GeometryBufferAnalystParameters} geometryBufferAnalystParameters - 几何对象缓冲区分析参数类。
     * @param {GeometryBufferAnalystParameters} tempObj - 几何对象缓冲区分析参数对象。
     * @description 将几何对象缓冲区分析参数对象转换为 JSON 对象。
     * @returns {Object} JSON 对象。
     */
    static toObject(geometryBufferAnalystParameters, tempObj) {
        for (var name in geometryBufferAnalystParameters) {
            if (name === "bufferSetting") {
                var tempBufferSetting = {};
                for (var key in geometryBufferAnalystParameters.bufferSetting) {
                    tempBufferSetting[key] = geometryBufferAnalystParameters.bufferSetting[key];
                }
                tempObj.analystParameter = tempBufferSetting;
            } else if (name === "sourceGeometry") {
                tempObj.sourceGeometry = ServerGeometry.fromGeometry(geometryBufferAnalystParameters.sourceGeometry);

            } else {
                tempObj[name] = geometryBufferAnalystParameters[name];
            }
        }
    }

}

;// CONCATENATED MODULE: ./src/common/iServer/BufferAnalystService.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/






/**
 * @class BufferAnalystService
 * @deprecatedclass SuperMap.BufferAnalystService
 * @category iServer SpatialAnalyst BufferAnalyst
 * @classdesc 缓冲区分析服务类。
 * 该类负责将客户设置的缓冲区分析参数传递给服务端，并接收服务端返回的缓冲区分析结果数据。
 * 缓冲区分析结果通过该类支持的事件的监听函数参数获取。
 * @param {string} url - 服务的访问地址。如：http://localhost:8090/iserver/services/spatialanalyst-changchun/restjsr/spatialanalyst。
 * @param {Object} options - 参数。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @extends {SpatialAnalystBase}
 * @example 例如：
 * (start code)
 * var myBufferAnalystService = new BufferAnalystService(url);
 * (end)
 * @usage
 */
class BufferAnalystService extends SpatialAnalystBase {


    constructor(url, options) {
        super(url, options);
        /**
         * @member {string} BufferAnalystService.prototype.mode
         * @description 缓冲区分析类型
         */
        this.mode = null;
        if (options) {
            Util_Util.extend(this, options);
        }
        this.CLASS_NAME = "SuperMap.BufferAnalystService";
    }


    /**
     * @function BufferAnalystService.prototype.destroy
     * @override
     */
    destroy() {
        super.destroy();
        this.mode = null;
    }


    /**
     * @method BufferAnalystService.prototype.processAsync
     * @description 负责将客户端的查询参数传递到服务端。
     * @param {BufferAnalystParameters} parameter - 缓冲区分析参数
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    processAsync(parameter, callback) {
        var parameterObject = {};
        var me = this;
        if (parameter instanceof DatasetBufferAnalystParameters) {
            me.mode = 'datasets';
            me.url = Util_Util.urlPathAppend(me.url, 'datasets/' + parameter.dataset + '/buffer');
            DatasetBufferAnalystParameters.toObject(parameter, parameterObject);
        } else if (parameter instanceof GeometryBufferAnalystParameters) {
            me.mode = 'geometry';
            me.url = Util_Util.urlPathAppend(me.url, 'geometry/buffer');
            GeometryBufferAnalystParameters.toObject(parameter, parameterObject);
        }

        var jsonParameters = Util_Util.toJSON(parameterObject);
        this.returnContent = true;
        return me.request({
            method: "POST",
            data: jsonParameters,
            scope: me,
            success: callback,
            failure: callback
        });
    }

    dataFormat() {
      return [DataFormat.GEOJSON, DataFormat.ISERVER, DataFormat.FGB];
    }
}

;// CONCATENATED MODULE: ./src/common/iServer/DensityKernelAnalystParameters.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


/**
 * @class DensityKernelAnalystParameters
 * @deprecatedclass SuperMap.DensityKernelAnalystParameters
 * @category  iServer SpatialAnalyst DensityAnalyst
 * @classdesc 核密度分析参数类。
 * @param {Object} options - 参数。
 * @param {string} options.dataset - 要用来做核密度分析数据源中数据集的名称。该名称用形如 "数据集名称@数据源别名" 形式来表示，例如：BaseMap_P@Jingjin。
 * @param {string} options.fieldName - 用于进行核密度分析的测量值的字段名称，核密度分析不支持文本类型的字段。
 * @param {string} options.resultGridName - 指定结果数据集名称。
 * @param {(SuperMap.Bounds|L.Bounds|L.LatLngBounds|ol.extent|mapboxgl.LngLatBounds|GeoJSONObject)} [options.bounds] - 核密度分析的范围，用于确定结果栅格数据集的范围。如果缺省，则默认为原数据集的范围。
 * @param {number} [options.searchRadius] - 栅格邻域内用于计算密度的查找半径，单位与当前数据集相同。默认值为当前数据集的长宽中的最大值除30。
 * @param {number} [options.resultGridDatasetResolution] - 密度分析结果栅格数据的分辨率，单位与当前数据集相同。默认值为当前数据集的长宽中的最小值除500。
 * @param {string} [options.targetDatasource] - 指定的存储结果数据集的数据源，默认为当前分析的数据集所在的数据源。
 * @param {boolean} [options.deleteExistResultDataset=false] - 如果用户命名的结果数据集名称与已有的数据集重名，是否删除已有的数据集。
 * @usage
 */
class DensityKernelAnalystParameters {


    constructor(options) {
        /**
         * @member {string} DensityKernelAnalystParameters.prototype.dataset
         * @description 要用来做核密度分析数据源中数据集的名称。
         * 该名称用形如 "数据集名称@数据源别名" 形式来表示，例如：Railway@Changchun。
         * 注：核密度分析支持点数据集和线数据集。
         */
        this.dataset = null;

        /**
         * @member {(SuperMap.Bounds|L.Bounds|L.LatLngBounds|ol.extent|mapboxgl.LngLatBounds|GeoJSONObject)} [DensityKernelAnalystParameters.prototype.bounds]
         * @description 核密度分析的范围，用于确定结果栅格数据集的范围。
         * 如果缺省，则默认为原数据集的范围。
         */
        this.bounds = null;

        /**
         * @member {string} DensityKernelAnalystParameters.prototype.fieldName
         * @description 用于进行核密度分析的测量值的字段名称，核密度分析不支持文本类型的字段。
         */
        this.fieldName = null;

        /**
         * @member {number} [DensityKernelAnalystParameters.prototype.resultGridDatasetResolution]
         * @description 密度分析结果栅格数据的分辨率，单位与当前数据集相同。默认值为当前数据集的长宽中的最小值除500。
         */
        this.resultGridDatasetResolution = null;

        /**
         * @member {number} [DensityKernelAnalystParameters.prototype.searchRadius]
         * @description 栅格邻域内用于计算密度的查找半径，单位与当前数据集相同。默认值为当前数据集的长宽中的最大值除30。
         */
        this.searchRadius = null;

        /**
         * @member {string} [DensityKernelAnalystParameters.prototype.targetDatasource]
         * @description 指定的存储结果数据集的数据源，默认为当前分析的数据集所在的数据源。
         */
        this.targetDatasource = null;

        /**
         * @member {string} DensityKernelAnalystParameters.prototype.resultGridName
         * @description 指定结果数据集名称。
         */
        this.resultGridName = null;

        /**
         * @member {boolean} [DensityKernelAnalystParameters.prototype.deleteExistResultDataset=false]
         * @description 如果用户命名的结果数据集名称与已有的数据集重名，是否删除已有的数据集。
         */
        this.deleteExistResultDataset = false;
        Util_Util.extend(this, options);

        this.CLASS_NAME = "SuperMap.DensityKernelAnalystParameters";

    }


    /**
     * @function DensityKernelAnalystParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        var me = this;
        me.dataset = null;
        me.bounds = null;
        me.fieldName = null;
        me.resultGridDatasetResolution = null;
        me.searchRadius = null;

        me.targetDatasource = null;
        me.resultGridName = null;
        me.deleteExistResultDataset = null;
    }

    /**
     * @function DensityKernelAnalystParameters.toObject
     * @param {DensityKernelAnalystParameters} densityKernelAnalystParameters -核密度分析参数类。
     * @param {DensityKernelAnalystParameters} tempObj - 核密度分析参数对象。
     * @description 将核密度分析参数对象转换成 JSON 对象。
     * @returns JSON 对象。
     */
    static toObject(densityKernelAnalystParameters, tempObj) {
        for (var name in densityKernelAnalystParameters) {
            if (name !== "dataset") {
                tempObj[name] = densityKernelAnalystParameters[name];
            }
        }
    }

}


;// CONCATENATED MODULE: ./src/common/iServer/DensityAnalystService.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/




/**
 * @class DensityAnalystService
 * @deprecatedclass SuperMap.DensityAnalystService
 * @category iServer SpatialAnalyst DensityAnalyst
 * @classdesc
 * 密度分析服务类，密度分析可计算每个输出栅格像元周围圆形邻域内输入的点或线对象的密度。
 * 密度分析，在某种意义上来说，相当于在表面上将输入的点线对象的测量值散开来，将每个点或线对象的测量量分布在整个研究区域，并计算输出栅格中每个像元的密度值。目前提供1种密度分析：核密度分析（Kernel）。
 * @param {string} url - 服务地址。如 http://localhost:8090/iserver/services/spatialanalyst-changchun/restjsr/spatialanalyst 。
 * @param {Object} options - 参数。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @extends {SpatialAnalystBase}
 * @example  例如：
 *  var myDensityAnalystService = new DensityAnalystService(url);
 *  myDensityAnalystService.on({
 *     "processCompleted": processCompleted,
 *     "processFailed": processFailed
 *     }
 *  );
 * @usage
 */
class DensityAnalystService extends SpatialAnalystBase {


    constructor(url, options) {
        super(url, options);
        /**
         * @member {string} DensityAnalystService.prototype.mode
         * @description 密度分析类型。
         */
        this.mode = null;

        if (options) {
            Util_Util.extend(this, options);
        }

        this.CLASS_NAME = "SuperMap.DensityAnalystService";
    }

    /**
     * @function DensityAnalystService.prototype.destroy
     * @description 释放资源,将引用资源的属性置空。
     */
    destroy() {
        super.destroy();
        this.mode = null;
    }

    /**
     * @function DensityAnalystService.prototype.processAsync
     * @description 负责将客户端的查询参数传递到服务端。
     * @param {DensityKernelAnalystParameters} parameter - 核密度分析参数。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    processAsync(parameter, callback) {
        var me = this;
        var parameterObject = new Object();

        if (parameter instanceof DensityKernelAnalystParameters) {
            me.url = Util_Util.urlPathAppend(me.url, 'datasets/' + parameter.dataset + '/densityanalyst/kernel');
            me.mode = "kernel";
        }

        DensityKernelAnalystParameters.toObject(parameter, parameterObject);
        var jsonParameters = Util_Util.toJSON(parameterObject);
        me.url = Util_Util.urlAppend(me.url, 'returnContent=true');

        return me.request({
            method: "POST",
            data: jsonParameters,
            scope: me,
            success: callback,
            failure: callback
        });
    }

}

;// CONCATENATED MODULE: ./src/common/iServer/GenerateSpatialDataParameters.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


/**
 * @class GenerateSpatialDataParameters
 * @deprecatedclass SuperMap.GenerateSpatialDataParameters
 * @category iServer SpatialAnalyst GenerateSpatialData
 * @classdesc 动态分段操作参数类。通过该类可以为动态分段提供参数信息。
 * @param {Object} options - 参数。
 * @param {string} options.routeTable - 路由数据集。
 * @param {string} options.routeIDField - 路由数据集的标识字段。
 * @param {string} options.eventTable - 用于生成空间数据的事件表名。
 * @param {DataReturnOption} options.dataReturnOption - 设置数据返回选项。
 * @param {string} [options.attributeFilter] - 属性过滤条件。
 * @param {string} options.eventRouteIDField - 用于生成空间数据的事件表的路由标识字段。
 * @param {string} [options.measureField] - 用于生成空间数据的事件表的刻度字段，只有当事件为点事件的时候该属性才有意义。
 * @param {string} [options.measureStartField] - 用于生成空间数据的事件表的起始刻度字段，只有当事件为线事件的时候该属性才有意义。
 * @param {string} [options.measureEndField] - 用于生成空间数据的事件表的终止刻度字段，只有当事件为线事件的时候该属性才有意义。
 * @param {string} [options.measureOffsetField] - 刻度偏移量字段。
 * @param {string} [options.errorInfoField] - 错误信息字段，直接写入原事件表，用于描述事件未能生成对应的点或线时的错误信息。
 * @param {Array.<string>} [options.retainedFields] - 欲保留到结果空间数据中的字段集合（系统字段除外）。
 * @usage
 */
class GenerateSpatialDataParameters {


    constructor(options) {
        /**
         * @member {string} GenerateSpatialDataParameters.prototype.routeTable
         * @description 路由数据集。
         */
        this.routeTable = null;

        /**
         * @member {string} GenerateSpatialDataParameters.prototype.routeIDField
         * @description 路由数据集的标识字段。
         */
        this.routeIDField = null;
        /**
         * @member {string} [GenerateSpatialDataParameters.prototype.attributeFilter]
         * @description 属性过滤条件。
         * 当 {@link GenerateSpatialDataParameters.prototype.dataReturnOption.dataReturnMode}  为 {@link DataReturnMode.DATASET_AND_RECORDSET} 或 {@link DataReturnMode.RECORDSET_ONLY} 时有效。
         */
        this.attributeFilter = null;
        /**
         * @member {string} GenerateSpatialDataParameters.prototype.eventTable
         * @description 用于生成空间数据的事件表名。
         */
        this.eventTable = null;

        /**
         * @member {string} GenerateSpatialDataParameters.prototype.eventRouteIDField
         * @description 用于生成空间数据的事件表的路由标识字段。
         */
        this.eventRouteIDField = null;

        /**
         * @member {string} [GenerateSpatialDataParameters.prototype.measureField]
         * @description 用于生成空间数据的事件表的刻度字段，只有当事件为点事件的时候该属性才有意义。
         */
        this.measureField = null;

        /**
         * @member {string} [GenerateSpatialDataParameters.prototype.measureStartField]
         * @description 用于生成空间数据的事件表的起始刻度字段，只有当事件为线事件的时候该属性才有意义。
         */
        this.measureStartField = null;

        /**
         * @member {string} [GenerateSpatialDataParameters.prototype.measureEndField]
         * @description 用于生成空间数据的事件表的终止刻度字段，只有当事件为线事件的时候该属性才有意义。
         */
        this.measureEndField = null;

        /**
         * @member {string} [GenerateSpatialDataParameters.prototype.measureOffsetField]
         * @description 刻度偏移量字段。
         */
        this.measureOffsetField = null;

        /**
         * @member {string} [GenerateSpatialDataParameters.prototype.errorInfoField]
         * @description 错误信息字段，直接写入原事件表，用于描述事件未能生成对应的点或线时的错误信息。
         */
        this.errorInfoField = null;

        /**
         * @member {Array.<string>} [GenerateSpatialDataParameters.prototype.retainedFields]
         * @description 欲保留到结果空间数据中的字段集合（系统字段除外）。
         * 生成空间数据时，无论是否指定保留字段，路由 ID 字段、刻度偏移量字段、刻度值字段（点事件为刻度字段，线事件是起始和终止刻度字段）都会保留到结果空间数据中；
         * 如果没有指定 retainedFields 参数或者 retainedFields 参数数组长度为 0，则返回所有用户字段。
         */
        this.retainedFields = null;

        /**
         * @member {DataReturnOption} GenerateSpatialDataParameters.prototype.dataReturnOption
         * @description 设置数据返回的选项。
         */
        this.dataReturnOption = null;
        if (options) {
            Util_Util.extend(this, options);
        }

        this.CLASS_NAME = "SuperMap.GenerateSpatialDataParameters";
    }


    /**
     * @function GenerateSpatialDataParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        var me = this;
        if (me.routeTable) {
            me.routeTable = null;
        }
        me.routeIDField = null;
        me.attributeFilter = null;
        me.eventTable = null;
        me.eventRouteIDField = null;
        me.measureField = null;
        me.measureStartField = null;
        me.measureEndField = null;
        me.measureOffsetField = null;
        me.errorInfoField = null;
        if (me.dataReturnOption) {
            me.dataReturnOption.destroy();
            me.dataReturnOption = null;
        }
    }


}

;// CONCATENATED MODULE: ./src/common/iServer/GenerateSpatialDataService.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/




/**
 * @class GenerateSpatialDataService
 * @deprecatedclass SuperMap.GenerateSpatialDataService
 * @category iServer SpatialAnalyst GenerateSpatialData
 * @classdesc 动态分段分析服务类。该类负责将客户设置的动态分段分析服务参数传递给服务端，并接收服务端返回的动态分段分析结果数据。
 * 获取的结果数据包括 originResult 、result 两种，其中，originResult 为服务端返回的用 JSON 对象表示的动态分段分析结果数据，result 为服务端返回的动态分段分析结果数据。
 * @param {string} url - 服务地址。如 http://localhost:8090/iserver/services/spatialanalyst-changchun/restjsr/spatialanalyst。
 * @param {Object} options - 参数。</br>
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @extends {SpatialAnalystBase}
 * @example 实例化该类如下例所示：
 * (start code)
 *  function GenerateSpatialData(){
     *
     *  //配置数据返回选项(option)
     *  var option = new DataReturnOption({
     *      expectCount: 1000,
     *      dataset: "generateSpatialData",
     *      deleteExistResultDataset: true,
     *      dataReturnMode: DataReturnMode.DATASET_ONLY
     *  }),
     *  //配置动态分段参数(Parameters)
     *  parameters = new GenerateSpatialDataParameters({
     *      routeTable: "RouteDT_road@Changchun",
     *      routeIDField: "RouteID",
     *      eventTable: "LinearEventTabDT@Changchun",
     *      eventRouteIDField: "RouteID",
     *      measureField: "",
     *      measureStartField: "LineMeasureFrom",
     *      measureEndField: "LineMeasureTo",
     *      measureOffsetField: "",
     *      errorInfoField: "",
     *      retainedFields:[],
     *      dataReturnOption: option
     *  }),
     *  //配置动态分段iService
     *  iService = new GenerateSpatialDataService(Changchun_spatialanalyst);
     *  //执行
     *  iService.processAsync(parameters, generateCompleted);
     *  function Completed(generateSpatialDataEventArgs){//todo};
     *  function Error(generateSpatialDataEventArgs){//todo};
     * (end)
     * @usage
     */
class GenerateSpatialDataService extends SpatialAnalystBase {

    constructor(url, options) {
        super(url, options);

        this.CLASS_NAME = "SuperMap.GenerateSpatialDataService";
    }

    /**
     * @function GenerateSpatialDataService.prototype.destroy
     * @override
     */
    destroy() {
        super.destroy();
    }


    /**
     * @function GenerateSpatialDataService.prototype.processAsync
     * @description 负责将客户端的动态分段服务参数传递到服务端。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @param {GenerateSpatialDataParameters} params - 动态分段操作参数类。
     * @returns {Promise} Promise 对象。
     */
    processAsync(params, callback) {
        if (!(params instanceof GenerateSpatialDataParameters)) {
            return;
        }
        var me = this,
            jsonParameters;

        jsonParameters = me.getJsonParameters(params);

        return me.request({
            method: "POST",
            data: jsonParameters,
            scope: me,
            success: callback,
            failure: callback
        });
    }


    /**
     * @function GenerateSpatialDataService.prototype.getJsonParameters
     * @description 将参数转化为 JSON 字符串。
     * @param {GenerateSpatialDataParameters} params - 动态分段操作参数类。
     * @returns {string}转化后的JSON字符串。
     */
    getJsonParameters(params) {
        var jsonParameters = "",
            jsonStr = "datasets/" + params.routeTable + "/linearreferencing/generatespatialdata",
            me = this;

        me.url = Util_Util.urlPathAppend(me.url, jsonStr);
        me.url = Util_Util.urlAppend(me.url, 'returnContent=true');
        jsonParameters = Util_Util.toJSON(params);
        return jsonParameters;
    }


}

;// CONCATENATED MODULE: ./src/common/iServer/GeoRelationAnalystParameters.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


/**
 * @class GeoRelationAnalystParameters
 * @deprecatedclass SuperMap.GeoRelationAnalystParameters
 * @category iServer SpatialAnalyst GeoRelationAnalyst
 * @classdesc 空间关系分析服务参数类。使用该类可以为空间关系分析服务提供所需的参数信息。
 * @param {Object} options - 参数。
 * @param {FilterParameter} options.sourceFilter - 空间关系分析中的源数据集查询参数。仅 name, ids, attributeFilter 和 fields 字段有效。
 * @param {FilterParameter} options.referenceFilter - 空间关系分析中的参考数据集查询参数。仅 name, ids, attributeFilter 和 fields 字段有效。
 * @param {SpatialRelationType} options.spatialRelationType - 指定的空间关系类型。
 * @param {boolean} [options.isBorderInside] - 边界处理方式，即位于面边线上的点是否被面包含。此参数仅用于空间关系为包含或被包含的情况。
 * @param {boolean} [options.returnFeature] - 是否返回 Feature 信息。
 * @param {boolean} [options.returnGeoRelatedOnly=true] - 仅返回满足指定空间关系的空间对象。
 * @param {number} [options.startRecord=0] - 分析结果起始记录位置。
 * @param {number} [options.expectCount=500] - 空间关系分析期望返回结果记录数，如果实际不足500条结果则返回所有分析结果。
 * @usage
 */
class GeoRelationAnalystParameters {


    constructor(options) {
        /**
         *  @member {string} GeoRelationAnalystParameters.prototype.dataset
         *  @description 源数据集名称。
         */
        this.dataset = null;

        /**
         * @member {FilterParameter} GeoRelationAnalystParameters.prototype.sourceFilter
         * @description 空间关系分析中的源数据集查询参数。仅 ids、attributeFilter 和 fields 字段有效。
         */
        this.sourceFilter = null;

        /**
         * @member {FilterParameter} GeoRelationAnalystParameters.prototype.referenceFilter
         * @description 空间关系分析中的参考数据集查询参数。仅 name，ids，attributeFilter 和 fields 字段有效。
         */
        this.referenceFilter = null;

        /**
         * @member {SpatialRelationType} GeoRelationAnalystParameters.prototype.spatialRelationType
         * @description 指定的空间关系类型。
         */
        this.spatialRelationType = null;

        /**
         * @member {boolean} [GeoRelationAnalystParameters.prototype.isBorderInside]
         * @description 边界处理方式，即位于面边线上的点是否被面包含。此参数仅用于空间关系为包含或被包含的情况。
         */
        this.isBorderInside = null;

        /**
         * @member {boolean} [GeoRelationAnalystParameters.prototype.returnFeature]
         * @description 是否返回 Feature 信息。
         */
        this.returnFeature = null;

        /**
         * @member {boolean} [GeoRelationAnalystParameters.prototype.returnGeoRelatedOnly=true]
         * @description 是否仅返回满足指定空间关系的空间对象。
         */
        this.returnGeoRelatedOnly = null;

        /**
         * @member {number} [GeoRelationAnalystParameters.prototype.returnGeoRelatedOnly=0]
         * @description 分析结果起始记录位置。
         */
        this.startRecord = 0;

        /**
         * @member {number} [GeoRelationAnalystParameters.prototype.expectCount=500]
         * @description 空间关系分析期望返回结果记录数，如果实际不足 500 条结果则返回所有分析结果。
         */
        this.expectCount = 500;
        if (options) {
            Util_Util.extend(this, options);
        }

        this.CLASS_NAME = "SuperMap.GeoRelationAnalystParameters";
    }

    /**
     * @function GeoRelationAnalystParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        var me = this;
        if (me.sourceFilter) {
            me.sourceFilter.destroy();
        }
        me.sourceFilter = null;

        if (me.referenceFilter) {
            me.referenceFilter.destroy();
        }
        me.referenceFilter = null;

        me.dataset = null;
        me.spatialRelationType = null;
        me.isBorderInside = null;
        me.returnFeature = null;
        me.returnGeoRelatedOnly = null;
        me.startRecord = null;
        me.expectCount = null;
    }

}

;// CONCATENATED MODULE: ./src/common/iServer/GeoRelationAnalystService.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/




/**
 * @class GeoRelationAnalystService
 * @deprecatedclass SuperMap.GeoRelationAnalystService
 * @category iServer SpatialAnalyst GeoRelationAnalyst
 * @classdesc 空间关系分析服务类。该类负责将客户设置的空间关系分析服务参数传递给服务端，并接收服务端返回的空间关系分析结果数据。
 * @param {string} url - 服务地址。如 http://localhost:8090/iserver/services/spatialanalyst-changchun/restjsr/spatialanalyst。
 * @param {Object} options - 参数。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @extends {SpatialAnalystBase}
 * @example 实例化该类如下例所示：
 * (start code)
 *  function datasetGeoRelationAnalystProcess() {
     *      var referenceFilter = new FilterParameter({
     *                              name:"Frame_R@Changchun",
     *                              attributeFilter:"SmID>0"});
     *      var sourceFilter = new FilterParameter({
     *                          attributeFilter:"SmID>0"});
     *      //初始化服务类
     *      var datasetGeoRelationService = new GeoRelationAnalystService(
     *          "http://localhost:8090/iserver/services/spatialanalyst-changchun/restjsr/spatialanalyst/"),
     *      //构建参数类
     *      datasetGeoRelationParameters = new GeoRelationAnalystParameters({
     *          dataset: "Park@Changchun",
     *          startRecord: 0,
     *          expectCount: 20,
     *          sourceFilter: sourceFilter,
     *          referenceFilter: referenceFilter,
     *          spatialRelationType: SpatialRelationType.INTERSECT,
     *          isBorderInside: true,
     *          returnFeature: true,
     *          returnGeoRelatedOnly: true
     *      });
     *      datasetGeoRelationService.events.on({
     *          "processCompleted": datasetGeoRelationAnalystCompleted,
     *          "processFailed": datasetGeoRelationAnalystFailed});
     *      //执行
     *      datasetGeoRelationService.processAsync(datasetGeoRelationParameters);
     *  }
 *  function Completed(datasetGeoRelationAnalystCompleted){//todo};
 *  function Error(datasetGeoRelationAnalystFailed){//todo};
 * (end)
 * @usage
 */
class GeoRelationAnalystService extends SpatialAnalystBase {

    constructor(url, options) {
        super(url, options);
        this.CLASS_NAME = "SuperMap.GeoRelationAnalystService";
    }

    /**
     * @function GeoRelationAnalystService.prototype.destroy
     * @override
     */
    destroy() {
        super.destroy();
    }

    /**
     * @function GeoRelationAnalystService.prototype.processAsync
     * @description 负责将客户端的空间关系分析参数传递到服务端
     * @param {GeoRelationAnalystParameters} parameter - 空间关系分析所需的参数信息。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    processAsync(parameter, callback) {
        if (!(parameter instanceof GeoRelationAnalystParameters)) {
            return;
        }
        var me = this;
        me.url = Util_Util.urlPathAppend(me.url, 'datasets/' + parameter.dataset + '/georelation');
        var jsonParameters = Util_Util.toJSON(parameter);

        me.url = Util_Util.urlAppend(me.url, 'returnContent=true');

        return me.request({
            method: "POST",
            data: jsonParameters,
            scope: me,
            success: callback,
            failure: callback
        });
    }


}

;// CONCATENATED MODULE: ./src/common/iServer/InterpolationAnalystParameters.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


/**
 * @class InterpolationAnalystParameters
 * @deprecatedclass SuperMap.InterpolationAnalystParameters
 * @category iServer SpatialAnalyst InterpolationAnalyst
 * @classdesc 插值分析参数类。
 * @param {Object} options - 参数。
 * @param {(SuperMap.Bounds|L.Bounds|L.LatLngBounds|ol.extent|mapboxgl.LngLatBounds|GeoJSONObject)} options.bounds - 插值分析的范围，用于确定结果栅格数据集的范围。
 * @param {string} options.outputDatasetName - 插值分析结果数据集的名称。
 * @param {string} options.outputDatasourceName - 插值分析结果数据源的名称。
 * @param {string} [options.zValueFieldName] - 进行插值分析的字段名称，插值分析不支持文本类型的字段。
 * @param {string} [options.dataset] - 待分析的数据集名称。当插值分析类型（InterpolationAnalystType）为 dataset 时，此为必选参数。
 * @param {Array.<GeometryPoint|L.LatLng|L.Point|ol.geom.Point|mapboxgl.LngLat|Array.<number>>} [options.inputPoints] - 用于做插值分析的离散点集合。当插值分析类型（InterpolationAnalystType）为 geometry 时，此参数为必设参数。
 * @param {number} [options.searchRadius=0] - 查找半径，即参与运算点的查找范围，与点数据集单位相同。
 * @param {number} [options.zValueScale=1] - 进行插值分析值的缩放比率。
 * @param {number} [options.resolution] - 插值结果栅格数据集的分辨率，即一个像元所代表的实地距离，与点数据集单位相同。
 * @param {FilterParameter} [options.filterQueryParameter] - 属性过滤条件。
 * @param {PixelFormat} [options.pixelFormat] - 指定结果栅格数据集存储的像素格式。
 * @param {string} [options.InterpolationAnalystType="dataset"] - 插值分析类型（"dataset" 或 "geometry"）。
 * @usage
 */
class InterpolationAnalystParameters {

    constructor(options) {
        if (!options) {
            return;
        }
        /**
         * @member {(SuperMap.Bounds|L.Bounds|L.LatLngBounds|ol.extent|mapboxgl.LngLatBounds|GeoJSONObject)} InterpolationAnalystParameters.prototype.bounds
         * @description 插值分析的范围，用于确定结果栅格数据集的范围。
         * 如果缺省，则默认为原数据集的范围。鉴于此插值方法为内插方法，原数据集的范围内的插值结果才相对有参考价值，
         * 因此建议此参数不大于原数据集范围。
         */
        this.bounds = null;

        /**
         * @member {number} [InterpolationAnalystParameters.prototype.searchRadius=0]
         * @description 查找半径，即参与运算点的查找范围，与点数据集单位相同。
         * 计算某个位置的 Z 值时，会以该位置为圆心，以查找范围的值为半径，落在这个范围内的采样点都将参与运算。
         * 该值需要根据待插值点数据的分布状况和点数据集范围进行设置。
         */
        this.searchRadius = 0;

        /**
         * @member {string} InterpolationAnalystParameters.prototype.zValueFieldName
         * @description 数据集插值分析中，用于指定进行插值分析的目标字段名，插值分析不支持文本类型的字段。
         * 含义为每个插值点在插值过程中的权重，可以将所有点此字段值设置为 1，即所有点在整体插值中权重相同。
         * 当插值分析类型（InterpolationAnalystType）为 dataset 时，此为必选参数。
         */
        this.zValueFieldName = null;

        /**
         * @member {number} [InterpolationAnalystParameters.prototype.zValueScale=1]
         * @description 用于进行插值分析值的缩放比率。
         * 参加插值分析的值将乘以该参数值后再进行插值，也就是对进行插值分析的值进行统一的扩大或缩小。
         */
        this.zValueScale = 1;

        /**
         * @member {number} InterpolationAnalystParameters.prototype.resolution
         * @description 插值结果栅格数据集的分辨率，即一个像元所代表的实地距离，与点数据集单位相同。
         * 该值不能超过待分析数据集的范围边长。
         * 且该值设置时，应该考虑点数据集范围大小来取值，一般为结果栅格行列值（即结果栅格数据集范围除以分辨率），在 500 以内可以较好地体现密度走势。
         */
        this.resolution = null;

        /**
         * @member {FilterParameter} [InterpolationAnalystParameters.prototype.filterQueryParameter]
         * @description 过滤条件，对分析数据集中的点进行过滤，设置为 null 表示对数据集中的所有点进行分析。
         */
        this.filterQueryParameter = null;

        /**
         * @member {string} InterpolationAnalystParameters.prototype.outputDatasetName
         * @description 插值分析结果数据集的名称。
         */
        this.outputDatasetName = null;

        /**
         * @member {string} InterpolationAnalystParameters.prototype.outputDatasourceName
         * @description 插值分析结果数据源的名称。
         */
        this.outputDatasourceName = null;

        /**
         * @member {PixelFormat} [InterpolationAnalystParameters.prototype.pixelFormat]
         * @description 指定结果栅格数据集存储的像素格式。支持存储的像素格式有 BIT16、BIT32、DOUBLE、SINGLE、UBIT1、UBIT4、UBIT8、UBIT24、UBIT32。
         */
        this.pixelFormat = null;

        /**
         * @member {string} [InterpolationAnalystParameters.prototype.dataset]
         * @description 用来做插值分析的数据源中数据集的名称，该名称用形如 "数据集名称@数据源别名" 形式来表示。
         * 当插值分析类型（InterpolationAnalystType）为 dataset 时，此为必选参数。
         */
        this.dataset = null;

        /**
         * @member {Array.<GeometryPoint|L.LatLng|L.Point|ol.geom.Point|mapboxgl.LngLat|Array.<number>>} [InterpolationAnalystParameters.prototype.inputPoints]
         * @description 用于做插值分析的离散点（离散点包括Z值）集合。
         * 当插值分析类型（InterpolationAnalystType）为 geometry 时，此参数为必设参数。
         * 通过离散点直接进行插值分析不需要指定输入数据集inputDatasourceName，inputDatasetName以及zValueFieldName。
         */
        this.inputPoints = null;

        /**
         * @member {string} [InterpolationAnalystParameters.prototype.InterpolationAnalystType="dataset"]
         * @description  插值分析类型。插值分析包括数据集插值分析和几何插值分析两类，
         *               "dataset" 表示对数据集进行插值分析，"geometry" 表示对离散点数组进行插值分析。
         */
        this.InterpolationAnalystType = "dataset";

        /**
         * @member {ClipParameter} InterpolationAnalystParameters.prototype.clipParam
         * @description 对插值分析结果进行裁剪的参数。
         */
        this.clipParam = null;

        Util_Util.extend(this, options);
        this.CLASS_NAME = "SuperMap.InterpolationAnalystParameters";
    }

    /**
     * @function InterpolationAnalystParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        var me = this;
        me.bounds = null;
        me.searchRadius = null;
        me.zValueFieldName = null;
        me.zValueScale = null;

        me.resolution = null;
        me.filterQueryParameter = null;
        me.outputDatasetName = null;
        me.pixelFormat = null;
    }

    /**
     * @function InterpolationAnalystParameters.toObject
     * @param {InterpolationAnalystParameters} interpolationAnalystParameters - 插值分析参数类。
     * @param {InterpolationAnalystParameters} tempObj - 插值分析参数对象。
     * @description 将插值分析参数对象转换成 JSON 对象。
     * @returns JSON 对象。
     */
    static toObject(interpolationAnalystParameters, tempObj) {
        for (var name in interpolationAnalystParameters) {
            if (name === "inputPoints" && interpolationAnalystParameters.InterpolationAnalystType === "geometry") {
                var objs = [];
                for (var i = 0; i < interpolationAnalystParameters.inputPoints.length; i++) {
                    var item = interpolationAnalystParameters.inputPoints[i];
                    var obj = {
                        x: item.x,
                        y: item.y,
                        z: item.tag
                    };
                    objs.push(obj);
                }
                tempObj[name] = objs;
            } else {
                tempObj[name] = interpolationAnalystParameters[name];
            }
        }
    }
}

;// CONCATENATED MODULE: ./src/common/iServer/InterpolationRBFAnalystParameters.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/



/**
 * @class InterpolationRBFAnalystParameters
 * @deprecatedclass SuperMap.InterpolationRBFAnalystParameters
 * @category iServer SpatialAnalyst InterpolationAnalyst
 * @classdesc 样条插值（径向基函数插值法）分析参数类。
 * @extends {InterpolationAnalystParameters}
 * @param {Object} options - 参数。
 * @param {(SuperMap.Bounds|L.Bounds|L.LatLngBounds|ol.extent|mapboxgl.LngLatBounds|GeoJSONObject)} options.bounds - 插值分析的范围，用于确定结果栅格数据集的范围。
 * @param {string} options.searchMode - 插值运算时，查找参与运算点的方式，有固定点数查找、定长查找、块查找。
 * @param {string} options.outputDatasetName - 插值分析结果数据集的名称。
 * @param {string} options.outputDatasourceName - 插值分析结果数据源的名称。
 * @param {string} [options.zValueFieldName] - 存储用于进行插值分析的字段名称，插值分析不支持文本类型的字段。当插值分析类型(SuperMap.InterpolationAnalystType)为 dataset 时，此为必选参数。
 * @param {number} [options.smooth=0.1] - 光滑系数，该值表示插值函数曲线与点的逼近程度，值域为0到1。
 * @param {number} [options.tension=40] - 张力系数，用于调整结果栅格数据表面的特性。
 * @param {number} [options.expectedCount=12] - 【固定点数查找】方式下，设置参与插值运算的点数。
 * @param {number} [options.searchRadius=0] - 【定长查找】方式下，设置参与运算点的查找范围。
 * @param {number} [options.maxPointCountForInterpolation=200] - 【块查找】方式下，设置最多参与插值的点数。
 * @param {number} [options.maxPointCountInNode=50] - 【块查找】方式下，设置单个块内最多参与运算点数。
 * @param {number} [options.zValueScale=1] - 用于进行插值分析值的缩放比率。
 * @param {number} [options.resolution] - 插值结果栅格数据集的分辨率，即一个像元所代表的实地距离，与点数据集单位相同。
 * @param {FilterParameter} [options.filterQueryParameter] - 属性过滤条件。
 * @param {PixelFormat} [options.pixelFormat] - 指定结果栅格数据集存储的像素格式。
 * @param {string} [options.dataset] - 要用来做插值分析的数据源中数据集的名称。该名称用形如”数据集名称@数据源别名”形式来表示。当插值分析类型(InterpolationAnalystType)为 dataset 时。此为必选参数。
 * @param {Array.<GeometryPoint|L.LatLng|L.Point|ol.geom.Point|mapboxgl.LngLat|Array.<number>>} [options.inputPoints] - 用于做插值分析的离散点集合。当插值分析类型（InterpolationAnalystType）为 geometry 时。此为必选参数。
 * @example
 * var myInterpolationRBFAnalystParameters = new InterpolationRBFAnalystParameters({
 *     dataset:"SamplesP@Interpolation",
 *     smooth: 0.1,
 *     tension: 40,
 *     searchMode: "QUADTREE",
 *     maxPointCountForInterpolation: 20,
 *     maxPointCountInNode: 5,
 *     pixelFormat: "BIT16",
 *     zValueFieldName: "AVG_TMP",
 *     resolution: 3000,
 *     filterQueryParameter: {
 *         attributeFilter: ""
 *     },
 *     outputDatasetName: "myRBF"
 * });
 * @usage
 */
class InterpolationRBFAnalystParameters extends InterpolationAnalystParameters {

    constructor(options) {
        super(options);
        /**
         * @member {number} [InterpolationRBFAnalystParameters.prototype.smooth=0.1]
         * @description 光滑系数，值域为 0 到 1，常用取值如 0、0.001、0.01、0.1、和 0.5。
         * 该值表示插值函数曲线与点的逼近程度，此数值越大，函数曲线与点的偏差越大，反之越小。
         */
        this.smooth = 0.1;

        /**
         * @member {number} [InterpolationRBFAnalystParameters.prototype.tension=40]
         * @description 张力系数，常用取值如 0、1、5 和 10。
         * 用于调整结果栅格数据表面的特性，张力越大，插值时每个点对计算结果影响越小，反之越大。
         */
        this.tension = 40;

        /**
         * @member {SearchMode} InterpolationRBFAnalystParameters.prototype.searchMode
         * @description 插值运算时，查找参与运算点的方式，有固定点数查找、定长查找、块查找。必设参数。
         * 具体如下：
         * {KDTREE_FIXED_COUNT} 使用 KDTREE 的固定点数方式查找参与内插分析的点。
         * {KDTREE_FIXED_RADIUS} 使用 KDTREE 的定长方式查找参与内插分析的点。
         * {QUADTREE} 使用 QUADTREE 方式查找参与内插分析的点（块查找）。
         */
        this.searchMode = null;

        /**
         * @member {number} [InterpolationRBFAnalystParameters.prototype.expectedCount=12]
         * @description 【固定点数查找】方式下，设置待查找的点数，即参与插值运算的点数。
         */
        this.expectedCount = 12;

        /**
         * @member {number} [InterpolationRBFAnalystParameters.prototype.maxPointCountForInterpolation=200]
         * @description 【块查找】方式下，最多参与插值的点数。
         */
        this.maxPointCountForInterpolation = 200;

        /**
         * @member {number} [InterpolationRBFAnalystParameters.prototype.maxPointCountInNode=50]
         * @description 【块查找】方式下，单个块内最多参与运算点数。
         */
        this.maxPointCountInNode = 50;

        if (options) {
            Util_Util.extend(this, options);
        }
        this.CLASS_NAME = "SuperMap.InterpolationRBFAnalystParameters";

    }


    /**
     * @function InterpolationRBFAnalystParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        super.destroy();
        var me = this;
        me.smooth = null;
        me.tension = null;
        me.searchMode = null;
        me.expectedCount = null;
        me.maxPointCountForInterpolation = null;
        me.maxPointCountInNode = null;
    }

    /**
     * @function InterpolationRBFAnalystParameters.toObject
     * @param {InterpolationRBFAnalystParameters} datasetInterpolationRBFAnalystParameters - 样条插值（径向基函数插值法）分析参数类。
     * @param {InterpolationRBFAnalystParameters} tempObj - 样条插值（径向基函数插值法）分析参数对象。
     * @description 将样条插值（径向基函数插值法）分析参数对象转换为 JSON 对象。
     * @returns JSON 对象。
     */
    static toObject(datasetInterpolationRBFAnalystParameters, tempObj) {
        for (var name in datasetInterpolationRBFAnalystParameters) {
            tempObj[name] = datasetInterpolationRBFAnalystParameters[name];

        }
    }
}


;// CONCATENATED MODULE: ./src/common/iServer/InterpolationDensityAnalystParameters.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/



/**
 * @class InterpolationDensityAnalystParameters
 * @deprecatedclass SuperMap.InterpolationDensityAnalystParameters
 * @category iServer SpatialAnalyst InterpolationAnalyst
 * @classdesc 点密度插值分析参数类。
 * @param {Object} options - 参数。
 * @param {(SuperMap.Bounds|L.Bounds|L.LatLngBounds|ol.extent|mapboxgl.LngLatBounds|GeoJSONObject)} options.bounds - 插值分析的范围，用于确定结果栅格数据集的范围。
 * @param {string} options.outputDatasourceName - 插值分析结果数据源的名称。
 * @param {string} options.outputDatasetName - 插值分析结果数据集的名称。
 * @param {number} [options.searchRadius=0] - 查找半径，即参与运算点的查找范围，与点数据集单位相同。
 * @param {string} [options.zValueFieldName] - 进行插值分析的字段名称，插值分析不支持文本类型的字段。当插值分析类型(InterpolationAnalystParameters.prototype.InterpolationAnalystType)为 dataset 时。此为必选参数。
 * @param {number} [options.zValueScale=1] - 进行插值分析值的缩放比率。
 * @param {number} [options.resolution] - 插值结果栅格数据集的分辨率，即一个像元所代表的实地距离，与点数据集单位相同。
 * @param {FilterParameter} [options.filterQueryParameter] - 属性过滤条件。
 * @param {PixelFormat} [options.pixelFormat] - 指定结果栅格数据集存储的像素格式。
 * @param {string} [options.dataset] - 用来做插值分析的数据源中数据集的名称，该名称用形如 "数据集名称@数据源别名" 形式来表示。当插值分析类型（InterpolationAnalystParameters.prototype.InterpolationAnalystType）为 dataset 时，此为必选参数。
 * @param {Array.<GeometryPoint|L.LatLng|L.Point|ol.geom.Point|mapboxgl.LngLat|Array.<number>>} [options.inputPoints] - 用于做插值分析的离散点集合。当插值分析类型（InterpolationAnalystParameters.prototype.InterpolationAnalystType）为 geometry 时，此为必选参数。
 * @extends {InterpolationAnalystParameters}
 * @example
 * var myInterpolationDensityAnalystParameters = new InterpolationDensityAnalystParameters({
 *      dataset: "SamplesP@Interpolation",
 *      searchRadius: "100000",
 *      pixelFormat: "BIT16",
 *      zValueFieldName: "AVG_TMP",
 *      resolution: 3000,
 *      filterQueryParameter: {
 *          attributeFilter: ""
 *      },
 *      outputDatasetName: "myDensity"
 * });
 * @usage
 */
class InterpolationDensityAnalystParameters extends InterpolationAnalystParameters {


    constructor(options) {
        super(options);
        if (options) {
            Util_Util.extend(this, options);
        }
        this.CLASS_NAME = "SuperMap.InterpolationDensityAnalystParameters";
    }

    /**
     * @function InterpolationDensityAnalystParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        super.destroy();
    }
}

;// CONCATENATED MODULE: ./src/common/iServer/InterpolationIDWAnalystParameters.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/



/**
 * @class InterpolationIDWAnalystParameters
 * @deprecatedclass SuperMap.InterpolationIDWAnalystParameters
 * @category  iServer SpatialAnalyst InterpolationAnalyst
 * @classdesc 反距离加权插值（IDW）分析参数类。
 * @param {Object} options - 参数。
 * @param {(SuperMap.Bounds|L.Bounds|L.LatLngBounds|ol.extent|mapboxgl.LngLatBounds|GeoJSONObject)} options.bounds - 插值分析的范围，用于确定结果栅格数据集的范围。
 * @param {string} options.searchMode - 插值运算时，查找参与运算点的方式，支持固定点数查找、定长查找。
 * @param {string} options.outputDatasetName - 插值分析结果数据集的名称。
 * @param {string} options.outputDatasourceName - 插值分析结果数据源的名称。
 * @param {string} [options.zValueFieldName] - 进行插值分析的字段名称，插值分析不支持文本类型的字段。当插值分析类型(SuperMap.InterpolationAnalystType)为 dataset 时，此为必选参数。
 * @param {number} [options.expectedCount=12] - 【固定点数查找】方式下，设置待查找的点数，即参与插值运算的点数。
 * @param {number} [options.searchRadius=0] - 【定长查找】方式下，设置查找半径，即参与运算点的查找范围，与点数据集单位相同。
 * @param {number} [options.power=2] - 距离权重计算的幂次。
 * @param {number} [options.zValueScale=1] - 用于进行插值分析值的缩放比率。
 * @param {number} [options.resolution] - 插值结果栅格数据集的分辨率，即一个像元所代表的实地距离，与点数据集单位相同。
 * @param {FilterParameter} [options.filterQueryParameter] - 属性过滤条件。
 * @param {PixelFormat} [options.pixelFormat] - 指定结果栅格数据集存储的像素格式。
 * @param {string} [options.dataset] - 要用来做插值分析的数据源中数据集的名称。该名称用形如”数据集名称@数据源别名”形式来表示。当插值分析类型(SuperMap.InterpolationAnalystType)为 dataset 时，此为必选参数。
 * @param {Array.<GeometryPoint|L.LatLng|L.Point|ol.geom.Point|mapboxgl.LngLat|Array.<number>>} [options.inputPoints] - 用于做插值分析的离散点集合。当插值分析类型（SuperMap.InterpolationAnalystType）为 geometry 时，此为必选参数。
 * @extends {InterpolationAnalystParameters}
 * @example 例如：
 * var myInterpolationIDWAnalystParameters = new InterpolationIDWAnalystParameters({
 *      dataset:"SamplesP@Interpolation",
 *      power: 2,
 *      searchMode: "KDTREE_FIXED_COUNT",
 *      expectedCount: 12,
 *      pixelFormat: "BIT16",
 *      zValueFieldName: "AVG_TMP",
 *      resolution: 3000,
 *      filterQueryParameter: {
 *          attributeFilter: ""
 *      },
 *      outputDatasetName: "myIDW"
 * });
 * @usage
 */
class InterpolationIDWAnalystParameters extends InterpolationAnalystParameters {



    constructor(options) {
        super(options);
        /**
         * @member {number} [InterpolationIDWAnalystParameters.prototype.power=2]
         * @description 距离权重计算的幂次。
         * 该值决定了权值下降的速度，幂次越大，随距离的增大权值下降越快，距离预测点越远的点的权值也越小。
         * 理论上，参数值必须大于0，但是0.5到3之间时运算结果更合理，因此推荐值为0.5~3。
         */
        this.power = 2;

        /**
         * @member {SearchMode} InterpolationIDWAnalystParameters.prototype.searchMode
         * @description 插值运算时，查找参与运算点的方式，支持固定点数查找、定长查找。
         * 具体如下：
         * {KDTREE_FIXED_COUNT} 使用 KDTREE 的固定点数方式查找参与内插分析的点。
         * {KDTREE_FIXED_RADIUS} 使用 KDTREE 的定长方式查找参与内插分析的点。
         */
        this.searchMode = null;

        /**
         * @member {number} [InterpolationIDWAnalystParameters.prototype.expectedCount=12]
         * @description 【固定点数查找】方式下，设置待查找的点数，即参与插值运算的点数。
         */
        this.expectedCount = 12;
        if (options) {
            Util_Util.extend(this, options);
        }
        this.CLASS_NAME = "SuperMap.InterpolationIDWAnalystParameters";
    }

    /**
     * @function InterpolationIDWAnalystParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        super.destroy();
        var me = this;
        me.power = null;
        me.searchMode = null;
        me.expectedCount = null;
    }
}


;// CONCATENATED MODULE: ./src/common/iServer/ThiessenAnalystParameters.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


/**
 * @class ThiessenAnalystParameters
 * @deprecatedclass SuperMap.ThiessenAnalystParameters
 * @category  iServer SpatialAnalyst ThiessenPolygonAnalyst
 * @classdesc 泰森多边形分析参数基类。
 * @param {Object} options - 可选参数。
 * @param {GeometryPolygon|L.Polygon|ol.geom.Polygon|GeoJSONObject} [options.clipRegion] - 结果数据裁剪区域，可以为 null，表示不对结果进行裁剪。
 * @param {boolean} [options.createResultDataset=false] - 是否返回结果数据集。
 * @param {string} [options.resultDatasetName] - 指定结果数据集名称。
 * @param {string} [options.resultDatasourceName] - 指定结果数据集所在数据源，默认为当前数据源。
 * @param {boolean} [options.returnResultRegion=true] - 是否返回分析得到的多边形面数组。
 * @usage
 */
class ThiessenAnalystParameters {

    constructor(options) {
        if (!options) {
            return;
        }
        /**
         * @member {GeometryPolygon|L.Polygon|ol.geom.Polygon|GeoJSONObject} [ThiessenAnalystParameters.prototype.clipRegion]
         * @description 结果数据裁剪区域，可以为 null，表示不对结果进行裁剪。
         */
        this.clipRegion = null;

        /**
         *  @member {boolean} [ThiessenAnalystParameters.prototype.createResultDataset=false]
         *  @description 是否返回结果数据集。如果为 true，则必须设置属性 resultDatasetName 和 resultDatasourceName。
         */
        this.createResultDataset = false;

        /**
         * @member {string} ThiessenAnalystParameters.prototype.resultDatasetName
         * @description 指定结果数据集名称。
         */
        this.resultDatasetName = null;

        /**
         * @member {string} ThiessenAnalystParameters.prototype.resultDatasourceName
         * @description 指定结果数据集所在数据源。
         */
        this.resultDatasourceName = null;

        /**
         * @member {boolean} ThiessenAnalystParameters.prototype.returnResultRegion
         * @description 是否返回分析得到的多边形面数组。
         */
        this.returnResultRegion = true;

        Util_Util.extend(this, options);

        this.CLASS_NAME = "SuperMap.ThiessenAnalystParameters";
    }

    /**
     * @function ThiessenAnalystParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        var me = this;
        if (me.clipRegion) {
            me.clipRegion.destroy();
            me.clipRegion = null;
        }
        me.createResultDataset = null;
        me.resultDatasetName = null;
        me.resultDatasourceName = null;
        me.returnResultRegion = null;
    }

}

;// CONCATENATED MODULE: ./src/common/iServer/InterpolationKrigingAnalystParameters.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/





/**
 * @class InterpolationKrigingAnalystParameters
 * @deprecatedclass SuperMap.InterpolationKrigingAnalystParameters
 * @category iServer SpatialAnalyst InterpolationAnalyst
 * @classdesc 克吕金插值分析参数类。通过该类可以设置克吕金插值分析所需的参数。
 * 克吕金（Kriging）法为地统计学上一种空间数据内插处理方法，主要的目的是利用各数据点间变异数（variance）的大小来推求某一未知点与各已知点的权重关系，
 * 再由各数据点的值和其与未知点的权重关系推求未知点的值。Kriging 法最大的特色不仅是提供一个最小估计误差的预测值，并且可明确地指出误差值的大小。
 * 一般而言，许多地质参数，如地形面，本身即具有连续性，故在一段距离内的任两点必有空间上的关系。反之，在一不规则面上的两点若相距甚远，
 * 则在统计意义上可视为互为独立 (stastically indepedent)。这种随距离而改变的空间上连续性，可用半变异图 (semivariogram) 来表现。
 * 因此，若想由已知的散乱点来推求某一未知点的值，则可利用半变异图推求各已知点与未知点的空间关系，即以下四个参数：<br>
 * 1.块金值（nugget）：当采样点间距为0时，理论上半变异函数值为0，但时间上两采样点非常接近时半变异函数值并不为0，即产生了块金效应，
 * 对应的半变异函数值为块金值。块金值可能由于测量误差或者空间变异产生。<br>
 * 2.基台值（sill）：随着采样点间距的不断增大，半变异函数的值趋向一个稳定的常数，该常数成为基台值。到达基台值后，半变异函数的值不再随采样点间距而改变，
 *   即大于此间距的采样点不再具有空间相关性。<br>
 * 3.偏基台值：基台值与块金值的差值。<br>
 * 4.自相关阈值（range）：也称变程，是半变异函数值达到基台值时，采样点的间距。超过自相关阈值的采样点不再具有空间相关性，将不对预测结果产生影响。<br>
 * 然后，由此空间参数推求半变异数，由各数据点间的半变异数可推求未知点与已知点间的权重关系，进而推求出未知点的值。
 * 克吕金法的优点是以空间统计学作为其坚实的理论基础，物理含义明确；不但能估计测定参数的空间变异分布，而且还可以估算参数的方差分布。克吕金法的缺点是计算步骤较烦琐，
 * 计算量大，且变异函数有时需要根据经验人为选定。
 *
 * 由上述可知，半变异函数是克吕金插值的关键，因此选择合适的半变异函数模型非常重要，SuperMap 提供了以下三种半变异函数模型：<br>
 * 1.指数型（EXPONENTIAL）：适用于空间相关关系随样本间距的增加呈指数递减的情况，其空间自相关关系在样本间距的无穷远处完全消失。<br>
 * 2.球型（SPHERICAL）：适用于空间自相关关系随样本间距的增加而逐渐减少，直到超出一定的距离时空间自相关关系消失的情况。<br>
 * 3.高斯型（GAUSSIAN）：适用于半变异函数值渐进地逼近基台值的情况。<br>
 *
 * 半变异函数中，有一个关键参数即插值的字段值的期望（平均值），由于对于此参数的不同处理方法而衍生出了不同的 Kriging 方法。SuperMap的插值功能基于以下三种常用 Kriging 算法：<br>
 * 1.简单克吕金（Simple Kriging）：该方法假定用于插值的字段值的期望（平均值）为已知的某一常数。<br>
 * 2.普通克吕金（Kriging）：该方法假定用于插值的字段值的期望（平均值）未知且恒定。它利用一定的数学函数，通过对给定的空间点进行拟合来估算单元格的值，
 *     生成格网数据集。它不仅可以生成一个表面，还可以给出预测结果的精度或者确定性的度量。因此，此方法计算精度较高，常用于地学领域。<br>
 * 3.泛克吕金（Universal Kriging）：该方法假定用于插值的字段值的期望（平均值）是未知的变量。在样点数据中存在某种主导趋势且该趋势可以通过某一个确定
 *     的函数或者多项式进行拟合的情况下，适用泛克吕金插值法。<br>
 * @param {Object} options - 参数。
 * @param {string} options.type - 克吕金插值的类型。
 * @param {(SuperMap.Bounds|L.Bounds|L.LatLngBounds|ol.extent|mapboxgl.LngLatBounds|GeoJSONObject)} options.bounds - 插值分析的范围，用于确定结果栅格数据集的范围。
 * @param {string} options.searchMode - 插值运算时，查找参与运算点的方式，有固定点数查找、定长查找、块查找。
 * @param {string} options.outputDatasetName - 插值分析结果数据集的名称。
 * @param {string} options.outputDatasourceName - 插值分析结果数据源的名称。
 * @param {string} [options.zValueFieldName] - 存储用于进行插值分析的字段名称，插值分析不支持文本类型的字段。当插值分析类型(InterpolationAnalystParameters.prototype.InterpolationAnalystType)为 dataset 时，此为必选参数。
 * @param {number} [options.mean] - 【简单克吕金】类型下，插值字段的平均值。
 * @param {number} [options.angle=0] - 克吕金算法中旋转角度值。
 * @param {number} [options.nugget=0] - 克吕金算法中块金效应值。
 * @param {number} [options.range=0] - 克吕金算法中自相关阈值，单位与原数据集单位相同。
 * @param {number} [options.sill=0] - 克吕金算法中基台值。
 * @param {string} [options.variogramMode="SPHERICAL"] - 克吕金插值时的半变函数类型。
 * @param {string} [options.exponent='exp1'] - 【泛克吕金】类型下，用于插值的样点数据中趋势面方程的阶数，可选值为 exp1、exp2。
 * @param {number} [options.expectedCount=12] - 【固定点数查找】方式下，设置待查找的点数；【定长查找】方式下，设置查找的最小点数。
 * @param {number} [options.searchRadius=0] - 【定长查找】方式下，设置参与运算点的查找范围。
 * @param {number} [options.maxPointCountForInterpolation=200] - 【块查找】方式下，设置最多参与插值的点数。
 * @param {number} [options.maxPointCountInNode=50] - 【块查找】方式下，设置单个块内最多参与运算点数。
 * @param {number} [options.zValueScale=1] - 用于进行插值分析值的缩放比率。
 * @param {number} [options.resolution] - 插值结果栅格数据集的分辨率，即一个像元所代表的实地距离，与点数据集单位相同。
 * @param {FilterParameter} [options.filterQueryParameter] - 属性过滤条件。
 * @param {PixelFormat} [options.pixelFormat] - 指定结果栅格数据集存储的像素格式。
 * @param {string} [options.dataset] - 要用来做插值分析的数据源中数据集的名称。该名称用形如 ”数据集名称@数据源别名” 形式来表示。当插值分析类型（InterpolationAnalystParameters.prototype.InterpolationAnalystType）为 dataset 时。
 * @param {Array.<GeometryPoint|L.LatLng|L.Point|ol.geom.Point|mapboxgl.LngLat|Array.<number>>} [options.inputPoints] - 用于做插值分析的离散点集合。当插值分析类型（InterpolationAnalystParameters.prototype.InterpolationAnalystType）为 geometry 时。
 * @extends {InterpolationAnalystParameters}
 * @example 例如：
 * var myInterpolationKrigingAnalystParameters = new InterpolationKrigingAnalystParameters({
 *     dataset:"SamplesP@Interpolation",
 *     type: "KRIGING",
 *     angle: 0,
 *     mean: 5,
 *     nugget: 30,
 *     range: 50,
 *     sill: 300,
 *     variogramMode: "EXPONENTIAL",
 *     searchMode: "QUADTREE",
 *     maxPointCountForInterpolation: 20,
 *     maxPointCountInNode: 5,
 *     pixelFormat: "BIT16",
 *     zValueFieldName: "AVG_TMP",
 *     resolution: 30000,
 *     filterQueryParameter: {
 *         attributeFilter: ""
 *     },
 *     outputDatasetName: "myKriging"
 * });
 * @usage
 */
class InterpolationKrigingAnalystParameters extends InterpolationAnalystParameters {

    constructor(options) {
        super(options);
        /**
         * @member {InterpolationAlgorithmType} InterpolationKrigingAnalystParameters.prototype.type
         * @description 克吕金插值的类型。
         * 具体如下：<br>
         * {KRIGING} 普通克吕金插值法。
         * {SimpleKriging} 简单克吕金插值法。
         * {UniversalKriging} 泛克吕金插值法。
         */
        this.type = null;

        /**
         * @member {number} InterpolationKrigingAnalystParameters.prototype.mean
         * @description 【简单克吕金】方式下，插值字段的平均值。
         * 即采样点插值字段值总和除以采样点数目。
         */
        this.mean = null;

        /**
         * @member {number} [InterpolationKrigingAnalystParameters.prototype.angle=0]
         * @description 克吕金算法中旋转角度值。
         * 此角度值指示了每个查找邻域相对于水平方向逆时针旋转的角度。
         */
        this.angle = 0;

        /**
         * @member {number} [InterpolationKrigingAnalystParameters.prototype.nugget=0]
         * @description 克吕金算法中块金效应值。
         */
        this.nugget = 0;

        /**
         * @member {number} [InterpolationKrigingAnalystParameters.prototype.range=0]
         * @description 克吕金算法中自相关阈值，单位与原数据集单位相同。
         */
        this.range = 0;

        /**
         * @member {number} [InterpolationKrigingAnalystParameters.prototype.sill=0]
         * @description 克吕金算法中基台值。
         */
        this.sill = 0;

        /**
         * @member {VariogramMode} [InterpolationKrigingAnalystParameters.prototype.variogramMode=VariogramMode.SPHERICAL]
         * @description 克吕金插值时的半变函数类型。
         * 用户所选择的半变函数类型会影响未知点的预测，特别是曲线在原点处的不同形状有重要意义。
         * 曲线在原点处越陡，则较近领域对该预测值的影响就越大，因此输出表面就会越不光滑。
         */
        this.variogramMode = VariogramMode.SPHERICAL;

        /**
         * @member {Exponent} [InterpolationKrigingAnalystParameters.prototype.exponent=Exponent.EXP1]
         * @description 【泛克吕金】类型下，用于插值的样点数据中趋势面方程的阶数。
         */
        this.exponent = Exponent.EXP1;

        /**
         * @member {SearchMode} InterpolationKrigingAnalystParameters.prototype.searchMode
         * @description 插值运算时，查找参与运算点的方式，有固定点数查找、定长查找、块查找。此为必选参数。
         * 简单克吕金和泛克吕金不支持块查找。
         * 具体如下：<br>
         * {KDTREE_FIXED_COUNT} 使用 KDTREE 的固定点数方式查找参与内插分析的点。<br>
         * {KDTREE_FIXED_RADIUS} 使用 KDTREE 的定长方式查找参与内插分析的点。<br>
         * {QUADTREE} 使用 QUADTREE 方式查找参与内插分析的点（块查找）。
         */
        this.searchMode = null;

        /**
         * @member {number} [InterpolationKrigingAnalystParameters.prototype.expectedCount=12]
         * @description 【固定点数查找】方式下，设置待查找的点数，即参与插值运算的点数，默认值为12。
         * 【定长查找】方式下，设置查找的最小点数，默认值为12。
         */
        this.expectedCount = 12;

        /**
         * @member {number} [InterpolationKrigingAnalystParameters.prototype.maxPointCountForInterpolation=200]
         * @description 【块查找】方式下，最多参与插值的点数。
         * 仅用于普通克吕金插值，简单克吕金和泛克吕金不支持块查找。
         */
        this.maxPointCountForInterpolation = 200;

        /**
         * @member {number} [InterpolationKrigingAnalystParameters.prototype.maxPointCountInNode=50]
         * @description 【块查找】方式下，设置单个块内最多参与运算点数。
         * 仅用于普通克吕金插值，简单克吕金和泛克吕金不支持块查找。
         */
        this.maxPointCountInNode = 50;
        if (options) {
            Util_Util.extend(this, options);
        }
        this.CLASS_NAME = "SuperMap.InterpolationKrigingAnalystParameters";
    }

    /**
     * @function InterpolationKrigingAnalystParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        super.destroy();
        var me = this;
        me.type = null;
        me.mean = null;
        me.angle = null;
        me.nugget = null;
        me.range = null;
        me.sill = null;
        me.variogramMode = null;
        me.exponent = null;
        me.searchMode = null;
        me.expectedCount = null;
        me.maxPointCountForInterpolation = null;
        me.maxPointCountInNode = null;
    }
}

;// CONCATENATED MODULE: ./src/common/iServer/InterpolationAnalystService.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/








/**
 * @class InterpolationAnalystService
 * @deprecatedclass SuperMap.InterpolationAnalystService
 * @category iServer SpatialAnalyst InterpolationAnalyst
 * @classdesc 插值分析服务类。
 * 插值分析可以将有限的采样点数据，通过插值算法对采样点周围的数值情况进行预测，可以掌握研究区域内数据的总体分布状况，从而使采样的离散点不仅仅反映其所在位置的数值情况，
 * 还可以反映区域的数值分布。目前SuperMap iServer的插值功能提供从点数据集插值得到栅格数据集的功能，支持以下常用的内插方法，
 * 包括：反距离加权插值、克吕金（Kriging）插值法、样条（径向基函数，Radial Basis Function）插值、点密度插值。
 * @param {string} url - 服务地址。如 http://localhost:8090/iserver/services/spatialanalyst-changchun/restjsr/spatialanalyst。
 * @param {Object} options - 参数。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @extends {SpatialAnalystBase}
 * @example 例如：
 * (start code)
 * var myTInterpolationAnalystService = new InterpolationAnalystService(url);
 * (end)
 * @usage
 */
class InterpolationAnalystService extends SpatialAnalystBase {


    constructor(url, options) {
        super(url, options);
        /**
         * @member {string} InterpolationAnalystService.prototype.mode
         * @description 插值分析类型。
         */

        this.mode = null;
        if (options) {
            Util_Util.extend(this, options);
        }
    }

    /**
     * @function InterpolationAnalystService.prototype.destroy
     * @description 释放资源,将引用资源的属性置空。
     */
    destroy() {
        super.destroy();
        this.mode = null;
        this.CLASS_NAME = "SuperMap.InterpolationAnalystService";
    }

    /**
     * @function InterpolationAnalystService.prototype.processAsync
     * @description 负责将客户端的查询参数传递到服务端。
     * @param {InterpolationDensityAnalystParameters|InterpolationIDWAnalystParameters|InterpolationRBFAnalystParameters|InterpolationKrigingAnalystParameters} parameter - 插值分析参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    processAsync(parameter, callback) {
        var parameterObject = {};
        var me = this;

        if (parameter instanceof InterpolationDensityAnalystParameters) {
            me.mode = 'Density';
            if (parameter.InterpolationAnalystType === 'geometry') {
                me.url = Util_Util.urlPathAppend(me.url, 'geometry/interpolation/density');
            } else {
                me.url = Util_Util.urlPathAppend(me.url, 'datasets/' + parameter.dataset + '/interpolation/density');
            }
        } else if (parameter instanceof InterpolationIDWAnalystParameters) {
            me.mode = 'IDW';
            if (parameter.InterpolationAnalystType === 'geometry') {
                me.url = Util_Util.urlPathAppend(me.url, 'geometry/interpolation/idw');
            } else {
                me.url = Util_Util.urlPathAppend(me.url, 'datasets/' + parameter.dataset + '/interpolation/idw');
            }
        } else if (parameter instanceof InterpolationRBFAnalystParameters) {
            me.mode = 'RBF';
            if (parameter.InterpolationAnalystType === 'geometry') {
                me.url = Util_Util.urlPathAppend(me.url, 'geometry/interpolation/rbf');
            } else {
                me.url = Util_Util.urlPathAppend(me.url, 'datasets/' + parameter.dataset + '/interpolation/rbf');
            }
        } else if (parameter instanceof InterpolationKrigingAnalystParameters) {
            me.mode = 'Kriging';
            if (parameter.InterpolationAnalystType === 'geometry') {
                me.url = Util_Util.urlPathAppend(me.url, 'geometry/interpolation/kriging');
            } else {
                me.url = Util_Util.urlPathAppend(me.url, 'datasets/' + parameter.dataset + '/interpolation/kriging');
            }
        }
        InterpolationAnalystParameters.toObject(parameter, parameterObject);
        var jsonParameters = Util_Util.toJSON(parameterObject);
        me.url = Util_Util.urlAppend(me.url, 'returnContent=true');

        return me.request({
            method: "POST",
            data: jsonParameters,
            scope: me,
            success: callback,
            failure: callback
        });
    }
}

;// CONCATENATED MODULE: ./src/common/iServer/MathExpressionAnalysisParameters.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


/**
 * @class MathExpressionAnalysisParameters
 * @deprecatedclass SuperMap.MathExpressionAnalysisParameters
 * @category iServer SpatialAnalyst GridMathAnalyst
 * @classdesc 栅格代数运算参数类。
 * @param {Object} options - 参数。
 * @param {string} options.dataset - 指定栅格代数运算数据源中数据集的名称。该名称用形如"数据集名称@数据源别名"形式来表示，例如：BaseMap_P@Jingjin。
 * @param {string} options.resultGridName - 指定结果数据集名称。
 * @param {string} options.expression - 指定的栅格运算表达式。如：[DatasourceAlias1.Raster1]*2-10。
 * @param {string} options.targetDatasource - 指定存储结果数据集的数据源。
 * @param {GeometryPolygon|L.Polygon|ol.geom.Polygon|GeoJSONObject} [options.extractRegion] - 栅格代数运算的范围，指定数据集中参与栅格代数运算的区域。
 *                                                                                        如果缺省，则计算全部区域，如果参与运算的数据集范围不一致，将使用所有数据集的范围的交集作为计算区域 。
 * @param {boolean} [options.isZip=false] - 是否对结果数据集进行压缩处理。
 * @param {boolean} [options.ignoreNoValue=false] - 是否忽略无值栅格数据。true 表示忽略无值数据，即无值栅格不参与运算。
 * @param {boolean} [options.deleteExistResultDataset=false] - 如果用户命名的结果数据集名称与已有的数据集重名，是否删除已有的数据集。
 * @usage
 */
class MathExpressionAnalysisParameters {

    constructor(options) {
        if (!options) {
            return;
        }
        /**
         * @member {string} MathExpressionAnalysisParameters.prototype.dataset
         * @description 要用来做栅格代数运算数据源中数据集的名称。
         * 该名称用形如"数据集名称@数据源别名"形式来表示，例如：JingjinTerrain@Jingjin。
         *
         */
        this.dataset = null;

        /**
         * @member {GeometryPolygon|L.Polygon|ol.geom.Polygon|GeoJSONObject} [MathExpressionAnalysisParameters.prototype.extractRegion]
         * @description 栅格代数运算的范围，指定数据集中参与栅格代数运算的区域。
         * 如果缺省，则计算全部区域，如果参与运算的数据集范围不一致，将使用所有数据集的范围的交集作为计算区域 。
         */
        this.extractRegion = null;

        /**
         * @member {string} MathExpressionAnalysisParameters.prototype.expression
         * @description 指定的栅格运算表达式。如："[DatasourceAlias1.Raster1]*2-10"。
         */
        this.expression = null;

        /**
         * @member {boolean} [MathExpressionAnalysisParameters.prototype.isZip=false]
         * @description 是否对结果数据集进行压缩处理。
         */
        this.isZip = false;

        /**
         * @member {boolean} [MathExpressionAnalysisParameters.prototype.ignoreNoValue=false]
         * @description 是否忽略无值栅格数据。
         */
        this.ignoreNoValue = false;

        /**
         * @member {string} MathExpressionAnalysisParameters.prototype.targetDatasource
         * @description 指定存储结果数据集的数据源。
         */
        this.targetDatasource = null;

        /**
         * @member {string} MathExpressionAnalysisParameters.prototype.resultGridName
         * @description 指定结果数据集名称。
         */
        this.resultGridName = null;

        /**
         * @member {boolean} [MathExpressionAnalysisParameters.prototype.deleteExistResultDataset=false]
         * @description 如果用户命名的结果数据集名称与已有的数据集重名，是否删除已有的数据集。
         */
        this.deleteExistResultDataset = false;

        Util_Util.extend(this, options);

        this.CLASS_NAME = "SuperMap.MathExpressionAnalysisParameters"
    }


    /**
     * @function MathExpressionAnalysisParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        var me = this;
        me.dataset = null;
        me.bounds = null;
        me.expression = null;
        me.isZip = true;
        me.ignoreNoValue = true;
        me.targetDatasource = null;
        me.resultGridName = null;
        me.deleteExistResultDataset = null;
    }

    /**
     * @function MathExpressionAnalysisParameters.toObject
     * @param {Object} mathExpressionAnalysisParameters - 栅格代数运算参数。
     * @param {Object} tempObj - 目标对象。
     * @description 生成栅格代数运算对象。
     */
    static toObject(mathExpressionAnalysisParameters, tempObj) {
        for (var name in mathExpressionAnalysisParameters) {
            if (name !== "dataset") {
                tempObj[name] = mathExpressionAnalysisParameters[name];
            }

            if (name === "extractRegion") {
                if (mathExpressionAnalysisParameters[name]) {
                    var bs = mathExpressionAnalysisParameters[name].components[0].components;
                    var region = {},
                        points = [],
                        type = "REGION";

                    var len = bs.length;
                    for (var i = 0; i < len - 1; i++) {
                        var poi = {};
                        poi["x"] = bs[i].x;
                        poi["y"] = bs[i].y;
                        points.push(poi);
                    }


                    region["points"] = points;
                    region["type"] = type;

                    tempObj[name] = region;
                }
            }
        }
    }
}

;// CONCATENATED MODULE: ./src/common/iServer/MathExpressionAnalysisService.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/




/**
 * @class MathExpressionAnalysisService
 * @deprecatedclass SuperMap.MathExpressionAnalysisService
 * @category  iServer SpatialAnalyst GridMathAnalyst
 * @classdesc 栅格代数运算服务类。
 * @param {string} url - 服务地址。如 http://localhost:8090/iserver/services/spatialanalyst-changchun/restjsr/spatialanalyst
 * @param {Object} options - 参数。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @extends {SpatialAnalystBase}
 * @example 例如：
 * (start code)
 * var myMathExpressionAnalysisService = new MathExpressionAnalysisService(url);
 * (end)
 * @usage
 */
class MathExpressionAnalysisService extends SpatialAnalystBase {

    constructor(url, options) {
        super(url, options);

        this.CLASS_NAME = "SuperMap.MathExpressionAnalysisService";
    }

    /**
     * @override
     */
    destroy() {
        super.destroy();
    }

    /**
     * @function MathExpressionAnalysisService.prototype.processAsync
     * @description 负责将客户端的查询参数传递到服务端。
     * @param {MathExpressionAnalysisParameters} parameter - 栅格代数运算参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    processAsync(parameter, callback) {
        var me = this;
        var parameterObject = {};

        if (parameter instanceof MathExpressionAnalysisParameters) {
            me.url = Util_Util.urlPathAppend(me.url, 'datasets/' + parameter.dataset + '/mathanalyst');
        }

        MathExpressionAnalysisParameters.toObject(parameter, parameterObject);
        var jsonParameters = Util_Util.toJSON(parameterObject);
        me.url = Util_Util.urlAppend(me.url, 'returnContent=true');
        return me.request({
            method: "POST",
            data: jsonParameters,
            scope: me,
            success: callback,
            failure: callback
        });
    }

}

;// CONCATENATED MODULE: ./src/common/iServer/OverlayAnalystParameters.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/



/**
 * @class OverlayAnalystParameters
 * @deprecatedclass SuperMap.OverlayAnalystParameters
 * @category  iServer SpatialAnalyst OverlayAnalyst
 * @classdesc 叠加分析参数基类。数据集叠加分析参数和几何对象叠加分析参数均继承此基类。
 * @param {Object} options - 参数。
 * @usage
 */
class OverlayAnalystParameters {


    constructor(options) {
        /**
         * @member {OverlayOperationType} [OverlayAnalystParameters.prototype.operation=OverlayOperationType.UNION]
         * @description 指定叠加分析操作类型。
         */
        this.operation = OverlayOperationType.UNION;

        if (options) {
            Util_Util.extend(this, options);
        }
        this.CLASS_NAME = "SuperMap.OverlayAnalystParameters";
    }

    /**
     * @function OverlayAnalystParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        var me = this;
        me.operation = null;
    }


}

;// CONCATENATED MODULE: ./src/common/iServer/DatasetOverlayAnalystParameters.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/






/**
 * @class DatasetOverlayAnalystParameters
 * @deprecatedclass SuperMap.DatasetOverlayAnalystParameters
 * @category  iServer SpatialAnalyst OverlayAnalyst
 * @classdesc 数据集叠加分析参数类。
 * @param {Object} options - 参数。
 * @param {string} options.operateDataset -数据集名称。
 * @param {string} options.sourceDataset - 源数据集名称。
 * @param {Array.<string>} [options.operateDatasetFields] - 叠加分析中操作数据集保留在结果数据集中的字段名列表。
 * @param {FilterParameter} [options.operateDatasetFilter] - 设置操作数据集中空间对象过滤条件。
 * @param {Array.<GeometryPolygon|L.Polygon|ol.geom.Polygon|GeoJSONObject>} [options.operateRegions] - 操作面对象集合，表示与这些面对象进行叠加分析。与 operateDataset 参数互斥，冲突时以 operateDataset 为准。
 * @param {Array.<string>} [options.sourceDatasetFields] - 叠加分析中源数据集保留在结果数据集中的字段名列表。
 * @param {FilterParameter} [options.sourceDatasetFilter] - 设置源数据集中空间对象过滤条件。
 * @param {number} [options.tolerance=0] - 容限。
 * @param {OverlayOperationType} options.operation - 叠加操作枚举值。
 * @param {DataReturnOption} [options.resultSetting] - 结果返回设置类。
 * @extends {GetFeaturesParametersBase}
 * @usage
 */
class DatasetOverlayAnalystParameters extends OverlayAnalystParameters {


    constructor(options) {
        super(options);
        /**
         * @member {string} DatasetOverlayAnalystParameters.prototype.operateDataset
         * @description 叠加分析中操作数据集的名称。
         */
        this.operateDataset = null;

        /**
         * @member {Array.<string>} [DatasetOverlayAnalystParameters.prototype.operateDatasetFields]
         * @description 叠加分析中操作数据集保留在结果数据集中的字段名列表。
         */
        this.operateDatasetFields = [];

        /**
         * @member {FilterParameter} DatasetOverlayAnalystParameters.prototype.operateDatasetFilter
         * @description 设置操作数据集中空间对象过滤条件。
         */
        this.operateDatasetFilter = new FilterParameter();

        /**
         * @member {Array.<GeometryPolygon|L.Polygon|ol.geom.Polygon|GeoJSONObject>} [DatasetOverlayAnalystParameters.prototype.operateRegions]
         * @description 操作面对象集合，表示与这些面对象进行叠加分析。与 operateDataset 参数互斥，冲突时以 operateDataset 为准。
         */
        this.operateRegions = [];


        /**
         * @member {string} DatasetOverlayAnalystParameters.prototype.sourceDataset
         * @description 叠加分析中源数据集的名称。
         */
        this.sourceDataset = null;


        /**
         * @member {Array.<string>} [DatasetOverlayAnalystParameters.prototype.sourceDatasetFields]
         * @description 叠加分析中源数据集保留在结果数据集中的字段名列表。
         */
        this.sourceDatasetFields = [];


        /**
         * @member {FilterParameter} [DatasetOverlayAnalystParameters.prototype.filterQueryParameter]
         * @description 设置源数据集中空间对象过滤条件。
         */
        this.sourceDatasetFilter = new FilterParameter();

        /**
         * @member {number} [DatasetOverlayAnalystParameters.prototype.tolerance=0]
         * @description 容限。
         */
        this.tolerance = 0;

        /**
         * @member {DataReturnOption} [DatasetOverlayAnalystParameters.prototype.resultSetting]
         * @description 结果返回设置类。
         */
        this.resultSetting = new DataReturnOption();

        Util_Util.extend(this, options);

        this.CLASS_NAME = "SuperMap.DatasetOverlayAnalystParameters";
    }


    /**
     * @function DatasetOverlayAnalystParameters.prototype.destroy
     * @override
     */
    destroy() {
        super.destroy();

        var me = this;
        me.operateDataset = null;
        me.operateDatasetFields = null;
        if (me.operateDatasetFilter) {
            me.operateDatasetFilter.destroy();
            me.operateDatasetFilter = null;
        }
        if (me.operateRegions) {
            for (var i = 0, opRegions = me.operateRegions, len = opRegions.length; i < len; i++) {
                opRegions[i].destroy();
            }
            me.operateRegions = null;
        }
        me.sourceDataset = null;
        me.sourceDatasetFields = null;
        if (me.sourceDatasetFilter) {
            me.sourceDatasetFilter.destroy();
            me.sourceDatasetFilter = null;
        }
        me.tolerance = null;
        if (me.resultSetting) {
            me.resultSetting.destroy();
            me.resultSetting = null;
        }
    }

    /**
     * @function DatasetOverlayAnalystParameters.toObject
     * @param {DatasetOverlayAnalystParameters} datasetOverlayAnalystParameters - 数据集叠加分析参数类。
     * @param {DatasetOverlayAnalystParameters} tempObj - 数据集叠加分析参数对象。
     * @description 将数据集叠加分析参数类转换为 JSON 对象。
     * @returns {Object} JSON 对象。
     */
    static toObject(datasetOverlayAnalystParameters, tempObj) {
        for (var name in datasetOverlayAnalystParameters) {
            if (name === "sourceDataset") {
                continue;
            } else if (name === "operateRegions") {
                tempObj.operateRegions = [];
                var ors = datasetOverlayAnalystParameters.operateRegions;
                for (var index in ors) {
                    if (ors.hasOwnProperty(index)) {    //icl542
                        tempObj.operateRegions[index] = ServerGeometry.fromGeometry(ors[index]);
                    }
                }
            } else if (name === "resultSetting") {
                tempObj.dataReturnOption = datasetOverlayAnalystParameters.resultSetting;
            } else {
                tempObj[name] = datasetOverlayAnalystParameters[name];
            }
        }
    }


}

;// CONCATENATED MODULE: ./src/common/iServer/GeometryOverlayAnalystParameters.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/




/**
 * @class GeometryOverlayAnalystParameters
 * @deprecatedclass SuperMap.GeometryOverlayAnalystParameters
 * @category  iServer SpatialAnalyst OverlayAnalyst
 * @classdesc
 * 几何对象叠加分析参数类。对指定的某两个几何对象做叠加分析。通过该类可以指定要做叠加分析的几何对象、叠加操作类型。
 * @param {Object} options - 参数。
 * @param {GeoJSONObject} options.operateGeometry - 叠加分析的操作几何对象。<br>
 * 点类型可以是：{@link GeometryPoint}|{@link L.Marker}|{@link L.CircleMarker}|{@link L.Circle}|{@link L.GeoJSON}|{@link ol.geom.Point}|{@link ol.format.GeoJSON}|{@link GeoJSONObject}。<br>
 * 线类型可以是：{@link GeometryLineString}|{@link GeometryLinearRing}|{@link L.Polyline}|{@link L.GeoJSON}|{@link ol.geom.LineString}|{@link GeoJSONObject}。<br>
 * 面类型可以是：{@link GeometryPolygon}|{@link L.Polygon}|{@link L.GeoJSON}|{@link ol.geom.Polygon}|{@link GeoJSONObject}。<br>
 * @param {GeoJSONObject} options.sourceGeometry - 叠加分析的源几何对象。
 * @param {Array.<GeoJSONFeature>} [options.operateGeometries] - 批量叠加分析的操作几何对象数组。
 * @param {Array.<GeoJSONFeature>} [options.sourceGeometries] -批量叠加分析的源几何对象数组。
 * @param {OverlayOperationType} [options.operation] - 叠加操作枚举值。
 * @extends {OverlayAnalystParameters}
 * @usage
 */
class GeometryOverlayAnalystParameters extends OverlayAnalystParameters {

    constructor(options) {
        super(options);
        if (options && options.operateGeometry) {
            this.operateGeometry = options.operateGeometry;
        }
        if (options && options.sourceGeometry) {
            this.sourceGeometry = options.sourceGeometry;
        }
        if (options && options.operateGeometries) {
            this.operateGeometries = options.operateGeometries;
        }
        if (options && options.sourceGeometries) {
            this.sourceGeometries = options.sourceGeometries;
        }

        if (options) {
            Util_Util.extend(this, options);
        }
        this.CLASS_NAME = "SuperMap.GeometryOverlayAnalystParameters";
    }

    /**
     * @function GeometryOverlayAnalystParameters.prototype.destroy
     * @override
     */
    destroy() {
        super.destroy();
        var me = this;
        if (me.sourceGeometry) {
            me.sourceGeometry.destroy();
            me.sourceGeometry = null;
        }

        if (me.sourceGeometries) {
            me.sourceGeometries.destroy();
            me.sourceGeometries = null;
        }
        if (me.sourceGeometry) {
            me.sourceGeometry.destroy();
            me.sourceGeometry = null;
        }

        if (me.operateGeometries) {
            me.operateGeometries.destroy();
            me.operateGeometries = null;
        }
    }

    /**
     * @function GeometryOverlayAnalystParameters.toObject
     * @param {GeometryOverlayAnalystParameters} geometryOverlayAnalystParameters - 几何对象叠加分析参数类。
     * @param {GeometryOverlayAnalystParameters} tempObj - 几何对象叠加分析参数对象。
     * @description 将几何对象叠加分析参数对象转换为 JSON 对象。
     * @returns {Object} JSON 对象。
     */
    static toObject(geometryOverlayAnalystParameters, tempObj) {
        for (var name in geometryOverlayAnalystParameters) {
            if (name === "sourceGeometry") {
                tempObj.sourceGeometry = ServerGeometry.fromGeometry(geometryOverlayAnalystParameters.sourceGeometry);

            } else if (name === "sourceGeometries") {
                var sourceGeometries = [];
                for (var i = 0; i < geometryOverlayAnalystParameters.sourceGeometries.length; i++) {
                    sourceGeometries.push(ServerGeometry.fromGeometry(geometryOverlayAnalystParameters.sourceGeometries[i]));
                }
                tempObj.sourceGeometries = sourceGeometries;

            } else if (name === "operateGeometry") {
                tempObj.operateGeometry = ServerGeometry.fromGeometry(geometryOverlayAnalystParameters.operateGeometry);

            } else if (name === "operateGeometries") {
                var operateGeometries = [];
                for (var j = 0; j < geometryOverlayAnalystParameters.operateGeometries.length; j++) {
                    operateGeometries.push(ServerGeometry.fromGeometry(geometryOverlayAnalystParameters.operateGeometries[j]));
                }
                tempObj.operateGeometries = operateGeometries;

            } else {
                tempObj[name] = geometryOverlayAnalystParameters[name];
            }
        }
    }
}

;// CONCATENATED MODULE: ./src/common/iServer/OverlayAnalystService.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/






/**
 * @class OverlayAnalystService
 * @deprecatedclass SuperMap.OverlayAnalystService
 * @category iServer SpatialAnalyst OverlayAnalyst
 * @classdesc 叠加分析服务类。
 * 该类负责将客户设置的叠加分析参数传递给服务端，并接收服务端返回的叠加分析结果数据。
 * 叠加分析结果通过该类支持的事件的监听函数参数获取
 * @param {string} url - 服务地址。如http://localhost:8090/iserver/services/spatialanalyst-changchun/restjsr/spatialanalyst。
 * @param {Object} options - 参数。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {DataFormat} [options.format=DataFormat.GEOJSON] - 查询结果返回格式，目前支持 iServerJSON、GeoJSON、FGB 三种格式。参数格式为 "ISERVER"，"GEOJSON"，"FGB"。
 * @param {Object} [options.headers] - 请求头。
 * @extends {CommonServiceBase}
 * @example 例如：
 * (start code)
 * var myOverlayAnalystService = new OverlayAnalystService(url);
 * (end)
 * @usage
 */

class OverlayAnalystService extends SpatialAnalystBase {

    constructor(url, options) {
        super(url, options);

        /**
         * @member {string} OverlayAnalystService.prototype.mode
         * @description 叠加分析类型
         */
        this.mode = null;

        if (options) {
            Util_Util.extend(this, options);
        }
        this.CLASS_NAME = "SuperMap.OverlayAnalystService";
    }

    /**
     * @override
     */
    destroy() {
        super.destroy();
        this.mode = null;
    }

    /**
     * @function OverlayAnalystService.prototype.processAsync
     * @description 负责将客户端的查询参数传递到服务端。
     * @param {OverlayAnalystParameters} parameter - 叠加分析参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    processAsync(parameter, callback) {
        var parameterObject = {};
        var me = this;

        if (parameter instanceof DatasetOverlayAnalystParameters) {
            me.mode = "datasets";
            me.url = Util_Util.urlPathAppend(me.url, 'datasets/' + parameter.sourceDataset + '/overlay');
            DatasetOverlayAnalystParameters.toObject(parameter, parameterObject);
        } else if (parameter instanceof GeometryOverlayAnalystParameters) {
            me.mode = "geometry";
            //支持传入多个几何要素进行叠加分析
            if(parameter.operateGeometries && parameter.sourceGeometries){
                me.url = Util_Util.urlPathAppend(me.url, 'geometry/overlay/batch');
                me.url = Util_Util.urlAppend(me.url, 'ignoreAnalystParam=true');
            }else {
                me.url = Util_Util.urlPathAppend(me.url, 'geometry/overlay');
            }
            GeometryOverlayAnalystParameters.toObject(parameter, parameterObject);
        }
        this.returnContent = true;
        var jsonParameters = Util_Util.toJSON(parameterObject);
        return me.request({
            method: "POST",
            data: jsonParameters,
            scope: me,
            success: callback,
            failure: callback
        });
    }

    dataFormat() {
      return [DataFormat.GEOJSON, DataFormat.ISERVER, DataFormat.FGB];
    }
}

;// CONCATENATED MODULE: ./src/common/iServer/RouteCalculateMeasureParameters.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


/**
 * @class RouteCalculateMeasureParameters
 * @deprecatedclass SuperMap.RouteCalculateMeasureParameters
 * @category  iServer SpatialAnalyst RouteCalculateMeasure
 * @classdesc 基于路由对象计算指定点 M 值操作的参数类。通过该类提供参数信息。
 * @param {Object} options - 参数。
 * @param {(Route|L.Polyline|ol.geom.LineString|GeoJSONObject)} options.sourceRoute - 路由对象。该对象可以是用户自己生成或在数据源中查询得到的符合标准的路由对象。
 * @param {GeometryPoint|L.LatLng|L.Point|ol.geom.Point|mapboxgl.LngLat|Array.<number>} options.point - 二维地理坐标点对象，包含 x,y 坐标值属性的对象。
 * @param {number} [options.tolerance] - 容限值。
 * @param {boolean} [options.isIgnoreGap=false] - 是否忽略子对象之间的距离。
 * @usage
 */
class RouteCalculateMeasureParameters {

    constructor(options) {
        if (!options) {
            return this;
        }
        /**
         * @member {(Route|L.Polyline|ol.geom.LineString|GeoJSONObject)} RouteCalculateMeasureParameters.prototype.sourceRoute
         * @description 路由对象。该对象可以是用户自己生成或在数据源中查询得到的符合标准的路由对象。
         */
        this.sourceRoute = null;

        /**
         * @member {GeometryPoint|L.LatLng|L.Point|ol.geom.Point|mapboxgl.LngLat|Array.<number>} RouteCalculateMeasureParameters.prototype.point
         * @description 二维地理坐标点对象，包含 x,y 坐标值属性的对象。
         */
        this.point = null;

        /**
         * @member {number} [RouteCalculateMeasureParameters.prototype.tolerance]
         * @description 容限值。
         */
        this.tolerance = null;

        /**
         * @member {boolean} [RouteCalculateMeasureParameters.prototype.isIgnoreGap=false]
         * @description 是否忽略子对象之间的距离。
         */
        this.isIgnoreGap = false;

        Util_Util.extend(this, options);

        this.CLASS_NAME = "SuperMap.RouteCalculateMeasureParameters";
    }

    /**
     * @function RouteCalculateMeasureParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        var me = this;
        me.sourceRoute = null;
        me.point = null;
        if (me.tolerance) {
            me.tolerance = null;
        }
        if (me.isIgnoreGap) {
            me.isIgnoreGap = false;
        }
    }
}

;// CONCATENATED MODULE: ./src/common/iServer/RouteCalculateMeasureService.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/




/**
 * @class RouteCalculateMeasureService
 * @deprecatedclass SuperMap.RouteCalculateMeasureService
 * @category  iServer SpatialAnalyst RouteCalculateMeasure
 * @classdesc 基于路由对象计算指定点 M 值操作的服务类。
 *            该类负责将客户设置的计算指定点的 M 值参数传递给服务端，并接收服务端返回的
 *            指定点的 M 值。通过该类支持的事件的监听函数参数获取。
 * @extends {SpatialAnalystBase}
 * @param {string} url - 服务地址。如 http://localhost:8090/iserver/services/spatialanalyst-changchun/restjsr/spatialanalyst
 * @param {Object} options - 参数。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @example 实例化该类如下例所示：
 * (start code)
 * var parameters = new RouteCalculateMeasureParameters({
     *     "sourceRoute":{
     *         "type":"LINEM",
     *        "parts":[4],
     *         "points":[
     *             {
     *                 "measure":0,
     *                 "y":-6674.466867067764,
     *                 "x":3817.3527876130133
     *             },
     *             {
     *                 "measure":199.57954019411724,
     *                 "y":-6670.830929417594,
     *                 "x":3617.806369901496
     *             },
     *             {
     *                 "measure":609.3656478634477,
     *                "y":-6877.837541432356,
     *                 "x":3264.1498746678444
     *             },
     *             {
     *                 "measure":936.0174126282958,
     *                 "y":-7038.687780615184,
     *                 "x":2979.846206068903
     *             }
     *         ]
     *     },
     *     "tolerance":1,
     *     "point":{
     *         "x":3330.7754269417,
     *         "y":-6838.8394457216
     *     },
     *     "isIgnoreGap":false
     * });
 *
 * var routeCalculateMeasureService = new RouteCalculateMeasureService(spatialAnalystURL);
     * routeCalculateMeasureService.processAsync(parameters, calculateCompleted);
     *
     *  //执行
     * function calculateCompleted(){todo}
     * function calculateFailded(){todo}
     * (end)
     * @usage
     */
class RouteCalculateMeasureService extends SpatialAnalystBase {

    constructor(url, options) {
        super(url, options);
        this.CLASS_NAME = "SuperMap.RouteCalculateMeasureService";
    }

    /**
     * @override
     */
    destroy() {
        super.destroy();
    }

    /**
     * @function RouteCalculateMeasureService.prototype.processAsync
     * @description 负责将客户端的基于路由对象计算指定点 M 值操作的参数传递到服务端。
     * @param {RouteCalculateMeasureParameters} params - 基于路由对象计算指定点 M 值操作的参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    processAsync(params, callback) {
        if (!(params instanceof RouteCalculateMeasureParameters)) {
            return;
        }
        var me = this, jsonParameters;

        jsonParameters = me.getJsonParameters(params);

        return me.request({
            method: "POST",
            data: jsonParameters,
            scope: me,
            success: callback,
            failure: callback
        });
    }

    /**
     * @function RouteCalculateMeasureService.prototype.getJsonParameters
     * @description 将参数转化为 JSON 字符串。
     * @param {RouteCalculateMeasureParameters} params - 基于路由对象计算指定点 M 值操作的参数类。
     * @returns {Object} 转化后的 JSON 字符串。
     */
    getJsonParameters(params) {
        var jsonParameters, jsonStr = "geometry/calculatemeasure", me = this;
        me.url = Util_Util.urlPathAppend(me.url, jsonStr);
        me.url = Util_Util.urlAppend(me.url, 'returnContent=true');
        jsonParameters = Util_Util.toJSON(params);
        return jsonParameters;
    }

}


;// CONCATENATED MODULE: ./src/common/iServer/RouteLocatorParameters.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/



/**
 * @class RouteLocatorParameters
 * @deprecatedclass SuperMap.RouteLocatorParameters
 * @category  iServer SpatialAnalyst RouteLocator
 * @classdesc 路由对象定位空间对象的参数类。
 * 参数有两种方式，分别为 Geometry 和 Dataset 两种，前者需要指定 sourceRoute 对象作为参数，后者需要 dataset，routeIDField，routeID 三个参数。如果用户两种参数均设置，优先选择 Dataset 方式。
 * @param {Object} options - 参数。
 * @param {(Route|L.Polyline|ol.geom.LineString|GeoJSONObject)} options.sourceRoute - 路由对象。
 * @param {number} options.measure - 定位点的 M 值。只当路由对象定位点时有意义。
 * @param {string} [options.type] -  类型：点 or 线。
 * @param {number} [options.offset=0] - 定位点偏移量。只当路由对象定位点时有意义。
 * @param {boolean} [options.isIgnoreGap=false] - 是否忽略子对象之间的距离。即不忽略子对象之间的距离。
 * @param {number} [options.startMeasure] - 定位线的起始 M 值。只当路由对象定位线时有意义。
 * @param {number} [options.endMeasure] - 定位线的终止 M 值。只当路由对象定位线时有意义。
 * @usage
 */
class RouteLocatorParameters {

    constructor(options) {
        if (!options) {
            return this;
        }
        /**
         * @member {(Route|L.Polyline|ol.geom.LineString|GeoJSONObject)} RouteLocatorParameters.prototype.sourceRoute
         * @description 路由对象。
         */
        this.sourceRoute = null;

        /**
         * @member {string} RouteLocatorParameters.prototype.dataset
         * @description 要用来做缓冲区分析的数据源中数据集的名称。该名称用形如"数据集名称@数据源别名"形式来表示。
         */
        this.dataset = null;

        /**
         * @member {string} RouteLocatorParameters.prototype.routeIDField
         * @description  路由对象所在的字段名称。
         *
         */
        this.routeIDField = null;

        /**
         * @member {number} RouteLocatorParameters.prototype.routeID
         * @description 路由对象标识。
         *
         */
        this.routeID = null;

        /**
         * @member {string} [RouteLocatorParameters.prototype.type]
         * @description 类型：点 or 线。
         * 可选值为:
         * LINE :根据起始 M 值及终止 M 值定位线对象。
         * POINT : 根据 M 值定位点对象。
         */
        this.type = null;

        /**
         * @member {number} RouteLocatorParameters.prototype.measure
         * @description 定位点的 M 值。只当路由对象定位点时有意义。
         */
        this.measure = null;

        /**
         * @member {number} [RouteLocatorParameters.prototype.offset=0]
         * @description 定位点偏移量。只当路由对象定位点时有意义。
         */
        this.offset = 0;

        /**
         * @member {boolean} [RouteLocatorParameters.prototype.isIgnoreGap=false]
         * @description 是否忽略子对象之间的距离。
         */
        this.isIgnoreGap = false;

        /**
         *  @member {number} [RouteLocatorParameters.prototype.startMeasure]
         *  @description 定位线的起始 M 值。只当路由对象定位线时有意义。
         */
        this.startMeasure = null;

        /**
         *  @member {number} [RouteLocatorParameters.prototype.endMeasure]
         *  @description 定位线的终止 M 值。只当路由对象定位线时有意义。
         */
        this.endMeasure = null;

        var routeFromClient = options.sourceRoute;
        var routeHandle = {};
        if (routeFromClient && routeFromClient instanceof Geometry_Geometry && routeFromClient.components) {
            routeHandle.type = routeFromClient.type;
            routeHandle.parts = routeFromClient.parts;
            var parts = [];
            for (var i = 0, len = routeFromClient.components.length; i < len; i++) {
                parts = parts.concat(routeFromClient.components[i].components);
            }
            routeHandle.points = parts;
            options.sourceRoute = routeHandle;
        }
        Util_Util.extend(this, options);
        this.CLASS_NAME = "SuperMap.RouteLocatorParameters";
    }


    /**
     * @function RouteLocatorParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        var me = this;
        me.sourceRoute = null;
        me.type = null;
        me.measure = null;
        me.offset = 0;
        me.isIgnoreGap = false;
        me.startMeasure = null;
        me.endMeasure = null;
        me.dataset = null;
        me.routeID = null;
        me.routeIDField = null;
    }

}

;// CONCATENATED MODULE: ./src/common/iServer/RouteLocatorService.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/




/**
 * @class RouteLocatorService
 * @deprecatedclass SuperMap.RouteLocatorService
 * @category iServer SpatialAnalyst RouteLocator
 * @classdesc 路由对象定位空间对象的服务类。
 * @extends {SpatialAnalystBase}
 * @param {string} url -服务地址。如 http://localhost:8090/iserver/services/spatialanalyst-changchun/restjsr/spatialanalyst。
 * @param {Object} options - 参数。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @example 实例化该类如下例所示：
 * (start code)
 * var routeLocatorParameters_point = new RouteLocatorParameters({
     *   "sourceRoute":{
     *       "type":"LINEM",
     *       "parts":[4],
     *       "points":[
     *           {
     *               "measure":0,
     *               "y":-6674.466867067764,
     *               "x":3817.3527876130133
     *           },
     *           {
     *               "measure":199.57954019411724,
     *               "y":-6670.830929417594,
     *               "x":3617.806369901496
     *          },
     *           {
     *               "measure":609.3656478634477,
     *               "y":-6877.837541432356,
     *               "x":3264.1498746678444
     *           },
     *           {
     *               "measure":936.0174126282958,
     *               "y":-7038.687780615184,
     *               "x":2979.846206068903
     *           }
     *       ]
     *   },
     *   "type":"POINT",
     *   "measure":10,
     *   "offset":3,
     *   "isIgnoreGap":true
     * });
     * var routeLocatorService = new RouteLocatorService(spatialAnalystURL);
     * routeLocatorService.processAsync(routeLocatorParameters_point);
     *
     *  //执行
     * function routeLocatorCompleted(){todo}
     * function routeLocatorFailded(){todo}
     * (end)
     * @usage
     */
class RouteLocatorService extends SpatialAnalystBase {

    constructor(url, options) {
        super(url, options);
        this.CLASS_NAME = "SuperMap.RouteLocatorService";
    }

    /**
     * @override
     */
    destroy() {
        super.destroy();
    }

    /**
     * @function RouteLocatorService.prototype.processAsync
     * @description 负责将客户端的基于路由对象计算指定点 M 值操作的参数传递到服务端。
     * @param {RouteLocatorParameters} params - 路由对象定位空间对象的参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    processAsync(params, callback) {
        if (!(params instanceof RouteLocatorParameters)) {
            return;
        }
        var me = this, jsonParameters;

        jsonParameters = me.getJsonParameters(params);

        return me.request({
            method: "POST",
            data: jsonParameters,
            scope: me,
            success: callback,
            failure: callback
        });
    }

    /**
     * @function RouteLocatorService.prototype.processAsync
     * @description 将参数转化为 JSON 字符串。
     * @param {RouteLocatorParameters} params - 路由对象定位空间对象的参数类。
     * @returns {Object} 转化后的JSON字符串。
     */
    getJsonParameters(params) {
        var jsonParameters, jsonStr = "geometry/routelocator", me = this;

        if (params.dataset) {
            jsonStr = "datasets/" + params.dataset + "/linearreferencing/routelocator";
            params.sourceRoute = null;
        }
        me.url = Util_Util.urlPathAppend(me.url, jsonStr);
        me.url = Util_Util.urlAppend(me.url, 'returnContent=true');
        jsonParameters = Util_Util.toJSON(params);
        return jsonParameters;
    }

}


;// CONCATENATED MODULE: ./src/common/iServer/SurfaceAnalystParametersSetting.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/





/**
 * @class SurfaceAnalystParametersSetting
 * @deprecatedclass SuperMap.SurfaceAnalystParametersSetting
 * @category  iServer SpatialAnalyst SurfaceAnalyst
 * @classdesc 表面分析参数设置类。
 * 通过该类可以设置表面分析提取等值线、提取等值面的一些参数，包括基准值、等值距、光滑度、光滑方法等。
 * @param {Object} options - 参数。
 * @param {GeometryPolygon|L.Polygon|ol.geom.Polygon|GeoJSONObject} [options.clipRegion] - 裁剪面对象，如果不需要对操作结果进行裁剪，可以使用 null 值取代该参数。
 * @param {number} [options.datumValue=0] - 提取等值线、提取等值面的基准值。
 * @param {Array.<number>} options.expectedZValues - 期望分析结果的 Z 值集合。
 * @param {number} [options.interval=0] - 等值距。等值距是两条等值线之间的间隔值。
 * @param {number} [options.resampleTolerance=0] - 重采样容限。
 * @param {SmoothMethod} [options.smoothMethod=SmoothMethod.BSPLINE] - 光滑处理所使用的方法。
 * @param {number} [options.smoothness=0] - 等值线或等值面的边界线的光滑度。
 * @usage
 */
class SurfaceAnalystParametersSetting {

    constructor(options) {
        /**
         * @member {GeometryPolygon|L.Polygon|ol.geom.Polygon|GeoJSONObject} [SurfaceAnalystParametersSetting.prototype.clipRegion]
         * @description 获取或设置裁剪面对象，如果不需要对操作结果进行裁剪，可以使用 null 值取代该参数。
         */
        this.clipRegion = null;

        /**
         * @member {number} [SurfaceAnalystParametersSetting.prototype.datumValue=0]
         * @description 获取或设置表面分析中提取等值线、提取等值面的基准值。
         * 基准值是作为一个生成等值线的初始起算值，并不一定是最小等值线的值。例如，高程范围为 220 -1550 的 DEM 栅格数据，
         * 如果设基准值为 0，等值距为 50，则提取等值线时，以基准值 0 为起点，等值距 50 为间隔提取等值线，
         * 因为给定高程的最小值是 220，所以，在给定范围内提取等值线的最小高程是 250。
         * 提取等值线的结果是：最小等值线值为 250，最大等值线值为 1550。
         */
        this.datumValue = 0;
        /**
         * @member {Array.<number>} SurfaceAnalystParametersSetting.prototype.expectedZValues
         * @description 获取或设置期望分析结果的 Z 值集合。
         *              Z 值集合存储一系列数值，该数值为待提取等值线的值。即仅高程值在 Z 值集合中的等值线会被提取。
         */
        this.expectedZValues = null;

        /**
         *  @member {number} [SurfaceAnalystParametersSetting.prototype.interval=0]
         *  @description 获取或设置等值距。等值距是两条等值线之间的间隔值。
         */
        this.interval = 0;

        /**
         * @member {number} [SurfaceAnalystParametersSetting.prototype.resampleTolerance=0]
         * @description 获取或设置重采样容限。
         *              容限值越大，采样结果数据越简化。当分析结果出现交叉时，可通过调整重采样容限为较小的值来处理。
         */
        this.resampleTolerance = 0;

        /**
         * @member {SmoothMethod} [SurfaceAnalystParametersSetting.prototype.smoothMethod=SmoothMethod.BSPLINE]
         * @description 获取或设置光滑处理所使用的方法。
         */
        this.smoothMethod = SmoothMethod.BSPLINE;

        /**
         * @member {number} [SurfaceAnalystParametersSetting.prototype.smoothness=0]
         * @description 获取或设置表面分析中等值线或等值面的边界线的光滑度。
         * 以为 0-5 为例，光滑度为 0 表示不进行光滑操作，值越大表示光滑度越高。
         * 随着光滑度的增加，提取的等值线越光滑，当然光滑度越大，
         * 计算所需的时间和占用的内存也就越大。而且，当等值距较小时，
         * 光滑度太高会出现等值线相交的问题。
         */
        this.smoothness = 0;

        if (options) {
            Util_Util.extend(this, options);
        }

        this.CLASS_NAME = "SuperMap.SurfaceAnalystParametersSetting";
    }


    /**
     * @function SurfaceAnalystParametersSetting.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        var me = this;
        if (me.clipRegion) {
            me.clipRegion.destroy();
            me.clipRegion = null;
        }

        me.datumValue = null;
        me.expectedZValues = null;
        me.interval = null;
        me.resampleTolerance = null;
        me.smoothMethod = null;
        me.smoothness = null;
    }
    /**
     * @function SurfaceAnalystParametersSetting.prototype.toJSON
     * @description 将对象转化为 JSON 字符串。
     * @returns {string} 对象 JSON 字符串。
     */
    toJSON() {
        let json = "'datumValue':" + Util_Util.toJSON(this.datumValue);
        json += ",'interval':" + Util_Util.toJSON(this.interval);
        json += ",'resampleTolerance':" + Util_Util.toJSON(this.resampleTolerance);
        json += ",'smoothMethod':" + Util_Util.toJSON(this.smoothMethod);
        json += ",'smoothness':" + Util_Util.toJSON(this.smoothness);
        if (this.expectedZValues != null) {
            json += "," + "'expectedZValues':" + Util_Util.toJSON(this.expectedZValues);
        }
        if (this.clipRegion != null) {
            var serverGeometry = this.clipRegion;
            if (this.clipRegion instanceof Geometry_Geometry && this.clipRegion.components) {
                serverGeometry = ServerGeometry.fromGeometry(this.clipRegion)
            }
            json += ",'clipRegion':" + Util_Util.toJSON(serverGeometry);
        }
        return "{" + json + "}";
    }

}

;// CONCATENATED MODULE: ./src/common/iServer/SurfaceAnalystParameters.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/





/**
 * @class SurfaceAnalystParameters
 * @deprecatedclass SuperMap.SurfaceAnalystParameters
 * @category  iServer SpatialAnalyst SurfaceAnalyst
 * @classdesc 表面分析提取操作参数类。通过该类可以为进行表面分析提供参数信息，包括表面分析的方法提取等值线、提取等值面和中间结果的分辨率，
 * {@link DatasetSurfaceAnalystParameters} 和 {@link GeometrySurfaceAnalystParameters} 继承自该类。
 * @param {Object} options - 参数。
 * @param {SurfaceAnalystParametersSetting} options.extractParameter - 表面分析参数设置类。
 * @param {number} options.resolution - 指定中间结果（栅格数据集）的分辨率。
 * @param {DataReturnOption} options.resultSetting - 结果返回设置类。
 * @param {SurfaceAnalystMethod} [options.surfaceAnalystMethod=SurfaceAnalystMethod.ISOLINE] - 获取或设置表面分析的提取方法，提取等值线和提取等值面。
 * @usage
 */
class SurfaceAnalystParameters {

    constructor(options) {
        /**
         * @member {number} SurfaceAnalystParameters.prototype.resolution
         * @description 获取或设置指定中间结果（栅格数据集）的分辨率。
         */
        this.resolution = 0;

        /**
         * @member {SurfaceAnalystParametersSetting} SurfaceAnalystParameters.prototype.extractParameter
         * @description 获取或设置表面分析参数。
         * 在进行点数据集进行提取等值面分析时，暂时不支持 SurfaceAnalystParametersSetting 类中的 expectedZValues 字段。
         */
        this.extractParameter = new SurfaceAnalystParametersSetting();

        /**
         * @member {DataReturnOption} SurfaceAnalystParameters.prototype.resultSetting
         * @description 结果返回设置类。
         */
        this.resultSetting = new DataReturnOption();

        /**
         * @member {SurfaceAnalystMethod} [SurfaceAnalystParameters.prototype.surfaceAnalystMethod=SurfaceAnalystMethod.ISOLINE]
         * @description 获取或设置表面分析的提取方法，提取等值线和提取等值面。
         */
        this.surfaceAnalystMethod = SurfaceAnalystMethod.ISOLINE;

        if (options) {
            Util_Util.extend(this, options);
        }

        this.CLASS_NAME = "SuperMap.SurfaceAnalystParameters";
    }

    /**
     * @function SurfaceAnalystParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        var me = this;
        me.resolution = null;
        if (me.extractParameter) {
            me.extractParameter.destroy();
            me.extractParameter = null;
        }
        if (me.resultSetting) {
            me.resultSetting.destroy();
            me.resultSetting = null;
        }
        me.surfaceAnalystMethod = null;
    }

}

;// CONCATENATED MODULE: ./src/common/iServer/DatasetSurfaceAnalystParameters.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/






/**
 * @class DatasetSurfaceAnalystParameters
 * @deprecatedclass SuperMap.DatasetSurfaceAnalystParameters
 * @category iServer SpatialAnalyst SurfaceAnalyst
 * @classdesc 数据集表面分析参数类。该类对数据集表面分析所用到的参数进行设置。
 * @param {Object} options - 参数。
 * @param {string} options.dataset - 数据集名称。
 * @param {string} options.zValueFieldName - 字段名称。
 * @param {number} options.resolution - 指定中间结果（栅格数据集）的分辨率。
 * @param {SurfaceAnalystParametersSetting} options.extractParameter - 表面分析参数设置类。获取或设置表面分析参数。
 * @param {FilterParameter} [options.filterQueryParameter] - 查询过滤条件参数。
 * @param {DataReturnOption} [options.resultSetting] - 结果返回设置类。
 * @param {SurfaceAnalystMethod} [options.surfaceAnalystMethod=SurfaceAnalystMethod.ISOLINE] - 表面分析的提取方法，提取等值线和提取等值面。
 * @extends {SurfaceAnalystParameters}
 * @usage
 */
class DatasetSurfaceAnalystParameters extends SurfaceAnalystParameters {


    constructor(options) {
        super(options);
        /**
         * @member {string} DatasetSurfaceAnalystParameters.prototype.dataset
         * @description 要用来做数据集表面分析的数据源中数据集的名称。该名称用形如 "数据集名称@数据源别名" 形式来表示，例如：Country@World。
         */
        this.dataset = null;

        /**
         *  @member {FilterParameter} DatasetSurfaceAnalystParameters.prototype.filterQueryParameter
         *  @description 获取或设置查询过滤条件参数。
         */
        this.filterQueryParameter = new FilterParameter();

        /**
         * @member {string} DatasetSurfaceAnalystParameters.prototype.zValueFieldName
         * @description 获取或设置用于提取操作的字段名称。提取等值线时，将使用该字段中的值，对点记录集中的点数据进行插值分析，得到栅格数据集（中间结果），接着从栅格数据集提取等值线。
         */
        this.zValueFieldName = null;

        if (options) {
            Util_Util.extend(this, options);
        }

        this.CLASS_NAME = "SuperMap.DatasetSurfaceAnalystParameters";
    }

    /**
     * @function DatasetSurfaceAnalystParameters.prototype.destroy
     * @override
     */
    destroy() {
        super.destroy();
        var me = this;
        me.dataset = null;
        if (me.filterQueryParameter) {
            me.filterQueryParameter.destroy();
            me.filterQueryParameter = null;
        }
        me.zValueFieldName = null;
    }

    /**
     * @function DatasetSurfaceAnalystParameters.toObject
     * @param {DatasetSurfaceAnalystParameters} datasetSurfaceAnalystParameters - 数据集表面分析参数类。
     * @param {DatasetSurfaceAnalystParameters} tempObj - 数据集表面分析参数对象。
     * @description 将数据集表面分析参数对象转换为 JSON 对象。
     * @returns JSON 对象。
     */
    static toObject(datasetSurfaceAnalystParameters, tempObj) {
        for (var name in datasetSurfaceAnalystParameters) {
            if (name === "filterQueryParameter") {
                tempObj.filterQueryParameter = datasetSurfaceAnalystParameters.filterQueryParameter;
            }
            if (name === "extractParameter") {
                if (datasetSurfaceAnalystParameters.extractParameter.clipRegion instanceof Geometry_Geometry && datasetSurfaceAnalystParameters.extractParameter.clipRegion.components) {
                    datasetSurfaceAnalystParameters.extractParameter.clipRegion = ServerGeometry.fromGeometry(datasetSurfaceAnalystParameters.extractParameter.clipRegion);
                }
                tempObj.extractParameter = datasetSurfaceAnalystParameters.extractParameter;
            } else if (name === "dataset") {
                continue;
            } else if (name === "surfaceAnalystMethod") {
                continue;
            } else {
                tempObj[name] = datasetSurfaceAnalystParameters[name];
            }
        }
    }

}

;// CONCATENATED MODULE: ./src/common/iServer/GeometrySurfaceAnalystParameters.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/



/**
 * @class GeometrySurfaceAnalystParameters
 * @deprecatedclass SuperMap.GeometrySurfaceAnalystParameters
 * @category  iServer SpatialAnalyst SurfaceAnalyst
 * @classdesc 几何对象表面分析参数类。该类对几何对象表面分析所用到的参数进行设置。
 * @param {Object} options - 参数。
 * @param {Array.<GeometryPoint|L.LatLng|L.Point|ol.geom.Point|mapboxgl.LngLat|Array.<number>>} options.points - 表面分析的坐标点数组。
 * @param {Array.<number>} options.zValues - 表面分析的坐标点的 Z 值数组。
 * @param {number} [options.resolution] - 获取或设置指定中间结果（栅格数据集）的分辨率。
 * @param {DataReturnOption} [options.resultSetting] - 结果返回设置类。
 * @param {SurfaceAnalystParametersSetting} options.extractParameter - 获取或设置表面分析参数。
 * @param {SurfaceAnalystMethod} [options.surfaceAnalystMethod = SurfaceAnalystMethod.ISOLINE] - 获取或设置表面分析的提取方法，提取等值线和提取等值面。
 * @extends {SurfaceAnalystParameters}
 * @usage
 */
class GeometrySurfaceAnalystParameters extends SurfaceAnalystParameters {


    constructor(options) {
        super(options);
        /**
         * @member {Array.<GeometryPoint|L.LatLng|L.Point|ol.geom.Point|mapboxgl.LngLat|Array.<number>>} GeometrySurfaceAnalystParameters.prototype.points
         * @description 获取或设置用于表面分析的坐标点数组。
         */
        this.points = null;

        /**
         * @member {Array.<number>} GeometrySurfaceAnalystParameters.prototype.zValues
         * @description 获取或设置用于提取操作的值。提取等值线时，将使用该数组中的值，
         * 对几何对象中的坐标点数组进行插值分析，得到栅格数据集（中间结果），接着从栅格数据集提取等值线。
         */
        this.zValues = null;
        if (options) {
            Util_Util.extend(this, options);
        }

        this.CLASS_NAME = "SuperMap.GeometrySurfaceAnalystParameters";
    }

    /**
     * @function GeometrySurfaceAnalystParameters.prototype.destroy
     * @override
     */
    destroy() {
        super.destroy();
        var me = this;
        if (me.points) {
            for (var i = 0, points = me.points, len = points.length; i < len; i++) {
                points[i].destroy();
            }
            me.points = null;
        }
        me.zValues = null;
    }

}


;// CONCATENATED MODULE: ./src/common/iServer/SurfaceAnalystService.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/







/**
 * @class SurfaceAnalystService
 * @deprecatedclass SuperMap.SurfaceAnalystService
 * @category  iServer SpatialAnalyst SurfaceAnalyst
 * @classdesc 表面分析服务类。
 * 该类负责将客户设置的表面分析服务参数传递给服务端，并接收服务端返回的表面分析服务分析结果数据。
 * 表面分析结果通过该类支持的事件的监听函数参数获取
 * @param {string} url - 服务地址。如 http://localhost:8090/iserver/services/spatialanalyst-changchun/restjsr/spatialanalyst
 * @param {Object} options - 参数。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @extends {SpatialAnalystBase}
 * @example 例如：
 * (start code)
 * var mySurfaceAnalystService = new SurfaceAnalystService(url);
 * (end)
 * @usage
 */
class SurfaceAnalystService extends SpatialAnalystBase {

    constructor(url, options) {
        super(url, options);
        this.CLASS_NAME = "SuperMap.SurfaceAnalystService";
    }

    /**
     * @function SurfaceAnalystService.prototype.destroy
     * @description 释放资源,将引用的资源属性置空。
     */
    destroy() {
        super.destroy();
    }

    /**
     * @function SurfaceAnalystService.prototype.processAsync
     * @description 负责将客户端的表面分析服务参数传递到服务端。
     * @param {SurfaceAnalystParameters} params - 表面分析提取操作参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    processAsync(params, callback) {
        if (!(params instanceof SurfaceAnalystParameters)) {
            return;
        }
        var me = this, jsonParameters;
        jsonParameters = me.getJsonParameters(params);
        return me.request({
            method: "POST",
            data: jsonParameters,
            scope: me,
            success: callback,
            failure: callback
        });
    }

    /**
     * @function SurfaceAnalystService.prototype.getJsonParameters
     * @description 将参数转化为 JSON 字符串。
     * @param {SurfaceAnalystParameters} params - 表面分析提取操作参数类。
     * @returns {Object} 转化后的JSON字符串。
     */
    getJsonParameters(params) {
        var jsonParameters = '';
        var parameterObject = {};
        var me = this;
        if (params instanceof DatasetSurfaceAnalystParameters) {
            me.url = Util_Util.urlPathAppend(
                me.url,
                'datasets/' + params.dataset + '/' + params.surfaceAnalystMethod.toLowerCase()
            );
            DatasetSurfaceAnalystParameters.toObject(params, parameterObject);
            jsonParameters = Util_Util.toJSON(parameterObject);
        } else if (params instanceof GeometrySurfaceAnalystParameters) {
            me.url = Util_Util.urlPathAppend(me.url, 'geometry/' + params.surfaceAnalystMethod.toLowerCase());
            jsonParameters = Util_Util.toJSON(params);
        } else {
            return;
        }
        this.returnContent = true;
        return jsonParameters;
    }

    dataFormat() {
      return [DataFormat.GEOJSON, DataFormat.ISERVER, DataFormat.FGB];
    }
}

;// CONCATENATED MODULE: ./src/common/iServer/TerrainCurvatureCalculationParameters.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


/**
 * @class TerrainCurvatureCalculationParameters
 * @deprecatedclass SuperMap.TerrainCurvatureCalculationParameters
 * @category  iServer SpatialAnalyst TerrainCalculation
 * @classdesc 地形曲率计算参数类。
 * @param {Object} options - 参数。
 * @param {string} options.dataset - 地形曲率计算数据源中数据集的名称。该名称用形如"数据集名称@数据源别名"形式来表示，例如：JingjinTerrain@Jingjin。
 * @param {string} options.averageCurvatureName - 结果数据集：平均曲率数据集的名称。
 * @param {string} options.profileCurvatureName - 结果数据集：剖面曲率数据集的名称。
 * @param {string} options.planCurvatureName - 结果数据集：平面曲率数据集的名称。
 * @param {number} [options.zFactor=1.0] - 指定的高程缩放系数。1.0 表示不缩放。
 * @param {boolean} [options.deleteExistResultDataset=false] - 如果用户命名的结果数据集名称与已有的数据集重名，是否删除已有的数据集。
 * @usage
 */
class TerrainCurvatureCalculationParameters {

    constructor(options) {
        if (!options) {
            return;
        }
        /**
         * @member {string} TerrainCurvatureCalculationParameters.prototype.dataset
         * @description 要用来做地形曲率计算数据源中数据集的名称。
         * 该名称用形如"数据集名称@数据源别名"形式来表示，例如：JingjinTerrain@Jingjin。
         * 注：地形曲率计算必须为栅格数据集。
         */
        this.dataset = null;

        /**
         * @member {number} [TerrainCurvatureCalculationParameters.prototype.zFactor=1.0]
         * @description 指定的高程缩放系数。1.0 表示不缩放。
         * 该值是指在 DEM 栅格数据中，栅格值（ Z 坐标，即高程值）相对于 X 和 Y 坐标的单位变换系数。
         * 通常有 X，Y，Z 都参加的计算中，需要将高程值乘以一个高程缩放系数，使得三者单位一致。
         * 例如，X、Y 方向上的单位是米，而 Z 方向的单位是英尺，由于 1 英尺等于 0.3048 米，则需要指定缩放系数为 0.3048。
         */
        this.zFactor = 1.0;

        /**
         * @member {string} TerrainCurvatureCalculationParameters.prototype.averageCurvatureName
         * @description 结果数据集：平均曲率数据集的名称。
         */
        this.averageCurvatureName = null;

        /**
         * @member {string} TerrainCurvatureCalculationParameters.prototype.profileCurvatureName
         * @description 结果数据集：剖面曲率数据集的名称。
         */
        this.profileCurvatureName = "";

        /**
         * @member {string} TerrainCurvatureCalculationParameters.prototype.planCurvatureName
         * @description 结果数据集：平面曲率数据集的名称。
         */
        this.planCurvatureName = "";

        /**
         * @member {boolean} [TerrainCurvatureCalculationParameters.prototype.deleteExistResultDataset=false]
         * @description 如果用户命名的结果数据集名称与已有的数据集重名，是否删除已有的数据集。
         */
        this.deleteExistResultDataset = false;

        Util_Util.extend(this, options);

        this.CLASS_NAME = "SuperMap.TerrainCurvatureCalculationParameters";
    }


    /**
     * @function TerrainCurvatureCalculationParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        var me = this;
        me.dataset = null;
        me.zFactor = 1.0;
        me.averageCurvatureName = null;
        me.profileCurvatureName = null;
        me.planCurvatureName = null;
        me.deleteExistResultDataset = true;
    }

    /**
     * @function TerrainCurvatureCalculationParameters.toObject
     * @param {Object} derrainCurvatureCalculationParameters - 地形曲率计算参数。
     * @param {Object} tempObj - 目标对象。
     * @description 生成地形曲率计算对象。
     */
    static toObject(derrainCurvatureCalculationParameters, tempObj) {
        for (var name in derrainCurvatureCalculationParameters) {
            if (name !== "dataset") {
                tempObj[name] = derrainCurvatureCalculationParameters[name];
            }
        }
    }

}


;// CONCATENATED MODULE: ./src/common/iServer/TerrainCurvatureCalculationService.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/




/**
 * @class TerrainCurvatureCalculationService
 * @deprecatedclass SuperMap.TerrainCurvatureCalculationService
 * @category  iServer SpatialAnalyst TerrainCalculation
 * @classdesc 地形曲率计算服务类。
 * @extends {SpatialAnalystBase}
 * @param {Object} options - 参数。
 * @param {string} options.url - 服务的访问地址。如 http://localhost:8090/iserver/services/spatialanalyst-changchun/restjsr/spatialanalyst 。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @example 例如：
 * (start code)
 * var myTerrainCurvatureCalculationService = new TerrainCurvatureCalculationService(url);
 * myTerrainCurvatureCalculationService.on({
     *     "processCompleted": processCompleted,
     *     "processFailed": processFailed
     *     }
 * );
 * (end)
 * @usage
 */
class TerrainCurvatureCalculationService extends SpatialAnalystBase {

    constructor(url, options) {
        super(url, options);
        this.CLASS_NAME = "SuperMap.TerrainCurvatureCalculationService";
    }

    /**
     *@override
     */
    destroy() {
        super.destroy();
    }

    /**
     * @function TerrainCurvatureCalculationService.prototype.processAsync
     * @description 负责将客户端的查询参数传递到服务端。
     * @param {TerrainCurvatureCalculationParameters} parameter - 地形曲率计算参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    processAsync(parameter, callback) {
        var me = this;
        var parameterObject = {};

        if (parameter instanceof TerrainCurvatureCalculationParameters) {
            me.url = Util_Util.urlPathAppend(me.url, 'datasets/' + parameter.dataset + '/terraincalculation/curvature');
        }

        TerrainCurvatureCalculationParameters.toObject(parameter, parameterObject);
        var jsonParameters = Util_Util.toJSON(parameterObject);
        me.url = Util_Util.urlAppend(me.url, 'returnContent=true');
        return me.request({
            method: "POST",
            data: jsonParameters,
            scope: me,
            success: callback,
            failure: callback
        });
    }
}


;// CONCATENATED MODULE: ./src/common/iServer/TerrainCutFillCalculationParameters.js
/* Copyright© 2000 - 2022 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/

// import {Geometry3D} from '../commontypes/Geometry3D';

/**
 * @class TerrainCutFillCalculationParameters
 * @deprecatedclass SuperMap.TerrainCutFillCalculationParameters
 * @category  iServer SpatialAnalyst TerrainCalculation
 * @classdesc 填挖方计算参数类。
 * @version 11.1.1
 * @param {Object} options - 参数。
 * @param {string} options.dataset - 填挖方计算数据源中数据集的名称。该名称用形如"数据集名称@数据源别名"形式来表示，例如：JingjinTerrain@Jingjin。
 * @param {string} [options.cutFillType="GRID"] - 填挖方分析的类型，包含： 
                                                GRID：根据结果栅格进行填挖方分析，也叫栅格填挖方 
                                                LINE3DANDBUFFERRADIUS：根据指定的三维线及缓冲半径进行进行填挖方分析，也叫斜面填挖方。 
                                                REGION3D：三维面填挖方计算。 
                                                REGIONANDALTITUDE：根据指定的面区域及结果高程值进行填挖方分析，也叫选面填挖方计算。 
* @param {string} [options.afterCutFillDataset] - 填挖方后的栅格数据集，当填挖方分析的类型为 GRID 时有效，此时为必填。
* @param {string} [options.resultDataset] - 填挖方分析的结果数据集。
* @param {boolean} [options.buildPyramid] - 是否对结果栅格数据集创建金字塔。 
* @param {boolean} [options.deleteExistResultDataset] - 如果用户命名的结果数据集名称与已有的数据集重名，是否删除已有的数据集。
* @param {number} [options.bufferRadius] - 填挖方线路的缓冲区半径，当填挖方分析的类型为 LINE3DANDBUFFERRADIUS 时有效。
* @param {boolean} [options.isRoundHead] - 是否使用圆头缓冲为填挖方路线创建缓冲区，默认为 false，当填挖方分析的类型为 LINE3DANDBUFFERRADIUS 时有效。 
* @param {Geometry3D} [options.line3D] - 填挖方路线，当填挖方分析的类型为 LINE3DANDBUFFERRADIUS 时有效。
* @param {Geometry} [options.region] - 填挖方区域，当填挖方分析的类型为 REGIONANDALTITUDE 时有效。
* @param {Geometry3D} [options.region3D] - 三维面对象，当填挖方分析的类型为 REGION3D 时有效。
 * @usage
 */
class TerrainCutFillCalculationParameters {

    constructor(options) {
        if (!options) {
            return;
        }
        /**
         * @member {string} TerrainCutFillCalculationParameters.prototype.dataset
         * @description 要用来做填挖方计算数据源中数据集的名称。
         * 该名称用形如"数据集名称@数据源别名"形式来表示，例如：JingjinTerrain@Jingjin。
         */
        this.dataset = null;

        /**
         * @member {string} TerrainCutFillCalculationParameters.prototype.cutFillType
         * @description 填挖方分析的类型，包含： 
                                        GRID：根据结果栅格进行填挖方分析，也叫栅格填挖方 
                                        LINE3DANDBUFFERRADIUS：根据指定的三维线及缓冲半径进行进行填挖方分析，也叫斜面填挖方。 
                                        REGION3D：三维面填挖方计算。 
                                        REGIONANDALTITUDE：根据指定的面区域及结果高程值进行填挖方分析，也叫选面填挖方计算。 
         */
        // this.cutFillType = cutFillType.GRID;
        this.cutFillType = "GRID";

        /**
         * @member {string} TerrainCutFillCalculationParameters.prototype.afterCutFillDataset
         * @description 填挖方后的栅格数据集，当填挖方分析的类型为 GRID 时有效，此时为必填。
         */
        this.afterCutFillDataset = null;

        /**
         * @member {string} TerrainCutFillCalculationParameters.prototype.resultDataset
         * @description 填挖方分析的结果数据集。
         */
        this.resultDataset = null;

        /**
         * @member {boolean} TerrainCutFillCalculationParameters.prototype.buildPyramid
         * @description 是否对结果栅格数据集创建金字塔。 
         */
        this.buildPyramid = null;

        /**
         * @member {boolean} TerrainCutFillCalculationParameters.prototype.deleteExistResultDataset
         * @description 如果用户命名的结果数据集名称与已有的数据集重名，是否删除已有的数据集。
         */
        this.deleteExistResultDataset = null;

        /**
         * @member {number} TerrainCutFillCalculationParameters.prototype.bufferRadius
         * @description 填挖方线路的缓冲区半径，当填挖方分析的类型为 LINE3DANDBUFFERRADIUS 时有效。
         */
        this.bufferRadius = null;

        /**
         * @member {boolean} TerrainCutFillCalculationParameters.prototype.isRoundHead
         * @description 是否使用圆头缓冲为填挖方路线创建缓冲区，默认为 false，当填挖方分析的类型为 LINE3DANDBUFFERRADIUS 时有效。 
         */
        this.isRoundHead = null;

        /**
         * @member {Geometry3D} TerrainCutFillCalculationParameters.prototype.line3D
         * @description 填挖方路线，当填挖方分析的类型为 LINE3DANDBUFFERRADIUS 时有效。
         */
        this.line3D = null;

        /**
         * @member {Geometry} TerrainCutFillCalculationParameters.prototype.region
         * @description 填挖方区域，当填挖方分析的类型为 REGIONANDALTITUDE 时有效。
         */
        this.region = null;

        /**
         * @member {Geometry3D} TerrainCutFillCalculationParameters.prototype.region3D
         * @description 三维面对象，当填挖方分析的类型为 REGION3D 时有效。
         */
        this.region3D = null;


        Util_Util.extend(this, options);

        this.CLASS_NAME = "SuperMap.TerrainCutFillCalculationParameters";
    }


    /**
     * @function TerrainCutFillCalculationParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        var me = this;
        me.cutFillType = null;
        me.afterCutFillDataset = null;
        me.resultDataset = null;
        me.buildPyramid = null;
        me.deleteExistResultDataset = null;
        me.bufferRadius = null;
        me.isRoundHead = null;
        me.line3D = null;
        me.region = null;
        me.region3D = null;
    }

    /**
     * @function TerrainCutFillCalculationParameters.toObject
     * @param {Object} terrainCutFillCalculationParameters - 填挖方计算参数。
     * @param {Object} tempObj - 目标对象。
     * @description 填挖方计算对象。
     */
    static toObject(terrainCutFillCalculationParameters, tempObj) {
        for (var name in terrainCutFillCalculationParameters) {
            if (name !== "dataset") {
                tempObj[name] = terrainCutFillCalculationParameters[name];
            }
        }
    }

}


;// CONCATENATED MODULE: ./src/common/iServer/TerrainCutFillCalculationService.js
/* Copyright© 2000 - 2022 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/




/**
 * @class TerrainCutFillCalculationService
 * @deprecatedclass SuperMap.TerrainCutFillCalculationService
 * @category  iServer SpatialAnalyst TerrainCalculation
 * @classdesc 填挖方计算服务类。
 * @version 11.1.1
 * @extends {SpatialAnalystBase}
 * @param {Object} options - 参数。
 * @param {string} options.url - 服务的访问地址。如 http://localhost:8090/iserver/services/spatialanalyst-changchun/restjsr/spatialanalyst 。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @example 例如：
 * (start code)
 * var myTerrainCutFillCalculationService = new TerrainCutFillCalculationService(url);
 * myTerrainCutFillCalculationService.on({
     *     "processCompleted": processCompleted,
     *     "processFailed": processFailed
     *     }
 * );
 * (end)
 * @usage
 */
class TerrainCutFillCalculationService extends SpatialAnalystBase {

    constructor(url, options) {
        super(url, options);
        this.CLASS_NAME = "SuperMap.TerrainCutFillCalculationService";
    }

    /**
     *@override
     */
    destroy() {
        super.destroy();
    }

    /**
     * @function TerrainCutFillCalculationService.prototype.processAsync
     * @description 负责将客户端的查询参数传递到服务端。
     * @param {TerrainCutFillCalculationParameters} parameter - 填挖方计算参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     */
    processAsync(parameter, callback) {
        var me = this;
        var parameterObject = {};

        if (parameter instanceof TerrainCutFillCalculationParameters) {
            me.url = Util_Util.urlPathAppend(me.url, 'datasets/' + parameter.dataset + '/terraincalculation/cutfill');
        }

        TerrainCutFillCalculationParameters.toObject(parameter, parameterObject);
        var jsonParameters = Util_Util.toJSON(parameterObject);
        me.url = Util_Util.urlAppend(me.url, 'returnContent=true');
        return me.request({
            method: "POST",
            data: jsonParameters,
            scope: me,
            success: callback,
            failure: callback
        });
    }
}


;// CONCATENATED MODULE: ./src/common/iServer/TerrainAspectCalculationParameters.js
/* Copyright© 2000 - 2022 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


/**
 * @class TerrainAspectCalculationParameters
 * @deprecatedclass SuperMap.TerrainAspectCalculationParameters
 * @category  iServer SpatialAnalyst TerrainCalculation
 * @classdesc 地形坡向计算参数类。
 * @param {Object} options - 参数。
 * @param {string} options.dataset - 地形坡向计算数据源中数据集的名称。该名称用形如"数据集名称@数据源别名"形式来表示，例如：JingjinTerrain@Jingjin。
 * @param {terrainAnalystSetting} options.terrainAnalystSetting - 地形分析基本的环境设置。
 * @param {string} [options.resultDatasetName] - 结果数据集名称。
 * @param {boolean} [options.deleteExistResultDataset] - 如果用户命名的结果数据集名称与已有的数据集重名，是否删除已有的数据集。
 * @usage
 */
class TerrainAspectCalculationParameters {

    constructor(options) {
        if (!options) {
            return;
        }
        /**
         * @member {string} TerrainAspectCalculationParameters.prototype.dataset
         * @description 要用来做地形坡向计算数据源中数据集的名称。
         * 该名称用形如"数据集名称@数据源别名"形式来表示，例如：JingjinTerrain@Jingjin。
         */
        this.dataset = null;

        /**
         * @member {terrainAnalystSetting} TerrainAspectCalculationParameters.prototype.terrainAnalystSetting
         * @description 地形分析基本的环境设置。
         */
        this.terrainAnalystSetting = null;

        /**
         * @member {string} TerrainAspectCalculationParameters.prototype.resultDatasetName
         * @description 结果数据集名称。
         */
        this.resultDatasetName = null;

        /**
         * @member {boolean} TerrainAspectCalculationParameters.prototype.deleteExistResultDataset
         * @description 如果用户命名的结果数据集名称与已有的数据集重名，是否删除已有的数据集。
         */
        this.deleteExistResultDataset = null;

        Util_Util.extend(this, options);

        this.CLASS_NAME = "SuperMap.TerrainAspectCalculationParameters";
    }


    /**
     * @function TerrainAspectCalculationParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        var me = this;
        me.terrainAnalystSetting = null;
        me.resultDatasetName = null;
        me.deleteExistResultDataset = null;
    }

    /**
     * @function TerrainAspectCalculationParameters.toObject
     * @param {Object} terrainAspectCalculationParameters - 地形坡向计算参数。
     * @param {Object} tempObj - 目标对象。
     * @description 地形坡向计算对象。
     */
    static toObject(terrainAspectCalculationParameters, tempObj) {
        for (var name in terrainAspectCalculationParameters) {
            if (name !== "dataset") {
                tempObj[name] = terrainAspectCalculationParameters[name];
            }
        }
    }

}


;// CONCATENATED MODULE: ./src/common/iServer/TerrainAspectCalculationService.js
/* Copyright© 2000 - 2022 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/




/**
 * @class TerrainAspectCalculationService
 * @deprecatedclass SuperMap.TerrainAspectCalculationService
 * @category  iServer SpatialAnalyst TerrainCalculation
 * @classdesc 地形坡向计算服务类。
 * @version 11.1.1
 * @extends {SpatialAnalystBase}
 * @param {Object} options - 参数。
 * @param {string} options.url - 服务的访问地址。如 http://localhost:8090/iserver/services/spatialanalyst-changchun/restjsr/spatialanalyst 。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @example 例如：
 * (start code)
 * var myTerrainCutFillCalculationService = new TerrainAspectCalculationService(url);
 * myTerrainCutFillCalculationService.on({
     *     "processCompleted": processCompleted,
     *     "processFailed": processFailed
     *     }
 * );
 * (end)
 * @usage
 */
class TerrainAspectCalculationService extends SpatialAnalystBase {

    constructor(url, options) {
        super(url, options);
        this.CLASS_NAME = "SuperMap.TerrainAspectCalculationService";
    }

    /**
     *@override
     */
    destroy() {
        super.destroy();
    }

    /**
     * @function TerrainAspectCalculationService.prototype.processAsync
     * @description 负责将客户端的查询参数传递到服务端。
     * @param {TerrainAspectCalculationParameters} parameter - 地形坡向计算参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     */
    processAsync(parameter, callback) {
        var me = this;
        var parameterObject = {};

        if (parameter instanceof TerrainAspectCalculationParameters) {
            me.url = Util_Util.urlPathAppend(me.url, 'datasets/' + parameter.dataset + '/terraincalculation/aspect');
        }

        TerrainAspectCalculationParameters.toObject(parameter, parameterObject);
        var jsonParameters = Util_Util.toJSON(parameterObject);
        me.url = Util_Util.urlAppend(me.url, 'returnContent=true');
        return me.request({
            method: "POST",
            data: jsonParameters,
            scope: me,
            success: callback,
            failure: callback
        });
    }
}


;// CONCATENATED MODULE: ./src/common/iServer/TerrainSlopeCalculationParameters.js
/* Copyright© 2000 - 2022 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


/**
 * @class TerrainSlopeCalculationParameters
 * @deprecatedclass SuperMap.TerrainSlopeCalculationParameters
 * @category  iServer SpatialAnalyst TerrainCalculation
 * @classdesc 地形坡度计算参数类。
 * @param {Object} options - 参数。
 * @param {string} options.dataset - 地形坡度计算数据源中数据集的名称。该名称用形如"数据集名称@数据源别名"形式来表示，例如：JingjinTerrain@Jingjin。
 * @param {terrainAnalystSetting} options.terrainAnalystSetting - 地形分析基本的环境设置。
 * @param {string} [options.resultDatasetName] - 结果数据集名称。
 * @param {boolean} [options.deleteExistResultDataset] - 如果用户命名的结果数据集名称与已有的数据集重名，是否删除已有的数据集。
 * @param {number} [options.zFactor] - 高程缩放系数
 * @param {string} options.slopeType - 结果坡度的单位类型，包括： 
                                            DEGREE：以角度为单位表示坡度 
                                            PERCENT：以百分数来表示坡度 
                                            RADIAN：以弧度为单位表示坡度
 * @usage
 */
class TerrainSlopeCalculationParameters {

    constructor(options) {
        if (!options) {
            return;
        }
        /**
         * @member {string} TerrainSlopeCalculationParameters.prototype.dataset
         * @description 要用来做地形坡度计算数据源中数据集的名称。
         * 该名称用形如"数据集名称@数据源别名"形式来表示，例如：JingjinTerrain@Jingjin。
         */
        this.dataset = null;

        /**
         * @member {terrainAnalystSetting} TerrainSlopeCalculationParameters.prototype.terrainAnalystSetting
         * @description 地形分析基本的环境设置。
         */
        this.terrainAnalystSetting = null;

        /**
         * @member {string} TerrainSlopeCalculationParameters.prototype.resultDatasetName
         * @description 结果数据集名称。
         */
        this.resultDatasetName = null;

        /**
         * @member {boolean} TerrainSlopeCalculationParameters.prototype.deleteExistResultDataset
         * @description 如果用户命名的结果数据集名称与已有的数据集重名，是否删除已有的数据集。
         */
        this.deleteExistResultDataset = null;

        /**
         * @member {number} TerrainSlopeCalculationParameters.prototype.zFactor
         * @description 高程缩放系数。
         */
        this.zFactor = null;

        /**
         * @member {string} TerrainSlopeCalculationParameters.prototype.slopeType
         * @description 结果坡度的单位类型，包括： 
                            DEGREE：以角度为单位表示坡度 
                            PERCENT：以百分数来表示坡度 
                            RADIAN：以弧度为单位表示坡度
         */
        this.slopeType = null;

        Util_Util.extend(this, options);

        this.CLASS_NAME = "SuperMap.TerrainSlopeCalculationParameters";
    }


    /**
     * @function TerrainSlopeCalculationParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        var me = this;
        me.terrainAnalystSetting = null;
        me.resultDatasetName = null;
        me.deleteExistResultDataset = null;
        me.zFactor = null;
        me.slopeType = null;
    }

    /**
     * @function TerrainSlopeCalculationParameters.toObject
     * @param {Object} terrainSlopeCalculationParameters - 地形坡度计算参数。
     * @param {Object} tempObj - 目标对象。
     * @description 地形坡度计算对象。
     */
    static toObject(terrainSlopeCalculationParameters, tempObj) {
        for (var name in terrainSlopeCalculationParameters) {
            if (name !== "dataset") {
                tempObj[name] = terrainSlopeCalculationParameters[name];
            }
        }
    }

}


;// CONCATENATED MODULE: ./src/common/iServer/TerrainSlopeCalculationService.js
/* Copyright© 2000 - 2022 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/




/**
 * @class TerrainSlopeCalculationService
 * @deprecatedclass SuperMap.TerrainSlopeCalculationService
 * @category  iServer SpatialAnalyst TerrainCalculation
 * @classdesc 地形坡度计算服务类。
 * @extends {SpatialAnalystBase}
 * @param {Object} options - 参数。
 * @param {string} options.url - 服务的访问地址。如 http://localhost:8090/iserver/services/spatialanalyst-changchun/restjsr/spatialanalyst 。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @example 例如：
 * (start code)
 * var myTerrainCutFillCalculationService = new TerrainSlopeCalculationService(url);
 * myTerrainCutFillCalculationService.on({
     *     "processCompleted": processCompleted,
     *     "processFailed": processFailed
     *     }
 * );
 * (end)
 * @usage
 */
class TerrainSlopeCalculationService extends SpatialAnalystBase {

    constructor(url, options) {
        super(url, options);
        this.CLASS_NAME = "SuperMap.TerrainSlopeCalculationService";
    }

    /**
     *@override
     */
    destroy() {
        super.destroy();
    }

    /**
     * @function TerrainSlopeCalculationService.prototype.processAsync
     * @description 负责将客户端的查询参数传递到服务端。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @param {TerrainSlopeCalculationParameters} parameter - 地形坡度计算参数类。
     */
    processAsync(parameter, callback) {
        var me = this;
        var parameterObject = {};

        if (parameter instanceof TerrainSlopeCalculationParameters) {
            me.url = Util_Util.urlPathAppend(me.url, 'datasets/' + parameter.dataset + '/terraincalculation/slope');
        }

        TerrainSlopeCalculationParameters.toObject(parameter, parameterObject);
        var jsonParameters = Util_Util.toJSON(parameterObject);
        me.url = Util_Util.urlAppend(me.url, 'returnContent=true');
        return me.request({
            method: "POST",
            data: jsonParameters,
            scope: me,
            success: callback,
            failure: callback
        });
    }
}


;// CONCATENATED MODULE: ./src/common/iServer/DatasetThiessenAnalystParameters.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/




/**
 * @class DatasetThiessenAnalystParameters
 * @deprecatedclass SuperMap.DatasetThiessenAnalystParameters
 * @category iServer SpatialAnalyst ThiessenAnalyst
 * @classdesc 数据集泰森多边形分析参数类。
 * @param {Object} options - 参数。
 * @param {(GeometryPolygon|L.Polygon|ol.geom.Polygon|GeoJSONObject)} [options.clipRegion] - 结果数据裁剪区域，可以为 null，表示不对结果进行裁剪。
 * @param {boolean} [options.createResultDataset] - 是否返回结果数据集。如果为 true，则必须设置属性 resultDatasetName 和 resultDatasourceName。
 * @param {string} [options.dataset] - 数据集名称待分析的数据集名称，请使用 "datasetName@datasourceName" 格式来表示。
 * @param {FilterParameter} [options.filterQueryParameter] - 过滤参数类，即对数据集中的所有点进行分析。
 * @param {string} [options.resultDatasetName] - 指定结果数据集名称。
 * @param {boolean} [options.resultDatasourceName] - 指定结果数据集所在数据源。
 * @param {boolean} [options.returnResultRegion] - 是否返回分析得到的多边形面数组。
 * @extends {ThiessenAnalystParameters}
 * @usage
 */
class DatasetThiessenAnalystParameters extends ThiessenAnalystParameters {


    constructor(options) {
        super(options);
        /**
         * @member {FilterParameter} [DatasetThiessenAnalystParameters.prototype.filterQueryParameter]
         * @description 过滤条件，对待分析数据集中的点进行过滤，即对数据集中的所有点进行分析。
         * @example
         *  var filterQueryParameter = new FilterParameter({
         *   name: "Countries@World",
         *   attributeFilter: "SmID>100"
         *  });
         */
        this.filterQueryParameter = null;

        /**
         * @member {string} DatasetThiessenAnalystParameters.prototype.dataset
         * @description 数据集名称待分析的数据集名称，请使用 "datasetName@datasourceName" 格式来表示。
         */
        this.dataset = null;

        if (options) {
            Util_Util.extend(this, options);
        }


        this.CLASS_NAME = "SuperMap.DatasetThiessenAnalystParameters";
    }

    /**
     * @function DatasetThiessenAnalystParameters.prototype.destroy
     * @override
     */
    destroy() {
        super.destroy();
        var me = this;
        if (me.filterQueryParameter) {
            me.filterQueryParameter.destroy();
            me.filterQueryParameter = null;
        }
    }

    /**
     * @function DatasetThiessenAnalystParameters.toObject
     * @param {DatasetThiessenAnalystParameters} datasetThiessenAnalystParameters - 泰森多边形分析服务参数类。
     * @param {DatasetThiessenAnalystParameters} tempObj - 泰森多边形分析服务参数对象。
     * @description 将泰森多边形分析服务参数对象转换为 JSON 对象。
     * @returns JSON 对象。
     */
    static toObject(datasetThiessenAnalystParameters, tempObj) {
        for (var name in datasetThiessenAnalystParameters) {
            if (name === "clipRegion") {
                tempObj.clipRegion = ServerGeometry.fromGeometry(datasetThiessenAnalystParameters.clipRegion);
            } else {
                tempObj[name] = datasetThiessenAnalystParameters[name];
            }
        }
    }

}


;// CONCATENATED MODULE: ./src/common/iServer/GeometryThiessenAnalystParameters.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/




/**
 * @class GeometryThiessenAnalystParameters
 * @deprecatedclass SuperMap.GeometryThiessenAnalystParameters
 * @constructs GeometryThiessenAnalystParameters
 * @category iServer SpatialAnalyst ThiessenPolygonAnalyst
 * @classdesc 几何对象泰森多边形分析参数类。对指定的某个几何对象做泰森多边形分析。通过该类可以指定要做泰森多边形分析的几何对象、返回数据集名称等。
 * @param {Object} options - 参数。
 * @param {Array.<GeometryPoint|L.LatLng|L.Point|ol.geom.Point|mapboxgl.LngLat|Array.<number>>} options.points - 使用点数组进行分析时使用的几何对象。
 * @extends {ThiessenAnalystParameters}
 * @usage
 */

class GeometryThiessenAnalystParameters extends ThiessenAnalystParameters {


    constructor(options) {
        super(options);
        /**
         * @member {Array.<GeometryPoint|L.LatLng|L.Point|ol.geom.Point|mapboxgl.LngLat|Array.<number>>} GeometryThiessenAnalystParameters.prototype.points
         * @description 使用点数组进行分析时使用的几何对象。
         */
        this.points = null;
        if (options) {
            Util_Util.extend(this, options);
        }
        this.CLASS_NAME = "SuperMap.GeometryThiessenAnalystParameters";
    }

    /**
     * @function GeometryThiessenAnalystParameters.prototype.destroy
     * @override
     */
    destroy() {
        super.destroy();
        var me = this;
        if (me.points) {
            for (var i = me.points.length - 1; i >= 0; i--) {
                me.points[i].destroy();
            }
            me.points = null;
        }
    }

    /**
     * @function GeometryThiessenAnalystParameters.toObject
     * @param {GeometryThiessenAnalystParameters} geometryThiessenAnalystParameters - 几何对象泰森多边形分析参数类。
     * @param {GeometryThiessenAnalystParameters} tempObj - 几何对象泰森多边形分析参数对象。
     * @description 将几何对象泰森多边形分析参数对象转换为 JSON 对象。
     * @returns {Object} JSON 对象。
     */
    static toObject(geometryThiessenAnalystParameters, tempObj) {
        for (var name in geometryThiessenAnalystParameters) {
            if (name === "clipRegion") {
                tempObj.clipRegion = ServerGeometry.fromGeometry(geometryThiessenAnalystParameters.clipRegion);
            } else {
                tempObj[name] = geometryThiessenAnalystParameters[name];
            }
        }
    }


}

;// CONCATENATED MODULE: ./src/common/iServer/ThiessenAnalystService.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/





/**
 * @class ThiessenAnalystService
 * @deprecatedclass SuperMap.ThiessenAnalystService
 * @category  iServer SpatialAnalyst ThiessenPolygonAnalyst
 * @classdesc
 * 泰森多边形分析服务类
 * 该类负责将客户设置的泰森多边形分析参数传递给服务端，并接收服务端返回的分析结果数据。
 * 泰森多边形分析结果通过该类支持的事件的监听函数参数获取
 * 泰森多边形分析的参数支持两种，当参数为 {@link DatasetThiessenAnalystParameters} 类型
 * 时，执行数据集泰森多边形分析，当参数为 {@link GeometryThiessenAnalystParameters} 类型时，
 * 执行几何对象泰森多边形分析。
 * @param {string} url - 服务地址。如 http://localhost:8090/iserver/services/spatialanalyst-changchun/restjsr/spatialanalyst。
 * @param {Object} options - 参数。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @extends {SpatialAnalystBase}
 * @example 例如：
 * (start code)
 * var myThiessenAnalystService = new ThiessenAnalystService(url);
 * (end)
 * @usage
 */
class ThiessenAnalystService extends SpatialAnalystBase {

    constructor(url, options) {
        super(url, options);
        /**
         * @member {string} ThiessenAnalystService.prototype.mode
         * @description 缓冲区分析类型
         */
        this.mode = null;
        if (options) {
            Util_Util.extend(this, options);
        }
        this.CLASS_NAME = "SuperMap.ThiessenAnalystService";
    }

    /**
     * @override
     */
    destroy() {
        super.destroy();
        this.mode = null;
    }

    /**
     * @function ThiessenAnalystService.prototype.processAsync
     * @description 负责将客户端的查询参数传递到服务端。
     * @param {DatasetThiessenAnalystParameters|GeometryThiessenAnalystParameters} parameter - 泰森多边形分析参数基类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    processAsync(parameter, callback) {
        var parameterObject = {};
        var me = this;
        if (parameter instanceof DatasetThiessenAnalystParameters) {
            me.mode = "datasets";
            me.url = Util_Util.urlPathAppend(me.url, 'datasets/' + parameter.dataset + '/thiessenpolygon');
            DatasetThiessenAnalystParameters.toObject(parameter, parameterObject);
        } else if (parameter instanceof GeometryThiessenAnalystParameters) {
            me.mode = "geometry";
            me.url = Util_Util.urlPathAppend(me.url, 'geometry/thiessenpolygon');
            GeometryThiessenAnalystParameters.toObject(parameter, parameterObject);
        }

        var jsonParameters = Util_Util.toJSON(parameterObject);
        this.returnContent = true;
        return me.request({
            method: "POST",
            data: jsonParameters,
            scope: me,
            success: callback,
            failure: callback
        });
    }

    dataFormat() {
      return [DataFormat.GEOJSON, DataFormat.ISERVER, DataFormat.FGB];
    }
}

;// CONCATENATED MODULE: ./src/common/iServer/MinDistanceAnalystParameters.js
/* Copyright© 2000 - 2022 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


/**
 * @class MinDistanceAnalystParameters
 * @deprecatedclass SuperMap.MinDistanceAnalystParameters
 * @category iServer SpatialAnalyst MinDistanceAnalyst
 * @classdesc 最近距离分析参数基类。
 * @version 11.1.1
 * @param {Object} options - 参数。
 * @param {string} options.referenceDatasetName - 参考数据集的名称。可以是二维点、线、面数据集或二维网络数据集
 * @param {FilterParameter} [options.referenceFilterQueryParameter=null] - 对参考数据集中的要素进行过滤的属性过滤条件。不设置时默认为 null，即以参考数据集中的所有要素为参考要素进行计算。
 * @param {boolean} [options.createResultDataset] - 是否创建结果数据集。
 * @param {string} [options.resultDatasetName] - 结果数据集名称。
 * @param {string} [options.resultDatasourceName] - 结果数据集所在数据源的名称。
 * @param {number} options.minDistance - 指定的查询范围的最小距离。取值范围为大于或等于 0。单位与被计算记录集所属数据集的单位相同。
 * @param {number} options.maxDistance - 指定的查询范围的最大距离。取值范围为大于 0 的值及 -1。当设置为 -1 时，表示不限制最大距离。单位与被计算记录集所属数据集的单位相同。
 * @usage
 */
class MinDistanceAnalystParameters {

    constructor(options) {
        /**
         * @member {string} MinDistanceAnalystParameters.prototype.referenceDatasetName
         * @description 参考数据集的名称。可以是二维点、线、面数据集或二维网络数据集
         */
        this.referenceDatasetName = null;

        /**
         * @member {FilterParameter} [MinDistanceAnalystParameters.prototype.referenceFilterQueryParameter=null]
         * @description 对参考数据集中的要素进行过滤的属性过滤条件。不设置时默认为 null，即以参考数据集中的所有要素为参考要素进行计算。
         */
        this.referenceFilterQueryParameter = null;

        /**
         * @member {boolean} [MinDistanceAnalystParameters.prototype.createResultDataset]
         * @description 是否创建结果数据集。
         */
        this.createResultDataset = null;

        /**
         * @member {string} [MinDistanceAnalystParameters.prototype.resultDatasetName]
         * @description 结果数据集名称。
         */
        this.resultDatasetName = null;

        /**
         * @member {string} [MinDistanceAnalystParameters.prototype.resultDatasourceName]
         * @description 结果数据集所在数据源的名称。
         */
        this.resultDatasourceName = null;

        /**
         * @member {number} MinDistanceAnalystParameters.prototype.minDistance
         * @description 指定的查询范围的最小距离。取值范围为大于或等于 0。单位与被计算记录集所属数据集的单位相同。
         */
        this.minDistance = null;

        /**
         * @member {number} MinDistanceAnalystParameters.prototype.maxDistance
         * @description 指定的查询范围的最大距离。取值范围为大于 0 的值及 -1。当设置为 -1 时，表示不限制最大距离。单位与被计算记录集所属数据集的单位相同。
         */
        this.maxDistance = null;
        if (options) {
            Util_Util.extend(this, options);
        }

        this.CLASS_NAME = "SuperMap.MinDistanceAnalystParameters";
    }

    /**
     * @function MinDistanceAnalystParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        var me = this;
        me.referenceDatasetName = null;
        me.dataset = null;
        me.referenceFilterQueryParameter = null;
        me.createResultDataset = null;
        me.resultDatasetName = null;
        me.resultDatasourceName = null;
        me.minDistance = null;
        me.maxDistance = null;
    }

}

;// CONCATENATED MODULE: ./src/common/iServer/DatasetMinDistanceAnalystParameters.js
/* Copyright© 2000 - 2022 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/



/**
 * @class DatasetMinDistanceAnalystParameters
 * @deprecatedclass SuperMap.DatasetMinDistanceAnalystParameters
 * @category iServer SpatialAnalyst MinDistanceAnalyst
 * @classdesc 数据集最近距离分析参数类。
 * @version 11.1.1
 * @param {Object} options - 参数。
 * @param {FilterParameter} [options.inputFilterQueryParameter] - 对被计算数据集的要素进行过滤的属性过滤条件。只有满足此条件的要素才参与最近距离计算。
 * @param {string} options.referenceDatasetName - 参考数据集的名称。可以是二维点、线、面数据集或二维网络数据集
 * @param {FilterParameter} [options.referenceFilterQueryParameter=null] - 对参考数据集中的要素进行过滤的属性过滤条件。不设置时默认为 null，即以参考数据集中的所有要素为参考要素进行计算。
 * @param {boolean} [options.createResultDataset] - 是否创建结果数据集。
 * @param {string} [options.resultDatasetName] - 结果数据集名称。
 * @param {string} [options.resultDatasourceName] - 结果数据集所在数据源的名称。
 * @param {number} options.minDistance - 指定的查询范围的最小距离。取值范围为大于或等于 0。单位与被计算记录集所属数据集的单位相同。
 * @param {number} options.maxDistance - 指定的查询范围的最大距离。取值范围为大于 0 的值及 -1。当设置为 -1 时，表示不限制最大距离。单位与被计算记录集所属数据集的单位相同。
 * @extends {MinDistanceAnalystParameters}
 * @usage
 */
class DatasetMinDistanceAnalystParameters extends MinDistanceAnalystParameters{

    constructor(options) {
        super(options);
        /**
         *  @member {string} DatasetMinDistanceAnalystParameters.prototype.dataset
         *  @description 源数据集名称。
         */
            this.dataset = null;

        /**
         * @member {FilterParameter} [DatasetMinDistanceAnalystParameters.prototype.inputFilterQueryParameter]
         * @description 对被计算数据集的要素进行过滤的属性过滤条件。只有满足此条件的要素才参与最近距离计算。
         */
        this.inputFilterQueryParameter = null;

        if (options) {
            Util_Util.extend(this, options);
        }

        this.CLASS_NAME = "SuperMap.DatasetMinDistanceAnalystParameters";
    }

    /**
     * @function DatasetMinDistanceAnalystParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        super.destroy();
        var me = this;
        this.dataset = null;
        me.inputFilterQueryParameter = null;
    }
}

;// CONCATENATED MODULE: ./src/common/iServer/GeometryMinDistanceAnalystParameters.js
/* Copyright© 2000 - 2022 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/





/**
 * @class GeometryMinDistanceAnalystParameters
 * @deprecatedclass SuperMap.GeometryMinDistanceAnalystParameters
 * @category iServer SpatialAnalyst MinDistanceAnalyst
 * @classdesc 几何对象最近距离分析参数类。
 * @version 11.1.1
 * @param {Object} options - 参数。
 * @param {Array.<Geometry>} options.inputGeometries - 被计算几何对象集合，目前只支持二维点对象
 * @param {string} options.referenceDatasetName - 参考数据集的名称。可以是二维点、线、面数据集或二维网络数据集
 * @param {FilterParameter} [options.referenceFilterQueryParameter=null] - 对参考数据集中的要素进行过滤的属性过滤条件。不设置时默认为 null，即以参考数据集中的所有要素为参考要素进行计算。
 * @param {boolean} [options.createResultDataset] - 是否创建结果数据集。
 * @param {string} [options.resultDatasetName] - 结果数据集名称。
 * @param {string} [options.resultDatasourceName] - 结果数据集所在数据源的名称。
 * @param {number} options.minDistance - 指定的查询范围的最小距离。取值范围为大于或等于 0。单位与被计算记录集所属数据集的单位相同。
 * @param {number} options.maxDistance - 指定的查询范围的最大距离。取值范围为大于 0 的值及 -1。当设置为 -1 时，表示不限制最大距离。单位与被计算记录集所属数据集的单位相同。
 * @extends {MinDistanceAnalystParameters}
 * @usage
 */
class GeometryMinDistanceAnalystParameters extends MinDistanceAnalystParameters{

    constructor(options) {
        super(options);
        /**
         * @member {Array.<Geometry>} GeometryMinDistanceAnalystParameters.prototype.inputGeometries
         * @description 被计算几何对象集合，目前只支持二维点对象
         */
        this.inputGeometries = null;

        if (options) {
            Util_Util.extend(this, options);
        }

        this.CLASS_NAME = "SuperMap.GeometryMinDistanceAnalystParameters";
    }

    /**
     * @function GeometryMinDistanceAnalystParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        super.destroy();
        var me = this;
        me.inputGeometries = null;
    }
    
    /**
     * @function GeometryMinDistanceAnalystParameters.toObject
     * @param {GeometryMinDistanceAnalystParameters} geometryMinDistanceAnalystParameters - 几何对象最近距离分析参数类。
     * @param {GeometryMinDistanceAnalystParameters} tempObj - 几何对象最近距离分析参数对象。
     * @description 将几何对象最近距离分析参数对象转换为 JSON 对象。
     * @returns {Object} JSON 对象。
     */
    static toObject(geometryMinDistanceAnalystParameters, tempObj) {
        for (var name in geometryMinDistanceAnalystParameters) {
            if (name === "inputGeometries" && geometryMinDistanceAnalystParameters.inputGeometries) {
                var inputGeometries = [];
                for (var i = 0; i < geometryMinDistanceAnalystParameters.inputGeometries.length; i++) {
                    inputGeometries.push(ServerGeometry.fromGeometry(geometryMinDistanceAnalystParameters.inputGeometries[i]));
                }
                tempObj.inputGeometries = inputGeometries;

            } else {
                tempObj[name] = geometryMinDistanceAnalystParameters[name];
            }
        }
    }
}

;// CONCATENATED MODULE: ./src/common/iServer/MinDistanceAnalystService.js
/* Copyright© 2000 - 2022 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/





/**
 * @class MinDistanceAnalystService
 * @deprecatedclass SuperMap.MinDistanceAnalystService
 * @category iServer SpatialAnalyst MinDistanceAnalyst
 * @classdesc 空间关系分析服务类。该类负责将客户设置的空间关系分析服务参数传递给服务端，并接收服务端返回的空间关系分析结果数据。
 * @version 11.1.1
 * @param {string} url - 服务地址。如 http://localhost:8090/iserver/services/spatialanalyst-changchun/restjsr/spatialanalyst。
 * @param {Object} options - 参数。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @extends {SpatialAnalystBase}
 * @usage
 */
class MinDistanceAnalystService extends SpatialAnalystBase {

    constructor(url, options) {
        super(url, options);
        if (options) {
            Util_Util.extend(this, options);
        }
        this.CLASS_NAME = "SuperMap.MinDistanceAnalystService";
    }

    /**
     * @function MinDistanceAnalystService.prototype.destroy
     * @override
     */
    destroy() {
        super.destroy();
    }

    /**
     * @function MinDistanceAnalystService.prototype.processAsync
     * @description 负责将客户端的参数传递到服务端
     * @param {MinDistanceAnalystParameters} parameter - 最短距离分析所需的参数信息。
     */
    processAsync(parameter, callback) {
        var me = this;
        var parameterObject = {};
        if (parameter instanceof DatasetMinDistanceAnalystParameters) {
            me.url = Util_Util.urlPathAppend(me.url, 'datasets/' + parameter.dataset + '/mindistance');
            parameterObject = parameter;
        } else if (parameter instanceof GeometryMinDistanceAnalystParameters) {
            me.url = Util_Util.urlPathAppend(me.url, 'geometry/mindistance');
            GeometryMinDistanceAnalystParameters.toObject(parameter, parameterObject);
        }

        var jsonParameters = Util_Util.toJSON(parameterObject);
        me.url = Util_Util.urlAppend(me.url, 'returnContent=true');

        return me.request({
            method: "POST",
            data: jsonParameters,
            scope: me,
            success: callback,
            failure: callback
        });
    }


}

;// CONCATENATED MODULE: ./src/common/iServer/ConvexHullAnalystService.js
/* Copyright© 2000 - 2022 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/
 
 
//  import {ConvexHullAnalystParameters} from './ConvexHullAnalystParameters';
 
 /**
  * @class ConvexHullAnalystService
  * @deprecatedclass SuperMap.ConvexHullAnalystService
  * @category  iServer SpatialAnalyst ConvexHullAnalyst
  * @classdesc 凸包运算服务类
  * @version 11.1.1
  * @param {string} url - 服务地址。如 http://localhost:8090/iserver/services/spatialanalyst-changchun/restjsr/spatialanalyst。
  * @param {Object} options - 参数。
  * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
  * @param {Object} [options.headers] - 请求头。
  * @extends {SpatialAnalystBase}
  * @usage
  */
 class ConvexHullAnalystService extends SpatialAnalystBase {
 
     constructor(url, options) {
         super(url, options);

         if (options) {
             Util_Util.extend(this, options);
         }
         this.CLASS_NAME = "SuperMap.ConvexHullAnalystService";
     }
 
     /**
      * @override
      */
     destroy() {
         super.destroy();
         this.mode = null;
     }
 
     /**
      * @function ConvexHullAnalystService.prototype.processAsync
      * @description 负责将客户端的查询参数传递到服务端。
      * @param {ConvexHullAnalystParameters} parameter - 凸包运算参数基类。
      * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
      * @returns {Promise} Promise 对象。
      */
     processAsync(parameter, callback) {
         var me = this;
         me.url = Util_Util.urlPathAppend(me.url, 'geometry/3d/convexhull');
 
         var jsonParameters = Util_Util.toJSON(parameter);
         me.url = Util_Util.urlAppend(me.url, 'returnContent=true');
         return me.request({
             method: "POST",
             data: jsonParameters,
             scope: me,
             success: callback,
             failure: callback
         });
     }
 }
 
;// CONCATENATED MODULE: ./src/common/iServer/GeometryBatchAnalystService.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/







/**
 * @class GeometryBatchAnalystService
 * @deprecatedclass SuperMap.GeometryBatchAnalystService
 * @category iServer SpatialAnalyst BatchAnalyst
 * @classdesc 批量空间分析服务类
 * @description 该类负责将客户设置的叠加分析参数传递给服务端，并接收服务端返回的叠加分析结果数据。
 *              获取的结果数据包括 originResult 、result 两种，
 *              其中，originResult 为服务端返回的用 JSON 对象表示的量算结果数据，result 为服务端返回的量算结果数据。
 * @extends {SpatialAnalystBase}
 * @param {string} url - 服务地址。如：http://localhost:8090/iserver/services/spatialanalyst-changchun/restjsr/spatialanalyst。
 * @param {Object} options - 参数。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @example
 * var myOverlayAnalystService = new GeometryBatchAnalystService(url);
 * @usage
 */
class GeometryBatchAnalystService extends SpatialAnalystBase {

    constructor(url, options) {
        super(url, options);

        if (options) {
            Util_Util.extend(this, options);
        }

        this.CLASS_NAME = "SuperMap.GeometryBatchAnalystService";
    }

    /**
     * @function GeometryBatchAnalystService.prototype.processAsync
     * @description 负责将客户端的查询参数传递到服务端。
     * @param {GeometryOverlayAnalystParameter} parameter - 批量几何对象叠加分析参数类
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    processAsync(parameters, callback) {
        var me = this;
        me.url = Util_Util.urlPathAppend(me.url, 'geometry/batchanalyst');
        me.url = Util_Util.urlAppend(me.url, 'returnContent=true&ignoreAnalystParam=true');
        var parameterObjects = me._processParams(parameters);
        var jsonParameters = Util_Util.toJSON(parameterObjects);

        return me.request({
            method: "POST",
            data: jsonParameters,
            scope: me,
            success: callback,
            failure: callback
        });
    }

    _processParams(parameters) {
        var me = this;
        if (!Util_Util.isArray(parameters)) {
            return;
        }
        var processParams = [];
        parameters.map(function (item) {
            processParams.push(me._toJSON(item));
            return item;
        });

        return processParams;
    }

    _toJSON(parameter) {
        var tempObj = {};
        if(parameter.analystName ==="buffer"){
            tempObj.analystName = "buffer";
            tempObj.param = {};
            //几何对象的批量空间分析，
            GeometryBufferAnalystParameters.toObject(parameter.param, tempObj.param);

        }else if(parameter.analystName ==="overlay"){
            tempObj.analystName = "overlay";
            tempObj.param = {};
            GeometryOverlayAnalystParameters.toObject(parameter.param, tempObj.param);

        }else if(parameter.analystName ==="interpolationDensity"){
            tempObj.analystName = "interpolationDensity";
            tempObj.param = {};
            InterpolationAnalystParameters.toObject(parameter.param, tempObj.param);

        }else if(parameter.analystName ==="interpolationidw"){
            tempObj.analystName = "interpolationidw";
            tempObj.param = {};
            InterpolationAnalystParameters.toObject(parameter.param, tempObj.param);

        }else if(parameter.analystName ==="interpolationRBF"){
            tempObj.analystName = "interpolationRBF";
            tempObj.param = {};
            InterpolationAnalystParameters.toObject(parameter.param, tempObj.param);

        }else if(parameter.analystName ==="interpolationKriging"){
            tempObj.analystName = "interpolationKriging";
            tempObj.param = {};
            InterpolationAnalystParameters.toObject(parameter.param, tempObj.param);

        }else if(parameter.analystName ==="thiessenpolygon"){
            tempObj.analystName = "thiessenpolygon";
            tempObj.param = {};
            GeometryThiessenAnalystParameters.toObject(parameter.param, tempObj.param);

        }else {
            //isoline; isoregion; calculatemeasure; routelocator 四种分析不需要再处理参数
            return parameter;
        }
        return tempObj;
    }

    /**
     * @override
     */
    destroy() {
        super.destroy();
    }


}

;// CONCATENATED MODULE: ./src/common/iServer/SpatialAnalystService.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/





















/**
 * @class SpatialAnalystService
 * @extends {ServiceBase}
 * @category  iServer SpatialAnalyst
 * @classdesc 空间分析服务类。提供：地区太阳辐射、缓冲区分析、点密度分析、动态分段分析、空间关系分析、插值分析、栅格代数运算、叠加分析、路由定位、路由测量计算、表面分析、地形曲率计算、泰森多边形分析。
 * @example
 *      new SpatialAnalystService(url).bufferAnalysis(params,function(result){
 *          //doSomething
 *      })
 * @param {string} url - 服务地址。
 * @param {Object} options - 参数。
 * @param {string} [options.proxy] - 服务代理地址。
 * @param {boolean} [options.withCredentials=false] - 请求是否携带 cookie。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @usage
 */
class SpatialAnalystService_SpatialAnalystService {

    constructor(url, options) {
        this.url = url;
        this.options = options || {};
    }

    /**
     * @function SpatialAnalystService.prototype.getAreaSolarRadiationResult
     * @description 地区太阳辐射。
     * @param {AreaSolarRadiationParameters} params - 地区太阳辐射参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @param {DataFormat} [resultFormat=DataFormat.GEOJSON] - 返回的结果类型。
     * @returns {Promise} Promise 对象。
     */
    getAreaSolarRadiationResult(params, callback, resultFormat) {
        var me = this;
        var areaSolarRadiationService = new AreaSolarRadiationService(me.url, {
            proxy: me.options.proxy,
            withCredentials: me.options.withCredentials,
            crossOrigin: me.options.crossOrigin,
            headers: me.options.headers,
            format: me._processFormat(resultFormat)
        });
        return areaSolarRadiationService.processAsync(params, callback);
    }

    /**
     * @function SpatialAnalystService.prototype.bufferAnalysis
     * @description 缓冲区分析。
     * @param {DatasetBufferAnalystParameters} params - 数据集缓冲区分析参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @param {DataFormat} [resultFormat=DataFormat.GEOJSON] - 返回的结果类型。
     * @returns {Promise} Promise 对象。
     */
    bufferAnalysis(params, callback, resultFormat) {
        var me = this;
        var bufferAnalystService = new BufferAnalystService(me.url, {
            proxy: me.options.proxy,
            withCredentials: me.options.withCredentials,
            crossOrigin: me.options.crossOrigin,
            headers: me.options.headers,
            format: me._processFormat(resultFormat)
        });
        return bufferAnalystService.processAsync(params, callback);
    }

    /**
     * @function SpatialAnalystService.prototype.densityAnalysis
     * @description 点密度分析。
     * @param {DensityKernelAnalystParameters} params - 核密度分析参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @param {DataFormat} [resultFormat=DataFormat.GEOJSON] - 返回的结果类型。
     * @returns {Promise} Promise 对象。
     */
    densityAnalysis(params, callback, resultFormat) {
        var me = this;
        var densityAnalystService = new DensityAnalystService(me.url, {
            proxy: me.options.proxy,
            withCredentials: me.options.withCredentials,
            crossOrigin: me.options.crossOrigin,
            headers: me.options.headers,
            format: me._processFormat(resultFormat)
        });
        return densityAnalystService.processAsync(params, callback);
    }

    /**
     * @function SpatialAnalystService.prototype.generateSpatialData
     * @description 动态分段分析。
     * @param {GenerateSpatialDataParameters} params - 动态分段操作参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @param {DataFormat} [resultFormat=DataFormat.GEOJSON] - 返回的结果类型。
     * @returns {Promise} Promise 对象。
     */
    generateSpatialData(params, callback, resultFormat) {
        var me = this;
        var generateSpatialDataService = new GenerateSpatialDataService(me.url, {
            proxy: me.options.proxy,
            withCredentials: me.options.withCredentials,
            crossOrigin: me.options.crossOrigin,
            headers: me.options.headers,
            format: me._processFormat(resultFormat)
        });
        return generateSpatialDataService.processAsync(params, callback);
    }

    /**
     * @function SpatialAnalystService.prototype.geoRelationAnalysis
     * @description 空间关系分析。
     * @param {GeoRelationAnalystParameters} params - 空间关系分析服务参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @param {DataFormat} [resultFormat=DataFormat.GEOJSON] - 返回的结果类型。
     * @returns {Promise} Promise 对象。
     */
    geoRelationAnalysis(params, callback, resultFormat) {
        var me = this;
        var geoRelationAnalystService = new GeoRelationAnalystService(me.url, {
            proxy: me.options.proxy,
            withCredentials: me.options.withCredentials,
            crossOrigin: me.options.crossOrigin,
            headers: me.options.headers,
            format: me._processFormat(resultFormat)
        });
        return geoRelationAnalystService.processAsync(params, callback);
    }

    /**
     * @function SpatialAnalystService.prototype.interpolationAnalysis
     * @description 插值分析。
     * @param {InterpolationRBFAnalystParameters|InterpolationDensityAnalystParameters|InterpolationIDWAnalystParameters|InterpolationKrigingAnalystParameters} params - 样条插值分析参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @param {DataFormat} [resultFormat=DataFormat.GEOJSON] - 返回的结果类型。
     * @returns {Promise} Promise 对象。
     */
    interpolationAnalysis(params, callback, resultFormat) {
        var me = this;
        var interpolationAnalystService = new InterpolationAnalystService(me.url, {
            proxy: me.options.proxy,
            withCredentials: me.options.withCredentials,
            crossOrigin: me.options.crossOrigin,
            headers: me.options.headers,
            format: me._processFormat(resultFormat)
        });
        return interpolationAnalystService.processAsync(params, callback);
    }
    /**
     * @function SpatialAnalystService.prototype.mathExpressionAnalysis
     * @description 栅格代数运算。
     * @param {MathExpressionAnalysisParameters} params - 栅格代数运算参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @param {DataFormat} [resultFormat=DataFormat.GEOJSON] - 返回的结果类型。
     * @returns {Promise} Promise 对象。
     */
    mathExpressionAnalysis(params, callback, resultFormat) {
        var me = this;
        var mathExpressionAnalysisService = new MathExpressionAnalysisService(me.url, {
            proxy: me.options.proxy,
            withCredentials: me.options.withCredentials,
            crossOrigin: me.options.crossOrigin,
            headers: me.options.headers,
            format: me._processFormat(resultFormat)
        });
        return mathExpressionAnalysisService.processAsync(params, callback);
    }

    /**
     * @function SpatialAnalystService.prototype.overlayAnalysis
     * @description 叠加分析。
     * @param {DatasetOverlayAnalystParameters|GeometryOverlayAnalystParameters} params - 数据集叠加分析参数类或几何对象叠加分析参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @param {DataFormat} [resultFormat=DataFormat.GEOJSON] - 返回的结果类型。
     * @returns {Promise} Promise 对象。
     */
    overlayAnalysis(params, callback, resultFormat) {
        var me = this;
        var overlayAnalystService = new OverlayAnalystService(me.url, {
            proxy: me.options.proxy,
            withCredentials: me.options.withCredentials,
            crossOrigin: me.options.crossOrigin,
            headers: me.options.headers,
            format: me._processFormat(resultFormat)
        });
        return overlayAnalystService.processAsync(params, callback);
    }

    /**
     * @function SpatialAnalystService.prototype.routeCalculateMeasure
     * @description 路由测量计算。
     * @param {RouteCalculateMeasureParameters} params - 基于路由对象计算指定点 M 值操作的参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @param {DataFormat} [resultFormat=DataFormat.GEOJSON] - 返回的结果类型。
     * @returns {Promise} Promise 对象。
     */
    routeCalculateMeasure(params, callback, resultFormat) {
        var me = this;
        var routeCalculateMeasureService = new RouteCalculateMeasureService(me.url, {
            proxy: me.options.proxy,
            withCredentials: me.options.withCredentials,
            crossOrigin: me.options.crossOrigin,
            headers: me.options.headers,
            format: me._processFormat(resultFormat)
        });
        return routeCalculateMeasureService.processAsync(params, callback);
    }

    /**
     * @function SpatialAnalystService.prototype.routeLocate
     * @description 路由定位。
     * @param {RouteLocatorParameters} params - 路由对象定位空间对象的参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @param {DataFormat} [resultFormat=DataFormat.GEOJSON] - 返回的结果类型。
     * @returns {Promise} Promise 对象。
     */
    routeLocate(params, callback, resultFormat) {
        var me = this;
        var routeLocatorService = new RouteLocatorService(me.url, {
            proxy: me.options.proxy,
            withCredentials: me.options.withCredentials,
            crossOrigin: me.options.crossOrigin,
            headers: me.options.headers,
            format: me._processFormat(resultFormat)
        });
        return routeLocatorService.processAsync(params, callback);
    }

    /**
     * @function SpatialAnalystService.prototype.surfaceAnalysis
     * @description 表面分析。
     * @param {SurfaceAnalystParameters} params - 表面分析提取操作参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @param {DataFormat} [resultFormat=DataFormat.GEOJSON] - 返回的结果类型。
     * @returns {Promise} Promise 对象。
     */
    surfaceAnalysis(params, callback, resultFormat) {
        var me = this;
        var surfaceAnalystService = new SurfaceAnalystService(me.url, {
            proxy: me.options.proxy,
            withCredentials: me.options.withCredentials,
            crossOrigin: me.options.crossOrigin,
            headers: me.options.headers,
            format: me._processFormat(resultFormat)
        });
        return surfaceAnalystService.processAsync(params, callback);
    }

    /**
     * @function SpatialAnalystService.prototype.terrainCurvatureCalculate
     * @description 地形曲率计算。
     * @param {TerrainCurvatureCalculationParameters} params - 地形曲率计算参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @param {DataFormat} [resultFormat=DataFormat.GEOJSON] - 返回的结果类型。
     * @returns {Promise} Promise 对象。
     */
    terrainCurvatureCalculate(params, callback, resultFormat) {
        var me = this;
        var terrainCurvatureCalculationService = new TerrainCurvatureCalculationService(me.url, {
            proxy: me.options.proxy,
            withCredentials: me.options.withCredentials,
            crossOrigin: me.options.crossOrigin,
            headers: me.options.headers,
            format: me._processFormat(resultFormat)
        });
        return terrainCurvatureCalculationService.processAsync(params, callback);
    }

     /**
     * @function SpatialAnalystService.prototype.terrainCutFillCalculate
     * @description 填挖方计算。
     * @param {TerrainCutFillCalculationParameters} params - 填挖方计算参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @param {DataFormat} [resultFormat=DataFormat.GEOJSON] - 返回的结果类型。
     */
     terrainCutFillCalculate(params, callback, resultFormat) {
      var me = this;
      var terrainCutFillCalculationService = new TerrainCutFillCalculationService(me.url, {
          proxy: me.options.proxy,
          withCredentials: me.options.withCredentials,
          crossOrigin: me.options.crossOrigin,
          headers: me.options.headers,
          format: me._processFormat(resultFormat)
      });
      return terrainCutFillCalculationService.processAsync(params, callback);
    }

    /**
     * @function SpatialAnalystService.prototype.terrainAspectCalculate
     * @description 地形坡向分析。
     * @param {TerrainAspectCalculationParameters} params - 地形坡向分析参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @param {DataFormat} [resultFormat=DataFormat.GEOJSON] - 返回的结果类型。
     */
    terrainAspectCalculate(params, callback, resultFormat) {
        var me = this;
        var terrainAspectCalculationService = new TerrainAspectCalculationService(me.url, {
            proxy: me.options.proxy,
            withCredentials: me.options.withCredentials,
            crossOrigin: me.options.crossOrigin,
            headers: me.options.headers,
            format: me._processFormat(resultFormat)
        });
        return terrainAspectCalculationService.processAsync(params, callback);
    }

    /**
     * @function SpatialAnalystService.prototype.terrainSlopeCalculate
     * @description 地形坡度分析。
     * @param {TerrainSlopeCalculationParameters} params - 地形坡度分析参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @param {DataFormat} [resultFormat=DataFormat.GEOJSON] - 返回的结果类型。
     */
    terrainSlopeCalculate(params, callback, resultFormat) {
        var me = this;
        var terrainSlopeCalculationService = new TerrainSlopeCalculationService(me.url, {
            proxy: me.options.proxy,
            withCredentials: me.options.withCredentials,
            crossOrigin: me.options.crossOrigin,
            headers: me.options.headers,
            format: me._processFormat(resultFormat)
        });
        return terrainSlopeCalculationService.processAsync(params, callback);
    }

    /**
     * @function SpatialAnalystService.prototype.thiessenAnalysis
     * @description 泰森多边形分析。
     * @param {DatasetThiessenAnalystParameters|GeometryThiessenAnalystParameters} params - 数据集泰森多边形分析参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @param {DataFormat} [resultFormat=DataFormat.GEOJSON] - 返回的结果类型。
     * @returns {Promise} Promise 对象。
     */
    thiessenAnalysis(params, callback, resultFormat) {
        var me = this;
        var thiessenAnalystService = new ThiessenAnalystService(me.url, {
            proxy: me.options.proxy,
            withCredentials: me.options.withCredentials,
            crossOrigin: me.options.crossOrigin,
            headers: me.options.headers,
            format: me._processFormat(resultFormat)
        });
        return thiessenAnalystService.processAsync(params, callback);
    }

     /**
     * @function SpatialAnalystService.prototype.minDistanceAnalysis
     * @description 最近距离计算。
     * @param {DatasetMinDistanceAnalystParameters|GeometryMinDistanceAnalystParameters} params - 最近距离计算参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @param {DataFormat} [resultFormat=DataFormat.GEOJSON] - 返回的结果类型。
     */
     minDistanceAnalysis(params, callback, resultFormat) {
      var me = this;
      var minDistanceAnalystService = new MinDistanceAnalystService(me.url, {
          proxy: me.options.proxy,
          withCredentials: me.options.withCredentials,
          crossOrigin: me.options.crossOrigin,
          headers: me.options.headers,
          format: me._processFormat(resultFormat)
      });
      return minDistanceAnalystService.processAsync(params, callback);
    }

    /**
     * @function SpatialAnalystService.prototype.convexHullAnalysis
     * @description 凸包计算。
     * @param {ConvexHullAnalystParameters} params - 凸包计算参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @param {DataFormat} [resultFormat=DataFormat.GEOJSON] - 返回的结果类型。
     */
    convexHullAnalysis(params, callback, resultFormat) {
        var me = this;
        var convexHullAnalystService = new ConvexHullAnalystService(me.url, {
            proxy: me.options.proxy,
            withCredentials: me.options.withCredentials,
            crossOrigin: me.options.crossOrigin,
            headers: me.options.headers,
            format: me._processFormat(resultFormat)
        });
        return convexHullAnalystService.processAsync(params, callback);
    }

    /**
     * @function SpatialAnalystService.prototype.geometrybatchAnalysis
     * @description 批量空间分析。
     * @param {Array.<Object>} params - 批量分析参数对象数组。
     * @param {Array.<Object>} params.analystName - 空间分析方法的名称。包括：</br>
     *                                              "buffer"，"overlay"，"interpolationDensity"，"interpolationidw"，"interpolationRBF"，"interpolationKriging"，"isoregion"，"isoline"。
     * @param {Object} params.param - 空间分析类型对应的请求参数，包括：</br>
     *                                {@link GeometryBufferAnalystParameters} 缓冲区分析参数类。</br>
     *                                {@link GeometryOverlayAnalystParameters} 叠加分析参数类。</br>
     *                                {@link InterpolationAnalystParameters} 插值分析参数类。</br>
     *                                {@link SurfaceAnalystParameters} 表面分析参数类。</br>
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @param {DataFormat} [resultFormat=DataFormat.GEOJSON] - 返回的结果类型。
     * @returns {Promise} Promise 对象。
     */
    geometrybatchAnalysis(params, callback, resultFormat) {
        var me = this;
        var geometryBatchAnalystService = new GeometryBatchAnalystService(me.url, {
            format: me._processFormat(resultFormat)
        });

        //处理批量分析中各个分类类型的参数：
        var analystParameters = [];
        for (var i = 0; i < params.length; i++) {
            var tempParameter = params[i];
            analystParameters.push({
                analystName: tempParameter.analystName,
                param: tempParameter.param
            })
        }

        return geometryBatchAnalystService.processAsync(analystParameters, callback);
    }

    _processFormat(resultFormat) {
        return (resultFormat) ? resultFormat : DataFormat.GEOJSON;
    }
}

;// CONCATENATED MODULE: ./src/mapboxgl/services/SpatialAnalystService.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/






/**
 * @class SpatialAnalystService
 * @extends {ServiceBase}
 * @category  iServer SpatialAnalyst
 * @classdesc 空间分析服务类。提供：地区太阳辐射、缓冲区分析、点密度分析、动态分段分析、空间关系分析、插值分析、栅格代数运算、叠加分析、路由定位、路由测量计算、表面分析、地形曲率计算、泰森多边形分析。
 * @modulecategory Services
 * @example
 * new SpatialAnalystService(url)
 *  .bufferAnalysis(params,function(result){
 *    //doSomething
 * })
 * @param {string} url - 服务地址。
 * @param {Object} options - 参数。
 * @param {string} [options.proxy] - 服务代理地址。
 * @param {boolean} [options.withCredentials=false] - 请求是否携带 cookie。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @usage
 */
class SpatialAnalystService extends ServiceBase {

    constructor(url, options) {
        super(url, options);
        this._spatialAnalystService = new SpatialAnalystService_SpatialAnalystService(url, options);
    }

    /**
     * @function SpatialAnalystService.prototype.getAreaSolarRadiationResult
     * @description 地区太阳辐射。
     * @param {AreaSolarRadiationParameters} params -查询相关参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @param {DataFormat}  [resultFormat=DataFormat.GEOJSON] - 返回结果类型。
     * @returns {Promise} Promise 对象。
     */
    getAreaSolarRadiationResult(params, callback, resultFormat) {
      return this._spatialAnalystService.getAreaSolarRadiationResult(params, callback, resultFormat);
    }

    /**
     * @function SpatialAnalystService.prototype.bufferAnalysis
     * @description 缓冲区分析。
     * @param {DatasetBufferAnalystParameters} params - 数据集缓冲区分析参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @param {DataFormat}  [resultFormat=DataFormat.GEOJSON] - 返回结果类型。
     * @returns {Promise} Promise 对象。
     */
    bufferAnalysis(params, callback, resultFormat) {
      params = this._processParams(params);
      return this._spatialAnalystService.bufferAnalysis(params, callback, resultFormat);
    }

    /**
     * @function SpatialAnalystService.prototype.densityAnalysis
     * @description 点密度分析。
     * @param {DensityKernelAnalystParameters} params - 核密度分析参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @param {DataFormat}  [resultFormat=DataFormat.GEOJSON] - 返回结果类型。
     * @returns {Promise} Promise 对象。
     */
    densityAnalysis(params, callback, resultFormat) {
      params = this._processParams(params);
      return this._spatialAnalystService.densityAnalysis(params, callback, resultFormat);
    }

    /**
     * @function SpatialAnalystService.prototype.generateSpatialData
     * @description 动态分段分析。
     * @param {GenerateSpatialDataParameters} params - 动态分段操作参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @param {DataFormat}  [resultFormat=DataFormat.GEOJSON] - 返回结果类型。
     * @returns {Promise} Promise 对象。
     */
    generateSpatialData(params, callback, resultFormat) {
      return this._spatialAnalystService.generateSpatialData(params, callback, resultFormat);
    }

    /**
     * @function SpatialAnalystService.prototype.geoRelationAnalysis
     * @description 空间关系分析。
     * @param {GeoRelationAnalystParameters} params - 空间关系分析服务参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @param {DataFormat}  [resultFormat=DataFormat.GEOJSON] - 返回结果类型。
     * @returns {Promise} Promise 对象。
     */
    geoRelationAnalysis(params, callback, resultFormat) {
      params = this._processParams(params);
      return this._spatialAnalystService.geoRelationAnalysis(params, callback, resultFormat);
    }

    /**
     * @function SpatialAnalystService.prototype.interpolationAnalysis
     * @description 插值分析。
     * @param {InterpolationDensityAnalystParameters|InterpolationIDWAnalystParameters|InterpolationRBFAnalystParameters|InterpolationKrigingAnalystParameters} params - 样条插值（径向基函数插值法）分析参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @param {DataFormat}  [resultFormat=DataFormat.GEOJSON] - 返回结果类型。
     * @returns {Promise} Promise 对象。
     */
    interpolationAnalysis(params, callback, resultFormat) {
      params = this._processParams(params);
      return this._spatialAnalystService.interpolationAnalysis(params, callback, resultFormat);
    }

    /**
     * @function SpatialAnalystService.prototype.mathExpressionAnalysis
     * @description 栅格代数运算。
     * @param {MathExpressionAnalysisParameters} params - 栅格代数运算参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @param {DataFormat}  [resultFormat=DataFormat.GEOJSON] - 返回结果类型。
     * @returns {Promise} Promise 对象。
     */
    mathExpressionAnalysis(params, callback, resultFormat) {
      params = this._processParams(params);
      return this._spatialAnalystService.mathExpressionAnalysis(params, callback, resultFormat);
    }

    /**
     * @function SpatialAnalystService.prototype.overlayAnalysis
     * @description 叠加分析。
     * @param {DatasetOverlayAnalystParameters|GeometryOverlayAnalystParameters} params - 数据集叠加分析参数类或者几何对象叠加分析参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @param {DataFormat}  [resultFormat=DataFormat.GEOJSON] - 返回结果类型。
     * @returns {Promise} Promise 对象。
     */
    overlayAnalysis(params, callback, resultFormat) {
      params = this._processParams(params);
      return this._spatialAnalystService.overlayAnalysis(params, callback, resultFormat);
    }

    /**
     * @function SpatialAnalystService.prototype.routeCalculateMeasure
     * @description 路由测量计算。
     * @param {RouteCalculateMeasureParameters} params - 基于路由对象计算指定点 M 值操作的参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @param {DataFormat}  [resultFormat=DataFormat.GEOJSON] - 返回结果类型。
     * @returns {Promise} Promise 对象。
     */
    routeCalculateMeasure(params, callback, resultFormat) {
      params = this._processParams(params);
      return this._spatialAnalystService.routeCalculateMeasure(params, callback, resultFormat);
    }

    /**
     * @function SpatialAnalystService.prototype.routeLocate
     * @description 路由定位。
     * @param {RouteLocatorParameters} params - 路由对象定位空间对象的参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @param {DataFormat}  [resultFormat=DataFormat.GEOJSON] - 返回结果类型。
     * @returns {Promise} Promise 对象。
     */
    routeLocate(params, callback, resultFormat) {
      params = this._processParams(params);
      return this._spatialAnalystService.routeLocate(params, callback, resultFormat);
    }

    /**
     * @function SpatialAnalystService.prototype.surfaceAnalysis
     * @description 表面分析。
     * @param {SurfaceAnalystParameters} params - 表面分析提取操作参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @param {DataFormat}  [resultFormat=DataFormat.GEOJSON] - 返回结果类型。
     * @returns {Promise} Promise 对象。
     */
    surfaceAnalysis(params, callback, resultFormat) {
      params = this._processParams(params);
      return this._spatialAnalystService.surfaceAnalysis(params, callback, resultFormat);
    }

    /**
     * @function SpatialAnalystService.prototype.terrainCurvatureCalculate
     * @description 地形曲率计算。
     * @param {TerrainCurvatureCalculationParameters} params - 地形曲率计算参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @param {DataFormat}  [resultFormat=DataFormat.GEOJSON] - 返回结果类型。
     * @returns {Promise} Promise 对象。
     */
    terrainCurvatureCalculate(params, callback, resultFormat) {
      return this._spatialAnalystService.terrainCurvatureCalculate(params, callback, resultFormat);
    }

    /**
     * @function SpatialAnalystService.prototype.terrainCutFillCalculate
     * @description 填挖方计算。
     * @version 11.1.1
     * @param {TerrainCutFillCalculationParameters} params - 填挖方计算参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。。
     * @param {DataFormat} [resultFormat=DataFormat.GEOJSON] - 返回的结果类型。
     * @returns {Promise} Promise 对象。
     */
    terrainCutFillCalculate(params, callback, resultFormat) {
      params = this._processParams(params);
      return this._spatialAnalystService.terrainCutFillCalculate(params, callback, resultFormat);
    }

    /**
     * @function SpatialAnalystService.prototype.terrainAspectCalculate
     * @description 地形坡向分析。
     * @version 11.1.1
     * @param {TerrainAspectCalculationParameters} params - 地形坡向分析参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。。
     * @param {DataFormat} [resultFormat=DataFormat.GEOJSON] - 返回的结果类型。
     * @returns {Promise} Promise 对象。
     */
    terrainAspectCalculate(params, callback, resultFormat) {
      params = this._processParams(params);
      return this._spatialAnalystService.terrainAspectCalculate(params, callback, resultFormat);
    }

    /**
     * @function SpatialAnalystService.prototype.terrainSlopeCalculate
     * @description 地形坡度分析。
     * @version 11.1.1
     * @param {TerrainSlopeCalculationParameters} params - 地形坡度分析参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。。
     * @param {DataFormat} [resultFormat=DataFormat.GEOJSON] - 返回的结果类型。
     */
    terrainSlopeCalculate(params, callback, resultFormat) {
      params = this._processParams(params);
      return this._spatialAnalystService.terrainSlopeCalculate(params, callback, resultFormat);
    }

    /**
     * @function SpatialAnalystService.prototype.thiessenAnalysis
     * @description 泰森多边形分析。
     * @param {DatasetThiessenAnalystParameters|GeometryThiessenAnalystParameters} params - 数据集泰森多边形分析参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @param {DataFormat}  [resultFormat=DataFormat.GEOJSON] - 返回结果类型。
     * @returns {Promise} Promise 对象。
     */
    thiessenAnalysis(params, callback, resultFormat) {
      params = this._processParams(params);
      return this._spatialAnalystService.thiessenAnalysis(params, callback, resultFormat);
    } 

    /**
     * @function SpatialAnalystService.prototype.minDistanceAnalysis
     * @description 最近距离计算。
     * @version 11.1.1
     * @param {DatasetMinDistanceAnalystParameters|GeometryMinDistanceAnalystParameters} params - 最近距离计算参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。。
     * @param {DataFormat} [resultFormat=DataFormat.GEOJSON] - 返回的结果类型。
     */
    minDistanceAnalysis(params, callback, resultFormat) {
      params = this._processParams(params);
      return this._spatialAnalystService.minDistanceAnalysis(params, callback, resultFormat);
    }

    /**
     * @function SpatialAnalystService.prototype.convexHullAnalysis
     * @description 凸包计算。
     * @version 11.1.1
     * @param {ConvexHullAnalystParameters} params - 凸包计算参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。。
     * @param {DataFormat} [resultFormat=DataFormat.GEOJSON] - 返回的结果类型。
     */
    convexHullAnalysis(params, callback, resultFormat) {
      params = this._processParams(params);
      return this._spatialAnalystService.convexHullAnalysis(params, callback, resultFormat);
    }

    /**
     * @function SpatialAnalystService.prototype.geometrybatchAnalysis
     * @description 批量空间分析。
     * @param {Array.<Object>} params - 批量分析参数对象数组，包括：
     * @param {string} params.analystName - 空间分析方法的名称。包括：</br>
     *                                      "buffer"，"overlay"，"interpolationDensity"，"interpolationidw"，"interpolationRBF"，"interpolationKriging"，"isoregion"，"isoline"。
     * @param {Object} params.param - 空间分析类型对应的请求参数，包括：</br>
     *                                {@link GeometryBufferAnalystParameters} 缓冲区分析参数类。</br>
     *                                {@link GeometryOverlayAnalystParameters} 叠加分析参数类。</br>
     *                                {@link InterpolationAnalystParameters} 插值分析参数类。</br>
     *                                {@link SurfaceAnalystParameters} 表面分析参数类。</br>
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @param {DataFormat}  [resultFormat=DataFormat.GEOJSON] - 返回结果类型。
     * @returns {Promise} Promise 对象。
     */
    geometrybatchAnalysis(params, callback, resultFormat) {
        for (var i = 0; i < params.length; i++) {
            params[i].param = this._processParams(params[i].param)
        }
        return this._spatialAnalystService.geometrybatchAnalysis(params, callback, resultFormat);
    }


    _processParams(params) {
        if (!params) {
            return {};
        }
        if (params.bounds) {
            params.bounds = core_Util_Util.toSuperMapBounds(params.bounds);
        }
        //插值分析点数组转换
        if (params.inputPoints) {
            for (var i = 0; i < params.inputPoints.length; i++) {
                var inputPoint = params.inputPoints[i];
                if (core_Util_Util.isArray(inputPoint)) {
                    params.inputPoints[i] = {x: inputPoint[0], y: inputPoint[1], tag: inputPoint[2]};
                }
            }
        }
        //点数组转换
        if (params.points) {
            for (let i = 0; i < params.points.length; i++) {
                var point = params.points[i];
                params.points[i] = core_Util_Util.toSuperMapPoint(point);
            }
        }
        //mapboxgl点对象转SuperMap点对象
        if (params.point) {
            params.point = core_Util_Util.toSuperMapPoint(params.point);
        }

        //初步判断mapbox数据就为geojson格式 ，进行转json格式即可

        //栅格代数运算的范围
        if (params.extractRegion) {
            params.extractRegion = core_Util_Util.toSuperMapGeometry(params.extractRegion);
        }

        //获取或设置表面分析参数
        if (params.extractParameter && params.extractParameter.clipRegion) {
            params.extractParameter.clipRegion = core_Util_Util.toSuperMapGeometry(params.extractParameter.clipRegion);
        }
        if (params.clipParam && params.clipParam.clipRegion) {
            params.clipParam.clipRegion = core_Util_Util.toSuperMapGeometry(params.clipParam.clipRegion);
        }
        //sourceRoute 路由对象。用于里程分析，该对象可以是用户自己生 成或在数据源中查询得到的符合标准的路由对象；geojson格式
        if (params.sourceRoute) {
            if (params.sourceRoute) {
                var target = {};
                target.type = "LINEM";
                target.parts = [params.sourceRoute.geometry.coordinates.length];
                target.points = [];
                for (let i = 0; i < params.sourceRoute.geometry.coordinates.length; i++) {
                    var lnglat = params.sourceRoute.geometry.coordinates[i];
                    //measure 应该在传值时设置,
                    target.points = target.points.concat({x: lnglat[0], y: lnglat[1], measure: lnglat[2]})
                }
                params.sourceRoute = target;
            }

        }
        //operateRegions 操作面对象集合，数据集叠加分析,表示与这些面对象进行叠加分析
        if (params.operateRegions && core_Util_Util.isArray(params.operateRegions)) {
            params.operateRegions.map(function (geometry, key) {
                params.operateRegions[key] = core_Util_Util.toSuperMapGeometry(geometry);
                return params.operateRegions[key];
            });
        }

        //叠加分析，几何数据源 支持格式:GeoJson
        if (params.sourceGeometry) {
            var SRID = null;
            if (params.sourceGeometrySRID) {
                SRID = params.sourceGeometrySRID;
            }
            params.sourceGeometry = core_Util_Util.toSuperMapGeometry(params.sourceGeometry);
            if (SRID) {
                params.sourceGeometry.SRID = SRID;
            }
            delete params.sourceGeometry.sourceGeometrySRID;
        }
        if (params.operateGeometry) {
            params.operateGeometry = core_Util_Util.toSuperMapGeometry(params.operateGeometry);
        }
        //支持传入多个几何要素进行叠加分析：
        if (params.sourceGeometries) {
            var sourceGeometries = [];
            for (var k = 0; k < params.sourceGeometries.length; k++) {
                sourceGeometries.push(core_Util_Util.toSuperMapGeometry(params.sourceGeometries[k]));
            }
            params.sourceGeometries = sourceGeometries;
        }
        //支持传入多个几何要素进行叠加分析：
        if (params.operateGeometries) {
            var operateGeometries = [];
            for (var j = 0; j < params.operateGeometries.length; j++) {
                operateGeometries.push(core_Util_Util.toSuperMapGeometry(params.operateGeometries[j]));
            }
            params.operateGeometries = operateGeometries;
        }
        // 最近距离
        if (params.inputGeometries) {
          var inputGeometries = [];
          for (var l = 0; l < params.inputGeometries.length; l++) {
            inputGeometries.push(core_Util_Util.toSuperMapGeometry(params.inputGeometries[l]));
          }
          params.inputGeometries = inputGeometries;
        }
        //components 几何对象数组      Route
        if (params.sourceRoute && params.sourceRoute.components && core_Util_Util.isArray(params.sourceRoute.components)) {
            params.sourceRoute.components.map(function (geometry, key) {
                params.sourceRoute.components[key] = core_Util_Util.toSuperMapGeometry(geometry);
                return params.sourceRoute.components[key];
            });
        }
        return params;
    }

    _processFormat(resultFormat) {
        return (resultFormat) ? resultFormat : DataFormat.GEOJSON;
    }
}

;// CONCATENATED MODULE: ./src/common/iServer/ThemeParameters.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/

/**
 * @class ThemeParameters
 * @deprecatedclass SuperMap.ThemeParameters
 * @category  iServer Map Theme
 * @classdesc 专题图参数类。
 *            该类存储了制作专题所需的参数，包括数据源、数据集名称和专题图对象。
 * @param {Object} options - 参数。
 * @param {Array.<string>} options.datasetNames - 数据集数组。
 * @param {Array.<string>} options.dataSourceNames - 数据源数组。
 * @param {Array.<JoinItem>} [options.joinItems] - 专题图外部表的连接信息 JoinItem 数组。
 * @param {Array.<CommonTheme>} options.themes - 专题图对象列表。
 * @param {Array.<string>} [options.displayFilters] - 专题图属性过滤条件。
 * @param {Array.<string>} [options.displayOrderBys] - 专题图对象生成符号叠加次序排序字段。
 * @param {Object} [options.fieldValuesDisplayFilter] - 图层要素的显示和隐藏的过滤属性，其带有三个属性，分别是:values、fieldName、fieldValuesDisplayMode。
 * @usage
 */
class ThemeParameters {

    constructor(options) {
        /**
         * @member {Array.<string>} ThemeParameters.prototype.datasetNames
         * @description 要制作专题图的数据集数组。
         */
        this.datasetNames = null;

        /**
         * @member {Array.<string>} ThemeParameters.prototype.dataSourceNames
         * @description 要制作专题图的数据集所在的数据源数组。
         */
        this.dataSourceNames = null;

        /**
         * @member {Array.<JoinItem>} [ThemeParameters.prototype.joinItems]
         * @description 设置与外部表的连接信息 JoinItem 数组。
         *               使用此属性可以制作与外部表连接的专题图。
         */
        this.joinItems = null;

        /**
         * @member {Array.<CommonTheme>} ThemeParameters.prototype.themes
         * @description 专题图对象列表。
         *              该参数为实例化的各类专题图对象的集合。
         */
        this.themes = null;

        /**
         * @member {Array.<string>} [ThemeParameters.prototype.displayFilters]
         * @description 专题图属性过滤条件。
         */
        this.displayFilters = null;

        /**
         * @member {Array.<string>}  [ThemeParameters.prototype.displayOrderBys]
         * @description 专题图对象生成符号叠加次序排序字段。
         */
        this.displayOrderBys = null;

        /**
         * @member {Object} [ThemeParameters.prototype.fieldValuesDisplayFilter]
         * @property {Array.<number>} values - 待过滤的值。
         * @property {string} fieldName - 待过滤的字段名称只支持数字类型的字段。
         * @property {string} fieldValuesDisplayMode - 目前为 DISPLAY/DISABLE。当为 DISPLAY 时，表示只显示以上设置的相应属性值的要素，否则表示不显示以上设置的相应属性值的要素。
         */
        this.fieldValuesDisplayFilter = null;

        if (options) {
            Util_Util.extend(this, options);
        }

        this.CLASS_NAME = "SuperMap.ThemeParameters";
    }


    /**
     * @function ThemeParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        var me = this;
        me.datasetNames = null;
        me.dataSourceNames = null;
        if (me.joinItems) {
            for (let i = 0, joinItems = me.joinItems, len = joinItems.length; i < len; i++) {
                joinItems[i].destroy();
            }
            me.joinItems = null;
        }
        if (me.themes) {
            for (let i = 0, themes = me.themes, len = themes.length; i < len; i++) {
                themes[i].destroy();
            }
            me.themes = null;
        }
    }

}

;// CONCATENATED MODULE: ./src/common/iServer/ThemeService.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/




/**
 * @class ThemeService
 * @deprecatedclass SuperMap.ThemeService
 * @category  iServer Map Theme
 * @classdesc 专题图服务类。
 * @extends {CommonServiceBase}
 * @example
 * var myThemeService = new ThemeService(url);
 * @param {string} url - 服务地址。如：http://localhost:8090/iserver/services/map-world/rest/maps/World+Map 。
 * @param {Object} options - 参数。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @usage
 */
class ThemeService_ThemeService extends CommonServiceBase {

    constructor(url, options) {
        super(url, options);
        if (options) {
            Util_Util.extend(this, options);
        }
        this.url = Util_Util.urlPathAppend(this.url, 'tempLayersSet');
        this.CLASS_NAME = 'SuperMap.ThemeService';
    }

    /**
     * @override
     */
    destroy() {
        super.destroy();
    }

    /**
     * @function ThemeService.prototype.processAsync
     * @description 负责将客户端的专题图参数传递到服务端。
     * @param {ThemeParameters} params - 专题图参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    processAsync(params, callback) {
        if (!(params instanceof ThemeParameters)) {
            return;
        }
        var me = this,
            jsonParameters = null;
        jsonParameters = me.getJsonParameters(params);
        return me.request({
            method: "POST",
            data: jsonParameters,
            scope: me,
            success: callback,
            failure: callback
        });
    }

    /**
     * @function ThemeService.prototype.getJsonParameters
     * @description 将专题图参数参数转化为 JSON 字符串。
     * @param {ThemeParameters} parameter - 专题图参数类。
     * @returns {Object} 转化后的JSON字符串。
     */
    getJsonParameters(parameter) {
        var jsonParameters = "",
            themeObj = null,
            filters = null,
            orderBys = null,
            fieldValuesDisplayFilter;
        jsonParameters += "[{'type': 'UGC','subLayers': {'layers': [";

        for (var i = 0; i < parameter.themes.length; i++) {
            themeObj = parameter.themes[i];
            var jsonTheme = Util_Util.toJSON(themeObj);
            jsonTheme = jsonTheme.slice(0, -1);

            jsonParameters += "{'theme': " + jsonTheme + "},'type': 'UGC','ugcLayerType': 'THEME',";
            filters = parameter.displayFilters;
            if (filters && filters.length > 0) {
                if (filters.length === 1) {
                    jsonParameters += "'displayFilter':\"" + filters[0] + "\",";
                } else {
                    jsonParameters += "'displayFilter':\"" + filters[i] + "\",";
                }
            }
            orderBys = parameter.displayOrderBy;
            if (orderBys && orderBys.length > 0) {
                if (orderBys.length === 1) {
                    jsonParameters += "'displayOrderBy':'" + orderBys[0] + "',";
                } else {
                    jsonParameters += "'displayOrderBy':'" + orderBys[i] + "',";
                }
            }

            fieldValuesDisplayFilter = parameter.fieldValuesDisplayFilter;
            if (fieldValuesDisplayFilter) {
                jsonParameters += "'fieldValuesDisplayFilter':" + Util_Util.toJSON(fieldValuesDisplayFilter) + ",";
            }

            if (parameter.joinItems && parameter.joinItems.length > 0 && parameter.joinItems[i]) {
                jsonParameters += "'joinItems':[" + Util_Util.toJSON(parameter.joinItems[i]) + "],";
            }
            if (parameter.datasetNames && parameter.dataSourceNames) {
                var datasetID = parameter.datasetNames[i] ? i : (parameter.datasetNames.length - 1);
                var dataSourceID = parameter.dataSourceNames[i] ? i : (parameter.dataSourceNames.length - 1);
                jsonParameters += "'datasetInfo': {'name': '" + parameter.datasetNames[datasetID] +
                    "','dataSourceName': '" + parameter.dataSourceNames[dataSourceID] + "'}},";
            } else {
                jsonParameters += "},";
            }
        }
        //去除多余的逗号
        if (parameter.themes && parameter.themes.length > 0) {
            jsonParameters = jsonParameters.substring(0, jsonParameters.length - 1);
        }
        jsonParameters += "]},";
        var urlArray = this.url.split("/");
        var jsonMapName = urlArray[urlArray.length - 2];

        jsonParameters += "'name': '" + jsonMapName + "'}]";
        return jsonParameters;
    }

}

;// CONCATENATED MODULE: ./src/mapboxgl/services/ThemeService.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/




/**
 * @class ThemeService
 * @category  iServer Map Theme
 * @classdesc 专题图服务类。
 * @extends {ServiceBase}
 * @example
 * new ThemeService(url,{
 *      projection:projection
 * }).getThemeInfo(params,function(result){
 *      //doSomething
 * });
 * @param {string} url - 服务地址。
 * @param {Object} options - 参数。
 * @param {string} [options.proxy] - 服务代理地址。
 * @param {boolean} [options.withCredentials=false] - 请求是否携带 cookie。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @usage
 */
class ThemeService extends ServiceBase {

    constructor(url, options) {
        super(url, options);
        this._themeService = new ThemeService_ThemeService(this.url, {
          proxy: this.options.proxy,
          withCredentials: this.options.withCredentials,
          crossOrigin:this.options.crossOrigin,
          headers:this.options.headers
        });
    }

    /**
     * @function ThemeService.prototype.getThemeInfo
     * @description 获取专题图信息。
     * @param {ThemeParameters} params - 专题图参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    getThemeInfo(params, callback) {
      return this._themeService.processAsync(params, callback);
    }
}

;// CONCATENATED MODULE: ./src/common/iServer/StopQueryParameters.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


/**
 * @class StopQueryParameters
 * @deprecatedclass SuperMap.StopQueryParameters
 * @category  iServer TrafficTransferAnalyst TransferStops
 * @classdesc 站点查询参数类。
 * @param {Object} options - 参数。
 * @param {string} options.keyWord - 站点名称关键字。
 * @param {boolean} [options.returnPosition=false] - 是否返回站点坐标信息。
 * @usage
 */
class StopQueryParameters {

    constructor(options) {
        options = options || {};
        /**
         *  @member {string} StopQueryParameters.prototype.keyWord
         *  @description 站点名称关键字。
         */
        this.keyWord = null;

        /**
         * @member {boolean} [StopQueryParameters.prototype.returnPosition=false]
         * @description 是否返回站点坐标信息。
         */
        this.returnPosition = false;

        Util_Util.extend(this, options);

        this.CLASS_NAME = "SuperMap.StopQueryParameters";
    }

    /**
     * @function StopQueryParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        Util_Util.reset(this);
    }

}

;// CONCATENATED MODULE: ./src/common/iServer/StopQueryService.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/




/**
 * @class StopQueryService
 * @deprecatedclass SuperMap.StopQueryService
 * @category  iServer TrafficTransferAnalyst TransferStops
 * @classdesc 站点查询服务类。
 * 返回结果通过该类支持的事件的监听函数参数获取
 * @extends {CommonServiceBase}
 * @param {string} url - 服务地址。
 * 例如：</br>"http://localhost:8090/iserver/services/traffictransferanalyst-sample/restjsr/traffictransferanalyst/Traffic-Changchun"。
 * @param {Object} options - 参数。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @example 例如：
 * (start code)
 * var myService = new StopQueryService(url);
 * (end)
 * @usage
 *
 */

class StopQueryService extends CommonServiceBase {


    constructor(url, options) {
        super(url, options);
        options = options || {};
        Util_Util.extend(this, options);
        this.CLASS_NAME = "SuperMap.StopQueryService";
    }

    /**
     *@override
     */
    destroy() {
        super.destroy();
        Util_Util.reset(this);
    }

    /**
     * @function StopQueryService.prototype.processAsync
     * @description 负责将客户端的更新参数传递到服务端。
     * @param {StopQueryParameters} params - 交通换乘参数。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    processAsync(params, callback) {
        if (!(params instanceof StopQueryParameters)) {
            return;
        }
        var me = this;
        me.url = Util_Util.urlPathAppend(me.url, 'stops/keyword/' + params.keyWord);
        return me.request({
            method: "GET",
            params: {returnPosition: params.returnPosition},
            scope: me,
            success: callback,
            failure: callback
        });
    }

}

;// CONCATENATED MODULE: ./src/common/iServer/TransferPathParameters.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


/**
 * @class TransferPathParameters
 * @deprecatedclass SuperMap.TransferPathParameters
 * @category  iServer TrafficTransferAnalyst TransferPath
 * @classdesc 交通换乘线路查询参数类。
 * @param {Object} options - 参数。
 * @param {Array.<TransferLine>} options.transferLines - 本换乘分段内可乘车的路线集合。
 * @param {Array.<GeometryPoint|L.Point|L.LatLng|ol.geom.Point|mapboxgl.LngLat|Array.<number>|number>} options.points - 两种查询方式：按照公交站点的起止 ID 进行查询和按照起止点的坐标进行查询。
 * @usage
 */
class TransferPathParameters {

    constructor(options) {
        options = options || {};
        /**
         * @member {Array.<TransferLine>} TransferPathParameters.prototype.transferLines
         * @description 本换乘分段内可乘车的路线集合，通过交通换乘方案查询得到。
         */
        this.transferLines = null;


        /**
         *  @member {Array.<GeometryPoint|L.Point|L.LatLng|ol.geom.Point|mapboxgl.LngLat|Array.<number>|number>} TransferPathParameters.prototype.points
         *  @description 两种查询方式：<br>
         *           1. 按照公交站点的起止ID进行查询，则 points 参数的类型为 int[]，形如：[起点ID、终点ID]，公交站点的 ID 对应服务提供者配置中的站点 ID 字段；
         *           2. 按照起止点的坐标进行查询，则 points 参数的类型为 Point2D[]，形如：[{"x":44,"y":39},{"x":45,"y":40}]。
         */
        this.points = null;

        Util_Util.extend(this, options);

       this.CLASS_NAME = "SuperMap.TransferPathParameters";
    }

    /**
     * @function TransferPathParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        Util_Util.reset(this);
    }

    /**
     * @function TransferPathParameters.toJson
     * @description 将 {@link TransferPathParameters} 对象参数转换为 JSON 字符串。
     * @param {TransferPathParameters} params - 交通换乘参数。
     * @returns {string} 转化后的 JSON 字符串。
     */
    static toJson(params) {
        if (params) {
            return Util_Util.toJSON(params);
        }
    }

}

;// CONCATENATED MODULE: ./src/common/iServer/TransferPathService.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/




/**
 * @class TransferPathService
 * @deprecatedclass SuperMap.TransferPathService
 * @category  iServer TrafficTransferAnalyst TransferPath
 * @classdesc 交通换乘线路查询服务类，根据交通换乘分析结果(TransferSolutionResult)，获取某一条乘车路线的详细信息。
 *            返回结果通过该类支持的事件的监听函数参数获取
 * @extends {CommonServiceBase}
 * @example 例如：
 * var myService = new TransferPathService(url);
 * @param {string} url - 服务地址。
 * 例如:</br>"http://localhost:8090/iserver/services/traffictransferanalyst-sample/restjsr/traffictransferanalyst/Traffic-Changchun"。
 * @param {Object} options - 参数。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @usage
 */
class TransferPathService extends CommonServiceBase {

    constructor(url, options) {
        super(url, options);
        this.CLASS_NAME = "SuperMap.TransferPathService";
    }

    /**
     * @override
     */
    destroy() {
        super.destroy();
    }

    /**
     * @function TransferPathService.prototype.processAsync
     * @description 负责将客户端的更新参数传递到服务端。
     * @param {TransferPathParameters} params - 交通换乘参数。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    processAsync(params, callback) {
        if (!(params instanceof TransferPathParameters)) {
            return;
        }
        var me = this,
            method = "GET",
            jsonParameters;

        me.url = Util_Util.urlPathAppend(me.url, 'path');
        jsonParameters = {
            points: Util_Util.toJSON(params.points),
            transferLines: Util_Util.toJSON(params['transferLines'])
        };

        return me.request({
            method: method,
            params: jsonParameters,
            scope: me,
            success: callback,
            failure: callback
        });
    }

}


;// CONCATENATED MODULE: ./src/common/iServer/TransferSolutionParameters.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/



/**
 * @class TransferSolutionParameters
 * @deprecatedclass SuperMap.TransferSolutionParameters
 * @category  iServer TrafficTransferAnalyst TransferSolutions
 * @classdesc 交通换乘方案查询参数类。
 * @param {Object} options - 参数。
 * @param {Array.<GeometryPoint|L.Point|L.LatLng|ol.geom.Point|mapboxgl.LngLat|Array.<number>|number>} options.points - 两种查询方式：按照公交站点的起止ID进行查询和按照起止点的坐标进行查询。
 * @param {number} [options.solutionCount=6] - 乘车方案的数量。
 * @param {TransferTactic} [options.transferTactic=TransferTactic.LESS_TIME] - 交通换乘策略类型，包括时间最短、距离最短、最少换乘、最少步行四种选择。
 * @param {TransferPreference} [options.transferPreference=TransferPreference.NONE] - 乘车偏好枚举。
 * @param {number} [options.walkingRatio=10] - 步行与公交的消耗权重比。
 * @param {Array.<number>} [options.evadeLines] - 避让路线的 ID。
 * @param {Array.<number>} [options.evadeStops] - 避让站点的 ID。
 * @param {Array.<number>} [options.priorLines] - 优先路线的 ID。
 * @param {Array.<number>} [options.priorStops] - 优先站点的 ID。
 * @param {string} [options.travelTime] - 出行的时间。
 * @usage
 */
class TransferSolutionParameters {

    constructor(options) {
        options = options || {};
        /**
         *  @member {number} [TransferSolutionParameters.prototype.solutionCount=6]
         *  @description 乘车方案的数量。
         */
        this.solutionCount = 6;
        /**
         * @member {TransferPreference} [TransferSolutionParameters.prototype.transferPreference=TransferPreference.NONE]
         *  @description 乘车偏好枚举。
         */
        this.transferPreference = TransferPreference.NONE;

        /**
         *  @member {TransferTactic} [TransferSolutionParameters.prototype.transferTactic=TransferTactic|TransferTactic.LESS_TIME]
         *  @description 交通换乘策略类型，包括时间最短、距离最短、最少换乘、最少步行四种选择。
         */
        this.transferTactic = TransferTactic.LESS_TIME;

        /**
         *  @member {number} [TransferSolutionParameters.prototype.walkingRatio=10]
         *  @description 步行与公交的消耗权重比。此值越大，则步行因素对于方案选择的影响越大。例如：</br>
         *  例如现在有两种换乘方案（在仅考虑消耗因素的情况下）：</br>
         *  方案1：坐车 10 公里，走路 1 公里；</br>
         *  方案2：坐车 15 公里，走路 0.5 公里；</br>
         *  1. 假设权重比为 15：</br>
         *     •方案 1 的总消耗为：10 + 1*15 = 25</br>
         *     •方案 2 的总消耗为：15 + 0.5*15 = 22.5</br>
         *  此时方案 2 消耗更低。</br>
         *  2. 假设权重比为2：</br>
         *     •方案 1 的总消耗为：10+1*2 = 12</br>
         *     •方案 2 的总消耗为：15+0.5*2 = 17</br>
         *  此时方案 1 消耗更低。</br>
         */

        this.walkingRatio = null;

        /**
         *  @member {Array.<GeometryPoint|L.Point|L.LatLng|ol.geom.Point|mapboxgl.LngLat|Array.<number>|number>} TransferSolutionParameters.prototype.points
         *  @description 两种查询方式：</br>
         *           1. 按照公交站点的起止 ID 进行查询，则 points 参数的类型为 int[]，形如：[起点 ID、终点 ID]，公交站点的 ID 对应服务提供者配置中的站点 ID 字段；
         *           2. 按照起止点的坐标进行查询，则 points 参数的类型为 Point2D[]，形如：[{"x":44,"y":39},{"x":45,"y":40}]。
         */
        this.points = false;

        /**
         * @member {Array.<number>} [TransferSolutionParameters.prototype.evadeLinesnull]
         * @description 避让路线 ID。
         * */
        this.evadeLines = null;

        /**
         * @member {Array.<number>} [TransferSolutionParameters.prototype.evadeStops=TransferLine]
         * @description 避让站点 ID。
         * */
        this.evadeStops = null;

        /**
         * @member {Array.<number>} [TransferSolutionParameters.prototype.priorLines]
         * @description 优先路线 ID。
         * */
        this.priorLines = null;

        /**
         * @member {Array.<number>} [TransferSolutionParameters.prototype.priorStops]
         * @description 优先站点 ID。
         * */
        this.priorStops = null;

        /**
         * @member {string} TransferSolutionParameters.prototype.travelTime
         * @description 出行的时间；格式是："小时:分钟"，如："08:30"。如果设置了该参数，在分析时，则会考虑线路的首末班车时间的限制，即在返回的结果中会提示公交的首末班发车时间。
         */
        this.travelTime = null;

        Util_Util.extend(this, options);

        this.CLASS_NAME = "SuperMap.TransferSolutionParameters";
    }

    /**
     * @function TransferSolutionParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        Util_Util.reset(this);
    }


    /**
     * @function TransferSolutionParameters.toJsonParameters
     * @description 将 {@link TransferSolutionParameters} 对象参数转换为 JSON 字符串。
     * @param {TransferSolutionParameters} params - 交通换乘参数。
     * @returns {string} 转化后的 JSON 字符串。
     */
    static toJson(params) {
        if (params) {
            return Util_Util.toJSON(params);
        }
    }

}


;// CONCATENATED MODULE: ./src/common/iServer/TransferSolutionService.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/




/**
 * @class TransferSolutionService
 * @deprecatedclass SuperMap.TransferSolutionService
 * @category  iServer TrafficTransferAnalyst TransferSolutions
 * @classdesc 交通换乘方案查询服务类。
 * 返回结果通过该类支持的事件的监听函数参数获取。
 * @param {string} url - 服务地址。
 * 例如:</br>"http://localhost:8090/iserver/services/traffictransferanalyst-sample/restjsr/traffictransferanalyst/Traffic-Changchun"。
 * @param {Object} options - 参数。</br>
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @extends {CommonServiceBase}
 * @example 例如：
 * (start code)
 * var myService = new TransferSolutionService(url)
 * };
 * (end)
 * @usage
 */
class TransferSolutionService extends CommonServiceBase {

    constructor(url, options) {
        super(url, options);
        this.CLASS_NAME = "SuperMap.TransferSolutionService";
    }

    /**
     * @override
     */
    destroy() {
        super.destroy();
    }

    /**
     * @function TransferSolutionService.prototype.processAsync
     * @description 负责将客户端的更新参数传递到服务端。
     * @param {TransferSolutionParameters} params - 交通换乘参数。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    processAsync(params, callback) {
        if (!(params instanceof TransferSolutionParameters)) {
            return;
        }
        var me = this,
            method = "GET",
            jsonParameters;

        me.url = Util_Util.urlPathAppend(me.url, 'solutions');
        jsonParameters = {
            points: Util_Util.toJSON(params.points),
            walkingRatio: params['walkingRatio'],
            transferTactic: params['transferTactic'],
            solutionCount: params['solutionCount'],
            transferPreference: params["transferPreference"]
        };
        if (params.evadeLines) {
            jsonParameters["evadeLines"] = Util_Util.toJSON(params.evadeLines);
        }
        if (params.evadeStops) {
            jsonParameters["evadeStops"] = Util_Util.toJSON(params.evadeStops);
        }
        if (params.priorLines) {
            jsonParameters["priorLines"] = Util_Util.toJSON(params.priorLines);
        }
        if (params.priorStops) {
            jsonParameters["priorStops"] = Util_Util.toJSON(params.priorStops);
        }
        if (params.travelTime) {
            jsonParameters["travelTime"] = params.travelTime;
        }

        return me.request({
            method: method,
            params: jsonParameters,
            scope: me,
            success: callback,
            failure: callback
        });
    }

}



;// CONCATENATED MODULE: ./src/common/iServer/TrafficTransferAnalystService.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/




/**
 * @class TrafficTransferAnalystService
 * @extends {ServiceBase}
 * @category  iServer TrafficTransferAnalyst
 * @classdesc 交通换乘分析服务类。
 * @example
 *      new TrafficTransferAnalystService(url).queryStop(params,function(result){
 *           //doSomething
 *      })
 * @param {string} url - 服务地址。
 * @param {Object} options - 参数。
 * @param {string} [options.proxy] - 服务代理地址。
 * @param {boolean} [options.withCredentials=false] - 请求是否携带 cookie。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @usage
 */
class TrafficTransferAnalystService_TrafficTransferAnalystService {

    constructor(url, options) {
      this.url = url;
      this.options = options || {};
    }

    /**
     * @function TrafficTransferAnalystService.prototype.queryStop
     * @description 站点查询服务。
     * @param {StopQueryParameters} params - 查询相关参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    queryStop(params, callback) {
        var me = this;
        var stopQueryService = new StopQueryService(me.url, {
            proxy: me.options.proxy,
            withCredentials: me.options.withCredentials,
            crossOrigin: me.options.crossOrigin,
            headers: me.options.headers
        });
        return stopQueryService.processAsync(params, callback);
    }

    /**
     * @function TrafficTransferAnalystService.prototype.analysisTransferPath
     * @description 交通换乘线路查询服务。
     * @param {TransferPathParameters} params - 查询相关参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    analysisTransferPath(params, callback) {
        var me = this;
        var transferPathService = new TransferPathService(me.url, {
            proxy: me.options.proxy,
            withCredentials: me.options.withCredentials,
            crossOrigin: me.options.crossOrigin,
            headers: me.options.headers
        });
        return transferPathService.processAsync(params, callback);
    }

    /**
     * @function TrafficTransferAnalystService.prototype.analysisTransferSolution
     * @description 交通换乘方案查询服务。
     * @param {TransferSolutionParameters} params - 查询相关参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    analysisTransferSolution(params, callback) {
        var me = this;
        var transferSolutionService = new TransferSolutionService(me.url, {
            proxy: me.options.proxy,
            withCredentials: me.options.withCredentials,
            crossOrigin: me.options.crossOrigin,
            headers: me.options.headers
        });
        return transferSolutionService.processAsync(params, callback);
    }
}

;// CONCATENATED MODULE: ./src/mapboxgl/services/TrafficTransferAnalystService.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/





/**
 * @class TrafficTransferAnalystService
 * @extends ServiceBase
 * @category  iServer TrafficTransferAnalyst
 * @classdesc 交通换乘分析服务类。
 * @modulecategory Services
 * @example
 * new TrafficTransferAnalystService(url)
 *  .queryStop(params,function(result){
 *      //doSomething
 * })
 * @param {string} url - 服务地址。
 * @param {Object} options - 参数。
 * @param {string} [options.proxy] - 服务代理地址。
 * @param {boolean} [options.withCredentials=false] - 请求是否携带 cookie。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @usage
 */
class TrafficTransferAnalystService extends ServiceBase {

    constructor(url, options) {
        super(url, options);
        this._trafficTransferAnalystService = new TrafficTransferAnalystService_TrafficTransferAnalystService(url, options);
    }

    /**
     * @function TrafficTransferAnalystService.prototype.queryStop
     * @description 站点查询服务。
     * @param {StopQueryParameters} params - 站点查询参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    queryStop(params, callback) {
      return this._trafficTransferAnalystService.queryStop(params, callback);
    }

    /**
     * @function TrafficTransferAnalystService.prototype.analysisTransferPath
     * @description 交通换乘线路查询服务。
     * @param {TransferPathParameters} params - 交通换乘线路查询参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    analysisTransferPath(params, callback) {
      return this._trafficTransferAnalystService.analysisTransferPath(params, callback);
    }

    /**
     * @function TrafficTransferAnalystService.prototype.analysisTransferSolution
     * @description 交通换乘方案查询服务。
     * @param {TransferSolutionParameters} params - 交通换乘方案查询参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    analysisTransferSolution(params, callback) {
      return this._trafficTransferAnalystService.analysisTransferSolution(params, callback);
    }

    _processParams(params) {
        if (!params) {
            return {};
        }

        if (params.transferLines && !core_Util_Util.isArray(params.transferLines)) {
            params.transferLines = [params.transferLines];
        }
        if (params.points && core_Util_Util.isArray(params.points)) {
            params.points.map(function (point, key) {
                params.points[key] = (point instanceof (external_mapboxgl_default()).LngLat) ? {
                    x: point.lng,
                    y: point.lat
                } : point;
                return params.points[key];
            });
        }
        return params;
    }
}

;// CONCATENATED MODULE: ./src/common/iServer/WebPrintingService.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/



/**
 * @class WebPrintingService
 * @deprecatedclass SuperMap.WebPrintingService
 * @category iServer WebPrintingJob
 * @version 10.1.0
 * @classdesc 打印地图服务基类。
 * @extends {CommonServiceBase}
 * @param {string} url - 服务地址。请求打印地图服务的 URL 应为：http://{服务器地址}:{服务端口号}/iserver/services/webprinting/rest/webprinting/v1。
 * @param {Object} options - 参数。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @usage
 */
class WebPrintingService extends CommonServiceBase {
    constructor(url, options) {
        super(url, options);

        if (options) {
            Util_Util.extend(this, options);
        }
        this.CLASS_NAME = 'SuperMap.WebPrintingService';
        if (!this.url) {
            return;
        }
    }

    /**
     * @function WebPrintingService.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        super.destroy();
    }

    /**
     * @function WebPrintingService.prototype.createWebPrintingJob
     * @description 创建 Web 打印任务。
     * @param {WebPrintingJobParameters} params - Web 打印的请求参数。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    createWebPrintingJob(params, callback) {
        if (!params) {
            return;
        }
        if (params.layoutOptions) {
            if (params.layoutOptions.legendOptions) {
                !params.layoutOptions.legendOptions.title && (params.layoutOptions.legendOptions.title = '');
                params.layoutOptions.legendOptions.picAsBase64 =
                    params.layoutOptions.legendOptions.picAsBase64 &&
                    params.layoutOptions.legendOptions.picAsBase64.replace(/^data:.+;base64,/, '');
                if (
                    params.layoutOptions.legendOptions.customItems &&
                    params.layoutOptions.legendOptions.customItems.hasOwnProperty('picAsBase64')
                ) {
                    params.layoutOptions.legendOptions.customItems.picAsBase64 = params.layoutOptions.legendOptions.customItems.picAsBase64.replace(
                        /^data:.+;base64,/,
                        ''
                    );
                }
            }
        }
        return this.processAsync('jobs', 'POST', callback, params)
    }

    /**
     * @function WebPrintingService.prototype.getPrintingJob
     * @description 获取 Web 打印输出文档任务。
     * @param {string} jobId - Web 打印任务 ID
     * @param {RequestCallback} callback - 回调函数。
     */
    getPrintingJob(jobId, callback) {
        var me = this;
        me.processAsync(`jobs/${jobId}`, 'GET', function(result) {
          me.rollingProcess(result, me._processUrl(`jobs/${jobId}`), callback);
        });
    }

    /**
     * @function WebPrintingService.prototype.getPrintingJobResult
     * @description 获取 Web 打印任务的输出文档。
     * @param {string} jobId - Web 打印输入文档任务 ID。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    getPrintingJobResult(jobId, callback) {
        return this.processAsync(`jobs/${jobId}/result`, 'GET', callback);
    }

    /**
     * @function WebPrintingService.prototype.getLayoutTemplates
     * @description 查询 Web 打印服务所有可用的模板信息。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    getLayoutTemplates(callback) {
      return this.processAsync('layouts', 'GET', callback);
    }

    /**
     * @function WebPrintingService.prototype.rollingProcess
     * @description 轮询查询 Web 打印任务。
     * @param {Object} result - 服务器返回的结果对象。
     */
    rollingProcess(result, url, callback) {
        var me = this;
        if (!result) {
            return;
        }
        this.id && clearInterval(this.id);
        this.id = setInterval(function () {
          me.request({
            url,
            method: 'GET',
            scope: me,
            success: callback,
            failure: callback
          });
        }, 1000);
    }

    processAsync(url, method, callback, params) {
      var me = this;
      let requestConfig = {
        url: me._processUrl(url),
        method,
        scope: me,
        success: callback,
        failure: callback
      };
      params && (requestConfig.data = Util_Util.toJSON(params));
      return me.request(requestConfig);
    }

    transformResult(result, options) {
      result = Util_Util.transformResult(result);
      if (result.status === 'FINISHED' || result.status === 'ERROR') {
        clearInterval(this.id);
      }
      return { result, options };
    }

    _processUrl(appendContent) {
        if (appendContent) {
            return Util_Util.urlPathAppend(this.url, appendContent);
        }
        return this.url;
    }
}


;// CONCATENATED MODULE: ./src/mapboxgl/services/WebPrintingJobService.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/






/**
 * @class WebPrintingJobService
 * @category  iServer WebPrintingJob
 * @version 10.1.0
 * @classdesc Web 打印服务类。
 *            提供：创建 Web 打印任务，获取 Web 打印任务内容，获取 Web 打印输出文档流，获取 Web 打印服务的布局模板信息。
 * @modulecategory Services
 * @extends {ServiceBase}
 * @param {string} url - 资源根地址。请求打印地图服务的 URL 应为：http://{服务器地址}:{服务端口号}/iserver/services/webprinting/rest/webprinting/v1。
 * @param {Object} options - 参数。
 * @param {string} [options.proxy] - 服务代理地址。
 * @param {boolean} [options.withCredentials=false] - 请求是否携带 cookie。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @example
 * new WebPrintingJobService(url)
 * .createWebPrintingJob(param,function(result){
 *     //doSomething
 * })
 * @usage
 */
class WebPrintingJobService extends ServiceBase {
    constructor(url, options) {
        super(url, options);
        this._webPrintingService = new WebPrintingService(url, options);
    }

    /**
     * @function WebPrintingJobService.prototype.createWebPrintingJob
     * @description 创建 Web 打印任务。
     * @param {WebPrintingJobParameters} params - Web 打印参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    createWebPrintingJob(params, callback) {
      if (!params) {
        return;
      }
      return this._webPrintingService.createWebPrintingJob(this._processParams(params), callback);
    }

    /**
     * @function WebPrintingJobService.prototype.getPrintingJob
     * @description 获取 Web 打印输出文档任务。
     * @param {string} jobId - Web 打印输入文档任务 ID。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    getPrintingJob(jobId, callback) {
      return this._webPrintingService.getPrintingJob(jobId, callback);
    }

    /**
     * @function WebPrintingJobService.prototype.getPrintingJobResult
     * @description 获取 Web 打印任务的输出文档。
     * @param {string} jobId - Web 打印输入文档任务 ID。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    getPrintingJobResult(jobId, callback) {
      this._webPrintingService.getPrintingJobResult(jobId, callback);
    }

    /**
     * @function WebPrintingJobService.prototype.getLayoutTemplates
     * @description 查询 Web 打印服务所有可用的模板信息。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。、
     * @returns {Promise} Promise 对象。
     */
    getLayoutTemplates(callback) {
      return this._webPrintingService.getLayoutTemplates(callback);
    }

    _processParams(params) {
        if (params.layoutOptions && params.layoutOptions.littleMapOptions) {
            params.layoutOptions.littleMapOptions.center = this._toPointObject(params.layoutOptions.littleMapOptions.center);
        }
        if (params.exportOptions) {
            params.exportOptions.center = this._toPointObject(params.exportOptions.center);
        }
        return params;
    }

    _toPointObject(point) {
        if (core_Util_Util.isArray(point)) {
            return {
                x: point[0],
                y: point[1]
            };
        } else if (point instanceof Point || point instanceof (external_mapboxgl_default()).Point) {
            return {
                x: point.x,
                y: point.y
            };
        } else if (point instanceof (external_mapboxgl_default()).LngLat) {
            return {
                x: point.lng,
                y: point.lat
            };
        }
        return point;
    }
}


;// CONCATENATED MODULE: ./src/common/iServer/ImageService.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/




/**
 * @class ImageService
 * @deprecatedclass SuperMap.ImageService
 * @classdesc 影像服务类。
 * @version 10.2.0
 * @category iServer Image
 * @param {string} url - 服务地址。例如: http://{ip}:{port}/iserver/{imageservice-imageserviceName}/restjsr/
 * @param {Object} options - 可选参数。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @extends {CommonServiceBase}
 * @usage
 */
class ImageService_ImageService extends CommonServiceBase {
  constructor(url, options) {
    super(url, options);
    this.options = options || {};
    if (options) {
      Util_Util.extend(this, options);
    }
    this.CLASS_NAME = 'SuperMap.ImageService';
  }

  /**
   * @function ImageService.prototype.destroy
   * @override
   */
  destroy() {
    super.destroy();
  }

  /**
   * @function ImageService.prototype.getCollections
   * @description 返回当前影像服务中的影像集合列表（Collections）。
   * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
   * @returns {Promise} Promise 对象。
   */
  getCollections(callback) {
    var me = this;
    var path = Util_Util.convertPath('/collections');
    var url = Util_Util.urlPathAppend(me.url, path);
    return this._processAsync({ url, mehtod: 'GET', callback });
  }

  /**
   * @function ImageService.prototype.getCollectionByID
   * @description ID值等于`collectionId`参数值的影像集合（Collection）。ID值用于在服务中唯一标识该影像集合。
   * @param {string} collectionId 影像集合（Collection）的ID，在一个影像服务中唯一标识影像集合。
   * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
   * @returns {Promise} Promise 对象。
   */
  getCollectionByID(collectionId, callback) {
    var pathParams = {
      collectionId: collectionId
    };
    var me = this;
    var path = Util_Util.convertPath('/collections/{collectionId}', pathParams);
    var url = Util_Util.urlPathAppend(me.url, path);
    return this._processAsync({ url, mehtod: 'GET', callback });
  }

  /**
   * @function ImageSearchService.prototype.search
   * @description 查询与过滤条件匹配的影像数据。
   * @param {ImageSearchParameter} [imageSearchParameter] 查询参数。
   * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
   * @returns {Promise} Promise 对象。
   */
  search(imageSearchParameter, callback) {
    var postBody = { ...(imageSearchParameter || {}) };
    var me = this;
    var path = Util_Util.convertPath('/search');
    var url = Util_Util.urlPathAppend(me.url, path);
    return this._processAsync({ url, method: 'POST', data: postBody, callback });
  }

  _processAsync({ url, method, callback, data }) {
    return this.request({
      method: method || 'GET',
      url,
      data,
      scope: this,
      success: callback,
      failure: callback
    });
  }
}

;// CONCATENATED MODULE: ./src/mapboxgl/services/ImageService.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/




/**
 * @class ImageService
 * @version 10.2.0
 * @constructs ImageService
 * @classdesc 影像服务类。
 * @category  iServer Image
 * @modulecategory Services
 * @example
 *      new ImageService(url,options)
 *      .getCollections(function(result){
 *          //doSomething
 *      })
 * @param {string} url - 服务地址。例如: http://{ip}:{port}/iserver/{imageservice-imageserviceName}/restjsr/
 * @param {Object} options - 参数。
 * @param {string} [options.proxy] - 服务代理地址。
 * @param {boolean} [options.withCredentials=false] - 请求是否携带 cookie。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @extends {ServiceBase}
 * @usage
 */
class ImageService extends ServiceBase {
    constructor(url, options) {
        super(url, options);
        this._imageService = new ImageService_ImageService(this.url, {
          proxy: this.options.proxy,
          withCredentials: this.options.withCredentials,
          crossOrigin: this.options.crossOrigin,
          headers: this.options.headers
        });
    }

    /**
     * @function ImageService.prototype.getCollections
     * @description 返回当前影像服务中的影像集合列表（Collections）。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    getCollections(callback) {
      return this._imageService.getCollections(callback);
    }

    /**
     * @function ImageService.prototype.getCollectionByID
     * @description ID值等于`collectionId`参数值的影像集合（Collection）。ID值用于在服务中唯一标识该影像集合。
     * @param {string} collectionId 影像集合（Collection）的ID，在一个影像服务中唯一标识影像集合。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    getCollectionByID(collectionId, callback) {
      return this._imageService.getCollectionByID(collectionId, callback);
    }

    /**
     * @function ImageService.prototype.search
     * @description 查询与过滤条件匹配的影像数据。
     * @param {ImageSearchParameter} [itemSearch] 影像服务查询参数类。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    search(itemSearch, callback) {
      return this._imageService.search(itemSearch, callback);
    }
}


;// CONCATENATED MODULE: ./src/common/iServer/ImageCollectionService.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/




/**
 * @class ImageCollectionService
 * @deprecatedclass SuperMap.ImageCollectionService
 * @classdesc 影像集合服务类。
 * @version 10.2.0
 * @category iServer Image
 * @param {string} url - 服务地址。例如: http://{ip}:{port}/iserver/{imageservice-imageserviceName}/restjsr/
 * @param {Object} options - 参数。
 * @param {string} options.collectionId 影像集合（Collection）的ID，在一个影像服务中唯一标识影像集合。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @extends {CommonServiceBase}
 * @usage
 */
class ImageCollectionService_ImageCollectionService extends CommonServiceBase {
    constructor(url, options) {
        super(url, options);
        this.options = options || {};
        if (options) {
            Util_Util.extend(this, options);
        }
        this.CLASS_NAME = 'SuperMap.ImageCollectionService';
    }

    /**
     * @function ImageCollectionService.prototype.destroy
     * @override
     */
    destroy() {
        super.destroy();
    }

    /**
     * @function ImageCollectionService.prototype.getLegend
     * @description 返回当前影像集合的图例信息。默认为服务发布所配置的风格，支持根据风格参数生成新的图例。
     * @param {Object} queryParams query参数。
     * @param {ImageRenderingRule} [queryParams.renderingRule] renderingRule 对象，用来指定影像的渲染风格，从而确定图例内容。影像的渲染风格包含拉伸显示方式、颜色表、波段组合以及应用栅格函数进行快速处理等。该参数未设置时，将使用发布服务时所配置的风格。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    getLegend(queryParams, callback) {
        var me = this;
        var pathParams = {
            collectionId: me.options.collectionId
        };
        if (typeof queryParams === 'function') {
          callback = queryParams;
          queryParams = null;
        }
        var path = Util_Util.convertPath('/collections/{collectionId}/legend', pathParams);
        var url = Util_Util.urlPathAppend(me.url, path);
        return this._processAsync({ url, method: 'GET', params: queryParams, callback });
    }

    /**
     * @function ImageCollectionService.prototype.getStatistics
     * @description 返回当前影像集合的统计信息。包括文件数量，文件大小等信息。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    getStatistics(callback) {
        var me = this;
        var pathParams = {
            collectionId: me.options.collectionId
        };
        var path = Util_Util.convertPath('/collections/{collectionId}/statistics', pathParams);
        var url = Util_Util.urlPathAppend(me.url, path);
        return this._processAsync({ url, method: 'GET', callback });
    }

    /**
     * @function ImageCollectionService.prototype.getTileInfo
     * @description 返回影像集合所提供的服务瓦片的信息，包括：每层瓦片的分辨率，比例尺等信息，方便前端进行图层叠加。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    getTileInfo(callback) {
        var me = this;
        var pathParams = {
            collectionId: me.options.collectionId
        };
        var path = Util_Util.convertPath('/collections/{collectionId}/tileInfo', pathParams);
        var url = Util_Util.urlPathAppend(me.url, path);
        return this._processAsync({ url, method: 'GET', callback });
    }

    /**
     * @function ImageCollectionService.prototype.deleteItemByID
     * @description 删除影像集合中指定 ID 的 Item，即从影像集合中删除指定的影像。
     * @param {string} featureId Feature 的本地标识符。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    deleteItemByID(featureId, callback) {
        var me = this;
        var pathParams = {
            collectionId: me.options.collectionId,
            featureId: featureId
        };
        var path = Util_Util.convertPath('/collections/{collectionId}/items/{featureId}', pathParams);
        var url = Util_Util.urlPathAppend(me.url, path);
        return this._processAsync({ url, method: 'DELETE', callback });
    }

    /**
     * @function ImageCollectionService.prototype.getItemByID
     * @description 返回指定ID（`collectionId`）的影像集合中的指定ID（`featureId`）的Item对象，即返回影像集合中指定的影像。
     * @param {string} featureId Feature 的本地标识符。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    getItemByID(featureId, callback) {
        var me = this;
        var pathParams = {
            collectionId: me.options.collectionId,
            featureId: featureId
        };
        var path = Util_Util.convertPath('/collections/{collectionId}/items/{featureId}', pathParams);
        var url = Util_Util.urlPathAppend(me.url, path);
        return this._processAsync({ url, method: 'GET', callback });
    }

    _processAsync({ url, method, callback, params}) {
        return this.request({
          method: method || 'GET',
          url,
          params,
          scope: this,
          success: callback,
          failure: callback
        });
    }
}


;// CONCATENATED MODULE: ./src/mapboxgl/services/ImageCollectionService.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/




/**
 * @class ImageCollectionService
 * @version 10.2.0
 * @constructs ImageCollectionService
 * @classdesc 影像集合服务类。
 * @category  iServer Image
 * @modulecategory Services
 * @extends {ServiceBase}
 * @example
 *      new ImageCollectionService(url,options)
 *      .getLegend(collectionId, queryParams, function(result){
 *          //doSomething
 *      })
 * @param {string} url - 服务地址。例如: http://{ip}:{port}/iserver/{imageservice-imageserviceName}/restjsr/
 * @param {Object} options - 参数。
 * @param {string} options.collectionId 影像集合（Collection）的ID，在一个影像服务中唯一标识影像集合。
 * @param {string} [options.proxy] - 服务代理地址。
 * @param {boolean} [options.withCredentials=false] - 请求是否携带 cookie。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @usage
 */
class ImageCollectionService extends ServiceBase {
    constructor(url, options) {
        super(url, options);
        this._imageCollectionService = new ImageCollectionService_ImageCollectionService(this.url, {
          collectionId: this.options.collectionId,
          proxy: this.options.proxy,
          withCredentials: this.options.withCredentials,
          crossOrigin: this.options.crossOrigin,
          headers: this.options.headers
        });
    }
    /**
     * @function ImageCollectionService.prototype.getLegend
     * @param {Object} queryParams query参数。
     * @param {ImageRenderingRule} [queryParams.renderingRule] 指定影像显示的风格，包含拉伸显示方式、颜色表、波段组合以及应用栅格函数进行快速处理等。不指定时，使用发布服务时所配置的风格。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    getLegend(queryParams, callback) {
      return this._imageCollectionService.getLegend(queryParams, callback);
    }

    /**
     * @function ImageCollectionService.prototype.getStatistics
     * @description 返回当前影像集合的统计信息。包括文件数量，文件大小等信息。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    getStatistics(callback) {
      return this._imageCollectionService.getStatistics(callback);
    }

    /**
     * @function ImageCollectionService.prototype.getTileInfo
     * @description 返回影像集合所提供的服务瓦片的信息，包括：每层瓦片的分辨率，比例尺等信息，方便前端进行图层叠加。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    getTileInfo(callback) {
      return this._imageCollectionService.getTileInfo(callback);
    }

    /**
     * @function ImageCollectionService.prototype.deleteItemByID
     * @description 删除影像集合中指定ID （`featureId`） 的Item对象，即从影像集合中删除指定的影像。
     * @param {string} featureId Feature 的本地标识符。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    deleteItemByID(featureId, callback) {
      return this._imageCollectionService.deleteItemByID(featureId, callback);
    }

    /**
     * @function ImageCollectionService.prototype.getItemByID
     * @description 返回影像集合中的指定ID（`featureId`）的Item对象，即返回影像集合中指定的影像。
     * @param {string} featureId Feature 的本地标识符。
     * @param {RequestCallback} [callback] - 回调函数，该参数未传时可通过返回的 promise 获取结果。
     * @returns {Promise} Promise 对象。
     */
    getItemByID(featureId, callback) {
      return this._imageCollectionService.getItemByID(featureId, callback);
    }
}


;// CONCATENATED MODULE: ./src/mapboxgl/services/index.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/

























;// CONCATENATED MODULE: ./src/common/SuperMap.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/
var SuperMap = window.SuperMap = window.SuperMap || {};
SuperMap.Components = window.SuperMap.Components || {};

;// CONCATENATED MODULE: ./src/common/format/WKT.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/











/**
 * @class WKTFormat
 * @aliasclass Format.WKT
 * @deprecatedclass SuperMap.Format.WKT
 * @classdesc 用于读写常见文本的类。通过 {@link WKTFormat} 构造器来创建一个新的实例。
 * @category BaseTypes Format
 * @extends {Format}
 * @param {Object} options - 可选的选项对象，其属性将被设置到实例。option 具体配置项继承自 {@link Format}。
 * @usage
 */
class WKT extends Format {

    constructor(options) {
        super(options);
        this.regExes = {
            'typeStr': /^\s*(\w+)\s*\(\s*(.*)\s*\)\s*$/,
            'spaces': /\s+/,
            'parenComma': /\)\s*,\s*\(/,
            'doubleParenComma': /\)\s*\)\s*,\s*\(\s*\(/,  // can't use {2} here
            'trimParens': /^\s*\(?(.*?)\)?\s*$/
        };
        this.CLASS_NAME = "SuperMap.Format.WKT"; /**
         * @private
         * @description Object with properties corresponding to the geometry types.
         * Property values are functions that do the actual data extraction.
         */
        this.extract = {
            /**
             * @description Return a space delimited string of point coordinates.
             * @param {GeometryPoint} point
             * @returns  {string} A string of coordinates representing the point
             */
            'point': function (point) {
                return point.x + ' ' + point.y;
            },

            /**
             * @description  Return a comma delimited string of point coordinates from a multipoint.
             * @param {GeometryMultiPoint} multipoint
             * @returns  {string} A string of point coordinate strings representing
             *                  the multipoint
             */
            'multipoint'(multipoint) {
                var array = [];
                for (var i = 0, len = multipoint.components.length; i < len; ++i) {
                    array.push('(' +
                        this.extract.point.apply(this, [multipoint.components[i]]) +
                        ')');
                }
                return array.join(',');
            },

            /**
             * @description  Return a comma delimited string of point coordinates from a line.
             * @param {GeometryLineString} linestring
             * @returns  {string} A string of point coordinate strings representing
             *                  the linestring
             */
            'linestring'(linestring) {
                var array = [];
                for (var i = 0, len = linestring.components.length; i < len; ++i) {
                    array.push(this.extract.point.apply(this, [linestring.components[i]]));
                }
                return array.join(',');
            },

            /**
             * @description  Return a comma delimited string of linestring strings from a multilinestring.
             * @param {GeometryMultiLineString} multilinestring
             * @returns  {string} A string of of linestring strings representing
             *                  the multilinestring
             */
            'multilinestring'(multilinestring) {
                var array = [];
                for (var i = 0, len = multilinestring.components.length; i < len; ++i) {
                    array.push('(' +
                        this.extract.linestring.apply(this, [multilinestring.components[i]]) +
                        ')');
                }
                return array.join(',');
            },

            /**
             * @description  Return a comma delimited string of linear ring arrays from a polygon.
             * @param {GeometryPolygon} polygon
             * @returns  {string} An array of linear ring arrays representing the polygon
             */
            'polygon'(polygon) {
                var array = [];
                for (var i = 0, len = polygon.components.length; i < len; ++i) {
                    array.push('(' +
                        this.extract.linestring.apply(this, [polygon.components[i]]) +
                        ')');
                }
                return array.join(',');
            },

            /**
             * @description  Return an array of polygon arrays from a multipolygon.
             * @param {GeometryMultiPolygon} multipolygon
             * @returns  {string} An array of polygon arrays representing
             *                  the multipolygon
             */
            'multipolygon'(multipolygon) {
                var array = [];
                for (var i = 0, len = multipolygon.components.length; i < len; ++i) {
                    array.push('(' +
                        this.extract.polygon.apply(this, [multipolygon.components[i]]) +
                        ')');
                }
                return array.join(',');
            },

            /**
             * @description  Return the WKT portion between 'GEOMETRYCOLLECTION(' and ')' for an <GeometryCollection>
             * @param {GeometryCollection} collection
             * @returns  {string} internal WKT representation of the collection
             */
            'collection'(collection) {
                var array = [];
                for (var i = 0, len = collection.components.length; i < len; ++i) {
                    array.push(this.extractGeometry.apply(this, [collection.components[i]]));
                }
                return array.join(',');
            }

        };

        /**
         * @private
         * @description Object with properties corresponding to the geometry types.
         * Property values are functions that do the actual parsing.
         */
        this.parse = {
            /**
             * @private
             * @description  Return point feature given a point WKT fragment.
             * @param {string} str A WKT fragment representing the point
             * @returns  {FeatureVector} A point feature
             *
             */
            'point': function (str) {
                var coords = StringExt.trim(str).split(this.regExes.spaces);
                return new Vector(new Point(coords[0], coords[1])
                );
            },

            /**
             * @description  Return a multipoint feature given a multipoint WKT fragment.
             * @param {string} A WKT fragment representing the multipoint
             * @returns  {FeatureVector} A multipoint feature
             * @private
             */
            'multipoint': function (str) {
                var point;
                var points = StringExt.trim(str).split(',');
                var components = [];
                for (var i = 0, len = points.length; i < len; ++i) {
                    point = points[i].replace(this.regExes.trimParens, '$1');
                    components.push(this.parse.point.apply(this, [point]).geometry);
                }
                return new Vector(
                    new MultiPoint(components)
                );
            },

            /**
             * @description  Return a linestring feature given a linestring WKT fragment.
             * @param {string} A WKT fragment representing the linestring
             * @returns  {FeatureVector} A linestring feature
             * @private
             */
            'linestring': function (str) {
                var points = StringExt.trim(str).split(',');
                var components = [];
                for (var i = 0, len = points.length; i < len; ++i) {
                    components.push(this.parse.point.apply(this, [points[i]]).geometry);
                }
                return new Vector(
                    new LineString(components)
                );
            },

            /**
             * @description  Return a multilinestring feature given a multilinestring WKT fragment.
             * @param {string} A WKT fragment representing the multilinestring
             * @returns  {FeatureVector} A multilinestring feature
             * @private
             */
            'multilinestring': function (str) {
                var line;
                var lines = StringExt.trim(str).split(this.regExes.parenComma);
                var components = [];
                for (var i = 0, len = lines.length; i < len; ++i) {
                    line = lines[i].replace(this.regExes.trimParens, '$1');
                    components.push(this.parse.linestring.apply(this, [line]).geometry);
                }
                return new Vector(
                    new MultiLineString(components)
                );
            },

            /**
             * @description  Return a polygon feature given a polygon WKT fragment.
             * @param {string} A WKT fragment representing the polygon
             * @returns  {FeatureVector} A polygon feature
             * @private
             */
            'polygon': function (str) {
                var ring, linestring, linearring;
                var rings = StringExt.trim(str).split(this.regExes.parenComma);
                var components = [];
                for (var i = 0, len = rings.length; i < len; ++i) {
                    ring = rings[i].replace(this.regExes.trimParens, '$1');
                    linestring = this.parse.linestring.apply(this, [ring]).geometry;
                    linearring = new LinearRing_LinearRing(linestring.components);
                    components.push(linearring);
                }
                return new Vector(
                    new Polygon_Polygon(components)
                );
            },

            /**
             * @private
             * @description  Return a multipolygon feature given a multipolygon WKT fragment.
             * @param {string} A WKT fragment representing the multipolygon
             * @returns  {FeatureVector} A multipolygon feature
             *
             */
            'multipolygon': function (str) {
                var polygon;
                var polygons = StringExt.trim(str).split(this.regExes.doubleParenComma);
                var components = [];
                for (var i = 0, len = polygons.length; i < len; ++i) {
                    polygon = polygons[i].replace(this.regExes.trimParens, '$1');
                    components.push(this.parse.polygon.apply(this, [polygon]).geometry);
                }
                return new Vector(
                    new MultiPolygon(components)
                );
            },


            /**
             * @description  Return an array of features given a geometrycollection WKT fragment.
             * @param {string} A WKT fragment representing the geometrycollection
             * @returns  {Array} An array of FeatureVector
             * @private
             */
            'geometrycollection': function (str) {
                // separate components of the collection with |
                str = str.replace(/,\s*([A-Za-z])/g, '|$1');
                var wktArray = StringExt.trim(str).split('|');
                var components = [];
                for (var i = 0, len = wktArray.length; i < len; ++i) {
                    components.push(this.read(wktArray[i]));
                }
                return components;
            }

        };

    }


    /**
     * @function WKTFormat.prototype.read
     * @description 反序列化 WKT 字符串并返回向量特征或向量特征数组。支持 POINT、MULTIPOINT、LINESTRING、MULTILINESTRING、POLYGON、MULTIPOLYGON 和 GEOMETRYCOLLECTION 的 WKT。
     * @param {string} wkt - WKT 字符串。
     * @returns {FeatureVector|Array} GEOMETRYCOLLECTION WKT 的矢量要素或者矢量要素数组。
     */
    read(wkt) {
        var features, type, str;
        wkt = wkt.replace(/[\n\r]/g, " ");
        var matches = this.regExes.typeStr.exec(wkt);
        if (matches) {
            type = matches[1].toLowerCase();
            str = matches[2];
            if (this.parse[type]) {
                features = this.parse[type].apply(this, [str]);
            }
        }
        return features;
    }


    /**
     * @function WKTFormat.prototype.write
     * @description 将矢量要素或矢量要素数组序列化为 WKT 字符串。
     * @param {(FeatureVector|Array)} features - 矢量要素或矢量要素数组。
     * @returns {string} 表示几何的 WKT 字符串。
     */
    write(features) {
        var collection, geometry, isCollection;
        if (features.constructor === Array) {
            collection = features;
            isCollection = true;
        } else {
            collection = [features];
            isCollection = false;
        }
        var pieces = [];
        if (isCollection) {
            pieces.push('GEOMETRYCOLLECTION(');
        }
        for (var i = 0, len = collection.length; i < len; ++i) {
            if (isCollection && i > 0) {
                pieces.push(',');
            }
            geometry = collection[i].geometry;
            pieces.push(this.extractGeometry(geometry));
        }
        if (isCollection) {
            pieces.push(')');
        }
        return pieces.join('');
    }

    /**
     * @function WKTFormat.prototype.extractGeometry
     * @description 为单个 Geometry 对象构造 WKT 的入口点。
     * @param {Geometry} geometry - Geometry 对象。
     * @returns {string} 表示几何的 WKT 字符串。
     */
    extractGeometry(geometry) {
        var type = geometry.CLASS_NAME.split('.')[2].toLowerCase();
        if (!this.extract[type]) {
            return null;
        }
        var wktType = type === 'collection' ? 'GEOMETRYCOLLECTION' : type.toUpperCase();
        var data = wktType + '(' + this.extract[type].apply(this, [geometry]) + ')';
        return data;
    }
}

;// CONCATENATED MODULE: ./src/common/format/index.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/









;// CONCATENATED MODULE: ./src/common/control/TimeControlBase.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


/**
 * @class TimeControlBase
 * @deprecatedclass SuperMap.TimeControlBase
 * @classdesc 时间控制基类。
 * @modulecategory Control
 * @category  Control
 * @param {Object} options - 可选参数。
 * @param {number} [options.speed=1] - 速度。不能小于 0，（每帧渲染的数据之间的间隔为1），设置越大速度越快。
 * @param {number} [options.frequency=1000] - 刷新频率（单位 ms），服务器刷新的时间间隔。
 * @param {number} [options.startTime=0] - 起始时间，必须为数字，且小于等于 endTime。如果不设置，初始化时为 0，建议设置。
 * @param {number} [options.endTime] - 结束时间，必须为数字，且大于等于 startTime。如果不设置，初始化时以当前时间进行设置，建议设置。
 * @param {boolean} [options.repeat=true] - 是否重复循环。
 * @param {boolean} [options.reverse=false] - 是否反向。
 * @usage
 */
class TimeControlBase {


    constructor(options) {
        //设置步长，刷新频率、开始结束时间、是否循环、是否反向
        var me = this;
        options = options || {};


        /**
         * @member {number} [TimeControlBase.prototype.speed=1]
         * @description 步长，必须为非负数，默认为1（表示前后两次渲染的数据之间的间隔为1）。
         */
        this.speed = (options.speed && options.speed >= 0) ? options.speed : 1;

        /**
         * @member {number} [TimeControlBase.prototype.frequency=1000]
         * @description 刷新频率(单位ms)，服务器刷新的时间间隔。
         */
        this.frequency = (options.speed && options.frequency >= 0) ? options.frequency : 1000;

        /**
         * @member {number} [TimeControlBase.prototype.startTime=0]
         * @description 记录的起始时间，必须为数字，
         *              如果不设置，初始化时为0，建议设置。
         */
        this.startTime = (options.startTime && options.startTime != null) ? options.startTime : 0;

        /**
         * @member {number} TimeControlBase.prototype.endTime
         * @description 记录的结束时间，必须为数字，
         *              如果不设置，初始化时以当前时间进行设置，建议设置。
         */
        this.endTime = (options.endTime && options.endTime != null && options.endTime >= me.startTime) ? options.endTime : +new Date();

        /**
         * @member {boolean} [TimeControlBase.prototype.repeat=true]
         * @description 是否重复循环。
         */
        this.repeat = (options.repeat !== undefined) ? options.repeat : true;

        /**
         * @member {boolean} [TimeControlBase.prototype.reverse=false]
         * @description 是否反向。
         */
        this.reverse = (options.reverse !== undefined) ? options.reverse : false;

        /**
         * @member {number} TimeControlBase.prototype.currentTime
         * @description 记录近期的时间，也就是当前帧运行到的时间。
         */
        this.currentTime = null;

        /**
         * @member {number} TimeControlBase.prototype.oldTime
         * @description 记录上一帧的时间，也就是之前运行到的时间。
         */
        this.oldTime = null;

        /**
         * @member {boolean} [TimeControlBase.prototype.running=false]
         * @description 记录当前是否处于运行中。
         */
        this.running = false;


        /**
         * @private
         * @member {Array.<string>} TimeControlBase.prototype.EVENT_TYPES
         * @description 此类支持的事件类型。
         *
         */
        this.EVENT_TYPES = ["start", "pause", "stop"];

        /**
         * @private
         * @member {Events} TimeControlBase.prototype.events
         * @description 事件
         */
        me.events = new Events(this, null, this.EVENT_TYPES);

        me.speed = Number(me.speed);
        me.frequency = Number(me.frequency);
        me.startTime = Number(me.startTime);
        me.endTime = Number(me.endTime);

        me.startTime = Date.parse(new Date(me.startTime));
        me.endTime = Date.parse(new Date(me.endTime));

        //初始化当前时间
        me.currentTime = me.startTime;

        this.CLASS_NAME = "SuperMap.TimeControlBase";
    }


    /**
     * @function TimeControlBase.prototype.updateOptions
     * @description 更新参数。
     * @param {Object} options - 设置参数的可选参数。设置步长，刷新频率、开始结束时间、是否循环、是否反向。
     */
    updateOptions(options) {
        //设置步长，刷新频率、开始结束时间、是否循环、是否反向
        var me = this;
        options = options || {};
        if (options.speed && options.speed >= 0) {
            me.speed = options.speed;
            me.speed = Number(me.speed);
        }

        if (options.speed && options.frequency >= 0) {
            me.frequency = options.frequency;
            me.frequency = Number(me.frequency);
        }

        if (options.startTime && options.startTime != null) {
            me.startTime = options.startTime;
            me.startTime = Date.parse(new Date(me.startTime));
        }

        if (options.endTime && options.endTime != null && options.endTime >= me.startTime) {
            me.endTime = options.endTime;
            me.endTime = Date.parse(new Date(me.endTime));
        }

        if (options.repeat != null) {
            me.repeat = options.repeat;
        }

        if (options.reverse != null) {
            me.reverse = options.reverse;
        }
    }


    /**
     * @function TimeControlBase.prototype.start
     * @description 开始。
     */
    start() {
        var me = this;

        if (!me.running) {
            me.running = true;
            me.tick();
            me.events.triggerEvent('start', me.currentTime);
        }
    }


    /**
     * @function TimeControlBase.prototype.pause
     * @description 暂停。
     */
    pause() {
        var me = this;
        me.running = false;
        me.events.triggerEvent('pause', me.currentTime);
    }


    /**
     * @function TimeControlBase.prototype.stop
     * @description 停止，停止后返回起始状态。
     */
    stop() {
        var me = this;
        //停止时 时间设置为开始时间
        me.currentTime = me.startTime;
        //如果正在运行，修改为初始时间即可绘制一帧
        if (me.running) {
            me.running = false;
        }
        me.events.triggerEvent('stop', me.currentTime);
    }


    /**
     * @function TimeControlBase.prototype.toggle
     * @description 开关切换，切换的是开始和暂停。
     */
    toggle() {
        var me = this;

        if (me.running) {
            me.pause();
        } else {
            me.start();
        }
    }


    /**
     * @function TimeControlBase.prototype.setSpeed
     * @description 设置步长。
     * @param {number} [speed=1] - 步长，必须为非负数。
     * @returns {boolean} true 代表设置成功，false 设置失败（speed 小于 0 时失败）。
     */
    setSpeed(speed) {
        var me = this;
        if (speed >= 0) {
            me.speed = speed;
            return true;
        }
        return false;
    }


    /**
     * @function TimeControlBase.prototype.getSpeed
     * @description 获取步长。
     * @returns {number} 返回当前的步长。
     */
    getSpeed() {
        return this.speed;
    }


    /**
     * @function TimeControlBase.prototype.setFrequency
     * @description 设置刷新频率。
     * @param {number} [frequency=1000] - 刷新频率，单位为 ms。
     * @returns {boolean} true 代表设置成功，false 设置失败（frequency 小于 0 时失败）。
     */
    setFrequency(frequency) {
        var me = this;
        if (frequency >= 0) {
            me.frequency = frequency;
            return true;
        }
        return false;
    }


    /**
     * @function TimeControlBase.prototype.getFrequency
     * @description 获取刷新频率。
     * @returns {number} 返回当前的刷新频率。
     */
    getFrequency() {
        return this.frequency;
    }


    /**
     * @function TimeControlBase.prototype.setStartTime
     * @description 设置起始时间，设置完成后如果当前时间小于起始时间，则从起始时间开始。
     * @param {number} startTime - 需要设置的起始时间。
     * @returns {boolean} true 代表设置成功，false 设置失败（startTime 大于结束时间时失败）。
     */
    setStartTime(startTime) {
        var me = this;
        startTime = Date.parse(new Date(startTime));
        //起始时间不得大于结束时间
        if (startTime > me.endTime) {
            return false;
        }
        me.startTime = startTime;
        //如果当前时间小于了起始时间，则从当前起始时间开始
        if (me.currentTime < me.startTime) {
            me.currentTime = me.startTime;
            me.tick();
        }
        return true;
    }


    /**
     * @function TimeControlBase.prototype.getStartTime
     * @description 获取起始时间。
     * @returns {number} 返回当前的起始时间。
     */
    getStartTime() {
        return this.startTime;
    }


    /**
     * @function TimeControlBase.prototype.setEndTime
     * @description 设置结束时间，设置完成后如果当前时间大于结束，则从起始时间开始。
     * @param {number} endTime - 需要设置的结束时间。
     * @returns {boolean} true 代表设置成功，false 设置失败（endTime 小于开始时间时失败）。
     */
    setEndTime(endTime) {
        var me = this;
        me.endTime = Date.parse(new Date(me.endTime));
        //结束时间不得小于开始时间
        if (endTime < me.startTime) {
            return false;
        }
        me.endTime = endTime;
        //如果当前时间大于了结束时间，则从起始时间开始
        if (me.currentTime >= me.endTime) {
            me.currentTime = me.startTime;
            me.tick();
        }
        return true;
    }


    /**
     * @function TimeControlBase.prototype.getEndTime
     * @description 获取结束时间。
     * @returns {number} 返回当前的结束时间。
     */
    getEndTime() {
        return this.endTime;
    }


    /**
     * @function TimeControlBase.prototype.setCurrentTime
     * @description 设置当前时间。
     * @param {number} currentTime - 需要设置的当前时间。
     * @returns {boolean} true 代表设置成功，false 设置失败。
     */
    setCurrentTime(currentTime) {
        var me = this;
        me.currentTime = Date.parse(new Date(me.currentTime));
        //结束时间不得小于开始时间
        if (currentTime >= me.startTime && currentTime <= me.endTime) {
            me.currentTime = currentTime;
            me.startTime = me.currentTime;
            me.tick();
            return true;
        }
        return false;
    }


    /**
     * @function TimeControlBase.prototype.getCurrentTime
     * @description 获取当前时间。
     * @returns {number} 返回当前时间。
     */
    getCurrentTime() {
        return this.currentTime;
    }


    /**
     * @function TimeControlBase.prototype.setRepeat
     * @description 设置是否重复循环。
     * @param {boolean} [repeat=true] - 是否重复循环。
     */
    setRepeat(repeat) {
        this.repeat = repeat;
    }


    /**
     * @function TimeControlBase.prototype.getRepeat
     * @description 获取是否重复循环，默认是 true。
     * @returns {boolean} 返回是否重复循环。
     */
    getRepeat() {
        return this.repeat;
    }


    /**
     * @function TimeControlBase.prototype.setReverse
     * @description 设置是否反向。
     * @param {boolean} [reverse=false] - 是否反向。
     */
    setReverse(reverse) {
        this.reverse = reverse;
    }


    /**
     * @function TimeControlBase.prototype.getReverse
     * @description 获取是否反向，默认是false。
     * @returns {boolean} 返回是否反向。
     */
    getReverse() {
        return this.reverse;
    }


    /**
     * @function TimeControlBase.prototype.getRunning
     * @description 获取运行状态。
     * @returns {boolean} true 代表正在运行，false 发表没有运行。
     */
    getRunning() {
        return this.running;
    }


    /**
     * @function TimeControlBase.prototype.destroy
     * @description 销毁 Animator 对象，释放资源。
     */
    destroy() {
        var me = this;
        me.speed = null;
        me.frequency = null;
        me.startTime = null;
        me.endTime = null;
        me.currentTime = null;
        me.repeat = null;
        me.running = false;
        me.reverse = null;
    }


    tick() {
        //TODO 每次刷新执行的操作。子类实现
    }

}


;// CONCATENATED MODULE: ./src/common/control/TimeFlowControl.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


/**
 * @class TimeFlowControl
 * @deprecatedclass SuperMap.TimeFlowControl
 * @category  Control
 * @classdesc 时间管理类。此类只负责时间上的控制，具体执行的操作需要用户在初始化时的回调函数内部进行实现。
 * 如设置起始时间为 1000，结束时间是 2000，步长设置为 1，
 * 那么表示按照每次1年（可以通过 setSpeed 进行修改）的变化从公元 1000 年开始到公元 2000 年为止，默认每 1 秒会变化 1 次（通过 setFrequency 修改）
 * @modulecategory Control
 * @extends {TimeControlBase}
 * @param {function} callback - 每次刷新回调函数。具体的效果需要用户在此回调函数里面实现。
 * @param {Object} options - 可选参数。
 * @param {number} [options.speed=1] - 步长（单位 ms）。不能小于 0，（每次刷新的数据之间的间隔为 1ms）。
 * @param {number} [options.frequency=1000] - 刷新频率（单位 ms）。
 * @param {number} [options.startTime=0] - 起始时间，必须为数字，且小于等于 endTime。如果不设置，初始化时为 0，建议设置。
 * @param {number} [options.endTime] - 结束时间，必须为数字，且大于等于 startTime。如果不设置，初始化时使用 new Date() 以当前时间进行设置，建议设置。
 * @param {boolean} [options.repeat=true] - 是否重复循环。
 * @param {boolean} [options.reverse=false] - 是否反向。
 * @usage
 */
class TimeFlowControl extends TimeControlBase {


    constructor(callback, options) {
        super(options);
        var me = this;
        /**
         * @member TimeFlowControl.prototype.callback -{function}
         * @description 每次刷新执行的回调函数。
         */
        me.callback = callback;

        //先让IE下支持bind方法
        if (!Function.prototype.bind) {
            Function.prototype.bind = function (oThis) {
                if (typeof this !== "function") {
                    throw new TypeError("Function.prototype.bind - what is trying to be bound is not callable");
                }
                var aArgs = Array.prototype.slice.call(arguments, 1),
                    fToBind = this,
                    fNOP = function () {
                        //empty Function
                    },
                    fBound = function () {
                        return fToBind.apply(this instanceof fNOP && oThis
                            ? this
                            : oThis,
                            aArgs.concat(Array.prototype.slice.call(arguments)));
                    };
                fNOP.prototype = this.prototype;
                fBound.prototype = new fNOP();
                return fBound;
            };
        }
        //保证 this.tick 的上下文还是 TimeControl 这个对象
        me.update = me.update.bind(me);

        me.oldTime = me.currentTime;

        me.CLASS_NAME = "SuperMap.TimeFlowControl";
    }


    /**
     * @function TimeFlowControl.prototype.updateOptions
     * @override
     */
    updateOptions(options) {
        options = options || {};
        super.updateOptions(options);
    }


    /**
     * @function TimeFlowControl.prototype.start
     * @override
     */
    start() {
        var me = this;
        if (me.running) {
            return;
        }
        me.running = true;
        if (me.reverse) {
            if (me.currentTime === me.startTime) {
                me.oldTime = me.endTime;
                me.currentTime = me.oldTime;
            }
        } else {
            if (me.oldTime === me.endTime) {
                me.currentTime = me.startTime;
                me.oldTime = me.currentTime;
            }
        }
        me.tick();
    }


    /**
     * @function TimeFlowControl.prototype.stop
     * @override
     */
    stop() {
        super.stop();
        var me = this;
        me.oldTime = me.currentTime;

        if (me.running) {
            me.running = false;
        }
        //清除定时tick
        me.intervalId && window.clearTimeout(me.intervalId);
    }


    /**
     * @function TimeFlowControl.prototype.destroy
     * @override
     */
    destroy() {
        super.destroy();
        var me = this;
        me.oldTime = null;
        me.callback = null;
    }


    /**
     * @function TimeFlowControl.prototype.tick
     * @description 定时刷新。
     */
    tick() {
        var me = this;
        me.intervalId && window.clearInterval(me.intervalId);
        me.intervalId = null;
        me.update();
        me.intervalId = window.setInterval(me.update, me.frequency);
    }

    /**
     * @function TimeFlowControl.prototype.update
     * @description 更新控件。
     */
    update() {
        var me = this;

        //判定是否还需要继续
        if (!me.running) {
            return;
        }
        //调用回调函数
        me.callback && me.callback(me.currentTime);    //destroy之后callback就为空，所以需要判定一下

        if (!me.reverse) {
            //如果相等，则代表上一帧已经运行到了最后，下一帧运行初始化的状态
            if (me.currentTime === me.endTime) {
                //不循环时
                if (!me.repeat) {
                    me.running = false;
                    me.stop();
                    return null;
                }
                me.stop();
                me.currentTime = me.startTime;
                me.oldTime = me.currentTime;
                me.start();
            } else {//否则时间递增
                me.oldTime = me.currentTime;
                me.currentTime += me.speed;
            }

            if (me.currentTime >= me.endTime) {
                me.currentTime = me.endTime;
            }

        } else {
            //如果相等，则代表上一帧已经运行到了最前，下一帧运行结束的状态
            if (me.currentTime === me.startTime) {
                //不循环时
                if (!me.repeat) {
                    me.running = false;
                    return null;
                }

                me.oldTime = me.endTime;
                me.currentTime = me.oldTime;
            } else {//否则时间递减
                me.currentTime = me.oldTime;
                me.oldTime -= me.speed;
            }

            if (me.oldTime <= me.startTime) {
                me.oldTime = me.startTime;
            }
        }

    }


}


;// CONCATENATED MODULE: ./src/common/control/index.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/








;// CONCATENATED MODULE: ./src/common/iManager/iManagerServiceBase.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/



/**
 * @class IManagerServiceBase
 * @aliasclass iManagerServiceBase
 * @deprecatedclass SuperMap.iManagerServiceBase
 * @classdesc iManager 服务基类（有权限限制的类需要实现此类）。
 * @category iManager
 * @param {string} url - iManager 首页地址，如：http://localhost:8390/imanager。
 * @param {Object} options - 可选参数。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @usage
 */
class IManagerServiceBase {

    constructor(url,options) {
        if (url) {
            var end = url.substr(url.length - 1, 1);
            this.serviceUrl = end === "/" ? url.substr(0, url.length - 2) : url;
        }
        this.options = options || {};
        this.CLASS_NAME = "SuperMap.iManagerServiceBase";
    }

    /**
     * @function IManagerServiceBase.prototype.request
     * @description 子类统一通过该方法发送请求。
     * @param {string} url - 请求 URL。
     * @param {string} [method='GET'] - 请求类型。
     * @param {Object} [requestOptions] - 请求选项。
     * @param {Object} param - 请求参数。
     * @description 发送请求。
     * @returns {Promise} Promise 对象。
     */
    request(method, url, param, requestOptions) {
        requestOptions = requestOptions || {
            headers: {
                'Accept': '*/*',
                'Content-Type': 'application/json'
            }
        };
        requestOptions['crossOrigin'] = this.options.crossOrigin;
        requestOptions['headers'] = this.options.headers;
        var token = SecurityManager.imanagerToken;
        if (token) {
            if (!requestOptions.headers) {
                requestOptions.headers = {};
            }
            requestOptions.headers['X-Auth-Token'] = token;
        }
        if (param) {
            param = JSON.stringify(param);
        }
        return FetchRequest.commit(method, url, param, requestOptions).then(function (response) {
            return response.json();
        });
    }

}


;// CONCATENATED MODULE: ./src/common/iManager/iManagerCreateNodeParam.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


/**
 * @class IManagerCreateNodeParam
 * @aliasclass iManagerCreateNodeParam
 * @deprecatedclass SuperMap.iManagerCreateNodeParam
 * @classdesc iManager 创建节点参数。
 * @category iManager
 * @param {Object} [params] - 节点参数。
 * @usage
 */
class IManagerCreateNodeParam {

    constructor(params) {
        params = params || {};
        this.nodeSpec = 'SMALL';              //取值范围: ['SMALL','MEDIUM','LARGE'] 以及自定义的环境规格名称
        this.nodeCount = 1;                   //要创建vm的个数
        this.nodeName = '';                   //vm名称
        this.password = '';                   //vm的密码,空表示随机分配
        this.description = '';                //描述信息
        this.physicalMachineName = '';        //vm所属的物理机名称.
        this.ips = [];                        //vm的ip,空数组表示随机分配
        this.userName = '';                   //vm所属用户
        Util_Util.extend(this, params);
    }

}

;// CONCATENATED MODULE: ./src/common/iManager/iManager.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/



/**
 * @class IManager
 * @aliasclass iManager
 * @deprecatedclass SuperMap.iManager
 * @classdesc iManager 服务类。
 * @category iManager
 * @modulecategory Services
 * @param {string} serviceUrl - iManager 首页地址。
 * @usage
 */
class IManager extends IManagerServiceBase {

    constructor(iManagerUrl) {
        super(iManagerUrl);
    }

    /**
     * @function IManager.prototype.load
     * @description 获取所有服务接口，验证是否已登录授权。
     * @returns {Promise} Promise 对象。
     */
    load() {
        return this.request("GET", this.serviceUrl + '/web/api/service.json');
    }

    /**
     * @function IManager.prototype.createIServer
     * @param {IManagerCreateNodeParam} createParam - 创建参数。
     * @description 创建 iServer。
     * @returns {Promise} Promise 对象。
     */
    createIServer(createParam) {
        return this.request("POST", this.serviceUrl + '/cloud/web/nodes/server.json', new IManagerCreateNodeParam(createParam));
    }

    /**
     * @function IManager.prototype.createIPortal
     * @param {IManagerCreateNodeParam} createParam - 创建参数。
     * @description 创建 iPortal。
     * @returns {Promise} Promise 对象。
     */
    createIPortal(createParam) {
        return this.request("POST", this.serviceUrl + '/icloud/web/nodes/portal.json', new IManagerCreateNodeParam(createParam));
    }

    /**
     * @function IManager.prototype.iServerList
     * @description 获取所有创建的 iServer。
     * @returns {Promise} Promise 对象。
     */
    iServerList() {
        return this.request("GET", this.serviceUrl + '/cloud/web/nodes/server.json');
    }

    /**
     * @function IManager.prototype.iPortalList
     * @description 获取所有创建的 iPortal。
     * @returns {Promise} Promise 对象。
     */
    iPortalList() {
        return this.request("GET", this.serviceUrl + '/icloud/web/nodes/portal.json');
    }

    /**
     * @function IManager.prototype.startNodes
     * @param {Array.<string>} ids - 需要启动节点的 ID 数组。e.g:['1']。
     * @description 启动节点。
     * @returns {Promise} Promise 对象。
     */
    startNodes(ids) {
        return this.request("POST", this.serviceUrl + '/cloud/web/nodes/started.json', ids);
    }

    /**
     * @function IManager.prototype.stopNodes
     * @param {Array.<string>} ids - 需要停止节点的 ID 数组。e.g:['1']。
     * @description 停止节点。
     * @returns {Promise} Promise 对象。
     */
    stopNodes(ids) {
        return this.request("POST", this.serviceUrl + '/cloud/web/nodes/stopped.json', ids);
    }
}


;// CONCATENATED MODULE: ./src/common/iManager/index.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/








;// CONCATENATED MODULE: ./src/common/iPortal/iPortalServiceBase.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/



/**
 * @class IPortalServiceBase
 * @aliasclass iPortalServiceBase
 * @deprecatedclass SuperMap.iPortalServiceBase
 * @classdesc iPortal 服务基类（有权限限制的类需要实现此类）。
 * @category iPortal/Online Core
 * @param {string} url - 服务地址。
 * @param {Object} options - 可选参数。
 * @param {boolean} [options.withCredentials=false] - 请求是否携带 cookie。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @usage
 */
class IPortalServiceBase {

    constructor(url, options) {
        options = options || {};
        this.serviceUrl = url;
        this.CLASS_NAME = "SuperMap.iPortalServiceBase";
        this.withCredentials = options.withCredentials || false;
        this.crossOrigin = options.crossOrigin
        this.headers = options.headers
    }

    /**
     * @function IPortalServiceBase.prototype.request
     * @description 子类统一通过该方法发送请求。
     * @param {string} [method='GET'] - 请求类型。
     * @param {string} url - 服务地址。
     * @param {Object} param - 请求参数。
     * @param {Object} [requestOptions] - fetch 请求配置项。
     * @returns {Promise} 返回包含请求结果的 Promise 对象。
     */

    request(method, url, param, requestOptions = {headers: this.headers, crossOrigin: this.crossOrigin, withCredentials: this.withCredentials }) {
        url = SecurityManager.appendCredential(url);
        return FetchRequest.commit(method, url, param, requestOptions).then(function (response) {
            return response.json();
        });
    }


}


;// CONCATENATED MODULE: ./src/common/iPortal/iPortalQueryParam.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


/**
 * @class IPortalQueryParam
 * @aliasclass iPortalQueryParam
 * @deprecatedclass SuperMap.iPortalQueryParam
 * @classdesc iPortal 资源查询参数。
 * @version 10.0.1
 * @category iPortal/Online Resources ResourcesQuery
 * @param {Object} params - 可选参数。
 * @param {ResourceType} [params.resourceType] - 资源类型。
 * @param {number} [params.pageSize] - 分页中每页大小。
 * @param {number} [params.currentPage] - 分页页码。
 * @param {OrderBy} [params.orderBy] - 排序字段。
 * @param {OrderType} [params.orderType] - 根据升序还是降序过滤。
 * @param {SearchType} [params.searchType] - 根据查询的范围进行过滤。
 * @param {Array} [params.tags] - 标签。
 * @param {Array} [params.dirIds] - 目录 ID。
 * @param {Array} [params.resourceSubTypes] - 根据资源的子类型进行过滤。
 * @param {AggregationTypes} [params.aggregationTypes] - 聚合查询的类型。
 * @param {string} [params.text] - 	搜索的关键词。
 * @param {Array} [params.groupIds] - 	根据群组进行过滤。
 * @param {Array} [params.departmentIds] - 根据部门进行过滤。
 * @usage
 */
class IPortalQueryParam {

    constructor(params) {
        params = params || {};
        this.resourceType = ""; // 空为全部 MAP SERVICE SCENE DATA INSIGHTS_WORKSPACE MAP_DASHBOARD
        this.pageSize = 12; // 每页多少条
        this.currentPage = 1; // 第几页
        this.orderBy = "UPDATETIME"; // UPDATETIME HEATLEVEL
        this.orderType = "DESC"; // DESC ASC
        this.searchType = "PUBLIC"; // PUBLIC SHARETOME_RES MYDEPARTMENT_RES MYGROUP_RES MY_RES
        this.tags = [];  // 标签
        this.dirIds = []; // 类别
        this.resourceSubTypes = []; // 类型
        this.aggregationTypes = []; // TAG TYPE SUBTYPE
        this.text = ""; // 搜索字段
        this.groupIds = []; // 群组Id过滤
        this.departmentIds = []; // 部门Id过滤
        Util_Util.extend(this, params);
    }
}


;// CONCATENATED MODULE: ./src/common/iPortal/iPortalQueryResult.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


/**
 * @class IPortalQueryResult
 * @aliasclass iPortalQueryResult
 * @deprecatedclass SuperMap.iPortalQueryResult
 * @classdesc iPortal 资源结果集封装类。
 * @version 10.0.1
 * @category iPortal/Online Resources ResourcesQuery
 * @param {Object} queryResult - 可选参数。
 * @param {Array} [queryResult.content] - 页面内容。
 * @param {number} [queryResult.total] - 总记录数。
 * @param {number} [queryResult.currentPage] - 当前第几页。
 * @param {number} [queryResult.pageSize] - 每页大小。
 * @param {Object} [queryResult.aggregations] - 聚合查询的结果。
 * @usage
 */
class IPortalQueryResult {
    constructor(queryResult) {
        queryResult = queryResult || {};
        this.content = [];
        this.total = 0;
        this.currentPage = 1;
        this.pageSize = 12;
        this.aggregations = null;
        Util_Util.extend(this, queryResult);
    }

}



;// CONCATENATED MODULE: ./src/common/iPortal/iPortalResource.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


/**
 * @class IPortalResource
 * @aliasclass iPortalResource
 * @deprecatedclass SuperMap.iPortalResource
 * @classdesc iPortal 资源详情类。
 * @version 10.0.1
 * @category iPortal/Online Resources
 * @param {string} portalUrl - 服务地址。
 * @param {Object} resourceInfo - 可选参数。
 * @param {Array} [resourceInfo.authorizeSetting] - 资源的授权信息。
 * @param {string} [resourceInfo.bounds] - 资源的坐标范围。
 * @param {string} [resourceInfo.bounds4326] - 资源的坐标范围，转换为EPSG 4326坐标系统后的地理范围。
 * @param {string} [resourceInfo.checkStatus] - 资源的审核状态，可以是：空,SUCCESSFUL,UNCHECKED,FAILED。
 * @param {Date} [resourceInfo.createTime] - 资源的创建时间。
 * @param {string} [resourceInfo.description] - 资源描述。
 * @param {number} [resourceInfo.dirId] - 资源所在的门户目录的ID。
 * @param {number} [resourceInfo.epsgCode] - 门户资源基于的坐标系的EPSG值。
 * @param {number} [resourceInfo.heatLevel] - 记录资源的访问量或下载量。
 * @param {string} [resourceInfo.id] - 资源存储到ElasticSearch中的文档ID。
 * @param {string} [resourceInfo.name] - 资源名称。
 * @param {number} [resourceInfo.personalDirId] - 资源所在的个人目录的ID。
 * @param {number} [resourceInfo.resourceId] - 资源表(maps,services等)里的ID。
 * @param {string} [resourceInfo.resourceSubType] - 某类资源的具体子类型。
 * @param {ResourceType} [resourceInfo.resourceType] - 资源类型。
 * @param {number} [resourceInfo.serviceRootUrlId] - 批量注册服务时，服务根地址的ID。
 * @param {Array} [resourceInfo.tags] - 资源的标签。
 * @param {string} [resourceInfo.thumbnail] - 资源的缩略图。
 * @param {Date} [resourceInfo.updateTime] - 资源的更新时间。
 * @param {string} [resourceInfo.userName] - 搜索的关键词。
 * @param {Object} [resourceInfo.sourceJSON] - 提供了门户项目返回的所有信息。
 * @extends {IPortalServiceBase}
 * @usage
 */
class IPortalResource extends IPortalServiceBase {
    constructor(portalUrl, resourceInfo) {
        super(portalUrl);
        resourceInfo = resourceInfo || {};
        this.authorizeSetting = [];
        this.bounds = "";
        this.bounds4326 = "";
        this.checkStatus = "";
        this.createTime = 0;
        this.description = null;
        this.dirId = null;
        this.epsgCode = 0;
        this.heatLevel = 0;
        this.id = 0;
        this.name = "";
        this.personalDirId = null;
        this.resourceId = 0;
        this.resourceSubType = null;
        this.resourceType = null;
        this.serviceRootUrlId = null;
        this.tags = null;
        this.thumbnail = null;
        this.updateTime = 0;
        this.userName = "";
        this.sourceJSON = {};//返回门户资源详细信息
        Util_Util.extend(this, resourceInfo); // INSIGHTS_WORKSPACE MAP_DASHBOARD
        this.resourceUrl = portalUrl + "/web/"+this.resourceType.replace("_","").toLowerCase()+"s/" + this.resourceId;
        if (this.withCredentials) {
            this.resourceUrl = portalUrl + "/web/mycontent/"+this.resourceType.replace("_","").toLowerCase()+"s/" + this.resourceId;
        }
        // if (this.id) {
        //     this.mapUrl = mapUrl + "/" + this.id;
        // }
    }

    /**
     * @function IPortalResource.prototype.load
     * @description 加载资源信息。
     * @returns {Promise} 返回 Promise 对象。如果成功，Promise 没有返回值，请求返回结果自动填充到该类的属性中；如果失败，Promise 返回值包含错误信息。
     */
    load() {
        var me = this;
        return me.request("GET", me.resourceUrl + ".json")
            .then(function (resourceInfo) {
                if (resourceInfo.error) {
                    return resourceInfo;
                }
                me.sourceJSON = resourceInfo;
            });
    }

    /**
     * @function IPortalResource.prototype.update
     * @description 更新资源属性信息。
     * @returns {Promise} 返回包含更新操作状态的 Promise 对象。
     */
    update() {
        var resourceName = this.resourceType.replace("_","").toLowerCase();
        var options = {
            headers: {'Content-Type': 'application/x-www-form-urlencoded'}
        };
        if( resourceName === 'data') {
            this.resourceUrl = this.resourceUrl + "/attributes.json";
        }
        var entity = JSON.stringify(this.sourceJSON);
        //对服务资源进行编辑时，请求体内容只留关键字字段（目前如果是全部字段 更新返回成功 但其实没有真正的更新）
        if( resourceName === 'service') {
            var serviceInfo = {
                authorizeSetting:this.sourceJSON.authorizeSetting,
                metadata:this.sourceJSON.metadata,
                tags:this.sourceJSON.tags,
                thumbnail:this.sourceJSON.thumbnail,
                tokenRefreshUrl:this.sourceJSON.tokenRefreshUrl
            };
            entity = JSON.stringify(serviceInfo);
        }
        return this.request("PUT", this.resourceUrl, entity, options);
    }

}



;// CONCATENATED MODULE: ./src/common/iPortal/iPortalShareParam.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


/**
 * @class IPortalShareParam
 * @aliasclass iPortalShareParam
 * @deprecatedclass SuperMap.iPortalShareParam
 * @classdesc iPortal 资源共享参数。
 * @version 10.0.1
 * @category iPortal/Online Resources ResourcesShare
 * @param {Object} params - 可选参数。
 * @param {ResourceType} [params.resourceType] - 资源类型。
 * @param {Array} [params.ids] - 资源的ID数组。
 * @param {IPortalShareEntity} [params.entities] - 资源的实体共享参数。
 * @usage
 */
class IPortalShareParam {

    constructor(params) {
        params = params || {};
        this.ids = [];
        this.entities = [];
        this.resourceType = ""; // MAP SERVICE SCENE DATA INSIGHTS_WORKSPACE MAP_DASHBOARD
        Util_Util.extend(this, params);
    }
}


;// CONCATENATED MODULE: ./src/common/iPortal/iPortal.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/







/**
 * @class IPortal
 * @aliasclass iPortal
 * @deprecatedclass SuperMap.iPortal
 * @classdesc 对接 SuperMap iPortal 基础服务。
 * @category iPortal/Online Resources
 * @modulecategory Services
 * @extends {IPortalServiceBase}
 * @param {string} iportalUrl - 服务地址。
 * @param {Object} options - 可选参数。
 * @param {boolean} [options.withCredentials] - 请求是否携带 cookie。
 * @usage
 */
class IPortal extends IPortalServiceBase {
    constructor(iportalUrl, options) {
        super(iportalUrl, options);
        this.iportalUrl = iportalUrl;
        options = options || {};
        this.withCredentials = options.withCredentials || false;
    }

    /**
     * @function IPortal.prototype.load
     * @description 加载页面。
     * @returns {Promise} 包含 iportal web 资源信息的 Promise 对象。
     */
    load() {
        return FetchRequest.get(this.iportalUrl + "/web");
    }

    /**
     * @function IPortal.prototype.queryResources
     * @description 查询资源。
     * @version 10.0.1
     * @param {IPortalQueryParam} queryParams - 查询参数。
     * @returns {Promise} 包含所有资源结果的 Promise 对象。
     */
    queryResources(queryParams) {
        if (!(queryParams instanceof IPortalQueryParam)) {
            return new Promise( function(resolve){
                resolve(
                    "queryParams is not instanceof iPortalQueryParam !"
                );
            });
        }
        var me = this;
        var resourceUrl = this.iportalUrl + "/gateway/catalog/resource/search.json";
        queryParams.t = new Date().getTime();
        return this.request("GET", resourceUrl, queryParams).then(function(result) {
            var content = [];
            (result.content || []).forEach(function(item) {
                content.push(new IPortalResource(me.iportalUrl, item));
            });
            let queryResult = new IPortalQueryResult();
            queryResult.content = content;
            queryResult.total = result.total;
            queryResult.currentPage = result.currentPage;
            queryResult.pageSize = result.pageSize;
            queryResult.aggregations = result.aggregations;
            return queryResult;
        });
    }


    /**
     * @function IPortal.prototype.updateResourcesShareSetting
     * @description 更新共享设置。
     * @version 10.0.1
     * @param {IPortalShareParam} shareParams - 共享的参数。
     * @returns {Promise} 包含共享资源结果的 Promise 对象。
     */
    updateResourcesShareSetting(shareParams) {
        if (!(shareParams instanceof IPortalShareParam)) {
            return new Promise( function(resolve){
                resolve(
                    "shareParams is not instanceof iPortalShareParam !"
                );
            });
        }
        var resourceUrlName = shareParams.resourceType.replace("_","").toLowerCase()+"s";
        if(resourceUrlName === "datas"){
            resourceUrlName = "mycontent/"+resourceUrlName;
        }
        var cloneShareParams = {
            ids: shareParams.ids,
            entities: shareParams.entities
        }
        var shareUrl = this.iportalUrl + "/web/"+resourceUrlName+"/sharesetting.json";
        return this.request("PUT", shareUrl, JSON.stringify(cloneShareParams)).then(function(result) {
            return result;
        });
    }
}

;// CONCATENATED MODULE: ./src/common/iPortal/iPortalShareEntity.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


/**
 * @class IPortalShareEntity
 * @aliasclass iPortalShareEntity
 * @deprecatedclass SuperMap.iPortalShareEntity
 * @classdesc iPortal 资源共享实体参数。
 * @version 10.0.1
 * @category iPortal/Online Resources ResourcesShare
 * @param {Object} shareEntity - 可选参数。
 * @param {PermissionType} [shareEntity.permissionType] - 权限类型。
 * @param {EntityType} [shareEntity.entityType] - 实体类型。
 * @param {string} [shareEntity.entityName] - 实体 Name。对应的 USER（用户）、ROLE（角色）、GROUP（用户组）、IPORTALGROUP（群组）的名称。
 * @param {number} [shareEntity.entityId] - 实体的 ID。用于群组的授权。
 * @usage
 */
class IPortalShareEntity {

    constructor(shareEntity) {
        shareEntity = shareEntity || {};
        this.permissionType = ""; // SEARCH READ READWRITE DOWNLOAD
        this.entityType = ""; // USER DEPARTMENT IPORTALGROUP
        this.entityName = "GUEST"; // GUEST or 具体用户 name
        this.entityId = null;
        Util_Util.extend(this, shareEntity);
    }
}


;// CONCATENATED MODULE: ./src/common/iPortal/iPortalAddResourceParam.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/
 

 /**
  * @class IPortalAddResourceParam
  * @aliasclass iPortalAddResourceParam
  * @deprecatedclass SuperMap.iPortalAddResourceParam
  * @classdesc iPortal 添加资源参数。
  * @version 10.0.1
  * @category iPortal/Online Resources ResourcesShare
  * @param {Object} params - 可选参数。
  * @param {string} [params.rootUrl] - 服务地址。
  * @param {Array} [params.tags] - 标签。
  * @param {IPortalShareEntity} [params.entities] - 资源的实体共享参数。
  * @usage
  */
 class IPortalAddResourceParam {

     constructor(params) {
         params = params || {};
         this.rootUrl = "";
         this.tags = [];
         this.entities = [];
         Util_Util.extend(this, params);
     }
 }


;// CONCATENATED MODULE: ./src/common/iPortal/iPortalRegisterServiceParam.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


/**
 * @class IPortalRegisterServiceParam
 * @aliasclass iPortalRegisterServiceParam
 * @deprecatedclass SuperMap.iPortalRegisterServiceParam
 * @classdesc iPortal 注册服务参数。
 * @version 10.0.1
 * @category iPortal/Online Resources Data
 * @param {Object} params - 可选参数。
 * @param {string} [params.type] - 服务类型。
 * @param {Array} [params.tags] - 服务标签。
 * @param {IPortalShareEntity} [params.entities] - 资源的实体共享参数。
 * @param {Object} [params.metadata] - 服务元信息。
 * @param {Array} [params.addedMapNames] - 地图服务列表。
 * @param {Array} [params.addedSceneNames] - 场景服务列表。
 * @usage
 */
class IPortalRegisterServiceParam {

    constructor(params) {
        params = params || {};
        this.type = ""; // SUPERMAP_REST ARCGIS_REST WMS WFS WCS WPS WMTS OTHERS
        this.tags = [];
        this.entities = [];
        this.metadata = {};
        this.addedMapNames = [];
        this.addedSceneNames = [];
        Util_Util.extend(this, params);
    }
}


;// CONCATENATED MODULE: ./src/common/iPortal/iPortalAddDataParam.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/
 

 /**
  * @class IPortalAddDataParam
  * @aliasclass iPortalAddDataParam
  * @deprecatedclass SuperMap.iPortalAddDataParam
  * @classdesc iPortal 上传/注册数据所需的参数。
  * @version 10.0.1
  * @category iPortal/Online Resources Data
  * @param {Object} params - 参数。
  * @param {string} params.fileName - 文件名称。
  * @param {DataItemType} params.type - 数据类型。
  * @param {Array} [params.tags] - 数据的标签。
  * @param {IPortalDataMetaInfoParam} [params.dataMetaInfo] - 数据元信息。
  * @usage
  */
 class IPortalAddDataParam {

     constructor(params) {
        params = params || {};
        this.fileName = "";
        this.type = "";
        this.tags = [];
        this.dataMetaInfo = {};
        Util_Util.extend(this, params);
     }
 }


;// CONCATENATED MODULE: ./src/common/iPortal/iPortalDataMetaInfoParam.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/
 

 /**
  * @class IPortalDataMetaInfoParam
  * @aliasclass iPortalDataMetaInfoParam
  * @deprecatedclass SuperMap.iPortalDataMetaInfoParam
  * @classdesc iPortal 上传数据/注册数据元信息所需的参数。
  * @version 10.0.1
  * @category iPortal/Online Resources Data
  * @param {Object} params - 参数。
  * @param {string} params.xField - X 坐标字段。
  * @param {string} params.yField - Y 坐标字段。
  * @param {number} params.xIndex - x所在列（关系型存储下CSV或EXCEL数据时必填）。
  * @param {number} params.yIndex - y所在列（关系型存储下CSV或EXCEL数据时必填）。
  * @param {Array.<string>} [params.fieldTypes] - 设置字段类型（关系型存储下CSV或EXCEL数据时可选填）。默认类型为：WTEXT。该参数按照CSV文件字段顺序从左到右依次设置，其中默认字段类型可省略不设置。例如，CSV文件中有10个字段，如果只需设定第1，2，4个字段，可设置为['a','b',,'c']。
  * @param {string} params.separator - 分隔符（关系型存储下CSV数据时必填）。
  * @param {boolean} params.firstRowIsHead - 是否带表头（关系型存储下CSV数据时必填）。
  * @param {boolean} params.url - HDFS注册目录地址。
  * @param {IPortalDataStoreInfoParam} params.dataStoreInfo - 注册数据时的数据存储信息。
  * @usage
  */
 class IPortalDataMetaInfoParam {

     constructor(params) {
        params = params || {};
        this.xField = "";
        this.yField = "";
        this.fileEncoding = "UTF-8";

        this.xIndex = 1;
        this.yIndex = 1;
        this.fieldTypes = [];
        this.separator = "";
        this.firstRowIsHead = true;

        this.url = "";
        this.dataStoreInfo = {};
        Util_Util.extend(this, params);
     }
 }


;// CONCATENATED MODULE: ./src/common/iPortal/iPortalDataStoreInfoParam.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/
 

 /**
  * @class IPortalDataStoreInfoParam
  * @aliasclass iPortalDataStoreInfoParam
  * @deprecatedclass SuperMap.iPortalDataStoreInfoParam
  * @classdesc iPortal 注册一个HBASE HDFS数据存储类。
  * @version 10.0.1
  * @category iPortal/Online Resources Data
  * @param {Object} params - 参数。
  * @param {string} params.type - 大数据文件共享类型和空间数据库类型，包括大数据文件共享HDFS 目录(HDFS)和空间数据库HBASE。
  * @param {string} params.url - HDFS数据存储目录地址。
  * @param {IPortalDataConnectionInfoParam} [params.connectionInfo] - HBASE空间数据库服务的连接信息。
  * @usage
  */
 class IPortalDataStoreInfoParam {

     constructor(params) {
        params = params || {};
        this.type = "";
        this.url = "";
        this.connectionInfo = {};
        Util_Util.extend(this, params);
     }
 }


;// CONCATENATED MODULE: ./src/common/iPortal/iPortalDataConnectionInfoParam.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/
 

 /**
  * @class IPortalDataConnectionInfoParam
  * @aliasclass iPortalDataConnectionInfoParam
  * @deprecatedclass SuperMap.iPortalDataConnectionInfoParam
  * @classdesc iPortal HBASE数据源连接信息类。
  * @version 10.0.1
  * @category iPortal/Online Resources Data
  * @param {Object} params - 参数。
  * @param {string} params.dataBase - 数据源连接的数据库名。
  * @param {string} params.server - 服务地址。
  * @usage
  */
 class IPortalDataConnectionInfoParam {

     constructor(params) {
        params = params || {};
        this.dataBase = "";
        this.server = "";
        Util_Util.extend(this, params);
     }
 }


;// CONCATENATED MODULE: ./src/common/iPortal/iPortalUser.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/







/**
 * @class IPortalUser
 * @aliasclass iPortalUser
 * @deprecatedclass SuperMap.iPortalUser
 * @classdesc iPortal 门户中用户信息的封装类。用于管理用户资源，包括可删除，添加资源。
 * @version 10.0.1
 * @category iPortal/Online Resources
 * @param {string} iportalUrl - 服务地址。
 * @extends {IPortalServiceBase}
 * @usage
 */
class IPortalUser extends IPortalServiceBase {
    constructor(iportalUrl) {
        super(iportalUrl);
        this.iportalUrl = iportalUrl;
    }

    /**
     * @function IPortalUser.prototype.deleteResources
     * @description 删除资源。
     * @param {Object} params - 删除资源所需的参数对象：{ids,resourceType}。
     * @returns {Promise} 返回包含删除操作状态的 Promise 对象。
     */
    deleteResources(params) {
        var resourceName = params.resourceType.replace("_","").toLowerCase();
        var deleteResourceUrl = this.iportalUrl+"/web/" + resourceName +"s.json?ids=" + encodeURI(JSON.stringify(params.ids));
        if( resourceName === 'data') {
            deleteResourceUrl = this.iportalUrl + "/web/mycontent/datas/delete.json";
            return this.request("POST", deleteResourceUrl, JSON.stringify(params.ids));
        }
        return this.request("DELETE", deleteResourceUrl);
    }

    /**
     * @function IPortalUser.prototype.addMap
     * @description 添加地图。
     * @version 10.1.0
     * @param {IPortalAddResourceParam} addMapParams - 添加地图的参数。
     * @returns {Promise} 返回包含添加地图结果的 Promise 对象。
     */
    addMap(addMapParams) {
        if (!(addMapParams instanceof IPortalAddResourceParam)) {
            return this.getErrMsgPromise("addMapParams is not instanceof IPortalAddResourceParam !");
        }
        let cloneAddMapParams = {
            rootUrl: addMapParams.rootUrl,
            tags: addMapParams.tags,
            authorizeSetting: addMapParams.entities
        }
        let addMapUrl = this.iportalUrl + "/web/maps/batchaddmaps.json";
        return this.request("POST", addMapUrl, JSON.stringify(cloneAddMapParams)).then(function(result) {
            return result;
        });
    }

    /**
     * @function IPortalUser.prototype.addScene
     * @description 添加场景。
     * @version 10.1.0
     * @param {IPortalAddResourceParam} addSceneParams - 添加场景的参数。
     * @returns {Promise} 返回包含添加场景结果的 Promise 对象。
     */
    addScene(addSceneParams) {
        if (!(addSceneParams instanceof IPortalAddResourceParam)) {
            return this.getErrMsgPromise("addSceneParams is not instanceof IPortalAddResourceParam !");
        }
        let cloneAddSceneParams = {
            rootUrl: addSceneParams.rootUrl,
            tags: addSceneParams.tags,
            authorizeSetting: addSceneParams.entities
        }
        let addSceneUrl = this.iportalUrl + "/web/scenes/batchaddscenes.json";
        return this.request("POST", addSceneUrl, JSON.stringify(cloneAddSceneParams)).then(function(result) {
            return result;
        });
    }

    /**
     * @function IPortalUser.prototype.registerService
     * @description 注册服务。
     * @version 10.1.0
     * @param {IPortalRegisterServiceParam} registerParams - 注册服务的参数。
     * @returns {Promise} 返回包含注册服务结果的 Promise 对象。
     */
    registerService(registerParams) {
        if(!(registerParams instanceof IPortalRegisterServiceParam)) {
            return this.getErrMsgPromise("registerParams is not instanceof IPortalRegisterServiceParam !");
        }
        let cloneRegisterParams = {
            type: registerParams.type,
            tags: registerParams.tags,
            authorizeSetting: registerParams.entities,
            metadata: registerParams.metadata,
            addedMapNames: registerParams.addedMapNames,
            addedSceneNames: registerParams.addedSceneNames
        }
        let registerUrl = this.iportalUrl + "/web/services.json";
        return this.request("POST", registerUrl, JSON.stringify(cloneRegisterParams)).then(result => {
            return result;
        });
    }

    /**
     * @function IPortalUser.prototype.getErrMsgPromise
     * @description 获取包含错误信息的Promise对象。
     * @version 10.1.0
     * @param {string} errMsg - 传入的错误信息。
     * @returns {Promise} 返回包含错误信息的 Promise 对象。
     */
    getErrMsgPromise(errMsg) {
        return new Promise(resolve => {
            resolve(errMsg);
        })
    }

    /**
     * @function IPortalUser.prototype.uploadDataRequest
     * @description 上传数据。
     * @version 10.1.0
     * @param {number} id - 上传数据的资源ID。
     * @param {Object} formData - 请求体为文本数据流。
     * @returns {Promise} 返回包含上传数据操作的 Promise 对象。
     */
    uploadDataRequest(id,formData) {
        var uploadDataUrl = this.iportalUrl + "/web/mycontent/datas/"+id+"/upload.json";
        return this.request("POST",uploadDataUrl,formData);
    }

    /**
     * @function IPortalUser.prototype.addData
     * @description 上传/注册数据。
     * @version 10.1.0
     * @param {IPortalAddDataParam} params - 上传/注册数据所需的参数。
     * @param {Object} [formData] - 请求体为文本数据流(上传数据时传入)。
     * @returns {Promise} 返回上传/注册数据的 Promise 对象。
     */
    addData(params,formData) {
        if(!(params instanceof IPortalAddDataParam)){
            return this.getErrMsgPromise("params is not instanceof iPortalAddDataParam !");
        }
        var datasUrl = this.iportalUrl + "/web/mycontent/datas.json";
        var entity = {
            fileName:params.fileName,
            tags:params.tags,
            type:params.type
        };
        var type = params.type.toLowerCase();
        var dataMetaInfo;
        if(type === "excel" || type === "csv"){
            if(!(params.dataMetaInfo instanceof IPortalDataMetaInfoParam)){
                return  this.getErrMsgPromise("params.dataMetaInfo is not instanceof iPortalDataMetaInfoParam !");
            }
            dataMetaInfo = {
                xField:params.dataMetaInfo.xField,
                yField:params.dataMetaInfo.yField
            }
            if(type === 'csv') {
                dataMetaInfo.fileEncoding = params.dataMetaInfo.fileEncoding
            }
            entity.coordType = "WGS84";
            entity.dataMetaInfo = dataMetaInfo;
        }else if(type === "hdfs" || type === "hbase") {
            if(!(params.dataMetaInfo instanceof IPortalDataMetaInfoParam)){
                return this.getErrMsgPromise("params.dataMetaInfo is not instanceof iPortalDataMetaInfoParam !");
            }
            if(!(params.dataMetaInfo.dataStoreInfo instanceof IPortalDataStoreInfoParam)){
                return this.getErrMsgPromise("params.dataMetaInfo.dataStoreInfo is not instanceof iPortalDataStoreInfoParam !");
            }
            var dataStoreInfo = {
                type:params.dataMetaInfo.dataStoreInfo.type
            }
            switch (type) {
                case "hdfs":
                    dataStoreInfo.url = params.dataMetaInfo.dataStoreInfo.url;
                    dataMetaInfo = {
                        url: params.dataMetaInfo.url,
                        dataStoreInfo:dataStoreInfo
                    }
                    break;
                case "hbase":
                    if(!(params.dataMetaInfo.dataStoreInfo.connectionInfo instanceof IPortalDataConnectionInfoParam)){
                        return this.getErrMsgPromise("params.dataMetaInfo.dataStoreInfo.connectionInfo is not instanceof iPortalDataConnectionInfoParam !");
                    }
                    dataStoreInfo.connectionInfo = {
                        dataBase:params.dataMetaInfo.dataStoreInfo.connectionInfo.dataBase,
                        server:params.dataMetaInfo.dataStoreInfo.connectionInfo.server,
                        engineType:'HBASE'
                    }
                    dataStoreInfo.datastoreType = "SPATIAL";//该字段SPATIAL表示HBASE注册
                    dataMetaInfo = {
                        dataStoreInfo:dataStoreInfo
                    }
                    break;
            }
            entity.dataMetaInfo = dataMetaInfo;
        }
        return this.request("POST",datasUrl,JSON.stringify(entity)).then(res=>{
            if(type === "hdfs" || type === "hbase"){
                return res;
            }else {
                if(res.childID) {
                    return this.uploadDataRequest(res.childID,formData);
                }else {
                    return res.customResult;
                }
            }
        })
    }

    /**
     * @function IPortalUser.prototype.publishOrUnpublish
     * @description 发布/取消发布。
     * @version 10.1.0
     * @param {Object} options - 发布/取消发布数据服务所需的参数。
     * @param {Object} options.dataId - 数据项ID。
     * @param {Object} options.serviceType - 发布的服务类型，目前支持发布的服务类型包括：RESTDATA, RESTMAP, RESTREALSPACE, RESTSPATIALANALYST。
     * @param {Object} [options.dataServiceId] - 发布的服务 ID。
     * @param {boolean} forPublish - 是否取消发布。
     * @returns {Promise} 返回发布/取消发布数据服务的 Promise 对象。
     */
    publishOrUnpublish(option,forPublish){
        if(!option.dataId || !option.serviceType) {
            return this.getErrMsgPromise("option.dataID and option.serviceType are Required!");
        }
        var dataId = option.dataId;
        var dataServiceId = option.dataServiceId;
        var serviceType = option.serviceType;
        var publishUrl = this.iportalUrl + "/web/mycontent/datas/" + dataId + "/publishstatus.json?serviceType=" + serviceType;
        if (dataServiceId) {
            publishUrl += "&dataServiceId=" + dataServiceId;
        }
        return this.request("PUT",publishUrl,JSON.stringify(forPublish)).then(res=>{
            // 发起服务状态查询
            if(forPublish) {
                // 发布服务的结果异步处理
                //  var publishStateUrl = this.iportalUrl + "web/mycontent/datas/" + dataId + "/publishstatus.rjson";
                if (!dataServiceId) { // 发布服务时会回传serviceIDs，发布服务之前serviceIDs为空
                    dataServiceId = res.customResult;
                }
                return dataServiceId;
            }else {
                // 取消发布的结果同步处理
                return res;
            }
        });
    }

    /**
     * @function IPortalUser.prototype.getDataPublishedStatus
     * @description 查询服务状态，发起服务状态查询。
     * @version 10.1.0
     * @param {number} dataId - 查询服务状态的数据项ID。
     * @param {string} dataServiceId - 发布的服务ID。
     * @returns {Promise} 返回查询服务状态的 Promise 对象。
     */
    getDataPublishedStatus(dataId,dataServiceId){
        var publishStateUrl = this.iportalUrl + "/web/mycontent/datas/" + dataId + "/publishstatus.json?dataServiceId="+dataServiceId+"&forPublish=true";
        return this.request("GET",publishStateUrl);
    }

    /**
     * @function IPortalUser.prototype.unPublishedDataService
     * @description 取消发布。
     * @version 10.1.0
     * @param {Object} options - 取消发布服务具体参数。
     * @param {Object} options.dataId - 数据项ID。
     * @param {Object} options.serviceType - 发布的服务类型，目前支持发布的服务类型包括：RESTDATA, RESTMAP, RESTREALSPACE, RESTSPATIALANALYST。
     * @param {Object} [options.dataServiceId] - 发布的服务 ID。
     * @returns {Promise} 返回取消发布数据服务的 Promise 对象。
     */
    unPublishDataService(option){
        return this.publishOrUnpublish(option,false);
    }

    /**
     * @function IPortalUser.prototype.publishedDataService
     * @description 发布数据服务。
     * @version 10.1.0
     * @param {Object} options - 发布数据服务具体参数。
     * @param {Object} options.dataId - 数据项ID。
     * @param {Object} options.serviceType - 发布的服务类型，目前支持发布的服务类型包括：RESTDATA, RESTMAP, RESTREALSPACE, RESTSPATIALANALYST。
     * @param {Object} [options.dataServiceId] - 发布的服务 ID。
     * @returns {Promise} 返回发布数据服务的 Promise 对象。
     */
    publishDataService(option){
        return this.publishOrUnpublish(option,true);
    }
}

;// CONCATENATED MODULE: ./src/common/iPortal/index.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/





























;// CONCATENATED MODULE: ./src/common/iServer/AggregationParameter.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


/**
 * @class AggregationParameter
 * @deprecatedclass SuperMap.AggregationParameter
 * @classdesc 聚合查询参数设置，该参数仅支持数据来源 Elasticsearch 服务的数据服务。
 * @category iServer Data FeatureResults
 * @param {Object} options - 参数。
 * @param {string} options.aggName - 聚合名称。
 * @param {string} options.aggFieldName - 聚合字段。
 * @usage
 */
class AggregationParameter {
    constructor(options) {
        /**
         * @member {string} AggregationParameter.prototype.aggName
         * @description 聚合名称。
         */
        this.aggName = null;
        /**
         * @member {string} AggregationParameter.prototype.aggFieldName
         * @description 聚合字段。
         */
        this.aggFieldName = null;

        this.CLASS_NAME = 'SuperMap.AggregationParameter';
        Util_Util.extend(this, options);
    }

    destroy() {
        var me = this;
        me.aggName = null;
        me.aggFieldName = null;
        me.aggType = null;
    }
}


;// CONCATENATED MODULE: ./src/common/iServer/BucketAggParameter.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/



/**
 * @class BucketAggParameter
 * @deprecatedclass SuperMap.BucketAggParameter
 * @classdesc 子聚合类查询参数设置，该参数仅支持数据来源 Elasticsearch 服务的Supermap iServer的rest数据服务。
 * @category iServer Data FeatureResults
 * @param {Object} options - 参数。
 * @param {Array.<MetricsAggParameter>} options.subAggs - 子聚合类集合。
 * @extends {AggregationParameter}
 * @usage
 */
class BucketAggParameter extends AggregationParameter {
    constructor(options) {
        super();
        /**
         * @member {Array.<MetricsAggParameter>} BucketAggParameter.prototype.subAggs
         * @description 子聚合类集合。
         */
        this.subAggs = null;
        this.aggType = null;

        this.CLASS_NAME = 'SuperMap.BucketAggParameter';
        Util_Util.extend(this, options);
    }

    destroy() {
        var me = this;
        if (me.subAggs) {
            me.subAggs = null;
        }
    }
}


;// CONCATENATED MODULE: ./src/common/iServer/MetricsAggParameter.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/





/**
 * @class MetricsAggParameter
 * @deprecatedclass SuperMap.MetricsAggParameter
 * @classdesc 指标聚合查询参数类，该参数仅支持数据来源 Elasticsearch 服务的Supermap iServer的rest数据服务。
 * @category iServer Data FeatureResults
 * @param {Object} options - 可选参数。
 * @param {MetricsAggType} [options.aggType = 'avg'] - 聚合类型。
 * @extends {AggregationParameter}
 * @usage
 */
class MetricsAggParameter extends AggregationParameter {
    constructor(option) {
        super();
        /**
         * @member {MetricsAggType} [MetricsAggParameter.prototype.aggType=MetricsAggType.AVG]
         * @description 指标聚合类型。
         */
        this.aggType = MetricsAggType.AVG;

        Util_Util.extend(this, option);
        this.CLASS_NAME = 'SuperMap.MetricsAggParameter';
    }

    destroy() {
        super.destroy();
        var me = this;
        me.aggType = null;
    }
}


;// CONCATENATED MODULE: ./src/common/iServer/ClipParameter.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/



/**
 * @class ClipParameter
 * @deprecatedclass SuperMap.ClipParameter
 * @category iServer SpatialAnalyst InterpolationAnalyst
 * @classdesc 用于裁剪的参数。优先使用用户指定的裁剪区域多边形进行裁剪，也可以通过指定数据源和数据集名，从而使用指定数据集的边界多边形进行裁剪。
 * @param {Object} options - 可选参数。
 * @param {string} [options.clipDatasetName] - 裁剪的数据集名。
 * @param {string} [options.clipDatasourceName] - 裁剪的数据集所在数据源的名字。
 * @param {GeometryPolygon|L.Polygon|L.GeoJSON|ol.geom.Polygon|ol.format.GeoJSON|GeoJSONObject} [options.clipRegion] - 用户指定的裁剪区域。
 * @param {boolean} [options.isClipInRegion=true] - 是否对裁剪区内的数据集进行裁剪。
 * @param {boolean} [options.isExactClip=true] - 是否使用精确裁剪。
 * @usage
 */
class ClipParameter {


    constructor(options) {
        /**
         * @member {string} ClipParameter.prototype.clipDatasetName
         * @description 用于裁剪的数据集名，clipDatasetName 与 clipRegion 必须设置一个。
         */
        this.clipDatasetName = null;

        /**
         * @member {string} ClipParameter.prototype.clipDatasourceName
         * @description 用于裁剪的数据集所在数据源的名字。当 clipRegion 不设置时起作用。
         */
        this.clipDatasourceName = null;

        /**
         * @member {GeometryPolygon|L.Polygon|L.GeoJSON|ol.geom.Polygon|ol.format.GeoJSON|GeoJSONObject} ClipParameter.prototype.clipRegion
         * @description 用户指定的裁剪区域，优先使用，clipDatasetName 与 clipRegion 必须设置一个。
         */
        this.clipRegion = null;

        /**
         * @member {boolean} [ClipParameter.prototype.isClipInRegion=true]
         * @description 是否对裁剪区内的数据集进行裁剪。若为 true，则对裁剪区域内的结果进行裁剪，若为 false，则对裁剪区域外的结果进行裁剪。
         */
        this.isClipInRegion = true;

        /**
         * @member {boolean} [ClipParameter.prototype.isExactClip=true]
         * @description 是否使用精确裁剪。
         */
        this.isExactClip = null;

        if (options) {
            Util_Util.extend(this, options);
        }

        this.CLASS_NAME = "SuperMap.ClipParameter";
    }


    /**
     * @function ClipParameter.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        var me = this;
        me.clipDatasetName = null;
        me.clipDatasourceName = null;
        me.clipRegion = null;
        me.isClipInRegion = null;
        me.isExactClip = null;
    }


    /**
     * @function ClipParameter.prototype.toJSON
     * @description 将 ClipParameter 对象转化为 JSON 字符串。
     * @returns {string} 返回转换后的 JSON 字符串。
     */
    toJSON() {
        return Util_Util.toJSON({
            isClipInRegion: this.isClipInRegion,
            clipDatasetName: this.clipDatasetName,
            clipDatasourceName: this.clipDatasourceName,
            isExactClip: this.isExactClip,
            clipRegion: ServerGeometry.fromGeometry(this.clipRegion)
        });
    }

}

;// CONCATENATED MODULE: ./src/common/iServer/GeoHashGridAggParameter.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/




/**
 * @class GeoHashGridAggParameter
 * @deprecatedclass SuperMap.GeoHashGridAggParameter
 * @classdesc 格网聚合查询参数类，该参数仅支持数据来源 Elasticsearch 服务的Supermap iServer的rest数据服务。
 * @category iServer Data FeatureResults
 * @param {Object} options - 可选参数。
 * @param {number} [options.precision=5] - 精度。
 * @extends {BucketAggParameter}
 * @usage
 */
class GeoHashGridAggParameter extends BucketAggParameter {
    constructor(options) {
        super();
        /**
         * @member {number} [GeoHashGridAggParameter.prototype.precision=5]
         * @description 网格中数字的精度。
         */
        this.precision = 5;
        Util_Util.extend(this, options);
        /**
         * @member {BucketAggType} [GeoHashGridAggParameter.prototype.aggType=BucketAggType.GEOHASH_GRID]
         * @description 格网聚合类型。
         */
        this.aggType = BucketAggType.GEOHASH_GRID;

        this.CLASS_NAME = 'SuperMap.GeoHashGridAggParameter';
    }

    destroy() {
        super.destroy();
        this.aggType = null;
        this.precision = null;
    }

    /**
     * @function GeoHashGridAggParameter.toJsonParameters
     * @description 将对象转为 JSON 格式。
     * @param param 转换对象。
     * @returns {Object}
     */
    static toJsonParameters(param) {
        var parameters = {
            aggName: param.aggName,
            aggFieldName: param.aggFieldName,
            aggType: param.aggType,
            precision: param.precision
        };
        return Util_Util.toJson(parameters);
    }
}


;// CONCATENATED MODULE: ./src/common/iServer/LabelMatrixCell.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/

/**
 * @class LabelMatrixCell
 * @deprecatedclass SuperMap.LabelMatrixCell
 * @category iServer Map Theme
 * @classdesc 矩阵标签元素抽象类。该类可以包含 n*n 个矩阵标签元素，矩阵标签元素的类型可以是图片，符号，标签专题图等。
 *            符号类型的矩阵标签元素类、图片类型的矩阵标签元素类和专题图类型的矩阵标签元素类均继承自该类。
 * @usage
 */
class LabelMatrixCell {
    constructor() {
        this.CLASS_NAME = "LabelMatrixCell";
    }

}

;// CONCATENATED MODULE: ./src/common/iServer/LabelImageCell.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/



/**
 * @class LabelImageCell
 * @deprecatedclass SuperMap.LabelImageCell
 * @category iServer Map Theme
 * @classdesc 图片类型的矩阵标签元素类。该类继承自 {@link LabelMatrixCell}类，主要对矩阵标签中的专题图类型的矩阵标签元素进行设置。
 * 矩阵标签专题图是标签专题图（ThemeLabel）的一种，其中矩阵标签中的填充元素又可分为图片类型（{@link LabelImageCell}）、
 * 符号类型（{@link LabelSymbolCell}）、专题图类型（{@link LabelThemeCell}）三种，该类是这三种类型的矩阵标签元素其中的一种，
 * 用于定义符号类型的矩阵标签，如符号 ID 字段名称（符号 ID 与 SuperMap 桌面产品中点、线、面符号的 ID 对应）、大小等。
 * 用户在实现矩阵标签专题图时只需将定义好的矩阵标签元素赋值予 {@link ThemeLabel#matrixCells} 属性即可。matrixCells 是一个二维数组，
 * 每一维可以是任意类型的矩阵标签元素组成的数组（也可是单个标签元素组成的数组，即数组中只有一个元素）。
 * @extends {LabelMatrixCell}
 * @param {Object} options - 可选参数。
 * @param {number} [options.height=0] - 设置图片的高度，单位为毫米。
 * @param {string} [options.pathField] - 设置矩阵标签元素所使用图片的路径。
 * @param {number} [options.rotation=0.0] - 图片的旋转角度。逆时针方向为正方向，单位为度，精确到0.1度。
 * @param {number} [options.width=0] - 设置图片的宽度，单位为毫米。
 * @param {boolean} [options.sizeFixed=false] - 是否固定图片的大小。
 * @usage
 */
class LabelImageCell extends LabelMatrixCell {

    constructor(options) {
        super(options);
        /**
         * @member {number} LabelImageCell.prototype.height
         * @description 设置图片的高度，单位为毫米。
         */
        this.height = 0;

        /**
         * @member {string} LabelImageCell.prototype.pathField
         * @description 设置矩阵标签元素所使用的图片路径对应的字段名。
         */
        this.pathField = null;

        /**
         * @member {number} [LabelImageCell.prototype.rotation=0.0]
         * @description 图片的旋转角度。逆时针方向为正方向，单位为度，精确到0.1度。
         */
        this.rotation = 0.0;

        /**
         * @member {number} LabelImageCell.prototype.width
         * @description 设置图片的宽度，单位为毫米。
         */
        this.width = 0;

        /**
         * @member {boolean} [LabelImageCell.prototype.sizeFixed=false]
         * @description 是否固定图片的大小。
         */
        this.sizeFixed = false;

        /**
         * @member {string} LabelImageCell.prototype.type
         * @description 制作矩阵专题图时是必须的。
         */
        this.type = "IMAGE";

        if (options) {
            Util_Util.extend(this, options);
        }

        this.CLASS_NAME = "SuperMap.LabelImageCell";
    }

    /**
     * @function LabelImageCell.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        var me = this;
        me.height = null;
        me.pathField = null;
        me.rotation = null;
        me.width = null;
        me.sizeFixed = null;
    }
}

;// CONCATENATED MODULE: ./src/common/iServer/LabelSymbolCell.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/




/**
 * @class LabelSymbolCell
 * @deprecatedclass SuperMap.LabelSymbolCell
 * @category  iServer Map Theme
 * @classdesc 符号类型的矩阵标签元素类。
 * 该类继承自 {@link LabelMatrixCell}类，主要对矩阵标签中的专题图类型的矩阵标签元素进行设置。
 * 矩阵标签专题图是标签专题图（{@link ThemeLabel}）的一种，其中矩阵标签中的填充元素又可分为图片类型（{@link LabelImageCell}）、
 * 符号类型（{@link LabelSymbolCell}）、专题图类型（{@link LabelThemeCell}）三种，该类是这三种类型的矩阵标签元素其中的一种，
 * 用于定义符号类型的矩阵标签，如符号 ID 字段名称（符号 ID 与 SuperMap 桌面产品中点、线、面符号的 ID 对应）、大小等。
 * 用户在实现矩阵标签专题图时只需将定义好的矩阵标签元素赋值予 {@link ThemeLabel#matrixCells} 属性即可。matrixCells 属性是一个二维数组，
 * 每一维可以是任意类型的矩阵标签元素组成的数组（也可是单个标签元素组成的数组，即数组中只有一个元素）。
 * @extends {LabelMatrixCell}
 * @param {Object} options - 参数。
 * @param {ServerStyle} options.style - 获取或设置符号样式。
 * @param {string} options.symbolIDField - 符号 ID 或符号 ID 所对应的字段名称。
 * @usage
 */
class LabelSymbolCell extends LabelMatrixCell {

    constructor(options) {
        super(options);
        /**
         * @member {ServerStyle} LabelSymbolCell.prototype.style
         * @description 获取或设置符号样式—— {@link ServerStyle} 对象，包括符号大小（{@link ServerStyle#markerSize}）
         *              和符号旋转（{@link ServerStyle#markerAngle}）角度，其中用于设置符号 ID 的属性（{@link ServerStyle#markerSymbolID}）在此处不起作用。
         */
        this.style = new ServerStyle();

        /**
         * @member {string} LabelSymbolCell.prototype.symbolIDField
         * @description 获取或设置符号 ID 或符号 ID 所对应的字段名称。
         */
        this.symbolIDField = null;

        /**
         * @member {string} LabelSymbolCell.prototype.type
         * @description 制作矩阵专题图时是必须的。
         */
        this.type = "SYMBOL";

        if (options) {
            Util_Util.extend(this, options);
        }

        this.CLASS_NAME = "SuperMap.LabelSymbolCell";
    }

    /**
     * @function LabelSymbolCell.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        var me = this;
        if (me.style) {
            me.style.destroy();
            me.style = null;
        }
        me.symbolIDField = null;
    }

}

;// CONCATENATED MODULE: ./src/common/iServer/LabelThemeCell.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/




/**
 * @class LabelThemeCell
 * @deprecatedclass SuperMap.LabelThemeCell
 * @category iServer Map Theme
 * @classdesc 专题图类型的矩阵标签元素类。
 * 该类继承自 {@link LabelMatrixCell} 类，主要对矩阵标签中的专题图类型的矩阵标签元素进行设置。
 *              矩阵标签专题图是标签专题图（{@link ThemeLabel}）的一种，其中矩阵标签中的填充元素又可分为图片类型（{@link LabelImageCell}）、
 *              符号类型（{@link LabelSymbolCell}）、专题图类型（{@link LabelThemeCell}）三种，该类是这三种类型的矩阵标签元素其中的一种，
 *              用于定义符号类型的矩阵标签，如符号 ID 字段名称（符号 ID 与 SuperMap 桌面产品中点、线、面符号的 ID 对应）、大小等。
 *              用户在实现矩阵标签专题图时只需将定义好的矩阵标签元素赋值予 {@link ThemeLabel#matrixCells} 属性即可。matrixCells 属性是一个二维数组，
 *              每一维可以是任意类型的矩阵标签元素组成的数组（也可是单个标签元素组成的数组，即数组中只有一个元素）。
 * @extends {LabelMatrixCell}
 * @param {Object} options -参数。
 * @param {ThemeLabel} options.themeLabel - 作为矩阵标签元素的标签专题图类。
 * @usage
 */
class LabelThemeCell extends LabelMatrixCell {


    constructor(options) {
        super(options);
        /**
         * @member {ThemeLabel} LabelThemeCell.prototype.themeLabel
         * @description 使用专题图对象作为矩阵标签的一个元素。
         */
        this.themeLabel =  new ThemeLabel();

        /**
         * @member {string} LabelThemeCell.prototype.type
         * @description 制作矩阵专题图时是必须的。
         */
        this.type = "THEME";

        if (options) {
            Util_Util.extend(this, options);
        }
        this.CLASS_NAME = " SuperMap.LabelThemeCell";
    }

    /**
     * @function LabelThemeCell.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        var me = this;
        if (me.themeLabel) {
            me.themeLabel.destroy();
            me.themeLabel = null;
        }
    }


}

;// CONCATENATED MODULE: ./src/common/iServer/LayerStatus.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


/**
 * @class LayerStatus
 * @deprecatedclass SuperMap.LayerStatus
 * @category iServer Map TempLayersSet
 * @classdesc 子图层显示参数类。该类存储了各个子图层的名字和是否可见的状态。
 * @param {Object} options - 参数。
 * @param {string} options.layerName - 图层名称。
 * @param {boolean} [options.isVisible=true] - 图层是否可见，true 表示可见。
 * @param {string} [options.displayFilter] - 图层显示 SQL 过滤条件。
 * @usage
 */
class LayerStatus {

    constructor(options) {
        /**
         * @member {string} LayerStatus.prototype.layerName
         * @description 获取或设置图层名称。
         */
        this.layerName = null;

        /**
         * @member {boolean} LayerStatus.prototype.isVisible
         * @description 获取或设置图层是否可见，true 表示可见。
         */
        this.isVisible = null;

        /**
         * @member {string} [LayerStatus.prototype.displayFilter]
         * @description 图层显示 SQL 过滤条件，如 layerStatus.displayFilter = "smid < 10"，表示仅显示 smid 值小于 10 的对象。
         */
        this.displayFilter = null;

        /**
         * @member {Object} [LayerStatus.prototype.fieldValuesDisplayFilter]
         * @property {Array.<number>} values - 要过滤的值。
         * @property {string} fieldName - 要过滤的字段名称只支持数字类型的字段。
         * @property {string} fieldValuesDisplayMode - 目前有两个 DISPLAY/DISABLE。当为 DISPLAY 时，表示只显示以上设置的相应属性值的要素，否则表示不显示以上设置的相应属性值的要素。
         */

        this.fieldValuesDisplayFilter = null;

        if (options) {
            Util_Util.extend(this, options);
        }
        this.CLASS_NAME = "SuperMap.LayerStatus";
    }

    /**
     * @function LayerStatus.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        var me = this;
        me.layerName = null;
        me.isVisible = null;
        me.displayFilter = null;
    }


    /**
     * @function LayerStatus.prototype.toJSON
     * @description 生成对应的 JSON。
     * @returns {Object} 对应的 JSON。
     */
    toJSON() {
        var json = '{';
        json += '"type":"UGC",';
        var v = [];
        if (this.layerName) {
            v.push('"name":"' + this.layerName + '"');
            v.push('"visible":' + this.isVisible);
        }

        if (this.displayFilter) {
            v.push('"displayFilter":"' + this.displayFilter + '"');
        }

        if (this.minScale || this.minScale == 0) {
            v.push('"minScale":' + this.minScale);
        }

        if (this.maxScale || this.maxScale == 0) {
            v.push('"maxScale":' + this.maxScale);
        }

        if (this.fieldValuesDisplayFilter) {
            v.push('"fieldValuesDisplayFilter":' + Util_Util.toJSON(this.fieldValuesDisplayFilter));
        }

        json += v;
        json += '}';

        return json;
    }

}

;// CONCATENATED MODULE: ./src/common/iServer/LinkItem.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/



/**
 * @class LinkItem
 * @deprecatedclass SuperMap.LinkItem
 * @constructs LinkItem
 * @category iServer Data FeatureResults
 * @classdesc 关联信息类。该类用于矢量数据集与外部表的关联。外部表是另一个数据集（其中纯属性数据集中没有空间几何信息）中的 DBMS 表,
 * 矢量数据集与外部表可以属于不同的数据源，但数据源类型目前只支持 SQL Server 和 Oracle 类型。使用 LinkItem 时，
 * 空间数据和属性数据必须满足关联条件，即主空间数据集与外部属性表之间存在关联字段。{@link LinkItem}
 * 只支持左连接，UDB、PostgreSQL 和 DB2 数据源不支持 {@link LinkItem}；另外，用于建立关联关系的两个表可以不在同一个数据源下。注意：<br>
 * 1.使用 {@link LinkItem} 的约束条件为：空间数据和属性数据必须有关联条件，即主空间数据集与外部属性表之间存在关联字段；<br>
 * 2.使用外关联表制作专题图时，所关联的字段必须设置表名，例如，如果所关联的字段为 BaseMap_R 数据集的 SmID，就要写成 BaseMap_R.SMID。
 * @param {Object} options - 参数。
 * @param {DatasourceConnectionInfo} options.datasourceConnectionInfo - 关联的外部数据源信息。
 * @param {Array.<string>} options.foreignKeys - 主空间数据集的外键。
 * @param {string} options.foreignTable - 关联的外部属性表的名称。
 * @param {Array.<string>} options.linkFields - 欲保留的外部属性表的字段。
 * @param {string} options.linkFilter - 与外部属性表的连接条件。
 * @param {string} options.name - 此关联信息对象的名称。
 * @param {Array.<string>} options.primaryKeys - 关联的外部属性表的主键。
 * @example 下面以 SQL 查询说明 linkitem 的使用方法：
 *  function queryBySQL() {
 *      // 设置关联的外部数据库信息,alias表示数据库别名
 *      var dc = new DatasourceConnectionInfo({
 *          dataBase: "RelQuery",
 *          server: "{ip}:{port}",
 *          user: "sa",
 *          password: "map",
 *          driver: "SQL Server",
 *          connect: true,
 *          OpenLinkTable: false,
 *          alias: "RelQuery",
 *          engineType: EngineType.SQLPLUS,
 *          readOnly: false,
 *          exclusive: false
 *      });
 *     // 设置关联信息
 *      var linkItem = new LinkItem({
 *          datasourceConnectionInfo: dc,
 *          foreignKeys: ["name"],
 *          foreignTable: "Pop_2011",
 *          linkFields: ["SmID as Pid","pop"],
 *          name: "link",
 *          primatryKeys: ["name"],
 *      });
 *      // 设置查询参数，在查询参数中添加linkItem关联条件信息
 *      var queryParam, queryBySQLParams, queryBySQLService;
 *      queryParam = new FilterParameter({
 *          name: "Province@RelQuery",
 *          fields: ["SmID","name"],
 *          attributeFilter: "SmID<7",
 *          linkItems: [linkItem]
 *       }),
 *      queryBySQLParams = new QueryBySQLParameters({
 *           queryParams: [queryParam]
 *              }),
 *      queryBySQLService = new QueryBySQLService(url);
     *      queryBySQLService.processAsync(queryBySQLParams);
     *  }
 *  function processCompleted(queryEventArgs) {//todo}
 *  function processFailed(e) {//todo}
 * @usage
 */
class LinkItem {


    constructor(options) {

        /**
         * @member {DatasourceConnectionInfo} LinkItem.prototype.datasourceConnectionInfo
         * @description 关联的外部数据源信息。
         */
        this.datasourceConnectionInfo = null;

        /**
         * @member {Array.<string>} LinkItem.prototype.foreignKeys
         * @description 主空间数据集的外键。
         */
        this.foreignKeys = null;

        /**
         * @member {string} LinkItem.prototype.foreignTable
         * @description 关联的外部属性表的名称，目前仅支持 Supermap 管理的表，即另一个矢量数据集所对应的 DBMS 表。
         */
        this.foreignTable = null;

        /**
         * @member {Array.<string>} LinkItem.prototype.linkFields
         * @description 欲保留的外部属性表的字段。如果不设置字段或者设置的字段在外部属性表中不存在的话则不返回任何外部属性表的属性信息。如果欲保留的外部表字段与主表字段存在同名，则还需要指定一个不存在字段名作为外部表的字段别名。
         */
        this.linkFields = null;

        /**
         * @member {string} LinkItem.prototype.linkFilter
         * @description 与外部属性表的连接条件。
         */
        this.linkFilter = null;

        /**
         * @member {string} LinkItem.prototype.name
         * @description 此关联信息对象的名称。
         */
        this.name = null;

        /**
         * @member {Array.<string>} LinkItem.prototype.primaryKeys
         * @description 需要关联的外部属性表的主键。
         */
        this.primaryKeys = null;

        if (options) {
            Util_Util.extend(this, options);
        }

        this.CLASS_NAME = "SuperMap.LinkItem";
    }

    /**
     * @function LinkItem.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        var me = this;
        if (me.datasourceConnectionInfo instanceof DatasourceConnectionInfo) {
            me.datasourceConnectionInfo.destroy();
            me.datasourceConnectionInfo = null;
        }
        me.foreignKeys = null;
        me.foreignTable = null;
        me.linkFields = null;
        me.linkFilter = null;
        me.name = null;
        me.primaryKeys = null;
    }

}

;// CONCATENATED MODULE: ./src/common/iServer/OverlapDisplayedOptions.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/



/**
 * @class OverlapDisplayedOptions
 * @deprecatedclass SuperMap.OverlapDisplayedOptions
 * @category iServer Map Layer
 * @classdesc 地图压盖过滤显示选项。在文本或专题图元素显示较密集的区域，文本之间或专题元素之间会发生相互压盖的现象，
 * 该类可以分别控制各种类型的对象的压盖显示情况，进而很好地处理地图中各种类型对象的压盖显示问题。
 * @param {Object} options - 可选参数。
 * @param {boolean} [options.allowPointOverlap=true] - 点和点压盖时是否显示压盖的点对象。
 * @param {boolean} [options.allowPointWithTextDisplay=true] - 标签和相应普通图层上的点是否一起过滤显示，如果过滤显示，
 *                                                             只以图层集合中对应数据集的索引最小的图层的点风格来绘制点。
 * @param {boolean} [options.allowTextOverlap=false] - 文本压盖时是否显示压盖的文本对象。
 * @param {boolean} [options.allowTextAndPointOverlap=true] - 文本和点压盖时是否显示压盖的文本或点对象（此属性不处理文本之间的压盖和点之间的压盖）。
 * @param {boolean} [options.allowThemeGraduatedSymbolOverlap=false] - 等级符号元素压盖时是否显示压盖的等级符号元素。
 * @param {boolean} [options.allowThemeGraphOverlap=false] - 统计专题图元素压盖时是否显示压盖的统计专题图元素。
 * @param {number} [options.horizontalOverlappedSpaceSize=0] - 两个对象之间的横向压盖间距，单位为 0.1 毫米，跟 verticalOverlappedSpaceSize 结合使用，
 *                                                             当两个对象的横向间距小于该值，且纵向间距小于 verticalOverlappedSpaceSize 时认为压盖。
 * @param {number} [options.verticalOverlappedSpaceSize=0] - 两个对象之间的纵向压盖间距，单位为 0.1 毫米，跟 horizontalOverlappedSpaceSize 结合使用，
 *                                                           当两个对象的纵向间距小于该值，且横向间距小于 horizontalOverlappedSpaceSize 时认为压盖。
 * @usage
 */
class OverlapDisplayedOptions {

    constructor(options) {
        options = options || {};
        /**
         * @member {boolean} [OverlapDisplayedOptions.prototype.allowPointOverlap=true]
         * @description 点和点压盖时是否显示压盖的点对象。
         */
        this.allowPointOverlap = true;

        /**
         * @member {boolean} [OverlapDisplayedOptions.prototype.allowPointWithTextDisplay=true]
         * @description 标签和相应普通图层上的点是否一起过滤显示，如果过滤显示，
         * 只以图层集合中对应数据集的索引最小的图层的点风格来绘制点。
         */
        this.allowPointWithTextDisplay = true;

        /**
         * @member {boolean} [OverlapDisplayedOptions.prototype.allowTextOverlap=false]
         * @description 文本压盖时是否显示压盖的文本对象。
         */
        this.allowTextOverlap = false;

        /**
         * @member {boolean} [OverlapDisplayedOptions.prototype.allowTextAndPointOverlap=true]
         * @description  文本和点压盖时是否显示压盖的文本或点对象（此属性不处理文本之间的压盖和点之间的压盖）。
         */
        this.allowTextAndPointOverlap = true;

        /**
         * @member {boolean} [OverlapDisplayedOptions.prototype.allowThemeGraduatedSymbolOverlap=false]
         * @description 等级符号元素压盖时是否显示压盖的等级符号元素。
         */
        this.allowThemeGraduatedSymbolOverlap = false;

        /**
         * @member {boolean} [OverlapDisplayedOptions.prototype.allowThemeGraphOverlap=false]
         * @description 统计专题图元素压盖时是否显示压盖的统计专题图元素。
         */
        this.allowThemeGraphOverlap = false;

        /**
         * @member {number} [OverlapDisplayedOptions.prototype.horizontalOverlappedSpaceSize=0]
         * @description 两个对象之间的横向压盖间距，单位为0.1毫米，跟 verticalOverlappedSpaceSize 结合使用，
         * 当两个对象的横向间距小于该值，且纵向间距小于 verticalOverlappedSpaceSize 时认为压盖。
         */
        this.horizontalOverlappedSpaceSize = 0;

        /**
         * @member {number} [OverlapDisplayedOptions.prototype.verticalOverlappedSpaceSize=0]
         * @description 两个对象之间的纵向压盖间距，单位为0.1毫米，跟 horizontalOverlappedSpaceSize 结合使用，
         * 当两个对象的纵向间距小于该值，且横向间距小于 horizontalOverlappedSpaceSize 时认为压盖。
         */
        this.verticalOverlappedSpaceSize = 0;

        Util_Util.extend(this, options);
        this.ugcLayer = new UGCLayer(options);

        this.CLASS_NAME = "SuperMap.OverlapDisplayedOptions";
    }

    /**
     * @function OverlapDisplayedOptions.prototype.destroy
     * @description 释放资源，将资源的属性置空。
     */
    destroy() {
        Util_Util.reset(this);
    }


    /**
     * @function OverlapDisplayedOptions.prototype.fromJson
     * @description 将服务端 JSON 对象转换成当前客户端对象。
     * @param {Object} jsonObject - 要转换的 JSON 对象。
     */
    fromJson(jsonObject) {
        this.ugcLayer.fromJson.apply(this, [jsonObject]);
    }


    /**
     * @function OverlapDisplayedOptions.prototype.toServerJSONObject
     * @description 转换成对应的 JSON 格式对象。
     * @returns {Object} 对应的 JSON 格式对象。
     */
    toServerJSONObject() {
        var jsonObject = this.ugcLayer.toServerJSONObject.apply(this, arguments);
        return jsonObject;
    }


    /**
     * @function OverlapDisplayedOptions.prototype.toString
     * @description 转换成对应的 tileLayer 请求瓦片时 overlapDisplayedOptions 参数。
     * @returns {string} 对应的 tileLayer 请求瓦片时 overlapDisplayedOptions 参数。
     */

    toString() {
        var jsonObject = this.ugcLayer.toServerJSONObject.apply(this, arguments);
        var str = "{";
        for (var attr in jsonObject) {
            if (jsonObject.hasOwnProperty(attr)) {
                str += "'" + attr + "':" + jsonObject[attr] + ",";
            }
        }
        str = str.substr(0, str.length - 1);
        str += "}";
        return str;
    }

}

;// CONCATENATED MODULE: ./src/common/iServer/ConvexHullAnalystParameters.js
/* Copyright© 2000 - 2022 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/
 
 
 /**
  * @class ConvexHullAnalystParameters
  * @deprecatedclass SuperMap.ConvexHullAnalystParameters
  * @constructs ConvexHullAnalystParameters
  * @category iServer SpatialAnalyst ConvexHullAnalyst
  * @classdesc 凸包运算参数类。
  * @version 11.1.1
  * @param {Object} options - 参数。
  * @param {Object} options.model - 源模型对象，即凸包计算中被操作的模型对象
  * @param {Object} [options.resultSetting] - 凸包计算结果设置，即模型对象凸包结果设置
  * @usage
  */
 
 class ConvexHullAnalystParameters {
 
     constructor(options) {
         /**
          * @member {Object} ConvexHullAnalystParameters.prototype.model
          * @description 源模型对象，即凸包计算中被操作的模型对象
          */
         this.model = null;

         /**
          * @member {Object} [ConvexHullAnalystParameters.prototype.resultSetting]
          * @description 凸包计算结果设置，即模型对象凸包结果设置
          */
         this.resultSetting = null;
         
         if (options) {
             Util_Util.extend(this, options);
         }
         this.CLASS_NAME = "SuperMap.ConvexHullAnalystParameters";
     }
 
     /**
      * @function ConvexHullAnalystParameters.prototype.destroy
      * @override
      */
     destroy() {
        var me = this;
        me.model = null;
        me.resultSetting = null;
     }
 
 }
 
;// CONCATENATED MODULE: ./src/common/iServer/GetLayersLegendInfoParameters.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


/**
 * @class GetLayersLegendInfoParameters
 * @deprecatedclass SuperMap.GetLayersLegendInfoParameters
 * @category iServer Map Layer
 * @classdesc 图例参数类。
 * @version 11.1.1
 * @param {Object} options - 参数。
 * @param {string} options.bbox - 查询与此矩形框有交集的图层的图例，当layers参数未设置时，bbox是必填参数。格式：bbox=xmin,ymin,xmax,ymax。
 * @param {string} options.layers - 图层过滤，当bbox参数未设置时，layers是必填参数。语法：[show|hide]:layerName1,layerName2。show表示只返回指定图层的图例，hide表示指定图层图例不返回，其他查询出来的图层图例都返回。例如：show:country@World@@World，表示只返回country@World@@World图层的图例。
 * @param {boolean} [options.transparent] - 图例图片是否背景透明。默认为true。
 * @param {number} [options.mapScale] - 地图比例尺。当returnVisibleOnly为true时，mapScale是必填参数。
 * @param {boolean} [options.returnVisibleOnly] - 是否只返回当前地图范围内可见要素的图例。默认为false。
 * @param {number} [options.width] - 返回图例的宽度。默认16像素。
 * @param {number} [options.height] - 返回图例的高度。默认16像素。

 * @usage
 */
class GetLayersLegendInfoParameters {


    constructor(options) {
        /**
         * @member {string} GetLayersLegendInfoParameters.prototype.bbox
         * @description 查询与此矩形框有交集的图层的图例，当layers参数未设置时，bbox是必填参数。格式：bbox=xmin,ymin,xmax,ymax。
         */
        this.bbox = null;

        /**
         * @member {string} GetLayersLegendInfoParameters.prototype.layers
         * @description 图层过滤，当bbox参数未设置时，layers是必填参数。语法：[show|hide]:layerName1,layerName2。show表示只返回指定图层的图例，hide表示指定图层图例不返回，其他查询出来的图层图例都返回。例如：show:country@World@@World，表示只返回country@World@@World图层的图例。
         */
        this.layers = null;

        /**
         * @member {boolean} GetLayersLegendInfoParameters.prototype.transparent
         * @description 图例图片是否背景透明。默认为true。
         */
        this.transparent = null;

        /**
         * @member {number} GetLayersLegendInfoParameters.prototype.mapScale
         * @description  地图比例尺。当returnVisibleOnly为true时，mapScale是必填参数。
         */
        this.mapScale = null;

        /**
         * @member {boolean} GetLayersLegendInfoParameters.prototype.returnVisibleOnly
         * @description  是否只返回当前地图范围内可见要素的图例。默认为false。
         */
        this.returnVisibleOnly = null;

        /**
         * @member {number} GetLayersLegendInfoParameters.prototype.width
         * @description  返回图例的宽度。默认16像素。
         */
        this.width = null;

        /**
         * @member {number} GetLayersLegendInfoParameters.prototype.height
         * @description  返回图例的高度。默认16像素。
         */
        this.height = null;
        Util_Util.extend(this, options);

        this.CLASS_NAME = "SuperMap.GetLayersLegendInfoParameters";
    }


    /**
     * @function GetLayersLegendInfoParameters.prototype.destroy
     * @description 释放资源，将引用的资源属性置空。
     */
    destroy() {
        var me = this;
        me.bbox = null;
        me.layers = null;
        me.transparent = null;
        me.mapScale = null;
        me.returnVisibleOnly = null;
        me.width = null;
        me.height = null;
    }

}


;// CONCATENATED MODULE: ./src/common/iServer/SetLayerInfoParameters.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


/**
 * @class SetLayerInfoParameters
 * @deprecatedclass SuperMap.SetLayerInfoParameters
 * @category  iServer Map TempLayersSet
 * @classdesc 设置图层信息参数类。
 * @param {Object} options - 参数。
 * @param {string} options.resourceID - 临时图层的资源 ID。
 * @param {string} options.tempLayerName - 临时图层下的子图层名。
 * @param {string} options.layerInfo - 要更新的图层信息。
 * @usage
 */
class SetLayerInfoParameters {

    constructor(options) {
        options = options || {};
        /**
         * @member {string} SetLayerInfoParameters.prototype.resourceID
         * @description 临时图层的资源 ID。
         */
        this.resourceID = null;

        /**
         * @member {string} SetLayerInfoParameters.prototype.tempLayerName
         * @description 临时图层下子图层（或者其子图层）名，如：Countries@World.3@@World。
         */
        this.tempLayerName = null;

        /**
         * @member {Object} SetLayerInfoParameters.prototype.layerInfo
         * @description 要更新的图层信息（包含修改和未修改的所有字段）。该参数可以通过图层信息服务获取，然后对返回值中 subLayers.layers[i] 图层信息属性进行修改。
         */
        this.layerInfo = null;

        Util_Util.extend(this, options);

        this.CLASS_NAME = "SuperMap.SetLayerInfoParameters";
    }

    /**
     * @function SetLayerInfoParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        var me = this;
        me.resourceID = null;
        me.tempLayerName = null;
        me.layerInfo = null;
    }

}


;// CONCATENATED MODULE: ./src/common/iServer/SetLayersInfoParameters.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


/**
 * @class SetLayersInfoParameters
 * @deprecatedclass SuperMap.SetLayersInfoParameters
 * @category  iServer Map TempLayersSet
 * @classdesc 设置图层信息参数类。
 * @param {Object} options - 参数。
 * @param {boolean} [options.isTempLayers=false] - 是否是临时图层。
 * @param {string} options.resourceID - 临时图层资源 ID。
 * @param {Object} options.layersInfo - 要更新的图层信息。
 * @usage
 */
class SetLayersInfoParameters {

    constructor(options) {
        options = options || {};
        /**
         * @member {boolean} [SetLayersInfoParameters.prototype.isTempLayers=false]
         * @description 是否是临时图层。
         */
        this.isTempLayers = null;
        /**
         * @member {string} SetLayersInfoParameters.prototype.resourceID
         * @description 临时图层资源 ID。
         */
        this.resourceID = null;

        /**
         * @member {Object} SetLayersInfoParameters.prototype.layersInfo
         * @description 要更新的图层信息（包含修改和未修改的所有字段）。该参数可以通过图层信息服务获取，然后对返回值中 subLayers.layers[i] 图层信息属性进行修改。
         */
        this.layersInfo = null;

        Util_Util.extend(this, options);

        this.CLASS_NAME = "SuperMap.SetLayersInfoParameters";
    }


    /**
     * @function SetLayersInfoParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        var me = this;
        me.isTempLayers = null;
        me.resourceID = null;
        me.layersInfo = null;
    }



}


;// CONCATENATED MODULE: ./src/common/iServer/SupplyCenter.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


/**
 * @class SupplyCenter
 * @deprecatedclass SuperMap.SupplyCenter
 * @category  iServer NetworkAnalyst Location
 * @classdesc 资源供给中心类。在资源分配和选址分区分析两个功能中使用。
 * @param {Object} options - 参数。
 * @param {number} options.maxWeight - 最大耗费值。
 * @param {number} options.nodeID - 结点 ID 号。资源供给中心必须是结点。
 * @param {number} options.resourceValue - 能提供的最大服务量或商品数量。
 * @param {SupplyCenterType} [options.type] - 资源供给中心点的类型常量。
 * @usage
 */
class SupplyCenter {

    constructor(options) {
        /**
         * @member {number} SupplyCenter.prototype.maxWeight
         * @description 资源供给中心的最大耗费值。中心点最大阻值设置越小，表示中心点所提供的资源可影响范围越大。
         *              最大阻力值是用来限制需求点到中心点的花费。
         *              如果需求点（弧段或结点）到此中心的花费大于最大阻力值，则该需求点不属于该资源供给中心提供资源的范围。
         */
        this.maxWeight = null;

        /**
         * @member {number} SupplyCenter.prototype.nodeID
         * @description 资源供给中心点的结点 ID 号，资源供给中心必须是结点。
         */
        this.nodeID = null;

        /**
         * @member {number} SupplyCenter.prototype.resourceValue
         * @description 资源供给中心能提供的最大服务量或商品数量。例如资源中心为学校，资源中心资源量表示该学校能够接纳多少学生。
         */
        this.resourceValue = null;

        /**
         * @member {SupplyCenterType} [SupplyCenter.prototype.type]
         * @description 资源供给中心点的类型常量。资源供给中心点的类型包括非中心，固定中心和可选中心。
         *              固定中心用于资源分配分析；固定中心和可选中心用于选址分析；非中心在两种网络分析时都不予考虑。
         */
        this.type = null;

        if (options) {
            Util_Util.extend(this, options);
        }

        this.CLASS_NAME = "SuperMap.SupplyCenter";
    }

    /**
     * @function SupplyCenter.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        var me = this;
        me.maxWeight = null;
        me.nodeID = null;
        me.resourceValue = null;
        me.type = null;
    }

    /**
     * @function SupplyCenter.fromJson
     * @description 将服务端 JSON 对象转换成当前客户端对象。
     * @param {Object} jsonObject - 要转换的 JSON 对象。
     * @returns {SupplyCenter} SupplyCenter 对象。
     */
    static fromJson(jsonObject) {
        if (!jsonObject) {
            return;
        }
        return new SupplyCenter({
            maxWeight: jsonObject.maxWeight,
            nodeID: jsonObject.nodeID,
            resourceValue: jsonObject.resourceValue,
            type: jsonObject.type
        });
    }

}



;// CONCATENATED MODULE: ./src/common/iServer/terrainAnalystSetting.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/
 
 
 
 /**
  * @class terrainAnalystSetting
  * @deprecatedclass SuperMap.terrainAnalystSetting
  * @category SpatialAnalyst TerrainCalculation
  * @classdesc 地形分析基本的环境设置类。
  * @param {Object} options - 参数。
  * @param {(SuperMap.Bounds|L.Bounds|L.LatLngBounds|ol.extent|mapboxgl.LngLatBounds|GeoJSONObject)} [options.bounds] - 结果数据集的地理范围。只有 BoundType 为 Custom 时才有效。
  * @param {BoundsType} [options.boundsType=BoundsType.MAX] - 分析结果数据集范围类型。
  * @param {number} [options.cellSize] - 结果数据集的单元格大小。当单元格类型为 Custom 时有效。
  * @param {CellSizeType} [options.cellSizeType=CellSizeType.UNION] - 结果数据集的单元格类型。
  * @usage
  */
 class terrainAnalystSetting {
 
     constructor(options) {
 
         /**
          * @member {(SuperMap.Bounds|L.Bounds|L.LatLngBounds|ol.extent|mapboxgl.LngLatBounds|GeoJSONObject)} [terrainAnalystSetting.prototype.bounds]
          * @description 结果数据集的地理范围。只有 BoundType 为 Custom 时才有效。
          */
         this.bounds = null;
 
         /**
          * @member {BoundsType} [terrainAnalystSetting.prototype.boundsType]
          * @description 分析结果数据集范围类型。
          */
         this.boundsType = BoundsType.MAX;
 
         /**
          * @member {DataReturnMode} [terrainAnalystSetting.prototype.cellSize]
          * @description 结果数据集的单元格大小。当单元格类型为 Custom 时有效。
          */
         this.cellSize = null;
 
         /**
          * @member {boolean} [terrainAnalystSetting.prototype.cellSizeType]
          * @description 结果数据集的单元格类型。
          */
         this.cellSizeType = CellSizeType.UNION;
 
         Util_Util.extend(this, options);
         this.CLASS_NAME = "SuperMap.terrainAnalystSetting";
     }
 
     /**
      * @function terrainAnalystSetting.prototype.destroy
      * @description 释放资源，将引用资源的属性置空。
      */
     destroy() {
         var me = this;
         me.bounds = null;
         me.boundsType = null;
         me.cellSize = null;
         me.cellSizeType = null;
     }
 }
 
;// CONCATENATED MODULE: ./src/common/iServer/ThemeFlow.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/



/**
 * @class ThemeFlow
 * @deprecatedclass SuperMap.ThemeFlow
 * @private
 * @category  iServer Map Theme
 * @classdesc 标签或符号流动显示和牵引线风格设置类。
 *            通过该类可以设置专题图中符号是否流动显示、是否使用牵引线以及牵引线风格。
 * @param {Object} options - 可选参数。
 * @param {boolean} [options.flowEnabled=false] - 是否流动显示标签或符号。
 * @param {boolean} [options.leaderLineDisplayed=false] - 是否显示标签或符号和它标注的对象之间的牵引线。
 * @param {ServerStyle} [options.leaderLineStyle] - 标签或符号与其标注对象之间牵引线的风格。
 * @usage
 */
class ThemeFlow {

    constructor(options) {
        /**
         * @member {boolean} [ThemeFlow.prototype.flowEnabled=false]
         * @description 是否流动显示标签或符号。<br>
         *              对于标签专题图而言，对于跨越比较大的区域和线条状的几何对象，在一个地图窗口中不能完全显示的情况下，如果其标签位置比较固定，
         *              在当前地图窗口中该对象的标签不可见，则需要通过平移地图来查看对象的标签信息。如果采用了流动显示的效果，在当前地图窗口中，对象即使是部分显示，
         *              其标签也会显示在当前地图窗口中。当平移地图时，对象的标签会随之移动，以保证在当前地图窗口中部分或全部显示的对象其标签都可见，从而可以方便地查看各要素的标签信息。
         */
        this.flowEnabled = false;

        /**
         * @member {boolean} [ThemeFlow.prototype.leaderLineDisplayed=false]
         * @description 是否显示标签或符号和它标注的对象之间的牵引线。false表示不显示标签或符号和它标注的对象之间的牵引线。<br>
         *              只有当 flowEnabled 为 true 时，牵引线才起作用。在当标签流动显示时，其位置不固定，由于牵引线始终指向要素的内点，
         *              因而通过牵引线显示功能可以找到流动的标签或符号实际对应的要素。或者渲染符号偏移它所指向的对象时，图与对象之间可以采用牵引线进行连接。
         */
        this.leaderLineDisplayed = false;

        /**
         * @member {ServerStyle} ThemeFlow.prototype.leaderLineStyle
         * @description 标签或符号与其标注对象之间牵引线的风格。
         */
        this.leaderLineStyle =  new ServerStyle();

        if (options) {
            Util_Util.extend(this, options);
        }

        this.CLASS_NAME = "SuperMap.ThemeFlow";
    }

    /**
     * @function ThemeFlow.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        var me = this;
        me.flowEnabled = null;
        me.leaderLineDisplayed = null;
        if (me.leaderLineStyle) {
            me.leaderLineStyle.destroy();
            me.leaderLineStyle = null;
        }
    }

    /**
     * @function ThemeFlow.fromObj
     * @description 从传入对象获取标签或符号流动显示和牵引线风格设置类。
     * @param {Object} obj - 传入对象。
     * @returns {ThemeFlow} ThemeFlow 对象。
     */
    static fromObj(obj) {
        if (!obj) {
            return;
        }
        var res = new ThemeFlow();
        Util_Util.copy(res, obj);
        res.leaderLineStyle = ServerStyle.fromJson(obj.leaderLineStyle);
        return res;
    }

}


;// CONCATENATED MODULE: ./src/common/iServer/ThemeGridRangeItem.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/



/**
 * @class ThemeGridRangeItem
 * @deprecatedclass SuperMap.ThemeGridRangeItem
 * @category  iServer Map Theme
 * @classdesc 栅格分段专题图子项类。在栅格分段专题图中，将栅格值按照某种分段模式被分成多个范围段。
 * 本类用来设置每个范围段的分段起始值、终止值、名称和颜色等。每个分段所表示的范围为 [Start,End)。
 * @param {Object} options - 参数。
 * @param {ServerColor} options.color - 栅格分段专题图中每一个分段专题图子项的对应的颜色。
 * @param {string} [options.caption] - 栅格分段专题图子项的标题。
 * @param {number} [options.end=0] - 栅格分段专题图子项的终止值。
 * @param {number} [options.start=0] - 栅格分段专题图子项的起始值。
 * @param {boolean} [options.visible=true] - 栅格分段专题图子项是否可见。
 * @usage
 */
class ThemeGridRangeItem {

    constructor(options) {
        /**
         * @member {string} [ThemeGridRangeItem.prototype.caption]
         * @description 栅格分段专题图子项的标题。
         */
        this.caption = null;

        /**
         * @member {ServerColor} ThemeGridRangeItem.prototype.color
         * @description 栅格分段专题图中每一个分段专题图子项的对应的颜色。
         */
        this.color =  new ServerColor();

        /**
         * @member {number} [ThemeGridRangeItem.prototype.end=0]
         * @description 栅格分段专题图子项的终止值，即该段专题值范围的最大值。
         */
        this.end = 0;

        /**
         * @member {number} [ThemeGridRangeItem.prototype.start=0]
         * @description 栅格分段专题图子项的起始值，即该段专题值范围的最小值。
         */
        this.start = 0;


        /**
         * @member {boolean} [ThemeGridRangeItem.prototype.visible=true]
         * @description 栅格分段专题图子项是否可见。
         */
        this.visible = true;

        if (options) {
            Util_Util.extend(this, options);
        }
        this.CLASS_NAME = "SuperMap.ThemeGridRangeItem";
    }

    /**
     * @function ThemeGridRangeItem.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        var me = this;
        me.caption = null;
        me.end = null;
        me.start = null;
        //需要验证是够存在destroy方法
        if (me.color) {
            me.color.destroy();
            me.color = null;
        }
        me.visible = null;
    }

    /**
     * @function ThemeGridRangeItem.prototype.toServerJSONObject
     * @description 转换成对应的 JSON 格式对象。
     * @returns {Object} 对应的 JSON 格式对象。
     */
    toServerJSONObject() {
        var obj = {};
        obj = Util_Util.copyAttributes(obj, this);
        if (obj.color) {
            if (obj.color.toServerJSONObject) {
                obj.color = obj.color.toServerJSONObject();
            }
        }
        return obj;
    }

    /**
     * @function ThemeGridRangeItem.fromObj
     * @description 从传入对象获取栅格分段专题图子项类。
     * @param {Object} obj - 传入对象。
     * @returns {ThemeGridRangeItem} ThemeGridRangeItem 对象。
     */
    static fromObj(obj) {
        if (!obj) {
            return;
        }
        var res = new ThemeGridRangeItem();
        Util_Util.copy(res, obj);
        res.color = ServerColor.fromJson(obj.color);
        return res;
    }

}

;// CONCATENATED MODULE: ./src/common/iServer/ThemeGridRange.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/





/**
 * @class ThemeGridRange
 * @deprecatedclass SuperMap.ThemeGridRange
 * @category  iServer Map Theme
 * @classdesc 栅格分段专题图。栅格分段专题图，是将所有单元格的值按照某种分段方式分成多个范围段，值在同一个范围段中的单元格使用相同的颜色进行显示。一般用来反映连续分布现象的数量或程度特征。
 * 比如某年的全国降水量分布图，将各气象站点的观测值经过内插之后生成的栅格数据进行分段显示。
 * 该类类似于分段专题图类，不同点在于分段专题图的操作对象是矢量数据，而栅格分段专题图的操作对象是栅格数据。
 * @extends {CommonTheme}
 * @param {Object} options - 参数。
 * @param {Array.<ThemeGridRangeItem>} options.items - 栅格分段专题图子项数组。
 * @param {boolean} [options.reverseColor=false] - 是否对栅格分段专题图中分段的颜色风格进行反序显示。
 * @param {RangeMode} [options.rangeMode=RangeMode.EQUALINTERVAL] - 分段专题图的分段模式。
 * @param {number} [options.rangeParameter=0] - 分段参数。
 * @param {ColorGradientType} [options.colorGradientType=ColorGradientType.YELLOW_RED] - 渐变颜色枚举类。
 * @usage
 */
class ThemeGridRange extends Theme_Theme {

    constructor(options) {
        super("GRIDRANGE", options);
        /**
         * @member {Array.<ThemeGridRangeItem>} ThemeGridRange.prototype.items
         * @description 栅格分段专题图子项数组。<br>
         *              在栅格分段专题图中，将栅格值按照某种分段模式被分成多个范围段。
         *              本类用来设置每个栅格范围段的分段起始值、终止值、名称和颜色等。每个分段所表示的范围为 [Start,End)。
         */
        this.items = null;

        /**
         * @member {RangeMode} [ThemeGridRange.prototype.rangeMode=RangeMode.EQUALINTERVAL]
         * @description 分段专题图的分段模式。<br>
         *              在栅格分段专题图中，作为专题变量的字段或表达式的值按照某种分段方式被分成多个范围段。
         *              目前 SuperMap 提供的分段方式包括：等距离分段法、平方根分段法、标准差分段法、对数分段法、等计数分段法和自定义距离法，
         *              显然这些分段方法根据一定的距离进行分段，因而范围分段专题图所基于的专题变量必须为数值型。
         */
        this.rangeMode = RangeMode.EQUALINTERVAL;

        /**
         * @member {number} [ThemeGridRange.prototype.rangeParameter=0]
         * @description 分段参数。<br>
         *              当分段模式为等距离分段法，平方根分段，对数分段法，等计数分段法其中一种模式时，该参数用于设置分段个数，必设；当分段模式为标准差分段法时，
         *              该参数不起作用；当分段模式为自定义距离时，该参数用于设置自定义距离。
         */
        this.rangeParameter = 0;

        /**
         * @member {ColorGradientType} [ThemeGridRange.prototype.colorGradientType=ColorGradientType.YELLOW_RED]
         * @description 渐变颜色枚举类。
         *
         */
        this.colorGradientType = ColorGradientType.YELLOW_RED;

        /**
         * @member {boolean} ThemeGridRange.prototype.reverseColor
         * @description 是否对栅格分段专题图中分段的颜色风格进行反序显示。
         */
        this.reverseColor = false;

        if (options) {
            Util_Util.extend(this, options);
        }

        this.CLASS_NAME = "SuperMap.ThemeGridRange";
    }

    /**
     * @function ThemeGridRange.prototype.destroy
     * @override
     */
    destroy() {
        super.destroy();
        var me = this;
        if (me.items) {
            if (me.items.length > 0) {
                for (var item in me.items) {
                    me.items[item].destroy();
                    me.items[item] = null;
                }
            }
            me.items = null;
        }
        me.reverseColor = null;
        me.rangeMode = null;
        me.rangeParameter = null;
        me.colorGradientType = null;
    }

    /**
     * @function ThemeGridRange.fromObj
     * @description 从传入对象获取栅格分段专题图。
     * @param {Object} obj - 传入对象。
     * @returns {ThemeGridRange} ThemeGridRange 对象。
     */
    static fromObj(obj) {
        if (!obj) {
            return;
        }
        var res = new ThemeGridRange();
        Util_Util.copy(res, obj);
        var itemsR = obj.items;
        var len = itemsR ? itemsR.length : 0;
        res.items = [];
        for (var i = 0; i < len; i++) {
            res.items.push(ThemeGridRangeItem.fromObj(itemsR[i]));
        }
        return res;
    }

}



;// CONCATENATED MODULE: ./src/common/iServer/ThemeGridUniqueItem.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/



/**
 * @class ThemeGridUniqueItem
 * @deprecatedclass SuperMap.ThemeGridUniqueItem
 * @category  iServer Map Theme
 * @classdesc 栅格单值专题图子项类。
 *            栅格单值专题图是将值相同的单元格归为一类，每一类是一个专题图子项。
 * @param {Object} options - 可选参数。
 * @param {string} [options.caption] - 子项的名称。
 * @param {ServerColor} [options.color] - 子项的显示颜色。
 * @param {number} options.unique - 子项的专题值，即单元格的值，值相同的单元格位于一个子项内。
 * @param {boolean} [options.visible=true] - 子项是否可见。
 * @usage
 */
class ThemeGridUniqueItem {

    constructor(options) {
        /**
         * @member {string} [ThemeGridUniqueItem.prototype.caption]
         * @description 栅格单值专题图子项的名称。
         */
        this.caption = null;

        /**
         * @member {ServerColor} [ThemeGridUniqueItem.prototype.color]
         * @description 栅格单值专题图子项的显示颜色。
         */
        this.color = new ServerColor();

        /**
         * @member {number} ThemeGridUniqueItem.prototype.unique
         * @description 栅格单值专题图子项的专题值，即单元格的值，值相同的单元格位于一个子项内。
         */
        this.unique = null;

        /**
         * @member {boolean} [ThemeGridUniqueItem.prototype.visible=true]
         * @description 栅格单值专题图子项是否可见。
         */
        this.visible = true;

        if (options) {
            Util_Util.extend(this, options);
        }

        this.CLASS_NAME = "SuperMap.ThemeGridUniqueItem";
    }

    /**
     * @function ThemeGridUniqueItem.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        var me = this;
        me.caption = null;
        me.unique = null;

        if (me.color) {
            me.color.destroy();
            me.color = null;
        }
        me.visible = null;
    }

    /**
     * @function ThemeGridUniqueItem.prototype.toServerJSONObject
     * @description 转换成对应的 JSON 格式对象。
     * @returns {Object} 对应的 JSON 格式对象。
     */
    toServerJSONObject() {
        var obj = {};
        obj = Util_Util.copyAttributes(obj, this);
        if (obj.color) {
            if (obj.color.toServerJSONObject) {
                obj.color = obj.color.toServerJSONObject();
            }
        }
        return obj;
    }

    /**
     * @function ThemeGridUniqueItem.fromObj
     * @description 从传入对象获取栅格单值专题图子项类。
     * @param {Object} obj - 传入对象。
     * @returns {ThemeGridUniqueItem} ThemeGridUniqueItem 对象。
     */
    static fromObj(obj) {
        var res = new ThemeGridUniqueItem();
        Util_Util.copy(res, obj);
        res.color = ServerColor.fromJson(obj.color);
        return res;

    }

}


;// CONCATENATED MODULE: ./src/common/iServer/ThemeGridUnique.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/





/**
 * @class ThemeGridUnique
 * @deprecatedclass SuperMap.ThemeGridUnique
 * @category  iServer Map Theme
 * @classdesc 栅格单值专题图类。栅格单值专题图是将单元格值相同的归为一类，为每一类设定一种颜色，从而用来区分不同的类别。
 * 适用于离散栅格数据和部分连续栅格数据，对于单元格值各不相同的那些连续栅格数据，使用栅格单值专题图不具有任何意义。
 * @extends {CommonTheme}
 * @param {Object} options - 参数。
 * @param {Array.<ThemeGridUniqueItem>} options.items - 栅格单值专题图子项数组。
 * @param {ServerColor} [options.defaultcolor] - 栅格单值专题图的默认颜色。
 * @usage
 */
class ThemeGridUnique extends Theme_Theme {

    constructor(options) {
        super("GRIDUNIQUE", options);
        /**
         * @member {ServerColor} ThemeGridUnique.prototype.defaultcolor
         * @description 栅格单值专题图的默认颜色。
         *              对于那些未在格网单值专题图子项之列的要素使用该颜色显示。
         */
        this.defaultcolor = new ServerColor();

        /**
         * @member {Array.<ThemeGridUniqueItem>} ThemeGridUnique.prototype.items
         * @description 栅格单值专题图子项数组。
         *              栅格单值专题图将值相同的单元格归为一类，每一类是一个专题图子项。
         */
        this.items = null;

        if (options) {
            Util_Util.extend(this, options);
        }

        this.CLASS_NAME = "SuperMap.ThemeGridUnique";
    }

    /**
     * @function ThemeGridUnique.prototype.destroy
     * @override
     */
    destroy() {
        super.destroy();
        var me = this;
        if (me.items) {
            if (me.items.length > 0) {
                for (var item in me.items) {
                    me.items[item].destroy();
                    me.items[item] = null;
                }
            }
            me.items = null;
        }

        if (me.defaultcolor) {
            me.defaultcolor.destroy();
            me.defaultcolor = null;
        }
    }

    /**
     * @function ThemeGridUnique.prototype.toServerJSONObject
     * @description 转换成对应的 JSON 格式对象。
     * @returns {Object} 对应的 JSON 格式对象
     */
    toServerJSONObject() {
        var obj = {};
        obj = Util_Util.copyAttributes(obj, this);
        if (obj.defaultcolor) {
            if (obj.defaultcolor.toServerJSONObject) {
                obj.defaultcolor = obj.defaultcolor.toServerJSONObject();
            }
        }
        if (obj.items) {
            var items = [],
                len = obj.items.length;
            for (var i = 0; i < len; i++) {
                items.push(obj.items[i].toServerJSONObject());
            }
            obj.items = items;
        }
        return obj;
    }

    /**
     * @function ThemeGridUnique.fromObj
     * @description 从传入对象获取栅格单值专题图类。
     * @param {Object} obj - 传入对象
     * @returns {ThemeGridUnique} ThemeGridUnique 对象
     */
    static fromObj(obj) {
        var res = new ThemeGridUnique();
        var uItems = obj.items;
        var len = uItems ? uItems.length : 0;
        Util_Util.extend(res, obj);
        res.items = [];
        res.defaultcolor = ServerColor.fromJson(obj.defaultcolor);
        for (var i = 0; i < len; i++) {
            res.items.push(ThemeGridUniqueItem.fromObj(uItems[i]));
        }
        return res;
    }

}

;// CONCATENATED MODULE: ./src/common/iServer/ThemeLabelUniqueItem.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/



/**
 * @class ThemeLabelUniqueItem
 * @deprecatedclass SuperMap.ThemeLabelUniqueItem
 * @category  iServer Map Theme
 * @classdesc 单值标签专题图的子项。标签专题图用专题值对点、线、面等对象做标注，值得注意的是，单值标签专题图允许用户通过 uniqueExpression
 * 字段指定用于单值的字段，同一值的标签具有相同的显示风格，其中每一个值就是一个专题图子项，
 * 每一个子项都具有其名称、风格、指定的单值、X 方向偏移量和 Y 方向偏移量。
 * @param {Object} options - 参数。
 * @param {string} options.unique - 子项的值，可以为数字、字符串等。
 * @param {string} [options.caption] - 子项的名称。
 * @param {number} [options.offsetX=0] - 标签在 X 方向偏移量。
 * @param {number} [options.offsetY=0] - 标签在 Y 方向偏移量。
 * @param {boolean} [options.visible=true] - 子项是否可见。
 * @param {ServerTextStyle} [options.style] - 子项文本的显示风格。
 * @usage
 */
class ThemeLabelUniqueItem {

    constructor(options) {
        /**
         * @member {string} [ThemeLabelUniqueItem.prototype.caption]
         * @description 标签专题子项的标题。
         */
        this.caption = null;

        /**
         * @member {string} ThemeLabelUniqueItem.prototype.unique
         * @description 单值专题图子项的值，可以为数字、字符串等。
         */
        this.unique = null;

        /**
         * @member {number} [ThemeLabelUniqueItem.prototype.offsetX=0]
         * @description 标签在 X 方向偏移量。
         */
        this.offsetX = 0;

        /**
         * @member {number} [ThemeLabelUniqueItem.prototype.offsetY=0]
         * @description 标签在 Y 方向偏移量。
         */
        this.offsetY = 0;

        /**
         * @member {boolean} [ThemeLabelUniqueItem.prototype.visible=true]
         * @description 标签专题图子项是否可见。如果标签专题图子项可见，则为 true，否则为 false。
         */
        this.visible = true;

        /**
         * @member {ServerTextStyle} ThemeLabelUniqueItem.prototype.style
         * @description 标签专题图子项文本的显示风格。各种风格的优先级从高到低为：<br>
         *              uniformMixedStyle（标签文本的复合风格），ThemeLabelUniqueItem.style（单值子项的文本风格），uniformStyle（统一文本风格）。
         */
        this.style = new ServerTextStyle();

        if (options) {
            Util_Util.extend(this, options);
        }
        this.CLASS_NAME = "SuperMap.ThemeLabelUniqueItem";
    }

    /**
     * @function ThemeLabelUniqueItem.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        var me = this;
        me.unique = null;
        me.caption = null;
        me.offsetX = null;
        me.offsetY = null;
        if (me.style) {
            me.style.destroy();
            me.style = null;
        }
        me.visible = null;
    }

    /**
     * @function ThemeLabelUniqueItem.fromObj
     * @description 从传入对象获取单值标签专题图的子项类。
     * @param {Object} obj - 传入对象。
     * @returns {ThemeLabelUniqueItem} ThemeLabelUniqueItem 对象。
     */
    static fromObj(obj) {
        if (!obj) {
            return;
        }
        var t = new ThemeLabelUniqueItem();
        Util_Util.copy(t, obj);
        return t;
    }

}


;// CONCATENATED MODULE: ./src/common/iServer/ThemeMemoryData.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/

/**
 * @class ThemeMemoryData
 * @deprecatedclass SuperMap.ThemeMemoryData
 * @category  iServer Map Theme
 * @classdesc 专题图内存数据类。
 * @param {Array} srcData - 原始值数组。
 * @param {Array} targetData - 外部值数组。
 * @usage
 */
class ThemeMemoryData {

    constructor(srcData, targetData) {
        /**
         * @member {Array} ThemeMemoryData.prototype.srcData
         * @description 原始值数组，该属性值将被 targetData 属性所指定的值替换掉，然后制作专题图，但数据库中的值并不会改变。
         */
        this.srcData = srcData;

        /**
         * @member {Array} ThemeMemoryData.prototype.targetData
         * @description 外部值数组，即用于制作专题图的内存数据，设定该属性值后，会将 srcData 属性所指定的原始值替换掉制作专题图，但数据库中的值并不会改变。
         */
        this.targetData = targetData;

        this.CLASS_NAME = "SuperMap.ThemeMemoryData";
    }

    /**
     * @function ThemeMemoryData.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        var me = this;
        me.srcData = null;
        me.targetData = null;
    }


    /**
     * @function ThemeMemoryData.prototype.toJSON
     * @description 将 ThemeMemoryData 对象转化为 JSON 字符串。
     * @returns {string} 返回转换后的 JSON 字符串。
     */
    toJSON() {
        if (this.srcData && this.targetData) {
            var memoryDataStr = "";
            var count = Math.min(this.srcData.length, this.targetData.length);
            for (var i = 0; i < count; i++) {
                memoryDataStr += "\'" + this.srcData[i] + "\':\'" + this.targetData[i] + "\',";
            }
            //去除多余的逗号
            if (i > 0) {
                memoryDataStr = memoryDataStr.substring(0, memoryDataStr.length - 1);
            }
            return "{" + memoryDataStr + "}";
        } else {
            return null;
        }
    }

}

;// CONCATENATED MODULE: ./src/common/iServer/TransferLine.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


/**
 * @class TransferLine
 * @deprecatedclass SuperMap.TransferLine
 * @category  iServer TrafficTransferAnalyst TransferPath
 * @classdesc 换乘路线信息类。
 * @param {Object} options - 参数。
 * @param {number} options.lineID - 乘车路线 ID。
 * @param {string} options.lineName - 乘车路线名称。
 * @param {string} options.lineAliasName - 乘车路线别名。
 * @param {number} options.startStopIndex - 上车站点在本公交路线中的索引。
 * @param {string} options.startStopName - 上车站点名称。
 * @param {string} options.startStopAliasName - 上车站点别名。
 * @param {number} options.endStopIndex - 下车站点在本公交路线中的索引。
 * @param {string} options.endStopName - 下车站点名称。
 * @param {string} options.endStopAliasName - 下车站点别名。
 * @usage
 */
class TransferLine {

    constructor(options) {
        options = options || {};
        /**
         * @member {number} TransferLine.prototype.lineID
         * @description 乘车路线 ID。
         */
        this.lineID = null;

        /**
         * @member {string} TransferLine.prototype.lineName
         * @description 乘车路线名称。
         */
        this.lineName = null;

        /**
         * @member {string} TransferLine.prototype.lineAliasName
         * @description 乘车路线别名。
         */
        this.lineAliasName = null;

        /**
         * @member {number} TransferLine.prototype.startStopIndex
         * @description 上车站点在本公交路线中的索引。
         */
        this.startStopIndex = null;

        /**
         * @member {string} TransferLine.prototype.startStopName
         * @description 上车站点名称。
         */
        this.startStopName = null;

        /**
         * @member {string} TransferLine.prototype.startStopAliasName
         * @description 上车站点别名。
         */
        this.startStopAliasName = null;

        /**
         * @member {number} TransferLine.prototype.endStopIndex
         * @description 下车站点在本公交路线中的索引。
         */
        this.endStopIndex = null;

        /**
         * @member {string} TransferLine.prototype.endStopName
         * @description 下车站点名称。
         */
        this.endStopName = null;

        /**
         * @member {string} TransferLine.prototype.endStopAliasName
         * @description 下车站点别名。
         */
        this.endStopAliasName = null;

        Util_Util.extend(this, options);

        this.CLASS_NAME = "SuperMap.TransferLine";
    }


    /**
     * @function TransferLine.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        Util_Util.reset(this);
    }

    /**
     * @function TransferLine.fromJson
     * @description 将返回结果转化为 {@link TransferLine} 对象。
     * @param {Object} jsonObject - 新的返回结果。
     * @returns {TransferLine} 转化后的 {@link TransferLine} 对象。
     */
    static fromJson(jsonObject) {
        if (!jsonObject) {
            return;
        }
        return new TransferLine({
            lineID: jsonObject['lineID'],
            lineName: jsonObject['lineName'],
            lineAliasName: jsonObject['lineAliasName'],
            startStopIndex: jsonObject['startStopIndex'],
            startStopName: jsonObject['startStopName'],
            startStopAliasName: jsonObject['startStopAliasName'],
            endStopIndex: jsonObject['endStopIndex'],
            endStopName: jsonObject['endStopName'],
            endStopAliasName: jsonObject['endStopAliasName']
        });
    }

}

;// CONCATENATED MODULE: ./src/common/iServer/RasterFunctionParameter.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


/**
 * @class RasterFunctionParameter
 * @deprecatedclass SuperMap.RasterFunctionParameter
 * @category iServer Map Tile
 * @classdesc iServer 地图服务栅格分析参数基类。
 * @param {Object} options - 参数。
 * @param {RasterFunctionType} options.type - 栅格分析方法。
 * @usage
 */
class RasterFunctionParameter {
    constructor(options) {
        options = options || {};

        /**
         * @member {RasterFunctionType} [RasterFunctionParameter.prototype.type]
         * @description 栅格分析方法。
         */
        this.type = null;

        Util_Util.extend(this, options);
        this.CLASS_NAME = 'SuperMap.RasterFunctionParameter';
    }

    /**
     * @function RasterFunctionParameter.prototype.destroy
     * @description 释放资源，将资源的属性置空。
     */
    destroy() {
        this.type = null;
    }
}


;// CONCATENATED MODULE: ./src/common/iServer/NDVIParameter.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/




/**
 * @class NDVIParameter
 * @deprecatedclass SuperMap.NDVIParameter
 * @category iServer Map Tile
 * @classdesc 归一化植被指数参数类。
 * @param {Object} options - 参数。
 * @param {number} [options.redIndex=0] - 红光谱波段索引。
 * @param {number} [options.nirIndex=1] - 近红外光谱波段索引。
 * @param {string} [options.colorMap="0:ffffe5ff;0.1:f7fcb9ff;0.2:d9f0a3ff;0.3:addd8eff;0.4:78c679ff;0.5:41ab5dff;0.6:238443ff;0.7:006837ff;1:004529ff"] - 颜色表。由栅格的中断值和颜色停止之间的映射组成的，如0.3->d9f0a3ff 指的是[0,0.3)显示d9f0a3ff。仅单波段数据时设定。
 * @extends {RasterFunctionParameter}
 * @usage
 */
class NDVIParameter extends RasterFunctionParameter {
    constructor(options) {
        super(options);
        /**
         * @member {number} [NDVIParameter.prototype.redIndex=0]
         * @description 红光谱波段索引。
         */
        this.redIndex = 0;

        /**
         * @member {number} [NDVIParameter.prototype.nirIndex=1]
         * @description 近红外光谱波段索引。
         */
        this.nirIndex = 1;

        /**
         * @member {string} [NDVIParameter.prototype.colorMap="0:ffffe5ff;0.1:f7fcb9ff;0.2:d9f0a3ff;0.3:addd8eff;0.4:78c679ff;0.5:41ab5dff;0.6:238443ff;0.7:006837ff;1:004529ff"]
         * @description 颜色表。由栅格的中断值和颜色停止之间的映射组成的，如0.3->d9f0a3ff 指的是[0,0.3)显示d9f0a3ff。仅单波段数据时设定。
         */
        this.colorMap =
            '0:ffffe5ff;0.1:f7fcb9ff;0.2:d9f0a3ff;0.3:addd8eff;0.4:78c679ff;0.5:41ab5dff;0.6:238443ff;0.7:006837ff;1:004529ff';

        /**
         * @member {RasterFunctionType} [NDVIParameter.prototype.type]
         * @description 栅格分析方法。
         */
        this.type = RasterFunctionType.NDVI;
        Util_Util.extend(this, options);

        this.CLASS_NAME = 'SuperMap.NDVIParameter';
    }

    /**
     * @function NDVIParameter.prototype.destroy
     * @override
     */
    destroy() {
        super.destroy();
        this.redIndex = null;
        this.nirIndex = null;
        this.colorMap = null;
    }
    /**
     * @function NDVIParameter.prototype.toJSON
     * @description 将 NDVIParameter 对象转化为 JSON 字符串。
     * @returns {string} 返回转换后的 JSON 字符串。
     */
    toJSON() {
        return {
            redIndex: this.redIndex,
            nirIndex: this.nirIndex,
            colorMap: this.colorMap,
            type: this.type
        };
    }
}


;// CONCATENATED MODULE: ./src/common/iServer/HillshadeParameter.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/




/**
 * @class HillshadeParameter
 * @deprecatedclass SuperMap.HillshadeParameter
 * @category iServer Map Tile
 * @classdesc 阴影面分析参数类。
 * @param {Object} options - 可选参数。
 * @param {number} [options.altitude=45] - 高于地平线的光源高度角。高度角由正度数表示，0 度代表地平线，而 90 度代表头顶正上方。
 * @param {number} [options.azimuth=315] - 光源的方位角。方位角由0到360度之间的正度数表示，以北为基准方向按顺时针进行测量。
 * @param {number} [options.zFactor=1] - 一个表面 z 单位中地面 x,y 单位的数量。z 单位与输入表面的 x,y 单位不同时，可使用 z 因子调整 z 单位的测量单位。计算最终输出表面时，将用 z 因子乘以输入表面的 z 值。
 *                                       z 单位与输入表面的 x,y 单位不同时，可使用 z 因子调整 z 单位的测量单位。计算最终输出表面时，将用 z 因子乘以输入表面的 z 值。
 *                                      如果 x,y 单位和 z 单位采用相同的测量单位，则 z 因子为 1。这是默认设置。
 *                                      如果 x,y 单位和 z 单位采用不同的测量单位，则必须将 z 因子设置为适当的因子，否则会得到错误的结果。例如，如果 z 单位是英尺而 x,y 单位是米，则应使用 z 因子 0.3048 将 z 单位从英尺转换为米（1 英尺 = 0.3048 米）。
 *                                      如果输入栅格位于球面坐标系中（如十进制度球面坐标系），则生成的山体阴影可能看起来很独特。这是因为水平地面单位与高程 z 单位之间的测量值存在差异。由于经度的长度随着纬度而变化，因此需要为该纬度指定一个适当的 z 因子。如果 x,y 单位是十进制度而 Z 单位是米，特定纬度的一些合适的 Z 因子为：
 *                                      Latitude     Z-factor
 *                                      0           0.00000898
 *                                      10           0.00000912
 *                                      20           0.00000956
 *                                      30           0.00001036
 *                                      40           0.00001171
 *                                      50           0.00001395
 *                                      60           0.00001792
 *                                      70           0.00002619
 *                                      80           0.00005156
 * @extends {RasterFunctionParameter}
 * @usage
 */
class HillshadeParameter extends RasterFunctionParameter {
    constructor(options) {
        super(options);
        /**
         * @member {number} [HillshadeParameter.prototype.altitude = 45]
         * @description 高于地平线的光源高度角。高度角由正度数表示，0 度代表地平线，而 90 度代表头顶正上方。
         */
        this.altitude = 45;

        /**
         * @member {number} [HillshadeParameter.prototype.azimuth = 315]
         * @description 光源的方位角。方位角由0到360度之间的正度数表示，以北为基准方向按顺时针进行测量。
         */
        this.azimuth = 315;

        /**
         * @member {number} [HillshadeParameter.prototype.zFactor = 1]
         * @description 一个表面 z 单位中地面 x,y 单位的数量。z 单位与输入表面的 x,y 单位不同时，可使用 z 因子调整 z 单位的测量单位。计算最终输出表面时，将用 z 因子乘以输入表面的 z 值。
         */
        this.zFactor = 1;

        /**
         * @member {RasterFunctionType} HillshadeParameter.prototype.type
         * @description 栅格分析方法。
         */
        this.type = RasterFunctionType.HILLSHADE;
        Util_Util.extend(this, options);

        this.CLASS_NAME = 'SuperMap.HillshadeParameter';
    }

    /**
     * @function HillshadeParameter.prototype.destroy
     * @override
     */
    destroy() {
        super.destroy();
        this.altitude = null;
        this.azimuth = null;
        this.zFactor = null;
    }
    /**
     * @function HillshadeParameter.prototype.toJSON
     * @description 将 HillshadeParameter 对象转化为 JSON 字符串。
     * @returns {string} 返回转换后的 JSON 字符串。
     */
    toJSON() {
        return {
            altitude: this.altitude,
            azimuth: this.azimuth,
            zFactor: this.zFactor,
            type: this.type
        };
    }
}


;// CONCATENATED MODULE: ./src/common/iServer/WebPrintingJobCustomItems.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


/**
 * @class WebPrintingJobCustomItems
 * @deprecatedclass SuperMap.WebPrintingJobCustomItems
 * @classdesc Web 打印图例元素参数类。
 * @version 10.1.0
 * @category iServer WebPrintingJob
 * @param {Object} option - 参数。
 * @param {string} option.name - 图例元素的名称。
 * @param {string} option.picAsUrl - 图例元素 Base64 格式图片。
 * @param {string} [option.picAsBase64] - 图例元素图片的获取地址。如果已填了 URL 参数，此参数可不传。
 * @usage
 */
class WebPrintingJobCustomItems {
    constructor(option) {
        /**
         * @member {string} WebPrintingJobCustomItems.prototype.name
         * @description  图例元素的名称。
         */
        this.name = null;
        /**
         * @member {string} [WebPrintingJobCustomItems.prototype.picAsUrl]
         * @description  图例元素 Base64 格式图片。
         */
        this.picAsUrl = null;
        /**
         * @member {string} [WebPrintingJobCustomItems.prototype.picAsBase64]
         * @description  图例元素图片的获取地址。
         */
        this.picAsBase64 = null;

        this.CLASS_NAME = 'SuperMap.WebPrintingJobCustomItems';
        Util_Util.extend(this, option);
    }

    /**
     * @function WebPrintingJobCustomItems.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        var me = this;
        me.name = null;
        me.picAsUrl = null;
        me.picAsBase64 = null;
    }

    /**
     * @function WebPrintingJobCustomItems.prototype.toJSON
     * @description 将 WebPrintingJobCustomItems 对象转化为 JSON 字符串。
     * @returns {string} 转换后的 JSON 字符串。
     */
    toJSON() {
        var params = {
            name: this.name
        };
        if (this.title) {
            params.title = this.title;
        }
        if (this.picAsUrl) {
            params.picAsUrl = this.picAsUrl;
        } else if (this.picAsBase64) {
            params.picAsBase64 = this.picAsBase64.replace(/^data:.+;base64,/, '');
        }
        return Util_Util.toJSON(params);
    }
}


;// CONCATENATED MODULE: ./src/common/iServer/WebPrintingJobImage.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


/**
 * @class WebPrintingJobImage
 * @deprecatedclass SuperMap.WebPrintingJobImage
 * @classdesc 表达小地图的静态图片参数类。
 * @version 10.1.0
 * @category iServer WebPrintingJob
 * @param {Object} option - 参数。
 * @param {string} option.picAsUrl - 小地图的图片 URL 地址。
 * @param {string} [option.picAsBase64] - 小地图的base64位图片信息。如果已填了 URL 参数，此参数可不传。
 * @usage
 */
class WebPrintingJobImage {
    constructor(option) {
        /**
         * @member {string} [WebPrintingJobImage.prototype.picAsUrl]
         * @description 小地图的图片 URL 地址。
         */
        this.picAsUrl = null;
        /**
         * @member {string} [WebPrintingJobImage.prototype.picAsBase64]
         * @description 小地图的base64位图片信息。
         */
        this.picAsBase64 = null;

        this.CLASS_NAME = 'SuperMap.WebPrintingJobImage';
        Util_Util.extend(this, option);
    }

    /**
     * @function WebPrintingJobImage.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        this.picAsUrl = null;
        this.picAsBase64 = null;
    }

    /**
     * @function WebPrintingJobImage.prototype.toJSON
     * @description 将 WebPrintingJobImage 对象转化为 JSON 字符串。
     * @returns {string} 转换后的 JSON 字符串。
     */
    toJSON() {
        var params = {};
        if (this.picAsUrl) {
            params.picAsUrl = this.picAsUrl;
        }
        if (this.picAsBase64) {
            params.picAsBase64 = this.picAsBase64.replace(/^data:.+;base64,/, '');
        }
        return Util_Util.toJSON(params);
    }
}


;// CONCATENATED MODULE: ./src/common/iServer/WebPrintingJobLayers.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/
 

 /**
  * @class WebPrintingJobLayers
  * @deprecatedclass SuperMap.WebPrintingJobLayers
  * @classdesc 将图例添加到布局的业务图层参数类。
  * @version 10.1.0
  * @category iServer WebPrintingJob
  * @param {Object} option - 参数。
  * @param {string} option.name - 图层 name 的字符串。此 name 必须唯一，并且必须与定义业务图层的 LegendOptions_layers 元素中的图层 name 匹配。
  * @usage
  */
 class WebPrintingJobLayers {
     constructor(option) {
         /**
          * @member {string} WebPrintingJobLayers.prototype.name
          * @description  图层 name。
          */
         this.name = null;
         /**
          * @member {string} WebPrintingJobLayers.prototype.layerType
          * @description  图层 type。
          */
         this.layerType = null;
         /**
          * @member {string} WebPrintingJobLayers.prototype.url
          * @description  图层 URL。
          */
         this.url = null;

         this.CLASS_NAME = 'SuperMap.WebPrintingJobLayers';
         Util_Util.extend(this, option);
     }

     /**
     * @function WebPrintingJobLayers.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
     destroy() {
         this.name = null;
         this.layerType = null;
         this.url = null;
     }
 }


;// CONCATENATED MODULE: ./src/common/iServer/WebPrintingJobLegendOptions.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/




/**
 * @class WebPrintingJobLegendOptions
 * @deprecatedclass SuperMap.WebPrintingJobLegendOptions
 * @classdesc Web 打印图例参数类。
 * @version 10.1.0
 * @category iServer WebPrintingJob
 * @param {Object} option - 参数。
 * @param {string} [option.title] - 图例名称。
 * @param {string} [option.picAsUrl] - 图例的图片 URL 地址。
 * @param {string} [option.picAsBase64] - 图例的 base64 位图片信息。
 * @param {WebPrintingJobLayers} [option.layers] - 图例的布局业务图层参数类。
 * @param {WebPrintingJobCustomItems} [option.customItems] - 自定义图例元素参数类。
 * @usage
 */
class WebPrintingJobLegendOptions {
    constructor(option) {
        /**
         * @member {string} WebPrintingJobLegendOptions.prototype.title
         * @description  图例名称。
         */
        this.title = null;
        /**
         * @member {string} [WebPrintingJobLegendOptions.prototype.picAsUrl]
         * @description  图例的图片 URL 地址。
         */
        this.picAsUrl = null;
        /**
         * @member {string} [WebPrintingJobLegendOptions.prototype.picAsBase64]
         * @description  图例的 base64 位图片信息。
         */
        this.picAsBase64 = null;
        /**
         * @member {WebPrintingJobLayers} [WebPrintingJobLegendOptions.prototype.layers]
         * @description  图例的布局业务图层参数类。
         */
        this.layers = null;
        /**
         * @member {WebPrintingJobCustomItems} [WebPrintingJobLegendOptions.prototype.customItems]
         * @description  自定义图例元素参数类。
         */
        this.customItems = null;

        this.CLASS_NAME = 'SuperMap.WebPrintingJobLegendOptions';
        Util_Util.extend(this, option);
    }

    /**
     * @function WebPrintingJobLegendOptions.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        this.title = null;
        this.picAsUrl = null;
        this.picAsBase64 = null;
        if (this.layers instanceof WebPrintingJobLayers) {
            this.layers.destroy();
            this.layers = null;
        }
        if (this.customItems instanceof WebPrintingJobCustomItems) {
            this.customItems.destroy();
            this.customItems = null;
        }
    }

    /**
     * @function WebPrintingJobLegendOptions.prototype.toJSON
     * @description 将 WebPrintingJobLegendOptions 对象转化为 JSON 字符串。
     * @returns {string} 转换后的 JSON 字符串。
     */
    toJSON() {
        var params = {
            title: this.title || ""
        };
        if (this.picAsUrl) {
            params.picAsUrl = this.picAsUrl;
        } else if (this.picAsBase64) {
            params.picAsBase64 = this.picAsBase64.replace(/^data:.+;base64,/, '');
        } else if (this.customItems) {
            params.customItems = this.customItems;
        }
        return Util_Util.toJSON(params);
    }
}


;// CONCATENATED MODULE: ./src/common/iServer/WebPrintingJobLittleMapOptions.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/




/**
 * @class WebPrintingJobLittleMapOptions
 * @deprecatedclass SuperMap.WebPrintingJobLittleMapOptions
 * @classdesc Web 打印小地图参数类。
 * @version 10.1.0
 * @category iServer WebPrintingJob
 * @param {Object} option - 参数。
 * @param {GeometryPoint|L.Point|L.LatLng|ol.geom.Point|mapboxgl.LngLat|mapboxgl.Point|Array.<number>} option.center - 小地图的中心点。
 * @param {number} [option.scale] - 小地图的比例尺。
 * @param {Array.<string>} [option.layerNames] - 指定 WebMap中图层名称的列表，用于渲染小地图。
 * @param {WebPrintingJobImage} [option.image] - 表达小地图的静态图类。
 * @param {WebPrintingJobLayers} [option.layers] - 指定 WebMap 中的 layers 图层类。
 * @usage
 */

class WebPrintingJobLittleMapOptions {
    constructor(option) {
        /**
         * @member {GeometryPoint|L.Point|L.LatLng|ol.geom.Point|mapboxgl.LngLat|mapboxgl.Point|Array.<number>} WebPrintingJobLittleMapOptions.prototype.center
         * @description 小地图的中心点。
         */
        this.center = null;
        /**
         * @member {number} [WebPrintingJobLittleMapOptions.prototype.scale]
         * @description 小地图的比例尺。
         */
        this.scale = null;
        /**
         * @member {Array.<string>} WebPrintingJobLittleMapOptions.prototype.layerNames
         * @description 指定 WebMap中图层名称的列表，用于渲染小地图。
         */
        this.layerNames = null;
        /**
         * @member {WebPrintingJobImage} [WebPrintingJobLittleMapOptions.prototype.image]
         * @description 表达小地图的静态图类。暂不支持。
         */
        this.image = null;
        /**
         * @member {WebPrintingJobLayers} [WebPrintingJobLittleMapOptions.prototype.layers]
         * @description 指定 WebMap 中的 layers 图层类。
         */
        this.layers = null;

        this.CLASS_NAME = 'SuperMap.WebPrintingJobLittleMapOptions';
        Util_Util.extend(this, option);
    }

    /**
     * @function WebPrintingJobLittleMapOptions.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        this.center = null;
        this.scale = null;
        this.layerNames = null;
        if (this.image instanceof WebPrintingJobImage) {
            this.image.destroy();
            this.image = null;
        }
        if (this.layers instanceof WebPrintingJobLayers) {
            this.layers.destroy();
            this.layers = null;
        }
    }

    /**
     * @function WebPrintingJobLittleMapOptions.prototype.toJSON
     * @description 将 WebPrintingJobLittleMapOptions 对象转化为 JSON 字符串。
     * @returns {string} 转换后的 JSON 字符串。
     */
    toJSON() {
        var params = {
            scale: this.scale,
            center: this.center
        };
        if (this.layerNames) {
            params.layerNames = this.layerNames;
        } else if (this.layers) {
            params.layers = this.layers;
        }
        if (this.image) {
            params.image = this.image;
        }
        return Util_Util.toJSON(params);
    }
}


;// CONCATENATED MODULE: ./src/common/iServer/WebPrintingJobNorthArrowOptions.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


/**
 * @class WebPrintingJobNorthArrowOptions
 * @deprecatedclass SuperMap.WebPrintingJobNorthArrowOptions
 * @classdesc Web 打印地图指北针参数类。
 * @version 10.1.0
 * @category iServer WebPrintingJob
 * @param {Object} option - 参数。
 * @param {string} option.picAsUrl - 指北针的图片 URL 地址。
 * @param {string} [option.picAsBase64] - 指北针的base64位图片信息。
 * @usage
 */
class WebPrintingJobNorthArrowOptions {
    constructor(option) {
        /**
         * @member {string} WebPrintingJobNorthArrowOptions.prototype.picAsUrl
         * @description 指北针的图片 URL 地址。
         */
        this.picAsUrl = null;
        /**
         * @member {string} [WebPrintingJobNorthArrowOptions.prototype.picAsBase64]
         * @description 指北针的base64位图片信息。
         */
        this.picAsBase64 = null;

        this.CLASS_NAME = 'SuperMap.WebPrintingJobNorthArrowOptions';
        Util_Util.extend(this, option);
    }

    /**
     * @function WebPrintingJobNorthArrowOptions.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        this.picAsUrl = null;
        this.picAsBase64 = null;
    }

    /**
     * @function WebPrintingJobNorthArrowOptions.prototype.toJSON
     * @description 将 WebPrintingJobNorthArrowOptions 对象转化为 JSON 字符串。
     * @returns {string} 转换后的 JSON 字符串。
     */
    toJSON() {
        var params = {};
        if (this.picAsUrl) {
            params.picAsUrl = this.picAsUrl;
        } else if (this.picAsBase64) {
            params.picAsBase64 = this.picAsBase64.replace(/^data:.+;base64,/, '');
        }
        return Util_Util.toJSON(params);
    }
}


;// CONCATENATED MODULE: ./src/common/iServer/WebPrintingJobScaleBarOptions.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


/**
 * @class WebPrintingJobScaleBarOptions
 * @deprecatedclass SuperMap.WebPrintingJobScaleBarOptions
 * @classdesc Web 打印比例尺参数类。
 * @category iServer WebPrintingJob
 * @version 10.1.0
 * @param {Object} option - 参数。
 * @param {string} [option.scaleText] - 比例尺文本信息。例如：1:1000000。
 * @param {WebScaleOrientationType} [option.orientation] - 比例尺的方位样式。
 * @param {WebScaleType} [option.type] - 比例尺的样式。
 * @param {number} [option.intervals] - 比例尺条的段数。
 * @param {WebScaleUnit} [option.unit] - 比例尺的单位制。
 * @usage
 */
class WebPrintingJobScaleBarOptions {
    constructor(option) {
        /**
         * @member {string} WebPrintingJobScaleBarOptions.prototype.scaleText
         * @description 比例尺文本信息。
         */
        this.scaleText = null;
        /**
         * @member {WebScaleOrientationType} [WebPrintingJobScaleBarOptions.prototype.orientation]
         * @description 比例尺的方位样式。
         */
        this.orientation = null;
        /**
         * @member {WebScaleType} [WebPrintingJobScaleBarOptions.prototype.type]
         * @description 比例尺的样式。
         */
        this.type = null;
        /**
         * @member {Object} [WebPrintingJobScaleBarOptions.prototype.intervals]
         * @description 比例尺条的段数。
         */
        this.intervals = null;
        /**
         * @member {WebScaleUnit} [WebPrintingJobScaleBarOptions.prototype.unit]
         * @description 比例尺的单位制。
         */
        this.unit = null;

        this.CLASS_NAME = 'SuperMap.WebPrintingJobScaleBarOptions';
        Util_Util.extend(this, option);
    }

    /**
     * @function WebPrintingJobScaleBarOptions.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        this.scaleText = null;
        this.orientation = null;
        this.type = null;
        this.intervals = null;
        this.unit = null;
    }

    /**
     * @function WebPrintingJobScaleBarOptions.prototype.toJSON
     * @description 将 WebPrintingJobScaleBarOptions 对象转化为 JSON 字符串。
     * @returns {string} 转换后的 JSON 字符串。
     */
    toJSON() {
        var params = {
            scaleText: this.scaleText || "",
            type: this.type || "BAR",
            intervals: this.intervals || "",
            unit: this.unit || "METER"
        };
        if (this.orientation) {
            params.orientation = this.orientation;
        }
        return Util_Util.toJSON(params);
    }
}


;// CONCATENATED MODULE: ./src/common/iServer/WebPrintingJobContent.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


/**
 * @class WebPrintingJobContent
 * @deprecatedclass SuperMap.WebPrintingJobContent
 * @classdesc Web 打印内容参数类。
 * @version 10.1.0
 * @category iServer WebPrintingJob
 * @param {Object} option - 参数。
 * @param {string} option.type - Web 打印内容支持的类型。目前支持的类型：WEBMAP。
 * @param {string} [option.url] - 待打印的 SuperMap iPortal WebMap 的 URL 地址。例如：http://supermapiportal:8190/iportal/web/maps/{mapid}/map.rjson 。
 * @param {string} [option.token] - 如果待打印的是 SuperMap iPortal 用户私有的 WebMap，需要提供 SuperMap iPortal 用户的 token。
 * @param {WebMapSummaryObject} [option.value] - 传递的是一个符合 SuperMap WebMap 规范的 WebMap 的 JSON 表达，也可以是一个完整的 SuperMap iPortal 数据上图制作的 WebMap 的 JSON 表达。如果已填了 URL 参数，此参数可不传。
 * @usage
 */
class WebPrintingJobContent {
    constructor(option) {
        /**
         * @member {string} WebPrintingJobContent.prototype.type
         * @description Web 打印内容支持的类型。
         */
        this.type = null;
        /**
         * @member {string} [WebPrintingJobContent.prototype.url]
         * @description 待打印的 SuperMap iPortal WebMap 的 URL 地址。
         */
        this.url = null;
        /**
         * @member {string} [WebPrintingJobContent.prototype.token]
         * @description 如果待打印的是 SuperMap iPortal 用户私有的 WebMap，需要提供 SuperMap iPortal 用户的 token。
         */
        this.token = null;
        /**
         * @member {WebMapSummaryObject} [WebPrintingJobContent.prototype.value]
         * @description 传递的是一个符合 SuperMap WebMap 规范的 WebMap 的 JSON 表达，也可以是一个完整的 SuperMap iPortal 数据上图制作的 WebMap 的 JSON 表达。
         */
        this.value = null;

        this.CLASS_NAME = 'SuperMap.WebPrintingJobContent';
        Util_Util.extend(this, option);
    }

    /**
     * @function WebPrintingJobContent.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        this.type =  false || "WEBMAP";
        this.url = null;
        this.token = null;
        this.value = null;
    }

    /**
     * @function WebPrintingJobContent.prototype.toJSON
     * @description 将 WebPrintingJobContent 对象转化为 JSON 字符串。
     * @returns {string} 转换后的 JSON 字符串。
     */
    toJSON() {
        var params = {
            type: this.type
        };
        if (this.token) {
            params.token = this.token;
        }
        if (this.url) {
            params.url = this.url;
        } else if (this.value) {
            params.value = this.value;
        }
        return Util_Util.toJSON(params);
    }
}


;// CONCATENATED MODULE: ./src/common/iServer/WebPrintingJobLayoutOptions.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/






/**
 * @class WebPrintingJobLayoutOptions
 * @deprecatedclass SuperMap.WebPrintingJobLayoutOptions
 * @classdesc Web 打印的布局参数类。
 * @version 10.1.0
 * @category iServer WebPrintingJob
 * @param {Object} option - 参数。
 * @param {string} option.templateName - 布局模板的名称。
 * @param {string} option.title - 地图主标题名称。
 * @param {string} option.subTitle - 地图副标题名称。
 * @param {string} option.author - 作者名称。
 * @param {string} option.copyright - 版权信息。
 * @param {WebPrintingJobLittleMapOptions} option.littleMapOptions - 小地图参数类。
 * @param {WebPrintingJobLegendOptions} option.legendOptions - 图例参数类。
 * @param {WebPrintingJobScaleBarOptions} [option.scaleBarOptions] - 地图比例尺参数类。
 * @param {WebPrintingJobNorthArrowOptions} [option.northArrowOptions] - 地图指北针参数类。
 * @usage
 */
class WebPrintingJobLayoutOptions {
    constructor(option) {
        /**
         * @member {string} WebPrintingJobLayoutOptions.prototype.templateName
         * @description 布局模板的名称。
         */
        this.templateName = null;
        /**
         * @member {string} WebPrintingJobLayoutOptions.prototype.title
         * @description 地图主标题名称。
         */
        this.title = null;
        /**
         * @member {string} WebPrintingJobLayoutOptions.prototype.subTitle
         * @description 地图副标题名称。
         */
        this.subTitle = null;
        /**
         * @member {string} WebPrintingJobLayoutOptions.prototype.author
         * @description 地图作者名称。
         */
        this.author = null;
        /**
         * @member {string} WebPrintingJobLayoutOptions.prototype.copyright
         * @description 地图版权信息。
         */
        this.copyright = null;
        /**
         * @member {WebPrintingJobScaleBarOptions} [WebPrintingJobLayoutOptions.prototype.scaleBarOptions]
         * @description 地图比例尺参数类。
         */
        this.scaleBarOptions = null;
        /**
         * @member {WebPrintingJobNorthArrowOptions} [WebPrintingJobLayoutOptions.prototype.northArrowOptions]
         * @description 地图指北针参数类。
         */
        this.northArrowOptions = null;
        /**
         * @member {WebPrintingJobLittleMapOptions} WebPrintingJobLayoutOptions.prototype.littleMapOptions
         * @description 小地图参数类。
         */
        this.littleMapOptions = null;
        /**
         * @member {WebPrintingJobLegendOptions} WebPrintingJobLayoutOptions.prototype.legendOptions
         * @description 图例参数类。
         */
        this.legendOptions = null;

        this.CLASS_NAME = 'SuperMap.WebPrintingJobLayoutOptions';
        Util_Util.extend(this, option);
    }

    /**
     * @function WebPrintingJobLayoutOptions.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        this.templateName = null;
        this.title = null;
        this.subTitle = null;
        this.author = null;
        this.copyright = null;
        if (this.scaleBarOptions instanceof WebPrintingJobScaleBarOptions) {
            this.scaleBarOptions.destroy();
            this.scaleBarOptions = null;
        }
        if (this.northArrowOptions instanceof WebPrintingJobNorthArrowOptions) {
            this.northArrowOptions.destroy();
            this.northArrowOptions = null;
        }
        if (this.littleMapOptions instanceof WebPrintingJobLittleMapOptions) {
            this.littleMapOptions.destroy();
            this.littleMapOptions = null;
        }
        if (this.legendOptions instanceof WebPrintingJobLegendOptions) {
            this.legendOptions.destroy();
            this.legendOptions = null;
        }
    }

    /**
     * @function WebPrintingJobLayoutOptions.prototype.toJSON
     * @description 将 WebPrintingJobLayoutOptions 对象转化为 JSON 字符串。
     * @returns {string} 转换后的 JSON 字符串。
     */
    toJSON() {
        var params = {
            templateName: this.templateName,
            title: this.title,
            subTitle: this.subTitle,
            author: this.author,
            copyright: this.copyright
        };
        if (this.scaleBarOptions) {
            params.scaleBarOptions = this.scaleBarOptions;
        }
        if (this.northArrowOptions) {
            params.northArrowOptions = this.northArrowOptions;
        }
        if (this.littleMapOptions) {
            params.littleMapOptions = this.littleMapOptions;
        }
        if (this.legendOptions) {
            params.legendOptions = this.legendOptions;
        }
        return Util_Util.toJSON(params);
    }
}


;// CONCATENATED MODULE: ./src/common/iServer/WebPrintingJobExportOptions.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


/**
 * @class WebPrintingJobExportOptions
 * @deprecatedclass SuperMap.WebPrintingJobExportOptions
 * @classdesc Web 打印的输出参数类。
 * @version 10.1.0
 * @category iServer WebPrintingJob
 * @param {Object} option - 参数。
 * @param {WebExportFormatType} option.format - Web 打印输出的格式，目前支持：PNG、PDF。
 * @param {number} [option.dpi=96] - Web 打印输出的分辨率，单位为每英寸点数。默认值为 96 DPI。
 * @param {number} [option.scale] - Web 打印输出的地图比例尺。
 * @param {number} [option.rotation] - Web 打印输出的地图角度。
 * @param {GeometryPoint|L.Point|L.LatLng|ol.geom.Point|mapboxgl.LngLat|mapboxgl.Point|Array.<number>} [option.center] - Web 打印输出的地图中心点。
 * @usage
 */
class WebPrintingJobExportOptions {
    constructor(option) {
        /**
         * @member {WebExportFormatType} WebPrintingJobExportOptions.prototype.format
         * @description Web 打印输出的格式。
         */
        this.format = null;
        /**
         * @member {number} [WebPrintingJobExportOptions.prototype.dpi=96]
         * @description  Web 打印输出的分辨率，单位为每英寸点数。
         */
        this.dpi = 96;
        /**
         * @member {number} [WebPrintingJobExportOptions.prototype.scale]
         * @description Web 打印输出的地图比例尺。
         */
        this.scale = null;
        /**
         * @member {number} [WebPrintingJobExportOptions.prototype.rotation]
         * @description Web 打印输出的地图角度。
         */
        this.rotation = null;
        /**
         * @member {GeometryPoint|L.Point|L.LatLng|ol.geom.Point|mapboxgl.LngLat|mapboxgl.Point|Array.<number>} [WebPrintingJobExportOptions.prototype.center]
         * @description Web 打印输出的地图中心点。
         */
        this.center = null;

        this.CLASS_NAME = 'SuperMap.WebPrintingJobExportOptions';
        Util_Util.extend(this, option);
    }

    /**
     * @function WebPrintingJobExportOptions.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        this.format = null;
        this.dpi = null;
        this.scale = null;
        this.rotation = null;
        this.center = null;
        this.outputSize = null;
    }

    /**
     * @function WebPrintingJobExportOptions.prototype.toJSON
     * @description 将 WebPrintingJobExportOptions 对象转化为 JSON 字符串。
     * @returns {string} 转换后的 JSON 字符串。
     */
    toJSON() {
        var params = {
            format: this.format || "PDF",
            dpi: this.dpi,
            scale: this.scale,
            center: this.center
        };
        if (this.rotation) {
            params.rotation = this.rotation;
        }
        if (this.outputSize) {
            params.outputSize = this.outputSize;
        }
        return Util_Util.toJSON(params);
    }
}


;// CONCATENATED MODULE: ./src/common/iServer/WebPrintingJobParameters.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/





/**
 * @class WebPrintingJobParameters
 * @deprecatedclass SuperMap.WebPrintingJobParameters
 * @category iServer WebPrintingJob
 * @version 10.1.0
 * @classdesc Web 打印参数类。
 * @param {Object} options - 参数。
 * @param {WebPrintingJobContent} options.content - Web 打印的内容类。
 * @param {WebPrintingJobLayoutOptions} options.layoutOptions - Web 打印的布局类，包含各种布局元素的设置。
 * @param {WebPrintingJobExportOptions} options.exportOptions - Web 打印的输出类，包含 DPI、页面大小等。
 * @usage
 */
class WebPrintingJobParameters {
    constructor(options) {
        if (!options) {
            return;
        }
        /**
         * @member {WebPrintingJobContent} WebPrintingJobParameters.prototype.content
         * @description Web 打印的内容类。
         */
        this.content = null;

        /**
         * @member {WebPrintingJobLayoutOptions} WebPrintingJobParameters.prototype.layoutOptions
         * @description Web 打印的布局类，包含各种布局元素的设置。
         */
        this.layoutOptions = null;

        /**
         * @member {WebPrintingJobExportOptions} WebPrintingJobParameters.prototype.exportOptions
         * @description Web 打印的输出类，包含 DPI、页面大小等。
         */
        this.exportOptions = null;

        Util_Util.extend(this, options);

        this.CLASS_NAME = 'SuperMap.WebPrintingJobParameters';
    }

    /**
     * @function WebPrintingJobParameters.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        if (this.content instanceof WebPrintingJobContent) {
            this.content.destroy();
            this.content = null;
        }
        if (this.layoutOptions instanceof WebPrintingJobLayoutOptions) {
            this.layoutOptions.destroy();
            this.layoutOptions = null;
        }
        if (this.exportOptions instanceof WebPrintingJobExportOptions) {
            this.exportOptions.destroy();
            this.exportOptions = null;
        }
    }
}


;// CONCATENATED MODULE: ./src/common/iServer/FieldsFilter.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/




/**
 * @class FieldsFilter
 * @deprecatedclass SuperMap.FieldsFilter
 * @category iServer Data Field
 * @classdesc 指定返回的用于描述 Feature 的字段。
 * @param {Object} options - 可选参数。
 * @param {Array.<string>} [options.include] 对返回的字段内容进行过滤，需保留的字段列表。
 * @param {Array.<string>} [options.exclude] 对返回的字段内容进行过滤，需排除的字段列表。
 * @usage
 */
class FieldsFilter {
  constructor(options) {
    /**
    * @description 对返回的字段内容进行过滤，需保留的字段列表。
    * @member {Array.<string>} FieldsFilter.prototype.include
    */
    this.include = undefined;
    /**
    * @description 对返回的字段内容进行过滤，需排除的字段列表。
    * @member {Array.<string>} FieldsFilter.prototype.exclude
    */
    this.exclude = undefined;

    this.CLASS_NAME = 'SuperMap.FieldsFilter';
    Util_Util.extend(this, options);

  }

  /**
  * @function FieldsFilter.prototype.destroy
  * @description 释放资源，将引用资源的属性置空。
  */
  destroy() {
    var me = this;
    me.include = undefined;
    me.exclude = undefined;
  }

  /**
  * @function FieldsFilter.prototype.constructFromObject
  * @description 目标对象新增该类的可选参数。
  * @param {Object} data 要转换的数据。
  * @param {FieldsFilter} obj 返回的模型。
  * @return {FieldsFilter} 返回结果。
  */
  static constructFromObject(data, obj) {
    if (data) {
      obj = obj || new FieldsFilter();
      if (data.hasOwnProperty('include')) {
          obj.include = data.include
      }
      if (data.hasOwnProperty('exclude')) {
          obj.exclude = data.exclude
      }
    }
    return obj;
  }
}





;// CONCATENATED MODULE: ./src/common/iServer/Sortby.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


/**
 * @class Sortby
 * @deprecatedclass SuperMap.Sortby
 * @classdesc 通过指定字段进行排序的方法类。
 * @category BaseTypes Util
 * @param {Object} options - 参数。
 * @param {string} options.field 属性名称。
 * @param {Sortby.Direction} options.direction 排序规则，默认升序。
 * @usage
 */
class Sortby {
  constructor(options) {
    /**
     * @description 属性名称。
     * @member {string} Sortby.prototype.field
     */
    this.field = undefined;
    /**
     * @description 排序规则。
     * @member {Sortby.Direction} Sortby.prototype.direction
     * @default Sortby.Direction.ASC
     */
    this.direction = Sortby.Direction.ASC;

    this.CLASS_NAME = 'SuperMap.Sortby';
    Util_Util.extend(this, options);
  }

  /**
   * @function Sortby.prototype.destroy
   * @description 释放资源，将引用资源的属性置空。
   */
  destroy() {
    var me = this;
    me.field = undefined;
    me.direction = 'ASC';
  }

  /**
   * @function Sortby.prototype.constructFromObject
   * @description 目标对象新增该类的可选参数。
   * @param {Object} data 要转换的数据。
   * @param {Sortby} obj 返回的模型。
   * @return {Sortby} 返回结果。
   */
  static constructFromObject(data, obj) {
    if (data) {
      obj = obj || new Sortby();
      if (data.hasOwnProperty('field')) {
        obj.field = data.field;
      }
      if (data.hasOwnProperty('direction')) {
        obj.direction = data.direction;
      }
    }
    return obj;
  }
}
/**
 * @enum Direction
 * @description 排序的类型枚举。
 * @memberOf Sortby
 * @readonly
 * @type {string}
 */
Sortby.Direction = {
  /** 升序。 */
  ASC: 'ASC',
  /** 降序。 */
  DESC: 'DESC'
};

;// CONCATENATED MODULE: ./src/common/iServer/ImageSearchParameter.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/





/**
 * @class ImageSearchParameter
 * @deprecatedclass SuperMap.ImageSearchParameter
 * @classdesc 影像服务查询参数类。
 * @category iServer Image
 * @param {Object} options - 可选参数。
 * @param {Array.<number>} [options.bbox] 指定查询范围。只有具有几何对象（geometry）属性的Features，并且该几何对象与该参数指定的范围相交的 Features 才会被选择出来。该参数可以包含4个数值或者6个数值，这取决于使用的坐标参考系统是否包含高程值：  * 左下角坐标轴 1 的值 * 左下角坐标轴 2 的值 * 坐标轴 3 的最小值（可选） * 右上角坐标轴 1 的值 * 右上角坐标轴 2 的值 * 坐标轴 3 的最大值（可选）  坐标参考系统为 WGS 84 经度/纬度 (http://www.opengis.net/def/crs/OGC/1.3/CRS84)。对于 “WGS 84 经度/纬度” 坐标参考系统，该参数值的格式通常为：最小经度,最小纬度,最大经度,最大纬度。如果包含了高程值，该参数的格式为：最小经度,最小纬度,最小高程值,最大经度,最大纬度,最大高程值。如果一个 Feature 具有多个空间几何对象（geometry）属性，由服务器决定是否使用单一的空间几何对象属性，还是使用所有相关的几何对象作为最终的查询空间范围。
 * @param {Array.<string>} [options.collections] 影像集合的ID数组，将在该指定的Collection中搜索Items。
 * @param {Array.<string>} [options.ids] 只返回指定 Item 的 ID 数组中的Item。返回的 Item 的 ID 值数组。设置了该参数，所有其他过滤器参数（除了next和limit）将被忽略。
 * @param {number} [options.limit] 返回的最大结果数，即响应文档包含的 Item 的数目。
 * @param {FieldsFilter} [options.fields] 通过‘include’和‘exclude’属性分别指定哪些字段包含在查询结果的 Feature 描述中，哪些需要排除。返回结果中的stac_version，id，bbox，assets，links，geometry，type，properties这些字段为必须字段，若要返回结果中不含这种字段信息，需要显示地进行排除设置，如：排除geometry和bbox字段；在POST请求中，则需要将这些字段添加到“exclude”字段中，例如： "fields": { "exclude": ["geometry","bbox"] } } 。而对于返回的“properties”对象中的扩展字段内容，可以将字段前添加到‘include’字段中，如： "fields": { "include": ["properties.SmFileName","properties.SmHighPS"] } ，表示properties.SmFileName和properties.SmHighPS 属性都包含在查询结果中。
 * @param {Object} [options.query] 定义查询哪些属性，查询运算符将应用于这些属性。运算符包括：eq、neq、gt、lt、gte、lte、startsWith、endsWith、contains、in。其中in是Array.<string>类型，例如：{ "SmFileName": { "eq":"B49C001002.tif" }}
 * @param {Array.<Sortby>} [options.sortby] 由包含属性名称和排序规则的对象构成的数组。
 * @usage
 */
class ImageSearchParameter {
    constructor(options) {
        /**
         * @description 指定查询范围。只有具有几何对象（geometry）属性的Features，并且该几何对象与该参数指定的范围相交的 Features 才会被选择出来该参数可以包含4个数值或者6个数值，这取决于使用的坐标参考系统是否包含高程值：  * 左下角坐标轴 1 的值 * 左下角坐标轴 2 的值 * 坐标轴 3 的最小值（可选） * 右上角坐标轴 1 的值 * 右上角坐标轴 2 的值 * 坐标轴 3 的最大值（可选）  坐标参考系统为 WGS 84 经度/纬度 (http://www.opengis.net/def/crs/OGC/1.3/CRS84).  对于 “WGS 84 经度/纬度” 坐标参考系统，该参数值的格式通常为：最小经度,最小纬度,最大经度,最大纬度。如果包含了高程值，该参数的格式为：最小经度,最小纬度,最小高程值,最大经度,最大纬度,最大高程值。如果一个 Feature 具有多个空间几何对象（geometry）属性，由服务器决定是否使用单一的空间几何对象属性，还是使用所有相关的几何对象作为最终的查询空间范围。
         * @member {Array.<number>} ImageSearchParameter.prototype.bbox
         */
        this.bbox = undefined;
        /**
         * @description 影像集合的ID数组，将在该指定的Collection中搜索Items。
         * @member {Array.<string>} ImageSearchParameter.prototype.collections
         */
        this.collections = undefined;
        /**
         * @description 返回的 Item 的 ID 值数组。设置了该参数，所有其他过滤器参数（除了next和limit）将被忽略。
         * @member {Array.<string>} ImageSearchParameter.prototype.ids
         */
        this.ids = undefined;
        /**
         * @description 单页返回的最大结果数。最小值为1，最大值为10000。
         * @member {number} ImageSearchParameter.prototype.limit
         */
        this.limit = undefined;
        /**
         * @description 通过‘include’和‘exclude’属性分别指定哪些字段包含在查询结果的 Feature 描述中，哪些需要排除。返回结果中的stac_version，id，bbox，assets，links，geometry，type，properties这些字段为必须字段，若要返回结果中不含这种字段信息，需要显示地进行排除设置，如：排除geometry和bbox字段；在POST请求中，则需要将这些字段添加到“exclude”字段中，例如： "fields": { "exclude": ["geometry","bbox"] } } 。而对于返回的“properties”对象中的扩展字段内容，可以将字段前添加到‘include’字段中，如： "fields": { "include": ["properties.SmFileName","properties.SmHighPS"] } } ，表示properties.SmFileName和properties.SmHighPS 属性都包含在查询结果中。
         * @member {FieldsFilter} ImageSearchParameter.prototype.fields
         */
        this.fields = undefined;
        /**
         * @description 定义查询哪些属性，查询运算符将应用于这些属性。
         * @member {Object} ImageSearchParameter.prototype.query
         */
        this.query = undefined;
        /**
         * @description 由包含属性名称和排序规则的对象构成的数组。
         * @member {Array.<Sortby>} ImageSearchParameter.prototype.sortby
         */
        this.sortby = undefined;

        this.CLASS_NAME = 'SuperMap.ImageSearchParameter';
        Util_Util.extend(this, options);
    }

    /**
     * @function ImageSearchParameter.prototype.destroy
     * @description 释放资源，将引用资源的属性置空。
     */
    destroy() {
        var me = this;
        me.bbox = undefined;
        me.collections = undefined;
        me.ids = undefined;
        me.limit = undefined;
        me.fields = undefined;
        me.query = undefined;
        me.sortby = undefined;
    }

    /**
     * @function ImageSearchParameter.prototype.constructFromObject
     * @description 目标对象新增该类的可选参数。
     * @param {Object} data 要转换的数据。
     * @param {ImageSearchParameter} obj 返回的模型。
     * @return {ImageSearchParameter} 返回结果。
     */
    static constructFromObject(data, obj) {
        if (data) {
            obj = obj || new ImageSearchParameter();
            if (data.hasOwnProperty('bbox')) {
                obj.bbox = data.bbox;
            }
            if (data.hasOwnProperty('collections')) {
                obj.collections = data.collections;
            }
            if (data.hasOwnProperty('ids')) {
                obj.ids = data.ids;
            }
            if (data.hasOwnProperty('limit')) {
                obj.limit = data.limit;
            }
            if (data.hasOwnProperty('fields')) {
                obj.fields = (FieldsFilter.constructFromObject && FieldsFilter.constructFromObject(data.fields, {})) || data.fields;
            }
            if (data.hasOwnProperty('query')) {
                obj.query = data.query;
            }
            if (data.hasOwnProperty('sortby')) {
                obj.sortby = data.sortby;
                if (data.sortby) {
                    obj.sortby = data.sortby.map((item) => {
                        return (Sortby.constructFromObject && Sortby.constructFromObject(item, {})) || item;
                    });
                }
            }
        }
        return obj;
    }
}

;// CONCATENATED MODULE: ./src/common/iServer/ImageStretchOption.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/



/**
 * @class ImageStretchOption
 * @deprecatedclass SuperMap.ImageStretchOption
 * @classdesc 影像拉伸类。
 * @category iServer Image
 * @param {Object} options - 可选参数。
 * @param {ImageStretchOption.StretchType} [options.stretchType] 影像拉伸类型。该属性的值有以下几种情况：NONE，无拉伸；GAUSSIAN，高斯拉伸；PERCENTCLIP，百分比截断拉伸；MINIMUMMAXIMUM，最值拉伸；STANDARDDEVIATION，标准差拉伸。
 * @param {number} [options.stdevCoefficient] 标准差系数。
 * @param {number} [options.gaussianCoefficient] 高斯系数。
 * @param {boolean} [options.useMedianValue] 高斯拉伸时，是否使用中间值，若该属性值为true，表示使用中间值；false，表示使用平均值。
 * @param {number} [options.minPercent] 使用百分比截断拉伸时，排除影像直方图最低值区域的像元，该参数值为这部分像元占总像元百分比。
 * @param {number} [options.maxPercent] 使用百分比截断拉伸时，排除影像直方图最高值区域的像元，该参数值为这部分像元占总像元百分比。
 * @usage
 */
class ImageStretchOption {
  constructor(options) {
    /**
     * @description 影像拉伸类型。该属性的值有以下几种情况：NONE，无拉伸；GAUSSIAN，高斯拉伸；PERCENTCLIP，百分比截断拉伸；MINIMUMMAXIMUM，最值拉伸；STANDARDDEVIATION，标准差拉伸。
     * @member {ImageStretchOption.StretchType} ImageStretchOption.prototype.stretchType
     */
    this.stretchType = undefined;
    /**
     * @description 标准差系数。
     * @member {number} ImageStretchOption.prototype.stdevCoefficient
     */
    this.stdevCoefficient = undefined;
    /**
     * @description 高斯系数。
     * @member {number} ImageStretchOption.prototype.gaussianCoefficient
     */
    this.gaussianCoefficient = undefined;
    /**
     * @description 高斯拉伸时，是否使用中间值，若该属性值为true，表示使用中间值；false，表示使用平均值。
     * @member {boolean} ImageStretchOption.prototype.useMedianValue
     */
    this.useMedianValue = undefined;
    /**
     * @description 使用百分比截断拉伸时，排除影像直方图最低值区域的像元，该参数值为这部分像元占总像元百分比。
     * @member {number} ImageStretchOption.prototype.minPercent
     */
    this.minPercent = undefined;
    /**
     * @description 使用百分比截断拉伸时，排除影像直方图最高值区域的像元，该参数值为这部分像元占总像元百分比。
     * @member {number} ImageStretchOption.prototype.maxPercent
     */
    this.maxPercent = undefined;

    this.CLASS_NAME = 'SuperMap.ImageStretchOption';
    Util_Util.extend(this, options);
  }

  /**
   * @function ImageStretchOption.prototype.destroy
   * @description 释放资源，将引用资源的属性置空。
   */
  destroy() {
    var me = this;
    me.stretchType = undefined;
    me.stdevCoefficient = undefined;
    me.gaussianCoefficient = undefined;
    me.useMedianValue = undefined;
    me.minPercent = undefined;
    me.maxPercent = undefined;
  }

  /**
   * @function ImageStretchOption.prototype.constructFromObject
   * @description 目标对象新增该类的可选参数。
   * @param {Object} data 要转换的数据。
   * @param {ImageStretchOption} obj 返回的模型。
   * @return {ImageStretchOption} 返回结果。
   */
  static constructFromObject(data, obj) {
    if (data) {
      obj = obj || new ImageStretchOption();
      if (data.hasOwnProperty('stretchType')) {
        obj.stretchType = data.stretchType;
      }
      if (data.hasOwnProperty('stdevCoefficient')) {
        obj.stdevCoefficient = data.stdevCoefficient;
      }
      if (data.hasOwnProperty('gaussianCoefficient')) {
        obj.gaussianCoefficient = data.gaussianCoefficient;
      }
      if (data.hasOwnProperty('useMedianValue')) {
        obj.useMedianValue = data.useMedianValue;
      }
      if (data.hasOwnProperty('minPercent')) {
        obj.minPercent = data.minPercent;
      }
      if (data.hasOwnProperty('maxPercent')) {
        obj.maxPercent = data.maxPercent;
      }
    }
    return obj;
  }
}
/**
 * @enum StretchType
 * @description 影像拉伸类型枚举。
 * @memberOf ImageStretchOption
 * @readonly
 * @type {string}
 */
ImageStretchOption.StretchType = {
  /** 无拉伸。 */
  NONE: 'NONE',
  /** 高斯拉伸。 */
  GAUSSIAN: 'GAUSSIAN',
  /** 百分比截断拉伸。 */
  PERCENTCLIP: 'PERCENTCLIP',
  /** 最值拉伸。 */
  MINIMUMMAXIMUM: 'MINIMUMMAXIMUM',
  /** 标准差拉伸。 */
  STANDARDDEVIATION: 'STANDARDDEVIATION'
};

;// CONCATENATED MODULE: ./src/common/iServer/ImageRenderingRule.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/




/**
 * @class ImageRenderingRule
 * @deprecatedclass SuperMap.ImageRenderingRule
 * @classdesc 定义请求的影像如何进行渲染或者处理，如：影像的拉伸显示方式、颜色表、波段组合以及应用栅格函数进行快速处理等。
 * @category iServer Image
 * @param {Object} options - 可选参数。
 * @param {ImageRenderingRule.DisplayMode} [options.displayMode] 影像显示模式，其中：Composite表示多波段组合显示；Stretched表示单波段拉伸显示。
 * @param {string} [options.displayBands] 影像显示的波段或者波段组合。若影像的显示模式为STRETCHED，该属性指定一个波段的索引号(波段索引号从0开始计数)；若影像的显示模式为COMPOSITE，该属性为组合的波段索引号，例如：属性值3,2,1表示采用4波段、3波段、2波段分别对应 R、G、B颜色通道进行组合显示。
 * @param {ImageStretchOption} [options.stretchOption] 影像的拉伸参数。
 * @param {ImageRenderingRule.InterpolationMode} [options.interpolationMode] 影像显示时使用的插值算法。
 * @param {Array.<string>} [options.colorScheme] 影像拉伸显示的颜色方案。颜色方案为RGBA颜色数组。RGBA是代表Red（红色）Green（绿色）Blue（蓝色）和Alpha的色彩空间。Alpha值可以省略不写，表示完全不透明。Alpha通道表示不透明度参数，若该值为0表示完全透明。例如："255,0,0","0,255,0","0,0,255" 表示由红色、绿色、蓝色三种颜色构成的色带。
 * @param {Array.<string>} [options.colorTable] 影像的颜色表。颜色表为栅格值与RGBA颜色值的对照表。RGBA是代表Red（红色）Green（绿色）Blue（蓝色）和Alpha的色彩空间。Alpha值可以省略不写，表示完全不透明。Alpha通道表示不透明度参数，若该值为0表示完全透明。以下示例表示该颜色对照表由三组构成，第一组高程值为500，对应的颜色为红色；第二组高程值为700，对应的颜色为绿色；第三组高程值为700，对应的颜色为蓝色。示例："500: 255,0,0", "700: 0,255,0" , "900: 0,0,255"。
 * @param {number} [options.brightness] 影像显示的亮度。数值范围为-100到100，增加亮度为正，降低亮度为负。
 * @param {number} [options.contrast] 影像显示的对比度。数值范围为-100到100，增加对比度为正，降低对比度为负。
 * @param {string} [options.noData] 影像的无值。影像为多波段时，通过逗号分隔 R,G,B 颜色通道对应波段的无值。
 * @param {string} [options.noDataColor] 影像的无值的显示颜色，支持RGB颜色，例如：255,0,0（红色），那么无值将以指定的红色显示。
 * @param {boolean} [options.noDataTransparent] 无值是否透明显示，true表示透明显示无值；否则为false。
 * @param {string} [options.backgroundValue] 影像的背景值。影像为多波段时，通过逗号分隔 R,G,B 颜色通道对应波段的背景值。
 * @param {string} [options.backgroundColor] 指定背景值的颜色。支持指定RGB颜色，例如：255,0,0（红色），那么背景值将以指定的红色显示。
 * @param {boolean} [options.backgroundTransparent] 背景值是否透明显示，true表示透明显示背景值；否则为false。
 * @param {Array.<ImageGFHillShade|ImageGFSlope|ImageGFAspect|ImageGFOrtho>} [options.gridFunctions] 栅格函数链。
 * @usage
 */
class ImageRenderingRule {
  constructor(options) {
    /**
     * @description 影像显示模式，其中：Composite表示多波段组合显示；Stretched表示单波段拉伸显示。
     * @member {ImageRenderingRule.DisplayMode} ImageRenderingRule.prototype.displayMode
     */
    this.displayMode = undefined;
    /**
     * @description 影像显示的波段或者波段组合。该参数为一个数组，数组元素为波段索引号。若影像的显示模式为Stretched，该属性指定一个显示的波段；若影像的显示模式为Composite，该属性为组合的波段索引号，例如：属性值4,3,2表示采用4波段、3波段、2波段分别对应 R、G、B颜色通道进行组合显示。
     * @member {string} ImageRenderingRule.prototype.displayBands
     */
    this.displayBands = undefined;
    /**
     * @description 影像的拉伸参数。
     * @member {ImageStretchOption} ImageRenderingRule.prototype.stretchOption
     */
    this.stretchOption = undefined;
    /**
     * @description 影像显示时使用的插值算法。
     * @member {ImageRenderingRule.InterpolationMode} ImageRenderingRule.prototype.interpolationMode
     */
    this.interpolationMode = undefined;
    /**
     * @description 影像拉伸显示的颜色方案。颜色方案为RGBA颜色数组。RGBA是代表Red（红色）Green（绿色）Blue（蓝色）和Alpha的色彩空间。Alpha值可以省略不写，表示完全不透明。Alpha通道表示不透明度参数，若该值为0表示完全透明。例如："255,0,0","0,255,0","0,0,255" 表示由红色、绿色、蓝色三种颜色构成的色带。
     * @member {Array.<string>} ImageRenderingRule.prototype.colorScheme
     */
    this.colorScheme = undefined;
    /**
     * @description 影像的颜色表。颜色表为栅格值与RGBA颜色值的对照表。RGBA是代表Red（红色）Green（绿色）Blue（蓝色）和Alpha的色彩空间。Alpha值可以省略不写，表示完全不透明。Alpha通道表示不透明度参数，若该值为0表示完全透明。以下示例表示该颜色对照表由三组构成，第一组高程值为500，对应的颜色为红色；第二组高程值为700，对应的颜色为绿色；第三组高程值为700，对应的颜色为蓝色。示例："500: 255,0,0", "700: 0,255,0" , "900: 0,0,255"
     * @member {Array.<string>} ImageRenderingRule.prototype.colorTable
     */
    this.colorTable = undefined;
    /**
     * @description 影像显示的亮度。数值范围为-100到100，增加亮度为正，降低亮度为负。
     * @member {number} ImageRenderingRule.prototype.brightness
     */
    this.brightness = undefined;
    /**
     * @description 影像显示的对比度。数值范围为-100到100，增加对比度为正，降低对比度为负。
     * @member {number} ImageRenderingRule.prototype.contrast
     */
    this.contrast = undefined;
    /**
     * @description 影像的无值。影像为多波段时，通过逗号分隔 R,G,B 颜色通道对应波段的无值。
     * @member {string} ImageRenderingRule.prototype.noData
     */
    this.noData = undefined;
    /**
     * @description 影像的无值的显示颜色，支持RGB颜色，例如：255,0,0（红色），那么无值将以指定的红色显示。
     * @member {string} ImageRenderingRule.prototype.noDataColor
     */
    this.noDataColor = undefined;
    /**
     * @description 无值是否透明显示，true表示透明显示无值；否则为false。
     * @member {boolean} ImageRenderingRule.prototype.noDataTransparent
     */
    this.noDataTransparent = undefined;

    /**
     * @description 影像的背景值。影像为多波段时，通过逗号分隔 R,G,B 颜色通道对应波段的背景值。
     * @member {string} ImageRenderingRule.prototype.backgroundValue
     */
    this.backgroundValue = undefined;
    /**
     * @description 指定背景值的颜色。支持指定RGB颜色，例如：255,0,0（红色），那么背景值将以指定的红色显示。
     * @member {string} ImageRenderingRule.prototype.backgroundColor
     */
    this.backgroundColor = undefined;
    /**
     * @description 背景值是否透明显示，true表示透明显示背景值；否则为false。
     * @member {boolean} ImageRenderingRule.prototype.backgroundTransparent
     */
    this.backgroundTransparent = undefined;
    /**
     * @description 栅格函数选项，通过应用栅格函数，可以对影像进行快速显示处理。
     * @member {Array.<ImageGFHillShade|ImageGFSlope|ImageGFAspect|ImageGFOrtho>} ImageRenderingRule.prototype.gridFunctions
     */
    this.gridFunctions = undefined;

    this.CLASS_NAME = 'SuperMap.ImageRenderingRule';
    Util_Util.extend(this, options);
  }

  /**
   * @function ImageRenderingRule.prototype.destroy
   * @description 释放资源，将引用资源的属性置空。
   */
  destroy() {
    var me = this;
    me.displayMode = undefined;
    me.displayBands = undefined;
    me.stretchOption = undefined;
    me.interpolationMode = undefined;
    me.colorScheme = undefined;
    me.colorTable = undefined;
    me.brightness = undefined;
    me.contrast = undefined;
    me.noData = undefined;
    me.noDataColor = undefined;
    me.noDataTransparent = undefined;
    me.backgroundValue = undefined;
    me.backgroundColor = undefined;
    me.backgroundTransparent = undefined;
    me.gridFuncOptions = undefined;
  }

  /**
   * @function ImageRenderingRule.prototype.constructFromObject
   * @description 目标对象新增该类的可选参数。
   * @param {Object} data 要转换的数据。
   * @param {ImageRenderingRule} obj 返回的模型。
   * @return {ImageRenderingRule} 返回结果。
   */
  static constructFromObject(data, obj) {
    if (data) {
      obj = obj || new ImageRenderingRule();
      if (data.hasOwnProperty('displayMode')) {
        obj.displayMode = data.displayMode;
      }
      if (data.hasOwnProperty('displayBands')) {
        obj.displayBands = data.displayBands;
      }
      if (data.hasOwnProperty('stretchOption')) {
        obj.stretchOption =
          (ImageStretchOption.constructFromObject && ImageStretchOption.constructFromObject(data.stretchOption, {})) ||
          data.stretchOption;
      }
      if (data.hasOwnProperty('interpolationMode')) {
        obj.interpolationMode = data.interpolationMode;
      }
      if (data.hasOwnProperty('colorScheme')) {
        obj.colorScheme = data.colorScheme;
      }
      if (data.hasOwnProperty('colorTable')) {
        obj.colorTable = data.colorTable;
      }
      if (data.hasOwnProperty('brightness')) {
        obj.brightness = data.brightness;
      }
      if (data.hasOwnProperty('contrast')) {
        obj.contrast = data.contrast;
      }
      if (data.hasOwnProperty('noData')) {
        obj.noData = data.noData;
      }
      if (data.hasOwnProperty('noDataColor')) {
        obj.noDataColor = data.noDataColor;
      }
      if (data.hasOwnProperty('backgroundValue')) {
        obj.backgroundValue = data.backgroundValue;
      }
      if (data.hasOwnProperty('noDataTransparent')) {
        obj.noDataTransparent = data.noDataTransparent;
      }
      if (data.hasOwnProperty('backgroundColor')) {
        obj.backgroundColor = data.backgroundColor;
      }
      if (data.hasOwnProperty('backgroundTransparent')) {
        obj.backgroundTransparent = data.backgroundTransparent;
      }
      if (data.hasOwnProperty('gridFunctions')) {
        obj.gridFunctions = data.gridFunctions;
      }
    }
    return obj;
  }
}

/**
 * @enum DisplayMode
 * @description 影像显示模式。
 * @memberOf ImageRenderingRule
 * @readonly
 * @type {string}
 */
ImageRenderingRule.DisplayMode = {
  COMPOSITE: 'COMPOSITE',
  STRETCHED: 'Stretched'
};

/**
 * @enum InterpolationMode
 * @description 影像显示时使用的插值算法枚举。
 * @memberOf ImageRenderingRule
 * @readonly
 * @type {string}
 */
ImageRenderingRule.InterpolationMode = {
  /** 最邻近插值模式。 */
  NEARESTNEIGHBOR: 'NEARESTNEIGHBOR',
  /** 高质量的双线性插值模式。 */
  HIGHQUALITYBILINEAR: 'HIGHQUALITYBILINEAR',
  /** 默认插值模式。 */
  DEFAULT: 'DEFAULT'
};

;// CONCATENATED MODULE: ./src/common/iServer/ImageGFHillShade.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/




/**
 * @class ImageGFHillShade
 * @deprecatedclass SuperMap.ImageGFHillShade
 * @classdesc 栅格函数对象：对DEM数据生成三维晕渲图。
 * @category iServer Image
 * @param {Object} options - 可选参数。
 * @param {string} [options.girdFuncName='GFHillShade'] 栅格函数名称，参数值为：GFHillShade。
 * @param {number} [options.Azimuth = 315] 光源方位角。用于确定光源的方向，是从光源所在位置的正北方向线起，依顺时针方向到光源与目标方向线的夹角，范围为 0-360 度，以正北方向为 0 度，依顺时针方向递增。默认值为：315。
 * @param {number} [options.Altitude = 45] 光源高度角。用于确定光源照射的倾斜角度，是光源与目标的方向线与水平面间的夹角，范围为 0-90 度。当光源高度角为 90 度时，光源正射地表。默认值为：45。
 * @param {number} [options.ZFactor = 1] 高程缩放系数。如果设置为 1.0，表示不缩放。默认值为：1。
 * @usage
*/
class ImageGFHillShade {
  constructor(options) {
    /**
    * @description 栅格函数名称，参数值为：GFHillShade。
    * @member {string} ImageGFHillShade.prototype.girdFuncName
    * @default 'GFHillShade'
    */
    this.girdFuncName = 'GFHillShade';
    /**
    * @description 光源方位角。用于确定光源的方向，是从光源所在位置的正北方向线起，依顺时针方向到光源与目标方向线的夹角，范围为 0-360 度，以正北方向为 0 度，依顺时针方向递增。默认值为：315。
    * @member {number} ImageGFHillShade.prototype.Azimuth
    */
    this.Azimuth = 315;
    /**
    * @description 光源高度角。用于确定光源照射的倾斜角度，是光源与目标的方向线与水平面间的夹角，范围为 0-90 度。当光源高度角为 90 度时，光源正射地表。默认值为：45。
    * @member {number} ImageGFHillShade.prototype.Altitude
    */
    this.Altitude = 45;
    /**
    * @description 高程缩放系数。如果设置为 1.0，表示不缩放。默认值为：1。
    * @member {number} ImageGFHillShade.prototype.ZFactor
    */
    this.ZFactor = 1;

    this.CLASS_NAME = 'SuperMap.ImageGFHillShade';
    Util_Util.extend(this, options);

  }

  /**
  * @function ImageGFHillShade.prototype.destroy
  * @description 释放资源，将引用资源的属性置空。
  */
  destroy() {
    var me = this;
    me.girdFuncName = 'GFHillShade';
    me.Azimuth = 315;
    me.Altitude = 45;
    me.ZFactor = 1;
  }

  /**
  * @function ImageGFHillShade.prototype.constructFromObject
  * @description 目标对象新增该类的可选参数。
  * @param {Object} data 要转换的数据。
  * @param {ImageGFHillShade} obj 返回的模型。
  * @return {ImageGFHillShade} 返回结果。
  */
  static constructFromObject(data, obj) {
    if (data) {
      obj = obj || new ImageGFHillShade();
      if (data.hasOwnProperty('girdFuncName')) {
          obj.girdFuncName = data.girdFuncName
      }
      if (data.hasOwnProperty('Azimuth')) {
          obj.Azimuth = data.Azimuth
      }
      if (data.hasOwnProperty('Altitude')) {
          obj.Altitude = data.Altitude
      }
      if (data.hasOwnProperty('ZFactor')) {
          obj.ZFactor = data.ZFactor
      }
    }
    return obj;
  }
}





;// CONCATENATED MODULE: ./src/common/iServer/ImageGFAspect.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


/**
 * @class ImageGFAspect
 * @deprecatedclass SuperMap.ImageGFAspect
 * @classdesc 栅格函数对象：对DEM数据生成坡向渲图。
 * @category iServer Image
 * @param {Object} options -可选参数。
 * @param {string} [options.girdFuncName='GFAspect'] 栅格函数名称，参数值为：GFAspect。
 * @param {number} [options.Azimuth] 光源方位角，固定为360度。
 * @usage
*/
class ImageGFAspect {
  constructor(options) {
    /**
    * @description 栅格函数名称，参数值为：GFAspect。
    * @member {string} ImageGFAspect.prototype.girdFuncName
    * @default 'GFAspect'
    */
    this.girdFuncName = 'GFAspect';
    /**
    * @description 光源方位角，固定为360度。
    * @member {number} ImageGFAspect.prototype.Azimuth
    */
    this.Azimuth = undefined;

    this.CLASS_NAME = 'SuperMap.ImageGFAspect';
    Util_Util.extend(this, options);

  }

  /**
  * @function ImageGFAspect.prototype.destroy
  * @description 释放资源，将引用资源的属性置空。
  */
  destroy() {
    var me = this;
    me.girdFuncName = 'GFAspect';
    me.Azimuth = undefined;
  }

  /**
  * @function ImageGFAspect.prototype.constructFromObject
  * @description 目标对象新增该类的可选参数。
  * @param {Object} data 要转换的数据。
  * @param {ImageGFAspect} obj 返回的模型。
  * @return {ImageGFAspect} 返回结果。
  */
  static constructFromObject(data, obj) {
    if (data) {
      obj = obj || new ImageGFAspect();
      if (data.hasOwnProperty('girdFuncName')) {
          obj.girdFuncName = data.girdFuncName
      }
      if (data.hasOwnProperty('Azimuth')) {
          obj.Azimuth = data.Azimuth
      }
    }
    return obj;
  }
}





;// CONCATENATED MODULE: ./src/common/iServer/ImageGFOrtho.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


/**
 * @class ImageGFOrtho
 * @deprecatedclass SuperMap.ImageGFOrtho
 * @classdesc 栅格函数对象：对DEM数据生成三维晕渲图。该栅格函数不需要输入参数，采用系统默认设置。
 * @category iServer Image
 * @param {Object} options - 可选参数。
 * @param {string} [options.girdFuncName='GFOrtho'] 栅格函数名称，参数值为：GFOrtho。
 * @usage
*/
class ImageGFOrtho {
  constructor(options) {
    /**
    * @description 栅格函数名称，参数值为：GFOrtho。
    * @member {string} ImageGFOrtho.prototype.girdFuncName
    * @default 'GFOrtho'
    */
    this.girdFuncName = 'GFOrtho';

    this.CLASS_NAME = 'SuperMap.ImageGFOrtho';
    Util_Util.extend(this, options);

  }

  /**
  * @function ImageGFOrtho.prototype.destroy
  * @description 释放资源，将引用资源的属性置空。
  */
  destroy() {
    var me = this;
    me.girdFuncName = 'GFOrtho';
  }

  /**
  * @function ImageGFOrtho.prototype.constructFromObject
  * @description 目标对象新增该类的可选参数。
  * @param {Object} data 要转换的数据。
  * @param {ImageGFOrtho} obj 返回的模型。
  * @return {ImageGFOrtho} 返回结果。
  */
  static constructFromObject(data, obj) {
    if (data) {
      obj = obj || new ImageGFOrtho();
      if (data.hasOwnProperty('girdFuncName')) {
          obj.girdFuncName = data.girdFuncName
      }
    }
    return obj;
  }
}



;// CONCATENATED MODULE: ./src/common/iServer/ImageGFSlope.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/




/**
 * @class ImageGFSlope
 * @deprecatedclass SuperMap.ImageGFSlope
 * @classdesc 栅格函数对象：对DEM数据生成坡度图。
 * @category iServer Image
 * @param {Object} options - 可选参数。
 * @param {string} [options.girdFuncName='GFSlope'] 栅格函数名称，参数值为：GFSlope。
 * @param {number} [options.Altitude = 45] 光源高度角。用于确定光源照射的倾斜角度，是光源与目标的方向线与水平面间的夹角，范围为 0-90 度。当光源高度角为 90 度时，光源正射地表。默认值为：45。
 * @param {number} [options.ZFactor = 1] 高程缩放系数。如果设置为 1.0，表示不缩放。默认值为：1。
 * @usage
*/
class ImageGFSlope {
  constructor(options) {
    /**
    * @description 栅格函数名称，参数值为：GFSlope。
    * @member {string} ImageGFSlope.prototype.girdFuncName
    * @default 'GFSlope'
    */
    this.girdFuncName = 'GFSlope';
    /**
    * @description 光源高度角。用于确定光源照射的倾斜角度，是光源与目标的方向线与水平面间的夹角，范围为 0-90 度。当光源高度角为 90 度时，光源正射地表。默认值为：45。
    * @member {number} ImageGFSlope.prototype.Altitude
    */
    this.Altitude = 45;
    /**
    * @description 高程缩放系数。如果设置为 1.0，表示不缩放。默认值为：1。
    * @member {number} ImageGFSlope.prototype.ZFactor
    */
    this.ZFactor = 1;

    this.CLASS_NAME = 'SuperMap.ImageGFSlope';
    Util_Util.extend(this, options);

  }

  /**
  * @function ImageGFSlope.prototype.destroy
  * @description 释放资源，将引用资源的属性置空。
  */
  destroy() {
    var me = this;
    me.girdFuncName = 'GFSlope';
    me.Altitude = 45;
    me.ZFactor = 1;
  }

  /**
  * @function ImageGFSlope.prototype.constructFromObject
  * @description 目标对象新增该类的可选参数。
  * @param {Object} data 要转换的数据。
  * @param {ImageGFSlope} obj 返回的模型。
  * @return {ImageGFSlope} 返回结果。
  */
  static constructFromObject(data, obj) {
    if (data) {
      obj = obj || new ImageGFSlope();
      if (data.hasOwnProperty('girdFuncName')) {
          obj.girdFuncName = data.girdFuncName
      }
      if (data.hasOwnProperty('Altitude')) {
          obj.Altitude = data.Altitude
      }
      if (data.hasOwnProperty('ZFactor')) {
          obj.ZFactor = data.ZFactor
      }
    }
    return obj;
  }
}





;// CONCATENATED MODULE: ./src/common/iServer/KnowledgeGraphNodeParameter.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


/**
 * @private
 * @class KnowledgeGraphNodeParameter
 * @deprecatedclass SuperMap.KnowledgeGraphNodeParameter
 * @classdesc 知识图谱实体的参数设置。
 * @category iServer KnowledgeGraph
 * @version 11.1.0
 * @param {Object} options - 参数。
 * @param {string} options.id - 实体id。
 * @param {Array.<string>} [options.labels] - 实体分类。
 * @param {Object} [options.properties] - 属性。
 * @usage
 */
// {
//   "id": 5348024557502471,
//   "properties": {
//     "server": "test1",
//     "_labelfieldname": "FEATUREGUID",
//     "_entityname": "院落",
//     "_bindfindid": "院落@ST_YARDA@1",
//     "FEATUREGUID": "{409E615B-A545-4E07-872D-B12EDA0B4A1A}",
//     "_findid": 1,
//     "ENTITYNAME": "公共管理与公共服务"
//   },
//   "labels": ["院落"]
// }
class KnowledgeGraphNodeParameter {
  constructor(options) {
    /**
     * @member {string} KnowledgeGraphNodeParameter.prototype.id
     * @description 实体ID。
     */
    this.id = null;
    /**
     * @member {Array.<string>} KnowledgeGraphNodeParameter.prototype.labels
     * @description 实体分类。
     */
    this.labels = null;
    /**
     * @member {Object} KnowledgeGraphNodeParameter.prototype.properties
     * @description 实体属性。
     */
    this.properties = null;

    this.CLASS_NAME = 'SuperMap.KnowledgeGraphNodeParameter';
    Util.extend(this, options);
  }

  destroy() {
    var me = this;
    me.id = null;
    me.labels = null;
    me.properties = null;
  }
}

;// CONCATENATED MODULE: ./src/common/iServer/KnowledgeGraphEdgeParameter.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


/**
 * @private
 * @class KnowledgeGraphEdgeParameter
 * @deprecatedclass SuperMap.KnowledgeGraphEdgeParameter
 * @classdesc 知识图谱关系的参数设置。
 * @category iServer KnowledgeGraph
 * @version 11.1.0
 * @param {Object} options - 参数。
 * @param {string} options.id - 边id。
 * @param {string} options.start - 开始实体id。
 * @param {string} options.end - 结束实体id。
 * @param {string} [options.type] - 标签，关系。
 * @param {Object} [options.properties] - 属性。
 * @usage
 */
class KnowledgeGraphEdgeParameter {
  constructor(options) {
    /**
     * @member {string} KnowledgeGraphEdgeParameter.prototype.id
     * @description 边id。
     */
    this.id = null;
    /**
     * @member {string} KnowledgeGraphEdgeParameter.prototype.start
     * @description 开始实体id。
     */
    this.start = null;
    /**
     * @member {string} KnowledgeGraphEdgeParameter.prototype.end
     * @description 结束实体id。
     */
    this.end = null;
    /**
     * @member {string} KnowledgeGraphEdgeParameter.prototype.type
     * @description 标签，关系。
     */
    this.type = null;
    /**
     * @member {Object} KnowledgeGraphEdgeParameter.prototype.properties
     * @description 实体属性。
     */
    this.properties = null;

    this.CLASS_NAME = 'SuperMap.KnowledgeGraphEdgeParameter';
    Util.extend(this, options);
  }

  destroy() {
    var me = this;
    me.id = null;
    me.start = null;
    me.end = null;
    me.type = null;
    me.properties = null;
  }
}

;// CONCATENATED MODULE: ./src/common/iServer/index.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/

























































































































































































































































































































































































































































































































































;// CONCATENATED MODULE: ./src/common/online/OnlineResources.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/

/**
 * @enum ServiceStatus
 * @category BaseTypes Constant
 * @description 服务发布状态。
 * @usage
 * ```
 * // 浏览器
 * <script type="text/javascript" src="{cdn}"></script>
 * <script>
 *   const result = {namespace}.ServiceStatus.DOES_NOT_INVOLVE;
 *
 * </script>
 * // ES6 Import
 * import { ServiceStatus } from '{npm}';
 *
 * const result = ServiceStatus.DOES_NOT_INVOLVE;
 * ```
 */
var ServiceStatus = {
    /** 不涉及，不可发布。 */
    DOES_NOT_INVOLVE: "DOES_NOT_INVOLVE",
    /** 发布失败。 */
    PUBLISH_FAILED: "PUBLISH_FAILED",
    /** 已发布。 */
    PUBLISHED: "PUBLISHED",
    /** 正在发布。 */
    PUBLISHING: "PUBLISHING",
    /** 未发布。 */
    UNPUBLISHED: "UNPUBLISHED",
    /** 取消服务失败。 */
    UNPUBLISHED_FAILED: "UNPUBLISHED_FAILED"
};


/**
 * @enum DataItemOrderBy
 * @category BaseTypes Constant
 * @description 数据排序字段。
 * @usage
 * ```
 * // 浏览器
 * <script type="text/javascript" src="{cdn}"></script>
 * <script>
 *   const result = {namespace}.DataItemOrderBy.FILENAME;
 *
 * </script>
 * // ES6 Import
 * import { DataItemOrderBy } from '{npm}';
 *
 * const result = DataItemOrderBy.FILENAME;
 * ```
 */
var DataItemOrderBy = {
    /** 文件名。 */
    FILENAME: "FILENAME",
    /** ID。 */
    ID: "ID",
    /** 最后修改时间。 */
    LASTMODIFIEDTIME: "LASTMODIFIEDTIME",
    /** 作者昵称。 */
    NICKNAME: "NICKNAME",
    /** SERVICESTATUS。 */
    SERVICESTATUS: "SERVICESTATUS",
    /** 大小。 */
    SIZE: "SIZE",
    /** 状态。 */
    STATUS: "STATUS",
    /** 类型。 */
    TYPE: "TYPE",
    /** 更新时间。 */
    UPDATETIME: "UPDATETIME",
    /** 作者名。 */
    USERNAME: "USERNAME"
};

/**
 * @enum FilterField {number}
 * @category BaseTypes Constant
 * @description 关键字查询时的过滤字段。
 * @usage
 * ```
 * // 浏览器
 * <script type="text/javascript" src="{cdn}"></script>
 * <script>
 *   const result = {namespace}.FilterField.LINKPAGE;
 *
 * </script>
 * // ES6 Import
 * import { FilterField } from '{npm}';
 *
 * const result = FilterField.LINKPAGE;
 * ```
 */
var FilterField = {
    /** 服务地址。 */
    LINKPAGE: "LINKPAGE",
    /** 服务中包含的地图的名称。 */
    MAPTITLE: "MAPTITLE",
    /** 服务创建者昵称。 */
    NICKNAME: "NICKNAME",
    /** 服务名称。 */
    RESTITLE: "RESTITLE",
    /** 服务创建者用户名。 */
    USERNAME: "USERNAME"
};


;// CONCATENATED MODULE: ./src/common/online/OnlineServiceBase.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/




/**
 * @class OnlineServiceBase
 * @deprecatedclass SuperMap.OnlineServiceBase
 * @classdesc Online 服务基类（使用 key 作为权限限制的类需要实现此类）。
 * @category iPortal/Online Core
 * @param {Object} options - 可选参数。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @usage
 */
class OnlineServiceBase {

    constructor(options) {
        options = options || {};
        Util_Util.extend(this, options);
        this.CLASS_NAME = "SuperMap.OnlineServiceBase";
    }

    /**
     * @function OnlineServiceBase.prototype.request
     * @description 请求 online 服务
     * @param {string} [method='GET'] - 请求方式, 'GET', 'PUT', 'POST', 'DELETE'。
     * @param {string} url - 服务地址。
     * @param {Object} param - URL 查询参数。
     * @param {Object} [requestOptions] - http 请求参数, 比如请求头，超时时间等。
     * @returns {Promise}  包含请求结果的 Promise 对象。
     */
    request(method, url, param, requestOptions = {}) {
        url = SecurityManager.appendCredential(url);
        requestOptions['crossOrigin'] = this.options.crossOrigin;
        requestOptions['headers'] = this.options.headers;
        return FetchRequest.commit(method, url, param, requestOptions).then(function(response) {
            return response.json();
        });
    }


}


;// CONCATENATED MODULE: ./src/common/online/OnlineData.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/



/**
 * @class OnlineData
 * @deprecatedclass SuperMap.OnlineData
 * @classdesc Online myData 服务。
 * @category iPortal/Online Resources Data
 * @param {string} serviceRootUrl - 服务地址。
 * @param {Object} options - 可选参数。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @usage
 * @extends OnlineServiceBase
 */
class OnlineData extends OnlineServiceBase {

    //TODO 目前并没有对接服务支持的所有操作，日后需要补充完整
    constructor(serviceRootUrl, options) {
        super(serviceRootUrl);
        options = options || {};
        //MD5
        this.MD5 = null;
        //文件类型。
        this.type = null;
        //数据上传者名称。
        this.userName = null;
        //文件名称。
        this.fileName = null;
        //文件大小，单位为 B 。
        this.size = null;
        //服务发布状态。
        this.serviceStatus = null;
        //服务 id 。
        this.serviceId = null;
        //数据项 id 。
        this.id = null;
        //最后修改时间。
        this.lastModfiedTime = null;
        //文件状态。
        this.status = null;
        //数据文件存储 id 。
        this.storageId = null;
        //数据的发布信息。
        this.publishInfo = null;
        //数据的权限信息。
        this.authorizeSetting = null;
        //用户的昵称。
        this.nickname = null;
        //数据的标签。
        this.tags = [];
        //数据的描述信息。
        this.description = null;
        //数据发布的服务信息集合。
        this.dataItemServices = null;
        //数据坐标类型。
        this.coordType = null;
        //数据审核信息
        this.dataCheckResult = null;
        //数据元数据信息
        this.dataMetaInfo = null;
        //数据的缩略图路径。
        this.thumbnail = null;

        Util_Util.extend(this, options);
        if (this.id) {
            this.serviceUrl = serviceRootUrl + "/" + this.id;
        }
        this.CLASS_NAME = "SuperMap.OnlineData";
    }

    /**
     * @function OnlineData.prototype.load
     * @description 通过 URL 请求获取该服务完整信息。
     * @returns {Promise} 不包含请求结果的 Promise 对象,请求返回结果自动填充到该类属性中。
     */
    load() {
        if (!this.serviceUrl) {
            return;
        }
        var me = this;
        return me.request("GET", this.serviceUrl).then(function (result) {
            Util_Util.extend(me, result);
        });
    }

    /**
     * @function OnlineData.prototype.getPublishedServices
     * @description 获取数据发布的所有服务。
     * @returns {Object} 数据发布的所有服务。
     */
    getPublishedServices() {
        return this.dataItemServices;
    }

    /**
     * @function OnlineData.prototype.getAuthorizeSetting
     * @description 获取数据的权限信息。
     * @returns {Object} 权限信息。
     */
    getAuthorizeSetting() {
        return this.authorizeSetting;
    }


}


;// CONCATENATED MODULE: ./src/common/online/Online.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/




/**
 * @class Online
 * @deprecatedclass SuperMap.Online
 * @classdesc 对接 SuperMap Online 所有基础服务。
 * @category iPortal/Online Resources
 * @modulecategory Services
 * @example
 * var online=new Online();
 * var services = online.queryDatas(param);
 * service.then(function(services){
 *      var service= services[0];
 *      service.updateDataInfo();
 * })
 * @usage
 */
class Online {

    //TODO 目前并没有对接Online的所有操作，需要补充完整
    //所有查询返回的是一个Promise,在外部使用的时候通过Promise的then方法获取异步结果
    constructor() {
        this.rootUrl = "https://www.supermapol.com";
        this.webUrl = this.rootUrl + "/web";

        var mContentUrl = this.webUrl + "/mycontent";
        this.mDatasUrl = mContentUrl + "/datas";

        this.CLASS_NAME = "SuperMap.Online";
    }

    /**
     * @function Online.prototype.load
     * @description 加载 online，验证 online 是否可用。
     * @returns {Promise} 包含网络请求结果的 Promise 对象。
     */
    load() {
        return FetchRequest.get(this.rootUrl).then(function (response) {
            return response;
        });
    }

    /**
     * @function Online.prototype.login
     * @description 登录Online
     */
    login() {
        SecurityManager.loginOnline(this.rootUrl, true);
    }

    /**
     * @function Online.prototype.queryDatas
     * @description 查询 Online “我的内容” 下 “我的数据” 服务（需要登录状态获取），并返回可操作的服务对象。
     * @param {OnlineQueryDatasParameter} parameter - myDatas 服务资源查询参数。
     * @returns {Promise} 包含所有数据服务信息的 Promise 对象。
     */
    queryDatas(parameter) {
        var me = this, url = me.mDatasUrl;
        if (parameter) {
            parameter = parameter.toJSON();
        }
        return FetchRequest.get(url, parameter).then(function (json) {
            if (!json || !json.content || json.content.length < 1) {
                return;
            }
            var services = [], contents = json.content, len = contents.length;
            for (var i = 0; i < len; i++) {
                var content = contents[i];
                var service = new OnlineData(me.mDatasUrl, content);
                services.push(service);
            }
            return services;
        });
    }
}

;// CONCATENATED MODULE: ./src/common/online/OnlineQueryDatasParameter.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/



/**
 * @class OnlineQueryDatasParameter
 * @deprecatedclass SuperMap.OnlineQueryDatasParameter
 * @classdesc myDatas 服务资源查询参数。
 * @category iPortal/Online Resources Data
 * @param {Object} options - 参数。
 * @usage
 */
class OnlineQueryDatasParameter {
    constructor(options) {
        options = options || {};

        /**
         * @member {Array.<string>} OnlineQueryDatasParameter.prototype.userNames
         * @description 数据作者名。可以根据数据作者名查询，默认查询全部。
         */
        this.userNames = null;
        /**
         * @member {Array.<Object>} OnlineQueryDatasParameter.prototype.types
         * @description  数据类型。
         */
        this.types = null;
        /**
         * @member {string} OnlineQueryDatasParameter.prototype.fileName
         * @description  文件名称。
         */
        this.fileName = null;
        /**
         * @member {string} OnlineQueryDatasParameter.prototype.serviceStatuses
         * @description  服务发布状态。
         */
        this.serviceStatuses = null;
        /**
         * @member {string} OnlineQueryDatasParameter.prototype.serviceId
         * @description  服务 ID。
         */
        this.serviceId = null;
        /**
         * @member {Array.<number>} OnlineQueryDatasParameter.prototype.ids
         * @description  由数据项 ID 组成的整型数组。
         */
        this.ids = null;
        /**
         * @member {Array.<string>} OnlineQueryDatasParameter.prototype.keywords
         * @description 关键字。
         */
        this.keywords = null;
        /**
         * @member {string} OnlineQueryDatasParameter.prototype.orderBy
         * @description 排序字段。
         */
        this.orderBy = null;
        /**
         * @member {Array.<string>} OnlineQueryDatasParameter.prototype.tags
         * @description 数据的标签。
         */
        this.tags = null;
        /**
         * @member {Array.<string>} OnlineQueryDatasParameter.prototype.filterFields
         * @description 用于关键字查询时的过滤字段。
         */
        this.filterFields = null;

        Util_Util.extend(this, options)

        this.CLASS_NAME = "SuperMap.OnlineQueryDatasParameter";
    }


    /**
     * @function OnlineQueryDatasParameter.prototype.toJSON
     * @description 返回对应的 JSON 对象。
     * @returns {Object} 对应的 JSON 对象。
     */
    toJSON() {
        var me = this;
        var jsonObj = {
            "types": me.types,
            "fileName": me.fileName,
            "serviceStatuses": me.serviceStatuses,
            "serviceId": me.serviceId,
            "ids": me.ids,
            "keywords": me.keywords,
            "orderBy": me.orderBy,
            "tags": me.tags,
            "filterFields": me.filterFields
        };
        for (var key in jsonObj) {
            if (jsonObj[key] == null) {
                delete jsonObj[key]
            }
        }
        return jsonObj;
    }

}

;// CONCATENATED MODULE: ./src/common/online/index.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/












;// CONCATENATED MODULE: ./src/common/security/KeyServiceParameter.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/



/**
 * @class KeyServiceParameter
 * @deprecatedclass SuperMap.KeyServiceParameter
 * @classdesc key申请参数
 * @category Security
 * @param {Object} options - 参数。
 * @param {string} options.name - 申请服务名称。
 * @param {number} options.serviceIds - 服务 ID。
 * @param {ClientType} [options.clientType=ClientType.SERVER] - 服务端类型。
 * @param {number} options.limitation - 有效期
 * @usage
 */
class KeyServiceParameter {

    constructor(options) {
        this.name = null;
        this.serviceIds = null;
        this.clientType = ClientType.SERVER;
        this.limitation = null;
        Util_Util.extend(this, options);
        this.CLASS_NAME = "SuperMap.KeyServiceParameter";
    }

    /**
     * @function KeyServiceParameter.prototype.toJSON
     * @description 转换成 JSON 对象
     * @returns {Object} 参数的 JSON 对象
     */
    toJSON() {
        return {
            name: this.name,
            serviceIds: this.serviceIds,
            clientType: this.clientType,
            limitation: this.limitation
        }
    }

}


;// CONCATENATED MODULE: ./src/common/security/ServerInfo.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/



/**
 * @class ServerInfo
 * @deprecatedclass SuperMap.ServerInfo
 * @classdesc 服务器信息(安全相关)，包含服务器类型，服务地址，token服务地址等。
 * @category Security
 * @param {string} type - 服务器类型。
 * @param {Object} options - 参数。
 * @param {string} options.server - 服务器地址，如：http://supermapiserver:8090/iserver。
 * @param {string} [options.tokenServiceUrl] - 如：http://supermapiserver:8090/iserver/services/security/tokens.json。
 * @param {string} [options.keyServiceUrl] - 如：http://supermapiserver:8092/web/mycontent/keys/register.json。
 * @usage
 */
class ServerInfo {
    constructor(type, options) {
        /**
         * @member {ServerType} ServerInfo.prototype.type
         * @description 服务器类型。
         */
        this.type = type;

        /**
         * @member {string} ServerInfo.prototype.server
         * @description 服务器地址。
         */
        this.server = null;

        /**
         * @member {string} [ServerInfo.prototype.tokenServiceUrl]
         * @description 如：http://supermapiserver:8090/iserver/services/security/tokens.json。
         */
        this.tokenServiceUrl = null;

        /**
         * @member {string} [ServerInfo.prototype.keyServiceUrl]
         * @description 如：http://supermapiserver:8092/web/mycontent/keys/register.json。
         */
        this.keyServiceUrl = null;

        Util_Util.extend(this, options);

        this.CLASS_NAME = "SuperMap.ServerInfo";
        this.type = this.type || ServerType.ISERVER;
        if (!this.server) {
            console.error('server url require is not  undefined')
        }
        // var patten = /http:\/\/([^\/]+)/i;
        //this.server = this.server.match(patten)[0];

        var tokenServiceSuffix = "/services/security/tokens";
        if (this.type === ServerType.ISERVER && this.server.indexOf("iserver") < 0) {
            tokenServiceSuffix = "/iserver" + tokenServiceSuffix;
        }

        if (!this.tokenServiceUrl) {
            this.tokenServiceUrl = Util_Util.urlPathAppend(this.server, tokenServiceSuffix);
        }

        if (!this.keyServiceUrl) {
            if (this.type === ServerType.IPORTAL) {
                this.keyServiceUrl = Util_Util.urlPathAppend(this.server, "/web/mycontent/keys/register");
            } else if (this.type === ServerType.ONLINE) {
                this.keyServiceUrl = Util_Util.urlPathAppend(this.server, "/web/mycontent/keys");
            }
        }
    }

}


;// CONCATENATED MODULE: ./src/common/security/TokenServiceParameter.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/



/**
 * @class TokenServiceParameter
 * @deprecatedclass SuperMap.TokenServiceParameter
 * @classdesc token 申请参数。
 * @category Security
 * @param {Object} options - 参数。
 * @param {string} options.username - 用户名。
 * @param {string} options.password - 密码。
 * @param {ClientType} [options.clientType='ClientType.NONE'] - token 申请的客户端标识类型。
 * @param {string} [options.ip] - clientType=IP 时，此为必选参数。
 * @param {string} [options.referer] -clientType=Referer 时，此为必选参数。如果按照指定 URL 的方式申请令牌，则设置相应的 URL。
 * @param {number} [options.expiration=60] - 申请令牌的有效期，从发布令牌的时间开始计算，单位为分钟。
 * @usage
 *
 */
class TokenServiceParameter {
    constructor(options) {
        /**
         * @member {string} TokenServiceParameter.prototype.userName
         * @description 用户名。
         */
        this.userName = null;

        /**
         * @member {string} TokenServiceParameter.prototype.password
         * @description 密码。
         */
        this.password = null;

        /**
         * @member {ClientType} TokenServiceParameter.prototype.clientType
         * @description token 申请的客户端标识类型。
         */
        this.clientType = ClientType.NONE;

        /**
         * @member {string} [TokenServiceParameter.prototype.ip]
         * @description clientType=IP 时，此为必选参数。
         */

        this.ip = null;
        /**
         * @member {string} [TokenServiceParameter.prototype.referer]
         * @description clientType=Referer 时，此为必选参数。如果按照指定 URL 的方式申请令牌，则设置相应的 URL。
         */
        this.referer = null;

        /**
         * @member {number} TokenServiceParameter.prototype.expiration
         * @description 申请令牌的有效期，从发布令牌的时间开始计算，单位为分钟。
         */
        this.expiration = 60;

        Util_Util.extend(this, options);

        this.CLASS_NAME = "SuperMap.TokenServiceParameter";
    }

    /**
     * @function TokenServiceParameter.prototype.toJSON
     * @description 将所有信息转成 JSON 字符串。
     * @returns {string} 参数的 JSON 字符串。
     */
    toJSON() {
        return {
            userName: this.userName,
            password: this.password,
            clientType: this.clientType,
            ip: this.ip,
            referer: this.referer,
            expiration: this.expiration
        }
    }

}


;// CONCATENATED MODULE: ./src/common/security/index.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/









;// CONCATENATED MODULE: ./src/common/thirdparty/elasticsearch/ElasticSearch.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/



/**
 * @class ElasticSearch
 * @deprecatedclass SuperMap.ElasticSearch
 * @classdesc ElasticSearch服务类。
 * @category ElasticSearch
 * @modulecategory Services
 * @param {string} url - ElasticSearch服务地址。
 * @param {Object} es - elasticsearch的全局变量。注意：需要@elastic/elasticsearch@5.6.22或者elasticsearch@16.7.3。
 * @param {Object} options - 参数。
 * @param {function} [options.change] - 服务器返回数据后执行的函数。废弃,不建议使用。使用search或msearch方法。
 * @param {boolean} [options.openGeoFence=false] - 是否开启地理围栏验证，默认为不开启。
 * @param {function} [options.outOfGeoFence] - 数据超出地理围栏后执行的函数。
 * @param {Object} [options.geoFence] - 地理围栏。
 * @usage
 */

class ElasticSearch {

    constructor(url, es, options) {
        if (!es || (typeof es !== 'function' && typeof es !== 'object') || typeof es.Client !== 'function') {
          throw Error('Please enter the global variable of @elastic/elasticsearch@5.6.22 or elasticsearch@16.7.3 for the second parameter!');
        }
        options = options || {};
        /**
         *  @member {string} ElasticSearch.prototype.url
         *  @description ElasticSearch服务地址。
         */
        this.url = url;
        /**
         *  @member {Object} ElasticSearch.prototype.client
         *  @description client ES客户端。
         */
        try {
          // 老版本
          this.client = new es.Client({
            host: this.url
          });
        } catch (e) {
          // 新版本
          this.client = new es.Client({
            node: {
              url: new URL(this.url)
            }
          });
        }
        /**
         *  @deprecated
         *  @member {function} [ElasticSearch.prototype.change]
         *  @description 服务器返回数据后执行的函数。废弃,不建议使用。使用search或msearch方法。
         */
        this.change = null;
        /**
         *  @member {boolean} [ElasticSearch.prototype.openGeoFence=false]
         *  @description 是否开启地理围栏验证，默认为不开启。
         */
        this.openGeoFence = false;
        /**
         *  @member {function} [ElasticSearch.prototype.outOfGeoFence]
         *  @description 数据超出地理围栏后执行的函数。
         */
        this.outOfGeoFence = null;

        /**
         * @member {Object} [ElasticSearch.prototype.geoFence]
         * @description 地理围栏。
         * @example {
     *    radius: 1000,//单位是m
     *    center: [104.40, 30.43],
     *    unit: 'meter|degree'
     *  }
         */
        this.geoFence = null;

        /*
         * Constant: EVENT_TYPES
         * {Array.<String>}
         * 此类支持的事件类型。
         *
         */
        this.EVENT_TYPES = ['change', 'error', 'outOfGeoFence'];

        /**
         * @member {Events} ElasticSearch.prototype.events
         * @description 事件。
         */
        this.events = new Events(this, null, this.EVENT_TYPES);

        /**
         * @member {Object} ElasticSearch.prototype.eventListeners
         * @description 监听器对象，在构造函数中设置此参数（可选），对 MapService 支持的两个事件 processCompleted 、processFailed 进行监听，
         * 相当于调用 Events.on(eventListeners)。
         */
        this.eventListeners = null;
        Util_Util.extend(this, options);
        if (this.eventListeners instanceof Object) {
            this.events.on(this.eventListeners);
        }
    }

    /**
     * @function ElasticSearch.prototype.setGeoFence
     * @description 设置地理围栏，openGeoFence参数为true的时候，设置的地理围栏才生效。
     * @param {Geometry} geoFence - 地理围栏。
     */

    setGeoFence(geoFence) {
        this.geoFence = geoFence;
    }

    /**
     * @function ElasticSearch.prototype.bulk
     * @description 批量操作API，允许执行多个索引/删除操作。
     * 参数设置参考 {@link https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-bulk}</br>
     * 更多信息参考 {@link https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-bulk.html}</br>
     * @param {Object} params - 参数。
     * @param {function} callback - 回调函数。
     */
    bulk(params, callback) {
        return this.client.bulk(params, this._handleCallback(callback));
    }

    /**
     * @function ElasticSearch.prototype.clearScroll
     * @description 通过指定scroll参数进行查询来清除已经创建的scroll请求。
     * 参数设置参考 {@link https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-clearscroll}</br>
     *更多信息参考 {@link https://www.elastic.co/guide/en/elasticsearch/reference/current/search-request-scroll.html}</br>
     * @param {Object} params - 参数。
     * @param {function} callback - 回调函数。
     */
    clearScroll(params, callback) {
        return this.client.clearScroll(params, this._handleCallback(callback));
    }

    /**
     * @function ElasticSearch.prototype.count
     * @description 获取集群、索引、类型或查询的文档个数。
     * 参数设置参考 {@link https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-count}</br>
     * 更多信息参考 {@link https://www.elastic.co/guide/en/elasticsearch/reference/current/search-count.html}</br>
     * @param {Object} params - 参数。
     * @param {function} callback - 回调函数。
     */
    count(params, callback) {
        return this.client.count(params, this._handleCallback(callback));
    }

    /**
     * @function ElasticSearch.prototype.create
     * @description 在特定索引中添加一个类型化的JSON文档，使其可搜索。如果具有相同index，type且ID已经存在的文档将发生错误。</br>
     * 参数设置参考 {@link https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-create}
     * 更多信息参考 {@link https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-index_.html}
     * @param {Object} params - 参数。
     * @param {function} callback - 回调函数。
     */
    create(params, callback) {
        return this.client.create(params, this._handleCallback(callback));
    }

    /**
     * @function ElasticSearch.prototype.delete
     * @description 根据其ID从特定索引中删除键入的JSON文档。
     * 参数设置参考 {@link https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-delete}</br>
     * 更多信息参考 {@link https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-delete.html}</br>
     * @param {Object} params - 参数。
     * @param {function} callback - 回调函数。
     */
    delete(params, callback) {
        return this.client.delete(params, this._handleCallback(callback));
    }

    /**
     * @function ElasticSearch.prototype.deleteByQuery
     * @description 根据其ID从特定索引中删除键入的JSON文档。
     * 参数设置参考 {@link https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-deletebyquery}</br>
     * 更多信息参考 {@link https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-delete-by-query.html}</br>
     * @param {Object} params - 参数。
     * @param {function} callback - 回调函数。
     */
    deleteByQuery(params, callback) {
        return this.client.deleteByQuery(params, this._handleCallback(callback));
    }

    /**
     * @function ElasticSearch.prototype.deleteScript
     * @description 根据其ID删除脚本。</br>
     * 参数设置参考 {@link https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-deletescript}</br>
     * 更多信息参考 {@link https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-scripting.html}</br>
     * @param {Object} params - 参数。
     * @param {function} callback - 回调函数。
     */
    deleteScript(params, callback) {
        return this.client.deleteScript(params, this._handleCallback(callback));
    }

    /**
     * @function ElasticSearch.prototype.deleteTemplate
     * @description 根据其ID删除模板。</br>
     * 参数设置参考 {@link https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-deletetemplate}</br>
     * 更多信息参考 {@link https://www.elastic.co/guide/en/elasticsearch/reference/current/search-template.html}</br>
     * @param {Object} params - 参数。
     * @param {function} callback - 回调函数。
     */
    deleteTemplate(params, callback) {
        return this.client.deleteTemplate(params, this._handleCallback(callback));
    }

    /**
     * @function ElasticSearch.prototype.exists
     * @description 检查给定文档是否存在。</br>
     * 参数设置参考 {@link https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-exists}</br>
     * 更多信息参考 {@link https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-get.html}</br>
     * @param {Object} params - 参数。
     * @param {function} callback - 回调函数。
     */
    exists(params, callback) {
        return this.client.exists(params, this._handleCallback(callback));
    }

    /**
     * @function ElasticSearch.prototype.existsSource
     * @description 检查资源是否存在。</br>
     * 参数设置参考 {@link https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-existssource}</br>
     * 更多信息参考 {@link https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-get.html}</br>
     * @param {Object} params - 参数。
     * @param {function} callback - 回调函数。
     */

    existsSource(params, callback) {
        return this.client.existsSource(params, this._handleCallback(callback));
    }

    /**
     * @function ElasticSearch.prototype.explain
     * @description 提供与特定查询相关的特定文档分数的详细信息。它还会告诉您文档是否与指定的查询匹配。</br>
     * 参数设置参考 {@link https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-explain}</br>
     * 更多信息参考 {@link https://www.elastic.co/guide/en/elasticsearch/reference/current/search-explain.html}</br>
     * @param {Object} params - 参数。
     * @param {function} callback - 回调函数。
     */
    explain(params, callback) {
        return this.client.explain(params, this._handleCallback(callback));
    }

    /**
     * @function ElasticSearch.prototype.fieldCaps
     * @description 允许检索多个索引之间的字段的功能。(实验性API，可能会在未来版本中删除)</br>
     * 参数设置参考 {@link https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-fieldcaps}</br>
     * 更多信息参考 {@link https://www.elastic.co/guide/en/elasticsearch/reference/current/search-field-caps.html}</br>
     * @param {Object} params - 参数。
     * @param {function} callback - 回调函数。
     */
    fieldCaps(params, callback) {
        return this.client.fieldCaps(params, this._handleCallback(callback));
    }


    /**
     * @function ElasticSearch.prototype.get
     * @description 从索引获取一个基于其ID的类型的JSON文档。</br>
     * 参数设置参考 {@link https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-get}</br>
     * 更多信息参考 {@link https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-get.html}</br>
     * @param {Object} params - 参数。
     * @param {function} callback - 回调函数。
     */
    get(params, callback) {
        return this.client.get(params, this._handleCallback(callback));
    }

    /**
     * @function ElasticSearch.prototype.getScript
     * @description 获取脚本。</br>
     * 参数设置参考 {@link https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-getscript}</br>
     * 更多信息参考 {@link https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-scripting.html}</br>
     * @param {Object} params - 参数。
     * @param {function} callback - 回调函数。
     */
    getScript(params, callback) {
        return this.client.getScript(params, this._handleCallback(callback));
    }

    /**
     * @function ElasticSearch.prototype.getSource
     * @description 通过索引，类型和ID获取文档的源。</br>
     * 参数设置参考 {@link https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-getsource}</br>
     * 更多信息参考 {@link https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-get.html}</br>
     * @param {Object} params - 参数。
     * @param {function} callback - 回调函数。
     */
    getSource(params, callback) {
        return this.client.getSource(params, this._handleCallback(callback));
    }

    /**
     * @function ElasticSearch.prototype.getTemplate
     * @description 获取模板。</br>
     * 参数设置参考 {@link https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-gettemplate}</br>
     * 更多信息参考 {@link https://www.elastic.co/guide/en/elasticsearch/reference/current/search-template.html}</br>
     * @param {Object} params - 参数。
     * @param {function} callback - 回调函数。
     */
    getTemplate(params, callback) {
        return this.client.getTemplate(params, this._handleCallback(callback));
    }

    /**
     * @function ElasticSearch.prototype.index
     * @description 在索引中存储一个键入的JSON文档，使其可搜索。</br>
     * 参数设置参考 {@link https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-index}</br>
     * 更多信息参考 {@link https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-index_.html}</br>
     * @param {Object} params - 参数。
     * @param {function} callback - 回调函数。
     */
    index(params, callback) {
        return this.client.index(params, this._handleCallback(callback));
    }

    /**
     * @function ElasticSearch.prototype.info
     * @description 从当前集群获取基本信息。</br>
     * 参数设置参考 {@link https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-info}</br>
     * 更多信息参考 {@link https://www.elastic.co/guide/index.html}</br>
     * @param {Object} params - 参数。
     * @param {function} callback - 回调函数。
     */
    info(params, callback) {
        return this.client.info(params, this._handleCallback(callback));
    }

    /**
     * @function ElasticSearch.prototype.mget
     * @description 根据索引，类型（可选）和ids来获取多个文档。mget所需的主体可以采用两种形式：文档位置数组或文档ID数组。</br>
     * 参数设置参考 {@link https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-mget}</br>
     * 更多信息参考 {@link https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-multi-get.html}</br>
     * @param {Object} params - 参数。
     * @param {function} callback - 回调函数。
     */
    mget(params, callback) {
        return this.client.mget(params, this._handleCallback(callback));
    }

    /**
     * @function ElasticSearch.prototype.msearch
     * @description 在同一请求中执行多个搜索请求。</br>
     * 参数设置参考 {@link https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-msearch}</br>
     * 更多信息参考 {@link https://www.elastic.co/guide/en/elasticsearch/reference/current/search-multi-search.html}</br>
     * @param {Object} params - 参数。
     * @param {function} callback - 请求返回的回调函数。也可以使用then表达式获取返回结果。
     *     回调参数：error,response，结果存储在response.responses中。
     */
    msearch(params, callback) {
        let me = this;

        return me.client.msearch(params)
            .then(function (resp) {
                resp = resp.body || resp;
                me._update(resp.responses, callback);
                return resp;
            }, function (err) {
                callback(err);
                me.events.triggerEvent('error', {error: err});
                return err;
            });
    }

    /**
     * @function ElasticSearch.prototype.msearchTemplate
     * @description 在同一请求中执行多个搜索模板请求。</br>
     * 参数设置参考 {@link https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-msearchtemplate}</br>
     * 更多信息参考 {@link https://www.elastic.co/guide/en/elasticsearch/reference/current/search-template.html}</br>
     * @param {Object} params - 参数。
     * @param {function} callback - 回调函数。
     */
    msearchTemplate(params, callback) {
        return this.client.msearchTemplate(params, this._handleCallback(callback));
    }

    /**
     * @function ElasticSearch.prototype.mtermvectors
     * @description 多termvectors API允许一次获得多个termvectors。</br>
     * 参数设置参考 {@link https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-mtermvectors}</br>
     * 更多信息参考 {@link https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-multi-termvectors.html}</br>
     * @param {Object} params - 参数。
     * @param {function} callback - 回调函数。
     */
    mtermvectors(params, callback) {
        return this.client.mtermvectors(params, this._handleCallback(callback));
    }

    /**
     * @function ElasticSearch.prototype.ping
     * @description 测试连接。</br>
     * 参数设置参考 {@link https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-ping}</br>
     * 更多信息参考 {@link https://www.elastic.co/guide/index.html}</br>
     * @param {Object} params - 参数。
     * @param {function} callback - 回调函数。
     */
    ping(params, callback) {
        return this.client.ping(params, this._handleCallback(callback));
    }

    /**
     * @function ElasticSearch.prototype.putScript
     * @description 添加脚本。</br>
     * 参数设置参考 {@link https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-putscript}</br>
     * 更多信息参考 {@link https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-scripting.html}</br>
     * @param {Object} params - 参数。
     * @param {function} callback - 回调函数。
     */
    putScript(params, callback) {
        return this.client.putScript(params, this._handleCallback(callback));
    }

    /**
     * @function ElasticSearch.prototype.putTemplate
     * @description 添加模板。</br>
     * 参数设置参考 {@link https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-puttemplate}</br>
     * 更多信息参考 {@link https://www.elastic.co/guide/en/elasticsearch/reference/current/search-template.html}</br>
     * @param {Object} params - 参数。
     * @param {function} callback - 回调函数。
     */
    putTemplate(params, callback) {
        return this.client.putTemplate(params, this._handleCallback(callback));
    }

    /**
     * @function ElasticSearch.prototype.reindex
     * @description 重新索引。</br>
     * 参数设置参考 {@link https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-reindex}</br>
     * 更多信息参考 {@link https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-reindex.html}</br>
     * @param {Object} params - 参数。
     * @param {function} callback - 回调函数。
     */
    reindex(params, callback) {
        return this.client.reindex(params, this._handleCallback(callback));
    }

    /**
     * @function ElasticSearch.prototype.reindexRessrottle
     * @description 重新索引。</br>
     * 参数设置参考 {@link https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-reindexrethrottle}</br>
     * 更多信息参考 {@link https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-reindex.html}</br>
     * @param {Object} params - 参数。
     * @param {function} callback - 回调函数。
     */
    reindexRessrottle(params, callback) {
        return this.client.reindexRessrottle(params, this._handleCallback(callback));
    }

    /**
     * @function ElasticSearch.prototype.renderSearchTemplate
     * @description 搜索模板。</br>
     * 参数设置参考 {@link https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-rendersearchtemplate}</br>
     * 更多信息参考 {@link https://www.elastic.co/guide/en/elasticsearch/reference/current/search-template.html}</br>
     * @param {Object} params - 参数。
     * @param {function} callback - 回调函数。
     */
    renderSearchTemplate(params, callback) {
        return this.client.renderSearchTemplate(params, this._handleCallback(callback));
    }

    /**
     * @function ElasticSearch.prototype.scroll
     * @description  在search()调用中指定滚动参数之后，滚动搜索请求（检索下一组结果）。</br>
     * 参数设置参考 {@link https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-scroll}</br>
     * 更多信息参考 {@link https://www.elastic.co/guide/en/elasticsearch/reference/current/search-request-scroll.html}</br>
     * @param {Object} params - 参数。
     * @param {function} callback - 回调函数。
     */
    scroll(params, callback) {
        return this.client.scroll(params, this._handleCallback(callback));
    }

    /**
     * @function ElasticSearch.prototype.search
     * @description  在search()调用中指定滚动参数之后，滚动搜索请求（检索下一组结果）。
     * 参数设置参考 {@link https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-search}</br>
     * 更多信息参考 {@link https://www.elastic.co/guide/en/elasticsearch/reference/current/search-search.html}</br>
     * @param {Object} params - 参数。
     * @param {function} callback - 请求返回的回调函数。也可以使用then表达式获取返回结果。
     *     回调参数：error,response，结果存储在response.responses中。
     */
    search(params, callback) {
        let me = this;
        return me.client.search(params)
            .then(function (resp) {
                resp = resp.body || resp;
                me._update(resp, callback);
                return resp;
            }, function (err) {
                callback && callback(err);
                me.events.triggerEvent('error', {error: err});
                return err;
            });
    }

    /**
     * @function ElasticSearch.prototype.searchShards
     * @description  返回要执行搜索请求的索引和分片。
     * 参数设置参考 {@link https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-searchshards}</br>
     * 更多信息参考 {@link https://www.elastic.co/guide/en/elasticsearch/reference/current/search-shards.html}</br>
     * @param {Object} params - 参数。
     * @param {function} callback - 回调函数。
     */
    searchShards(params, callback) {
        return this.client.searchShards(params, this._handleCallback(callback));
    }

    /**
     * @function ElasticSearch.prototype.searchTemplate
     * @description  搜索模板。
     * 参数设置参考 {@link https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-searchtemplate}</br>
     * 更多信息参考 {@link https://www.elastic.co/guide/en/elasticsearch/reference/current/search-suggesters.html}</br>
     * @param {Object} params - 参数。
     * @param {function} callback - 回调函数。
     */
    searchTemplate(params, callback) {
        return this.client.searchTemplate(params, this._handleCallback(callback));
    }

    /**
     * @function ElasticSearch.prototype.suggest
     * @description 该建议功能通过使用特定的建议者，基于所提供的文本来建议类似的术语。
     * 参数设置参考 {@link https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-suggest}</br>
     * 更多信息参考 {@link https://www.elastic.co/guide/en/elasticsearch/reference/current/search-suggesters.html}</br>
     * @param {Object} params - 参数。
     * @param {function} callback - 回调函数。
     */
    suggest(params, callback) {
        return this.client.suggest(params, this._handleCallback(callback));
    }

    /**
     * @function ElasticSearch.prototype.termvectors
     * @description 返回有关特定文档字段中的术语的信息和统计信息。
     * 参数设置参考 {@link https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-termvectors}</br>
     * 更多信息参考 {@link https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-termvectors.html}</br>
     * @param {Object} params - 参数。
     * @param {function} callback - 回调函数。
     */
    termvectors(params, callback) {
        return this.client.termvectors(params, this._handleCallback(callback));
    }

    /**
     * @function ElasticSearch.prototype.update
     * @description 更新文档的部分。
     * 参数设置参考 {@link https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-update}</br>
     * 更多信息参考 {@link https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-update.html}</br>
     * @param {Object} params - 参数。
     * @param {function} callback - 回调函数。
     */
    update(params, callback) {
        return this.client.update(params, this._handleCallback(callback));
    }

    /**
     * @function ElasticSearch.prototype.updateByQuery
     * @description 通过查询API来更新文档。
     * 参数设置参考 {@link https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-updatebyquery}</br>
     * 更多信息参考 {@link https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-update-by-query.html}</br>
     * @param {Object} params - 参数。
     * @param {function} callback - 回调函数。
     */
    updateByQuery(params, callback) {
        return this.client.updateByQuery(params, this._handleCallback(callback));
    }

    /**
     * @function ElasticSearch.prototype._handleCallback
     * @description 处理ElasticSearch 16.x和5.x的callback兼容。 5.x的回调参数多包了一层body
     * @param {function} callback - 回调函数。
     * @private
     */
    _handleCallback(callback) {
      return function () {
        let args = Array.from(arguments);
        const error = args.shift();
        let resp = args.shift();
        const body = resp && resp.body;
        if (body) {
          const { statusCode, headers } = resp;
          args = [statusCode, headers];
          resp = body;
        }
        callback.call(this, error, resp, ...args);
      };
    }

    _update(data, callback) {
        let me = this;
        if (!data) {
            return;
        }
        me.data = data;
        if (me.openGeoFence && me.geoFence) {
            me._validateDatas(data);
        }
        me.events.triggerEvent('change', {data: me.data});
        //change方法已废弃，不建议使用。建议使用search方法的第二个参数传入请求成功的回调
        if (me.change) {
            me.change && me.change(data);
        } else {
            //加responses是为了保持跟原来es自身的数据结构一致
            callback && callback(undefined, {responses: data});
        }
    }

    _validateDatas(datas) {
        if (!datas) {
            return;
        }
        if (!(datas instanceof Array)) {
            datas = [datas];
        }
        var i, len = datas.length;
        for (i = 0; i < len; i++) {
            this._validateData(datas[i]);
        }
    }

    _validateData(data) {
        let me = this;
        data.hits.hits.map(function (source) {
            let content = source._source;
            let meterUnit = me._getMeterPerMapUnit(me.geoFence.unit);
            let geoFenceCX = me.geoFence.center[0] * meterUnit;
            let geoFenceCY = me.geoFence.center[1] * meterUnit;
            let contentX = content.x * meterUnit;
            let contentY = content.y * meterUnit;
            let distance = me._distance(contentX, contentY, geoFenceCX, geoFenceCY);
            let radius = me.geoFence.radius;
            if (distance > radius) {
                me.outOfGeoFence && me.outOfGeoFence(data);
                me.events.triggerEvent('outOfGeoFence', {data: data});
            }
            return source;
        });
    }

    _distance(x1, y1, x2, y2) {
        return Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
    }

    _getMeterPerMapUnit(mapUnit) {
        let earchRadiusInMeters = 6378137;
        let meterPerMapUnit;
        if (mapUnit === 'meter') {
            meterPerMapUnit = 1;
        } else if (mapUnit === 'degree') {
            // 每度表示多少米。
            meterPerMapUnit = Math.PI * 2 * earchRadiusInMeters / 360;
        }
        return meterPerMapUnit;
    }

}


;// CONCATENATED MODULE: ./src/common/thirdparty/elasticsearch/index.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/



;// CONCATENATED MODULE: ./src/common/thirdparty/index.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/




;// CONCATENATED MODULE: ./src/common/util/ColorsPickerUtil.js


var ColorRender = new Color();
// let "http://www.qzu.zj.cn": "#bd10e0"
// 					"www.qzct.net": "#7ed321" = new LevelRenderer.Tool.Color();

/**
 * @name ColorsPickerUtil
 * @namespace
 * @category BaseTypes Util
 * @classdesc 色带选择器工具类。用于1、创建canvas对象，2、从几种颜色中获取一定数量的渐变色。
 * @usage
 * ```
 * // 浏览器
 * <script type="text/javascript" src="{cdn}"></script>
 * <script>
 *   const result = {namespace}.ColorsPickerUtil.createCanvas();
 *
 *   // 弃用的写法
 *   const result = SuperMap.ColorsPickerUtil.createCanvas();
 *
 * </script>
 *
 * // ES6 Import
 * import { ColorsPickerUtil } from '{npm}';
 *
 * const result = ColorsPickerUtil.createCanvas();
 * ```
 */
class ColorsPickerUtil  {
    /**
     * @function ColorsPickerUtil.createCanvas
     * @description 创建DOM canvas。
     * @param {number} height - canvas 高度。
     * @param {number} width - canvas 宽度。
     */

    static createCanvas (height, width){
        var canvas = document.createElement("canvas");
        canvas.height = height;
        canvas.width = width;

        return canvas.getContext("2d");
    }

    /**
     * @function ColorsPickerUtil.getLinearGradient
     * @description 线性渐变。
     * @param {number} x0 - 渐变起点 x 坐标。
     * @param {number} y0 - 渐变起点 y 坐标。
     * @param {number} x1 - 渐变终点 x 坐标。
     * @param {number} y1 - 渐变终点 y 坐标。
     * @param {Array} colorList 颜色列表。
     * @returns {CanvasGradient} Cavans 渐变颜色。
     */

    static getLinearGradient (x0, y0, x1, y1, colorList){
        if (!this._ctx) {
            this._ctx = this.getContext();
        }
        var gradient = this._ctx.createLinearGradient(x0, y0, x1, y1);
        var leng = colorList.length;
        var add = 1/(leng -1);
        var offset = 0;
        for (var i = 0; i < leng; i++) {
            gradient.addColorStop(offset, colorList[i]);
            offset += add;
        }
        gradient.__nonRecursion = true;
        return gradient;
    }

    /**
     * @function ColorsPickerUtil.getContext
     * @description 获取 Cavans 上下文。
     * @returns {Object} Cavans 上下文。
     */

    static getContext () {
        if (!this._ctx) {
            this._ctx = document.createElement('canvas').getContext('2d');
        }
        return this._ctx;
    }

    /**
     * @function ColorsPickerUtil.getStepColors
     * @description 获取两种颜色之间渐变颜色数组。
     * @param {string} start - 起始颜色。
     * @param {string} end - 结束颜色。
     * @param {number} step - 渐变级数。
     * @returns {Array} 颜色数组。
     */

    static getStepColors (start, end, step){
        start = ColorRender.toRGBA(start);
        end = ColorRender.toRGBA(end);
        start = ColorRender.getData(start);
        end = ColorRender.getData(end);

        var colors = [];
        var stepR = (end[0] - start[0]) / step;
        var stepG = (end[1] - start[1]) / step;
        var stepB = (end[2] - start[2]) / step;
        var stepA = (end[3] - start[3]) / step;
        // 生成颜色集合
        // fix by linfeng 颜色堆积
        for (var i = 0, r = start[0], g = start[1], b = start[2], a = start[3]; i < step; i++) {
            colors[i] = ColorRender.toColor([
                ColorRender.adjust(Math.floor(r), [ 0, 255 ]),
                ColorRender.adjust(Math.floor(g), [ 0, 255 ]),
                ColorRender.adjust(Math.floor(b), [ 0, 255 ]),
                a.toFixed(4) - 0
            ],'hex');
            r += stepR;
            g += stepG;
            b += stepB;
            a += stepA;
        }
        r = end[0];
        g = end[1];
        b = end[2];
        a = end[3];
        colors[i] = ColorRender.toColor([r, g, b, a], 'hex');
        return colors;
    }

    /**
     * @function ColorsPickerUtil.getGradientColors
     * @description 获取指定级数的渐变颜色数组。
     * @param {Array.<string>} colors - 颜色组。
     * @param {number} total - 颜色总数。
     * @param {string} themeType - 专题类型。
     * @returns {Array.<string>} 颜色数组。
     */

    static getGradientColors (colors, total, themeType){
        var ret = [], step;
        var i, n, len = colors.length;
        if (total === undefined) {
            return;
        }
        if(len >= total){
            if(themeType === 'RANGE'){
                for(i = 0; i<total; i++){
                    ret.push(colors[i]);
                }
            }else {
                //1/2前后取色
                for(i = 0; i<total; i++){
                    let ii = Math.floor(i/2);
                    if(i%2 === 0){
                        ret.push(colors[ii]);
                    }else {
                        let index = colors.length -1 - ii;
                        ret.push(colors[index]);
                    }
                }
            }
        } else {
            step = Math.ceil(total/(len-1));
            for (i = 0, n = len - 1; i < n; i++) {
                var steps = this.getStepColors(colors[i], colors[i + 1], step);
                if (i < n - 1) {
                    steps.pop();
                }
                ret = ret.concat(steps);
            }
            //删除多余元素
            var nouse = ret.length - total;
            for(var j = 0, index = 0; j< nouse; j++){
                ret.splice(index+2,1);
            }
        }
        return ret;
    }
}

;// CONCATENATED MODULE: ./src/common/util/ArrayStatistic.js
/**
 * @name ArrayStatistic
 * @namespace
 * @category BaseTypes Util
 * @classdesc 处理数组。
 * @usage
 * ```
 * // 浏览器
 * <script type="text/javascript" src="{cdn}"></script>
 * <script>
 *   const result = {namespace}.ArrayStatistic.newInstance();
 *
 *   // 弃用的写法
 *   const result = SuperMap.ArrayStatistic.newInstance();
 *
 * </script>
 *
 * // ES6 Import
 * import { ArrayStatistic } from '{npm}';
 *
 * const result = ArrayStatistic.newInstance();
 * ```
 */
 class ArrayStatistic {

    // geostatsInstance: null,

    /**
     * @function ArrayStatistic.newInstance
     * @description 初始化插件实例。
     */
    static newInstance() {
        // if(!this.geostatsInstance) {
        //         //     this.geostatsInstance = new geostats();
        //         // }
        // window.dataList = [];
        if(!this.geostatsInstance) {

            this.geostatsInstance = new window.geostats();
          
        }
        return this.geostatsInstance;
    }

    /**
     * @function ArrayStatistic.getInstance
     * @description 设置需要被处理的数组。
     * @param {Array} array - 数组。
     */
    static getInstance(array) {
        let instance = this.newInstance();
        instance.setSerie(array);
        return instance;
    }

    /**
     * @function ArrayStatistic.getArrayStatistic
     * @description 获取数组统计的值。
     * @param {Array.<number>} array - 需要统计的数组。
     * @param {string} type - 统计方法。
     */
    static getArrayStatistic(array, type){
        if(!array.length) {
            return 0;
        }
        if(type === "Sum" || type === "求和"){
            return this.getSum(array);
        } else if(type === "Maximum" || type === "最大值"){
            return this.getMax(array);
        } else if(type === "Minimum" || type === "最小值"){
            return this.getMin(array);
        } else if(type === "Average" || type === "平均值"){
            return this.getMean(array);
        } else if(type === "Median" || type === "中位数"){
            return this.getMedian(array);
        } else if(type === "times" || type === "计数"){
            return this.getTimes(array);
        }
    }

    /**
     * @function ArrayStatistic.getArraySegments
     * @description 获取数组分段后的数值。
     * @param {Array.<number>} array - 需要分段的数组。
     * @param {string} type - 分段方法。
     * @param {number} segNum - 分段个数。
     */
    static getArraySegments(array, type, segNum) {
        if(type === "offset") {
            return this.getEqInterval(array, segNum);
        } else if(type === "jenks") {
            return this.getJenks(array, segNum);
        } else if(type === "square") {
            // 数据都必须 >= 0
            let minValue = this.getMin(array);
            if(minValue >= 0){
                return this.getSqrtInterval(array, segNum);
            }else {
                //console.log('数据都必须 >= 0');
                // Util.showMessage(Language.hasNegValue + Language.noSupportRange, 'ERROR');
                return false;
            }

        } else if(type === "logarithm") {
            // 数据都必须 > 0
            let minValue = this.getMin(array);
            if(minValue > 0){
                return this.getGeometricProgression(array, segNum);
            }else {
                //console.log('数据都必须 > 0');
                // Util.showMessage(Language.hasZeroNegValue + Language.noSupportRange, 'ERROR');
                return false;
            }
        }
    }

    /**
     * @function ArrayStatistic.getSum
     * @description 求和。
     * @param {Array.<number>} array 需要求和的参数。
     * @returns {number} 返回求和结果。
     */
    static getSum(array){
        return this.getInstance(array).sum();
    }

    /**
     * @function ArrayStatistic.getMax
     * @description 最大值。
     * @param {Array.<number>} array 需要求最大值的参数。
     * @returns {number} 返回最大值。
     */
    static getMax(array){
        return this.getInstance(array).max();
    }

    /**
     * @function ArrayStatistic.getMin
     * @description 最小值。
     * @param {Array.<number>} array 需要求最小值的参数。
     * @returns {number} 返回最小值。
     */
    static getMin(array){
        return this.getInstance(array).min();
    }

    /**
     * @function ArrayStatistic.getMean
     * @description 求平均数。
     * @param {Array.<number>} array 需要求平均数的参数。
     * @returns {number} 返回平均数。
     */
    static getMean(array){
        return this.getInstance(array).mean();
    }

    /**
     * @function ArrayStatistic.getMedian
     * @description 求中位数。
     * @param {Array.<number>} array 需要求中位数的参数。
     * @returns {number} 返回中位数。
     */
    static getMedian(array) {
        return this.getInstance(array).median();
    }

    /**
     * @function ArrayStatistic.getTimes
     * @description 计数。
     * @param {Array.<number>} array 需要计数的参数。
     * @returns {number} 返回计数结果。
     */
    static getTimes(array) {
        return array.length;
    }

    /**
     * @function ArrayStatistic.getEqInterval
     * @description 等距分段法。
     * @param {Array} array 需要进行等距分段的数组。
     * @param {number} segNum 分段个数。
     */
    static getEqInterval(array, segNum) {
        return this.getInstance(array).getClassEqInterval(segNum);
    }
    
    /**
     * @function ArrayStatistic.getJenks
     * @description 自然断裂法。
     * @param {Array} array 需要进行自然断裂的参数。
     * @param {number} segNum 分段个数。
     */
    static getJenks(array, segNum) {
        return this.getInstance(array).getClassJenks(segNum);
    }

    /**
     * @function ArrayStatistic.getSqrtInterval
     * @description 平方根分段法。
     * @param {Array} array 需要进行平方根分段的参数。
     * @param {number} segNum 分段个数。
     */
    static getSqrtInterval(array, segNum) {
        array = array.map(function(value) {
            return Math.sqrt(value);
        });
        let breaks = this.getInstance(array).getClassEqInterval(segNum);
        return (
            breaks.map(function(value) {
                return value * value;
            })
        ) 
    }

    /**
     * @function ArrayStatistic.getGeometricProgression
     * @description 对数分段法。
     * @param {Array} array 需要进行对数分段的参数。
     * @param {number} segNum 分段个数。
     */
    static getGeometricProgression(array, segNum) {
        return this.getInstance(array).getClassGeometricProgression(segNum);
    }

}
;// CONCATENATED MODULE: ./src/common/util/index.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/












function toSuperMapGeometry(geoJSON) {
    if (geoJSON && geoJSON.type) {
        var format = new GeoJSONFormat();
        var result = format.read(geoJSON, "FeatureCollection");
        return result[0].geometry;
    }
}

function toSuperMapPolygon(lnglatBounds) {
    const west = lnglatBounds.getWest();
    const east = lnglatBounds.getEast();
    const sourth = lnglatBounds.getSouth();
    const north = lnglatBounds.getNorth();
    return new Polygon([
        new LinearRing([
            new GeometryPoint(west, sourth),
            new GeometryPoint(east, sourth),
            new GeometryPoint(east, north),
            new GeometryPoint(west, north)
        ])
    ]);
}

function extend(dest) {
   for (var index = 0; index < Object.getOwnPropertyNames(arguments).length; index++) {
       var arg = Object.getOwnPropertyNames(arguments)[index];
       if (arg == "caller" || arg == "callee" || arg == "length" || arg == "arguments") {
           continue;
       }
       var obj = arguments[arg];
       if (obj) {
           for (var j = 0; j < Object.getOwnPropertyNames(obj).length; j++) {
               var key = Object.getOwnPropertyNames(obj)[j];
               if (arg == "caller" || arg == "callee" || arg == "length" || arg == "arguments") {
                   continue;
               }
               dest[key] = obj[key];
           }
       }
   }
   return dest;
}



// EXTERNAL MODULE: ./node_modules/lodash.topairs/index.js
var lodash_topairs = __webpack_require__(52);
var lodash_topairs_default = /*#__PURE__*/__webpack_require__.n(lodash_topairs);
;// CONCATENATED MODULE: ./src/common/style/CartoCSS.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/



/**
 * @class CartoCSS
 * @deprecatedclass SuperMap.CartoCSS
 * @classdesc CartoCSS 解析类，其主要功能为将 CartoCSS 字符串解析为 CartoCSS 的 shader 属性风格对象。
 * @category BaseTypes Style
 * @param {string} cartoStr -  样式表字符串。
 * @example
 * var cartocss = "@provinceLineColor:#ddd;
 *                 #China_Provinces_L___China400{
 *                      line-dasharray:10,10;
 *                      line-color:@provinceLineColor;
 *                      line-width:1;
 *                 }";
 * new CartoCSS(cartocss);
 * @usage
 */
/*eslint no-useless-escape: "off"*/
class CartoCSS {

    constructor(cartoStr) {
        this.env = null;

        /**
         * @member CartoCSS.prototype.parser
         * @description 解析器。
         */
        this.parser = null;

        /**
         * @member CartoCSS.prototype.ruleSet
         * @description CartoCSS 规则对象。
         */
        this.ruleSet = null;

        /**
         * @member CartoCSS.prototype.cartoStr
         * @description CartoCSS 样式表字符串。
         */
        this.cartoStr = "";

        /**
         * @member CartoCSS.prototype.shaders
         * @description Carto 着色器集。
         */
        this.shaders = null;

        if (typeof cartoStr === "string") {
            this.cartoStr = cartoStr;
            this.env = {
                frames: [],
                errors: [],
                error: function (obj) {
                    this.errors.push(obj);
                }
            };
            this.parser = this.getParser(this.env);
            this.parse(cartoStr);
            this.shaders = this.toShaders();
        }
    }

    /**
     * @function CartoCSS.prototype.getParser
     * @description 获取 CartoCSS 解析器。
     */
    getParser(env) {
        var input,       // LeSS input string
            i,           // current index in `input`
            j,           // current chunk
            temp,        // temporarily holds a chunk's state, for backtracking
            memo,        // temporarily holds `i`, when backtracking
            furthest,    // furthest index the parser has gone to
            chunks,      // chunkified input
            current,     // index of current chunk, in `input`
            parser;

        var that = this;

        // This function is called after all files
        // have been imported through `@import`.
        var finish = function () {//NOSONAR
            //所有文件导入完成之后调用
        };

        function save() {
            temp = chunks[j];
            memo = i;
            current = i;
        }

        function restore() {
            chunks[j] = temp;
            i = memo;
            current = i;
        }

        function sync() {
            if (i > current) {
                chunks[j] = chunks[j].slice(i - current);
                current = i;
            }
        }

        //
        // Parse from a token, regexp or string, and move forward if match
        //
        function _match(tok) {
            var match, length, c, endIndex;

            // Non-terminal
            if (tok instanceof Function) {
                return tok.call(parser.parsers);
                // Terminal
                // Either match a single character in the input,
                // or match a regexp in the current chunk (chunk[j]).
            } else if (typeof(tok) === 'string') {
                match = input.charAt(i) === tok ? tok : null;
                length = 1;
                sync();
            } else {
                sync();

                match = tok.exec(chunks[j]);
                if (match) {
                    length = match[0].length;
                } else {
                    return null;
                }
            }

            // The match is confirmed, add the match length to `i`,
            // and consume any extra white-space characters (' ' || '\n')
            // which come after that. The reason for this is that LeSS's
            // grammar is mostly white-space insensitive.
            if (match) {
                var mem = i += length;
                endIndex = i + chunks[j].length - length;

                while (i < endIndex) {
                    c = input.charCodeAt(i);
                    if (!(c === 32 || c === 10 || c === 9)) {
                        break;
                    }
                    i++;
                }
                chunks[j] = chunks[j].slice(length + (i - mem));
                current = i;

                if (chunks[j].length === 0 && j < chunks.length - 1) {
                    j++;
                }

                if (typeof(match) === 'string') {
                    return match;
                } else {
                    return match.length === 1 ? match[0] : match;
                }
            }
        }

        // Same as _match(), but don't change the state of the parser,
        // just return the match.
        function peek(tok) {
            if (typeof(tok) === 'string') {
                return input.charAt(i) === tok;
            } else {
                return !!tok.test(chunks[j]);
            }
        }

        // Make an error object from a passed set of properties.
        // Accepted properties:
        // - `message`: Text of the error message.
        // - `filename`: Filename where the error occurred.
        // - `index`: Char. index where the error occurred.
        function makeError(err) {
            var einput;

            var defautls = {
                index: furthest,
                filename: env.filename,
                message: 'Parse error.',
                line: 0,
                column: -1
            };
            for (var prop in defautls) {
                if (err[prop] === 0) {
                    err[prop] = defautls[prop];
                }
            }

            if (err.filename && that.env.inputs && that.env.inputs[err.filename]) {
                einput = that.env.inputs[err.filename];
            } else {
                einput = input;
            }

            err.line = (einput.slice(0, err.index).match(/\n/g) || '').length + 1;
            for (var n = err.index; n >= 0 && einput.charAt(n) !== '\n'; n--) {
                err.column++;
            }
            return new Error([err.filename, err.line, err.column, err.message].join(";"));
        }

        this.env = env = env || {};
        this.env.filename = this.env.filename || null;
        this.env.inputs = this.env.inputs || {};

        // The Parser
        parser = {

            // Parse an input string into an abstract syntax tree.
            // Throws an error on parse errors.
            parse: function (str) {
                var root, error = null;

                i = j = current = furthest = 0;
                chunks = [];
                input = str.replace(/\r\n/g, '\n');
                if (env.filename) {
                    that.env.inputs[env.filename] = input;
                }

                // Split the input into chunks.
                chunks = (function (chunks) {
                    var j = 0,
                        skip = /(?:@\{[\w-]+\}|[^"'`\{\}\/\(\)\\])+/g,
                        comment = /\/\*(?:[^*]|\*+[^\/*])*\*+\/|\/\/.*/g,
                        string = /"((?:[^"\\\r\n]|\\.)*)"|'((?:[^'\\\r\n]|\\.)*)'|`((?:[^`]|\\.)*)`/g,
                        level = 0,
                        match,
                        chunk = chunks[0],
                        inParam;

                    for (var i = 0, c, cc; i < input.length;) {
                        skip.lastIndex = i;
                        if (match = skip.exec(input)) {
                            if (match.index === i) {
                                i += match[0].length;
                                chunk.push(match[0]);
                            }
                        }
                        c = input.charAt(i);
                        comment.lastIndex = string.lastIndex = i;

                        if (match = string.exec(input)) {
                            if (match.index === i) {
                                i += match[0].length;
                                chunk.push(match[0]);
                                continue;
                            }
                        }

                        if (!inParam && c === '/') {
                            cc = input.charAt(i + 1);
                            if (cc === '/' || cc === '*') {
                                if (match = comment.exec(input)) {
                                    if (match.index === i) {
                                        i += match[0].length;
                                        chunk.push(match[0]);
                                        continue;
                                    }
                                }
                            }
                        }

                        switch (c) {
                            case '{'://NOSONAR
                                if (!inParam) {
                                    level++;
                                    chunk.push(c);
                                    break;
                                }
                            case '}'://NOSONAR
                                if (!inParam) {
                                    level--;
                                    chunk.push(c);
                                    chunks[++j] = chunk = [];
                                    break;
                                }
                            case '('://NOSONAR
                                if (!inParam) {
                                    inParam = true;
                                    chunk.push(c);
                                    break;
                                }
                            case ')'://NOSONAR
                                if (inParam) {
                                    inParam = false;
                                    chunk.push(c);
                                    break;
                                }
                            default:
                                chunk.push(c);
                                break;
                        }

                        i++;
                    }
                    if (level !== 0) {
                        error = {
                            index: i - 1,
                            type: 'Parse',
                            message: (level > 0) ? "missing closing `}`" : "missing opening `{`"
                        };
                    }

                    return chunks.map(function (c) {
                        return c.join('');
                    });
                })([[]]);

                if (error) {
                    throw makeError(error);
                }

                // Sort rules by specificity: this function expects selectors to be
                // split already.
                //
                // Written to be used as a .sort(Function);
                // argument.
                //
                // [1, 0, 0, 467] > [0, 0, 1, 520]
                var specificitySort = function (a, b) {
                    var as = a.specificity;
                    var bs = b.specificity;

                    if (as[0] != bs[0]) {return bs[0] - as[0];}
                    if (as[1] != bs[1]) {return bs[1] - as[1];}
                    if (as[2] != bs[2]) {return bs[2] - as[2];}
                    return bs[3] - as[3];
                };

                // Start with the primary rule.
                // The whole syntax tree is held under a Ruleset node,
                // with the `root` property set to true, so no `{}` are
                // output.
                root = new CartoCSS.Tree.Ruleset([], _match(this.parsers.primary));
                root.root = true;

                // Get an array of Ruleset objects, flattened
                // and sorted according to specificitySort
                root.toList = (function () {
                    return function (env) {
                        env.error = function (e) {
                            if (!env.errors) {env.errors = new Error('');}
                            if (env.errors.message) {
                                env.errors.message += '\n' + makeError(e).message;
                            } else {
                                env.errors.message = makeError(e).message;
                            }
                        };
                        env.frames = env.frames || [];


                        // call populates Invalid-caused errors
                        var definitions = this.flatten([], [], env);
                        definitions.sort(specificitySort);
                        return definitions;
                    };
                })();

                return root;
            },

            // Here in, the parsing rules/functions
            //
            // The basic structure of the syntax tree generated is as follows:
            //
            //   Ruleset ->  Rule -> Value -> Expression -> Entity
            //
            //  In general, most rules will try to parse a token with the `_match()` function, and if the return
            //  value is truly, will return a new node, of the relevant type. Sometimes, we need to check
            //  first, before parsing, that's when we use `peek()`.
            parsers: {
                // The `primary` rule is the *entry* and *exit* point of the parser.
                // The rules here can appear at any level of the parse tree.
                //
                // The recursive nature of the grammar is an interplay between the `block`
                // rule, which represents `{ ... }`, the `ruleset` rule, and this `primary` rule,
                // as represented by this simplified grammar:
                //
                //     primary  →  (ruleset | rule)+
                //     ruleset  →  selector+ block
                //     block    →  '{' primary '}'
                //
                // Only at one point is the primary rule not called from the
                // block rule: at the root level.
                primary: function () {
                    var node, root = [];

                    while ((node = _match(this.rule) || _match(this.ruleset) ||
                        _match(this.comment)) ||
                    _match(/^[\s\n]+/) || (node = _match(this.invalid))) {
                        if (node) {root.push(node);}
                    }
                    return root;
                },

                invalid: function () {
                    var chunk = _match(/^[^;\n]*[;\n]/);

                    // To fail gracefully, match everything until a semicolon or linebreak.
                    if (chunk) {
                        return new CartoCSS.Tree.Invalid(chunk, memo);
                    }
                },

                // We create a Comment node for CSS comments `/* */`,
                // but keep the LeSS comments `//` silent, by just skipping
                // over them.
                comment: function () {
                    var comment;

                    if (input.charAt(i) !== '/') {return;}

                    if (input.charAt(i + 1) === '/') {
                        return new CartoCSS.Tree.Comment(_match(/^\/\/.*/), true);
                    } else if (comment = _match(/^\/\*(?:[^*]|\*+[^\/*])*\*+\/\n?/)) {
                        return new CartoCSS.Tree.Comment(comment);
                    }
                },

                // Entities are tokens which can be found inside an Expression
                entities: {

                    // A string, which supports escaping " and ' "milky way" 'he\'s the one!'
                    quoted: function () {
                        if (input.charAt(i) !== '"' && input.charAt(i) !== "'") {return;}
                        var str = _match(/^"((?:[^"\\\r\n]|\\.)*)"|'((?:[^'\\\r\n]|\\.)*)'/);
                        if (str) {
                            return new CartoCSS.Tree.Quoted(str[1] || str[2]);
                        }
                    },

                    // A reference to a Mapnik field, like [NAME]
                    // Behind the scenes, this has the same representation, but Carto
                    // needs to be careful to warn when unsupported operations are used.
                    field: function () {
                        var l = '[', r = ']';
                        if (!_match(l)) {return;}
                        var field_name = _match(/(^[^\]]+)/);
                        if (!_match(r)) {return;}
                        if (field_name) {return new CartoCSS.Tree.Field(field_name[1]);}
                    },

                    // This is a comparison operator
                    comparison: function () {
                        var str = _match(/^=~|=|!=|<=|>=|<|>/);
                        if (str) {
                            return str;
                        }
                    },

                    // A catch-all word, such as: hard-light
                    // These can start with either a letter or a dash (-),
                    // and then contain numbers, underscores, and letters.
                    keyword: function () {
                        var k = _match(/^[A-Za-z\u4e00-\u9fa5-]+[A-Za-z-0-9\u4e00-\u9fa5_]*/);
                        if (k) {
                            return new CartoCSS.Tree.Keyword(k);
                        }
                    },

                    // A function call like rgb(255, 0, 255)
                    // The arguments are parsed with the `entities.arguments` parser.
                    call: function () {
                        var name, args;

                        if (!(name = /^([\w\-]+|%)\(/.exec(chunks[j]))) {return;}

                        name = name[1];

                        if (name === 'url') {
                            // url() is handled by the url parser instead
                            return null;
                        } else {
                            i += name.length;
                        }

                        var l = '(', r = ')';
                        _match(l); // Parse the '(' and consume whitespace.

                        args = _match(this.entities['arguments']);

                        if (!_match(r)) {return;}

                        if (name) {
                            return new CartoCSS.Tree.Call(name, args, i);
                        }
                    },
                    // Arguments are comma-separated expressions
                    'arguments': function () {
                        var args = [], arg;

                        while (arg = _match(this.expression)) {
                            args.push(arg);
                            var q = ',';
                            if (!_match(q)) {
                                break;
                            }
                        }

                        return args;
                    },
                    literal: function () {
                        return _match(this.entities.dimension) ||
                            _match(this.entities.keywordcolor) ||
                            _match(this.entities.hexcolor) ||
                            _match(this.entities.quoted);
                    },

                    // Parse url() tokens
                    //
                    // We use a specific rule for urls, because they don't really behave like
                    // standard function calls. The difference is that the argument doesn't have
                    // to be enclosed within a string, so it can't be parsed as an Expression.
                    url: function () {
                        var value;

                        if (input.charAt(i) !== 'u' || !_match(/^url\(/)) {return;}
                        value = _match(this.entities.quoted) || _match(this.entities.variable) ||
                            _match(/^[\-\w%@_match\/.&=:;#+?~]+/) || '';
                        var r = ')';
                        if (!_match(r)) {
                            return new CartoCSS.Tree.Invalid(value, memo, 'Missing closing ) in URL.');
                        } else {
                            return new CartoCSS.Tree.URL((typeof value.value !== 'undefined' ||
                                value instanceof CartoCSS.Tree.Variable) ?
                                value : new CartoCSS.Tree.Quoted(value));
                        }
                    },

                    // A Variable entity, such as `@fink`, in
                    //
                    //     width: @fink + 2px
                    //
                    // We use a different parser for variable definitions,
                    // see `parsers.variable`.
                    variable: function () {
                        var name, index = i;

                        if (input.charAt(i) === '@' && (name = _match(/^@[\w-]+/))) {
                            return new CartoCSS.Tree.Variable(name, index, env.filename);
                        }
                    },

                    hexcolor: function () {
                        var rgb;
                        if (input.charAt(i) === '#' && (rgb = _match(/^#([a-fA-F0-9]{6}|[a-fA-F0-9]{3})/))) {
                            return new CartoCSS.Tree.Color(rgb[1]);
                        }
                    },

                    keywordcolor: function () {
                        var rgb = chunks[j].match(/^[a-z]+/);
                        if (rgb && rgb[0] in CartoCSS.Tree.Reference.data.colors) {
                            return new CartoCSS.Tree.Color(CartoCSS.Tree.Reference.data.colors[_match(/^[a-z]+/)]);
                        }
                    },

                    // A Dimension, that is, a number and a unit. The only
                    // unit that has an effect is %
                    dimension: function () {
                        var c = input.charCodeAt(i);
                        if ((c > 57 || c < 45) || c === 47) {return;}
                        var value = _match(/^(-?\d*\.?\d+(?:[eE][-+]?\d+)?)(\%|\w+)?/);
                        if (value) {
                            return new CartoCSS.Tree.Dimension(value[1], value[2], memo);
                        }
                    }
                },

                // The variable part of a variable definition.
                // Used in the `rule` parser. Like @fink:
                variable: function () {
                    var name;

                    if (input.charAt(i) === '@' && (name = _match(/^(@[\w-]+)\s*:/))) {
                        return name[1];
                    }
                },

                // Entities are the smallest recognized token,
                // and can be found inside a rule's value.
                entity: function () {
                    var property1 = _match(this.entities.call) || _match(this.entities.literal);
                    var property2 = _match(this.entities.field) || _match(this.entities.variable);
                    var property3 = _match(this.entities.url) || _match(this.entities.keyword);
                    return property1 || property2 || property3;
                },

                // A Rule terminator. Note that we use `peek()` to check for '}',
                // because the `block` rule will be expecting it, but we still need to make sure
                // it's there, if ';' was ommitted.
                end: function () {
                    var q = ';';
                    return _match(q) || peek('}');
                },

                // Elements are the building blocks for Selectors. They consist of
                // an element name, such as a tag a class, or `*`.
                //增加对中文的支持，[\u4e00-\u9fa5]
                element: function () {
                    var e = _match(/^(?:[.#][\w\u4e00-\u9fa5\-]+|\*|Map)/);
                    if (e) {return new CartoCSS.Tree.Element(e);}
                },

                // Attachments allow adding multiple lines, polygons etc. to an
                // object. There can only be one attachment per selector.
                attachment: function () {
                    var s = _match(/^::([\w\-]+(?:\/[\w\-]+)*)/);
                    if (s) {return s[1];}
                },

                // Selectors are made out of one or more Elements, see above.
                selector: function () {
                    var a, attachment,
                        e, elements = [],
                        f, filters = new CartoCSS.Tree.Filterset(),
                        z, zooms = [],
                        segments = 0, conditions = 0;

                    while (
                        (e = _match(this.element)) ||
                        (z = _match(this.zoom)) ||
                        (f = _match(this.filter)) ||
                        (a = _match(this.attachment))
                        ) {
                        segments++;
                        if (e) {
                            elements.push(e);
                        } else if (z) {
                            zooms.push(z);
                            conditions++;
                        } else if (f) {
                            var err = filters.add(f);
                            if (err) {
                                throw makeError({
                                    message: err,
                                    index: i - 1
                                });
                            }
                            conditions++;
                        } else if (attachment) {
                            throw makeError({
                                message: 'Encountered second attachment name.',
                                index: i - 1
                            });
                        } else {
                            attachment = a;
                        }

                        var c = input.charAt(i);
                        if (c === '{' || c === '}' || c === ';' || c === ',') {
                            break;
                        }
                    }

                    if (segments) {
                        return new CartoCSS.Tree.Selector(filters, zooms, elements, attachment, conditions, memo);
                    }
                },

                filter: function () {
                    save();
                    var key, op, val, l = '[', r = ']';
                    if (!_match(l)) {return;}
                    if (key = _match(/^[a-zA-Z0-9\-_]+/) ||
                            _match(this.entities.quoted) ||
                            _match(this.entities.variable) ||
                            _match(this.entities.keyword) ||
                            _match(this.entities.field)) {
                        if (key instanceof CartoCSS.Tree.Quoted) {
                            key = new CartoCSS.Tree.Field(key.toString());
                        }
                        if ((op = _match(this.entities.comparison)) &&
                            (val = _match(this.entities.quoted) ||
                                _match(this.entities.variable) ||
                                _match(this.entities.dimension) ||
                                _match(this.entities.keyword) ||
                                _match(this.entities.field))) {
                            if (!_match(r)) {
                                throw makeError({
                                    message: 'Missing closing ] of filter.',
                                    index: memo - 1
                                });
                            }
                            if (!key.is) {key = new CartoCSS.Tree.Field(key);}
                            return new CartoCSS.Tree.Filter(key, op, val, memo, env.filename);
                        }
                    }
                },

                zoom: function () {
                    save();
                    var op, val, r = ']';
                    if (_match(/^\[\s*zoom/g) &&
                        (op = _match(this.entities.comparison)) &&
                        (val = _match(this.entities.variable) || _match(this.entities.dimension)) && _match(r)) {
                        return new CartoCSS.Tree.Zoom(op, val, memo);
                    } else {
                        // backtrack
                        restore();
                    }
                },

                // The `block` rule is used by `ruleset`
                // It's a wrapper around the `primary` rule, with added `{}`.
                block: function () {
                    var content, l = '{', r = '}';

                    if (_match(l) && (content = _match(this.primary)) && _match(r)) {
                        return content;
                    }
                },

                // div, .class, body > p {...}
                ruleset: function () {
                    var selectors = [], s, rules, q = ',';
                    save();

                    while (s = _match(this.selector)) {
                        selectors.push(s);
                        while (_match(this.comment)) {//NOSONAR
                        }
                        if (!_match(q)) {
                            break;
                        }
                        while (_match(this.comment)) {//NOSONAR
                        }
                    }
                    if (s) {
                        while (_match(this.comment)) {//NOSONAR
                        }
                    }

                    if (selectors.length > 0 && (rules = _match(this.block))) {
                        if (selectors.length === 1 &&
                            selectors[0].elements.length &&
                            selectors[0].elements[0].value === 'Map') {
                            var rs = new CartoCSS.Tree.Ruleset(selectors, rules);
                            rs.isMap = true;
                            return rs;
                        }
                        return new CartoCSS.Tree.Ruleset(selectors, rules);
                    } else {
                        // Backtrack
                        restore();
                    }
                },

                rule: function () {
                    var name, value, c = input.charAt(i);
                    save();

                    if (c === '.' || c === '#') {
                        return;
                    }

                    if (name = _match(this.variable) || _match(this.property)) {
                        value = _match(this.value);

                        if (value && _match(this.end)) {
                            return new CartoCSS.Tree.Rule(name, value, memo, env.filename);
                        } else {
                            furthest = i;
                            restore();
                        }
                    }
                },

                font: function () {
                    var value = [], expression = [], e, q = ',';

                    while (e = _match(this.entity)) {
                        expression.push(e);
                    }

                    value.push(new CartoCSS.Tree.Expression(expression));

                    if (_match(q)) {
                        while (e = _match(this.expression)) {
                            value.push(e);
                            if (!_match(q)) {
                                break;
                            }
                        }
                    }
                    return new CartoCSS.Tree.Value(value);
                },

                // A Value is a comma-delimited list of Expressions
                // In a Rule, a Value represents everything after the `:`,
                // and before the `;`.
                value: function () {
                    var e, expressions = [], q = ',';

                    while (e = _match(this.expression)) {
                        expressions.push(e);
                        if (!_match(q)) {
                            break;
                        }
                    }

                    if (expressions.length > 1) {
                        return new CartoCSS.Tree.Value(expressions.map(function (e) {
                            return e.value[0];
                        }));
                    } else if (expressions.length === 1) {
                        return new CartoCSS.Tree.Value(expressions);
                    }
                },
                // A sub-expression, contained by parenthensis
                sub: function () {
                    var e, l = '(', r = ")";
                    if (_match(l) && (e = _match(this.expression)) && _match(r)) {
                        return e;
                    }
                },
                // This is a misnomer because it actually handles multiplication
                // and division.
                multiplication: function () {
                    var m, a, op, operation, q = '/';
                    if (m = _match(this.operand)) {
                        while ((op = (_match(q) || _match('*') || _match('%'))) && (a = _match(this.operand))) {
                            operation = new CartoCSS.Tree.Operation(op, [operation || m, a], memo);
                        }
                        return operation || m;
                    }
                },
                addition: function () {
                    var m, a, op, operation, plus = '+';
                    if (m = _match(this.multiplication)) {
                        while ((op = _match(/^[-+]\s+/) || (input.charAt(i - 1) != ' ' && (_match(plus) || _match('-')))) &&
                        (a = _match(this.multiplication))) {
                            operation = new CartoCSS.Tree.Operation(op, [operation || m, a], memo);
                        }
                        return operation || m;
                    }
                },

                // An operand is anything that can be part of an operation,
                // such as a Color, or a Variable
                operand: function () {
                    return _match(this.sub) || _match(this.entity);
                },

                // Expressions either represent mathematical operations,
                // or white-space delimited Entities.  @var * 2
                expression: function () {
                    var e, entities = [];

                    while (e = _match(this.addition) || _match(this.entity)) {
                        entities.push(e);
                    }

                    if (entities.length > 0) {
                        return new CartoCSS.Tree.Expression(entities);
                    }
                },
                property: function () {
                    var name = _match(/^(([a-z][-a-z_0-9]*\/)?\*?-?[-a-z_0-9]+)\s*:/);
                    if (name) {return name[1];}
                }
            }
        };
        return parser;
    }


    /**
     * @function CartoCSS.prototype.parse
     * @description 利用CartoCSS解析器里面的parse方法，将CartoCSS样式表字符串转化为CartoCSS规则集。
     * @returns {Object} CartoCSS规则集。
     */
    parse(str) {
        var parser = this.parser;
        var ruleSet = this.ruleSet = parser.parse(str);
        return ruleSet;
    }


    /**
     * @function CartoCSS.prototype.toShaders
     * @description 将CartoCSS规则集转化为着色器。
     * @returns {Array} CartoCSS着色器集。
     */
    toShaders() {
        if (this.ruleSet) {
            var ruleset = this.ruleSet;
            if (ruleset) {
                var defs = ruleset.toList(this.env);
                defs.reverse();

                var shaders = {};
                var keys = [];
                this._toShaders(shaders,keys,defs);

                var ordered_shaders = [];

                var done = {};
                for (var i = 0, len0 = defs.length; i < len0; ++i) {
                    var def = defs[i];
                    var k = def.attachment;
                    var shader = shaders[keys[i]];
                    var shaderArray = [];
                    if (!done[k]) {
                        var j = 0;
                        for (var prop in shader) {
                            if (prop !== 'zoom' && prop !== 'frames' && prop !== "attachment" && prop != "elements") {
                                //对layer-index作特殊处理以实现图层的控制
                                if (prop === "layer-index") {
                                    /*var getLayerIndex = Function("attributes", "zoom", "var _value = null;" + shader[prop].join('\n') + "; return _value; ");*/
                                    var getLayerIndex = function (attributes, zoom) {//NOSONAR
                                        var _value = null;
                                        shader[prop].join('\n');
                                        return _value;
                                    };
                                    var layerIndex = getLayerIndex();
                                    Object.defineProperty(shaderArray, "layerIndex", {
                                        configurable: true,
                                        enumerable: false,
                                        value: layerIndex
                                    });
                                } else {
                                    shaderArray[j++] = function (ops, shaderArray) {//NOSONAR
                                        if (!Array.isArray(ops)) {
                                            return ops;
                                        }
                                        var body = ops.join('\n');
                                        var myKeyword = 'attributes["FEATUREID"]&&attributes["FEATUREID"]';
                                        var index = body.indexOf(myKeyword);
                                        if (index >= 0) {
                                            //对featureID作一些特殊处理，以将featureID提取出来
                                            if (!shaderArray.featureFilter) {
                                                var featureFilterStart = index + myKeyword.length;
                                                var featureFilterEnd = body.indexOf(")", featureFilterStart + 1);
                                                var featureFilterStr = "featureId&&(featureId" + body.substring(featureFilterStart, featureFilterEnd) + ")";
                                                /*var featureFilter = Function("featureId", "if(" + featureFilterStr + "){return true;}return false;");*/
                                                var featureFilter = function (featureId) {
                                                    if (featureFilterStr) {
                                                        return true;
                                                    }
                                                    return false;
                                                }
                                                Object.defineProperty(shaderArray, "featureFilter", {
                                                    configurable: true,
                                                    enumerable: false,
                                                    value: featureFilter
                                                });
                                            }
                                            return {
                                                "property": prop,
                                                "getValue": Function("attributes", "zoom", "seftFilter", "var _value = null; var isExcute=typeof seftFilter=='function'?sefgFilter():seftFilter;if(isExcute){" + body + ";} return _value; ")//NOSONAR
                                            };
                                        } else {
                                            return {
                                                "property": prop,
                                                "getValue": Function("attributes", "zoom", "var _value = null;" + body + "; return _value; ")//NOSONAR
                                            };
                                        }
                                    }(shader[prop], shaderArray);
                                }
                            }
                        }
                        Object.defineProperty(shaderArray, "attachment", {
                            configurable: true,
                            enumerable: false,
                            value: k
                        });
                        Object.defineProperty(shaderArray, "elements", {
                            configurable: true,
                            enumerable: false,
                            value: def.elements
                        });
                        ordered_shaders.push(shaderArray);
                        done[keys[i]] = true;
                    }
                    Object.defineProperty(shaderArray, "zoom", {
                        configurable: true,
                        enumerable: false,
                        value: def.zoom
                    });
                    //shader.frames.push(def.frame_offset);
                }
                return ordered_shaders;
            }
        }
        return null;
    }

    _toShaders(shaders, keys,defs) {
        for (let i = 0, len0 = defs.length; i < len0; ++i) {
            let def = defs[i];
            let element_str = [];
            for (let j = 0, len1 = def.elements.length; j < len1; j++) {
                element_str.push(def.elements[j]);
            }
            let filters = def.filters.filters;
            let filterStr = [];
            for (let attr in filters) {
                filterStr.push(filters[attr].id);
            }
            let key = element_str.join("/") + "::" + def.attachment + "_" + filterStr.join("_");
            keys.push(key);
            let shader = shaders[key] = (shaders[key] || {});
            //shader.frames = [];
            shader.zoom = CartoCSS.Tree.Zoom.all;
            let props = def.toJS(this.env);
            for (let v in props) {
                (shader[v] = (shader[v] || [])).push(props[v].join('\n'))
            }
        }
    }
    /**
     * @function CartoCSS.prototype.getShaders
     * @description 获取CartoCSS着色器。
     * @returns {Array} 着色器集。
     * @example
     *   //shaders的结构大概如下：
     *   var shaders=[
     *   {
     *       attachment:"one",
     *       elements:[],
     *       zoom:23,
     *       length:2,
     *       0:{property:"line-color",value:function(attribute,zoom){var _value=null;if(zoom){_value="#123456"}return _vlaue;}},
     *       1:{preoperty:"line-width",value:function(attribute,zoom){var _value=null;if(zoom){_value=3}return _vlaue;}}
     *   },
     *   {
     *       attachment:"two",
     *       elements:[],
     *       zoom:23,
     *       length:2,
     *       0:{property:"polygon-color",value:function(attribute,zoom){var _value=null;if(zoom){_value="#123456"}return _vlaue;}},
     *       1:{property:"line-width",value:function(attribute,zoom){var _value=null;if(zoom){_value=3}return _vlaue;}}
     *   }
     *   ];
     */
    getShaders() {
        return this.shaders;
    }

    /**
     * @function CartoCSS.prototype.destroy
     * @description CartoCSS解析对象的析构函数，用于销毁CartoCSS解析对象。
     */
    destroy() {
        this.cartoStr = null;
        this.env = null;
        this.ruleSet = null;
        this.parser = null;
        this.shaders = null;
    }

}

var _mapnik_reference_latest = {
    "version": "2.1.1",
    "style": {
        "filter-mode": {
            "type": [
                "all",
                "first"
            ],
            "doc": "Control the processing behavior of Rule filters within a Style. If 'all' is used then all Rules are processed sequentially independent of whether any previous filters matched. If 'first' is used then it means processing ends after the first match (a positive filter evaluation) and no further Rules in the Style are processed ('first' is usually the default for CSS implementations on top of Mapnik to simplify translation from CSS to Mapnik XML)",
            "default-value": "all",
            "default-meaning": "All Rules in a Style are processed whether they have filters or not and whether or not the filter conditions evaluate to true."
        },
        "image-filters": {
            "css": "image-filters",
            "default-value": "none",
            "default-meaning": "no filters",
            "type": "functions",
            "functions": [
                ["agg-stack-blur", 2],
                ["emboss", 0],
                ["blur", 0],
                ["gray", 0],
                ["sobel", 0],
                ["edge-detect", 0],
                ["x-gradient", 0],
                ["y-gradient", 0],
                ["invert", 0],
                ["sharpen", 0]
            ],
            "doc": "A list of image filters."
        },
        "comp-op": {
            "css": "comp-op",
            "default-value": "src-over",
            "default-meaning": "add the current layer on top of other layers",
            "doc": "Composite operation. This defines how this layer should behave relative to layers atop or below it.",
            "type": ["clear",
                "src",
                "dst",
                "src-over",
                "dst-over",
                "src-in",
                "dst-in",
                "src-out",
                "dst-out",
                "src-atop",
                "dst-atop",
                "xor",
                "plus",
                "minus",
                "multiply",
                "screen",
                "overlay",
                "darken",
                "lighten",
                "color-dodge",
                "color-burn",
                "hard-light",
                "soft-light",
                "difference",
                "exclusion",
                "contrast",
                "invert",
                "invert-rgb",
                "grain-merge",
                "grain-extract",
                "hue",
                "saturation",
                "color",
                "value"
            ]
        },
        "opacity": {
            "css": "opacity",
            "type": "float",
            "doc": "An alpha value for the style (which means an alpha applied to all features in separate buffer and then composited back to main buffer)",
            "default-value": 1,
            "default-meaning": "no separate buffer will be used and no alpha will be applied to the style after rendering"
        }
    },
    "layer": {
        "name": {
            "default-value": "",
            "type": "string",
            "required": true,
            "default-meaning": "No layer name has been provided",
            "doc": "The name of a layer. Can be anything you wish and is not strictly validated, but ideally unique  in the map"
        },
        "srs": {
            "default-value": "",
            "type": "string",
            "default-meaning": "No srs value is provided and the value will be inherited from the Map's srs",
            "doc": "The spatial reference system definition for the layer, aka the projection. Can either be a proj4 literal string like '+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs' or, if the proper proj4 epsg/nad/etc identifier files are installed, a string that uses an id like: '+init=epsg:4326'"
        },
        "status": {
            "default-value": true,
            "type": "boolean",
            "default-meaning": "This layer will be marked as active and available for processing",
            "doc": "A property that can be set to false to disable this layer from being processed"
        },
        "minzoom": {
            "default-value": "0",
            "type": "float",
            "default-meaning": "The layer will be visible at the minimum possible scale",
            "doc": "The minimum scale denominator that this layer will be visible at. A layer's visibility is determined by whether its status is true and if the Map scale >= minzoom - 1e-6 and scale < maxzoom + 1e-6"
        },
        "maxzoom": {
            "default-value": "1.79769e+308",
            "type": "float",
            "default-meaning": "The layer will be visible at the maximum possible scale",
            "doc": "The maximum scale denominator that this layer will be visible at. The default is the numeric limit of the C++ double type, which may vary slightly by system, but is likely a massive number like 1.79769e+308 and ensures that this layer will always be visible unless the value is reduced. A layer's visibility is determined by whether its status is true and if the Map scale >= minzoom - 1e-6 and scale < maxzoom + 1e-6"
        },
        "queryable": {
            "default-value": false,
            "type": "boolean",
            "default-meaning": "The layer will not be available for the direct querying of data values",
            "doc": "This property was added for GetFeatureInfo/WMS compatibility and is rarely used. It is off by default meaning that in a WMS context the layer will not be able to be queried unless the property is explicitly set to true"
        },
        "clear-label-cache": {
            "default-value": false,
            "type": "boolean",
            "default-meaning": "The renderer's collision detector cache (used for avoiding duplicate labels and overlapping markers) will not be cleared immediately before processing this layer",
            "doc": "This property, by default off, can be enabled to allow a user to clear the collision detector cache before a given layer is processed. This may be desirable to ensure that a given layers data shows up on the map even if it normally would not because of collisions with previously rendered labels or markers"
        },
        "group-by": {
            "default-value": "",
            "type": "string",
            "default-meaning": "No special layer grouping will be used during rendering",
            "doc": "https://github.com/mapnik/mapnik/wiki/Grouped-rendering"
        },
        "buffer-size": {
            "default-value": "0",
            "type": "float",
            "default-meaning": "No buffer will be used",
            "doc": "Extra tolerance around the Layer extent (in pixels) used to when querying and (potentially) clipping the layer data during rendering"
        },
        "maximum-extent": {
            "default-value": "none",
            "type": "bbox",
            "default-meaning": "No clipping extent will be used",
            "doc": "An extent to be used to limit the bounds used to query this specific layer data during rendering. Should be minx, miny, maxx, maxy in the coordinates of the Layer."
        }
    },
    "symbolizers": {
        "*": {
            "image-filters": {
                "css": "image-filters",
                "default-value": "none",
                "default-meaning": "no filters",
                "type": "functions",
                "functions": [
                    ["agg-stack-blur", 2],
                    ["emboss", 0],
                    ["blur", 0],
                    ["gray", 0],
                    ["sobel", 0],
                    ["edge-detect", 0],
                    ["x-gradient", 0],
                    ["y-gradient", 0],
                    ["invert", 0],
                    ["sharpen", 0]
                ],
                "doc": "A list of image filters."
            },
            "comp-op": {
                "css": "comp-op",
                "default-value": "src-over",
                "default-meaning": "add the current layer on top of other layers",
                "doc": "Composite operation. This defines how this layer should behave relative to layers atop or below it.",
                "type": ["clear",
                    "src",
                    "dst",
                    "src-over",
                    "dst-over",
                    "src-in",
                    "dst-in",
                    "src-out",
                    "dst-out",
                    "src-atop",
                    "dst-atop",
                    "xor",
                    "plus",
                    "minus",
                    "multiply",
                    "screen",
                    "overlay",
                    "darken",
                    "lighten",
                    "color-dodge",
                    "color-burn",
                    "hard-light",
                    "soft-light",
                    "difference",
                    "exclusion",
                    "contrast",
                    "invert",
                    "invert-rgb",
                    "grain-merge",
                    "grain-extract",
                    "hue",
                    "saturation",
                    "color",
                    "value"
                ]
            },
            "opacity": {
                "css": "opacity",
                "type": "float",
                "doc": "An alpha value for the style (which means an alpha applied to all features in separate buffer and then composited back to main buffer)",
                "default-value": 1,
                "default-meaning": "no separate buffer will be used and no alpha will be applied to the style after rendering"
            }
        },
        "map": {
            "background-color": {
                "css": "background-color",
                "default-value": "none",
                "default-meaning": "transparent",
                "type": "color",
                "doc": "Map Background color"
            },
            "background-image": {
                "css": "background-image",
                "type": "uri",
                "default-value": "",
                "default-meaning": "transparent",
                "doc": "An image that is repeated below all features on a map as a background.",
                "description": "Map Background image"
            },
            "srs": {
                "css": "srs",
                "type": "string",
                "default-value": "+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs",
                "default-meaning": "The proj4 literal of EPSG:4326 is assumed to be the Map's spatial reference and all data from layers within this map will be plotted using this coordinate system. If any layers do not declare an srs value then they will be assumed to be in the same srs as the Map and not transformations will be needed to plot them in the Map's coordinate space",
                "doc": "Map spatial reference (proj4 string)"
            },
            "buffer-size": {
                "css": "buffer-size",
                "default-value": "0",
                "type": "float",
                "default-meaning": "No buffer will be used",
                "doc": "Extra tolerance around the map (in pixels) used to ensure labels crossing tile boundaries are equally rendered in each tile (e.g. cut in each tile). Not intended to be used in combination with \"avoid-edges\"."
            },
            "maximum-extent": {
                "css": "",
                "default-value": "none",
                "type": "bbox",
                "default-meaning": "No clipping extent will be used",
                "doc": "An extent to be used to limit the bounds used to query all layers during rendering. Should be minx, miny, maxx, maxy in the coordinates of the Map."
            },
            "base": {
                "css": "base",
                "default-value": "",
                "default-meaning": "This base path defaults to an empty string meaning that any relative paths to files referenced in styles or layers will be interpreted relative to the application process.",
                "type": "string",
                "doc": "Any relative paths used to reference files will be understood as relative to this directory path if the map is loaded from an in memory object rather than from the filesystem. If the map is loaded from the filesystem and this option is not provided it will be set to the directory of the stylesheet."
            },
            "paths-from-xml": {
                "css": "",
                "default-value": true,
                "default-meaning": "Paths read from XML will be interpreted from the location of the XML",
                "type": "boolean",
                "doc": "value to control whether paths in the XML will be interpreted from the location of the XML or from the working directory of the program that calls load_map()"
            },
            "minimum-version": {
                "css": "",
                "default-value": "none",
                "default-meaning": "Mapnik version will not be detected and no error will be thrown about compatibility",
                "type": "string",
                "doc": "The minumum Mapnik version (e.g. 0.7.2) needed to use certain functionality in the stylesheet"
            },
            "font-directory": {
                "css": "font-directory",
                "type": "uri",
                "default-value": "none",
                "default-meaning": "No map-specific fonts will be registered",
                "doc": "Path to a directory which holds fonts which should be registered when the Map is loaded (in addition to any fonts that may be automatically registered)."
            }
        },
        "polygon": {
            "fill": {
                "css": "polygon-fill",
                "type": "color",
                "default-value": "rgba(128,128,128,1)",
                "default-meaning": "gray and fully opaque (alpha = 1), same as rgb(128,128,128)",
                "doc": "Fill color to assign to a polygon"
            },
            "fill-opacity": {
                "css": "polygon-opacity",
                "type": "float",
                "doc": "The opacity of the polygon",
                "default-value": 1,
                "default-meaning": "opaque"
            },
            "gamma": {
                "css": "polygon-gamma",
                "type": "float",
                "default-value": 1,
                "default-meaning": "fully antialiased",
                "range": "0-1",
                "doc": "Level of antialiasing of polygon edges"
            },
            "gamma-method": {
                "css": "polygon-gamma-method",
                "type": [
                    "power",
                    "linear",
                    "none",
                    "threshold",
                    "multiply"
                ],
                "default-value": "power",
                "default-meaning": "pow(x,gamma) is used to calculate pixel gamma, which produces slightly smoother line and polygon antialiasing than the 'linear' method, while other methods are usually only used to disable AA",
                "doc": "An Antigrain Geometry specific rendering hint to control the quality of antialiasing. Under the hood in Mapnik this method is used in combination with the 'gamma' value (which defaults to 1). The methods are in the AGG source at https://github.com/mapnik/mapnik/blob/master/deps/agg/include/agg_gamma_functions.h"
            },
            "clip": {
                "css": "polygon-clip",
                "type": "boolean",
                "default-value": true,
                "default-meaning": "geometry will be clipped to map bounds before rendering",
                "doc": "geometries are clipped to map bounds by default for best rendering performance. In some cases users may wish to disable this to avoid rendering artifacts."
            },
            "smooth": {
                "css": "polygon-smooth",
                "type": "float",
                "default-value": 0,
                "default-meaning": "no smoothing",
                "range": "0-1",
                "doc": "Smooths out geometry angles. 0 is no smoothing, 1 is fully smoothed. Values greater than 1 will produce wild, looping geometries."
            },
            "geometry-transform": {
                "css": "polygon-geometry-transform",
                "type": "functions",
                "default-value": "none",
                "default-meaning": "geometry will not be transformed",
                "doc": "Allows transformation functions to be applied to the geometry.",
                "functions": [
                    ["matrix", 6],
                    ["translate", 2],
                    ["scale", 2],
                    ["rotate", 3],
                    ["skewX", 1],
                    ["skewY", 1]
                ]
            },
            "comp-op": {
                "css": "polygon-comp-op",
                "default-value": "src-over",
                "default-meaning": "add the current symbolizer on top of other symbolizer",
                "doc": "Composite operation. This defines how this symbolizer should behave relative to symbolizers atop or below it.",
                "type": ["clear",
                    "src",
                    "dst",
                    "src-over",
                    "dst-over",
                    "src-in",
                    "dst-in",
                    "src-out",
                    "dst-out",
                    "src-atop",
                    "dst-atop",
                    "xor",
                    "plus",
                    "minus",
                    "multiply",
                    "screen",
                    "overlay",
                    "darken",
                    "lighten",
                    "color-dodge",
                    "color-burn",
                    "hard-light",
                    "soft-light",
                    "difference",
                    "exclusion",
                    "contrast",
                    "invert",
                    "invert-rgb",
                    "grain-merge",
                    "grain-extract",
                    "hue",
                    "saturation",
                    "color",
                    "value"
                ]
            }
        },
        "line": {
            "stroke": {
                "css": "line-color",
                "default-value": "rgba(0,0,0,1)",
                "type": "color",
                "default-meaning": "black and fully opaque (alpha = 1), same as rgb(0,0,0)",
                "doc": "The color of a drawn line"
            },
            "stroke-width": {
                "css": "line-width",
                "default-value": 1,
                "type": "float",
                "doc": "The width of a line in pixels"
            },
            "stroke-opacity": {
                "css": "line-opacity",
                "default-value": 1,
                "type": "float",
                "default-meaning": "opaque",
                "doc": "The opacity of a line"
            },
            "stroke-linejoin": {
                "css": "line-join",
                "default-value": "miter",
                "type": [
                    "miter",
                    "round",
                    "bevel"
                ],
                "doc": "The behavior of lines when joining"
            },
            "stroke-linecap": {
                "css": "line-cap",
                "default-value": "butt",
                "type": [
                    "butt",
                    "round",
                    "square"
                ],
                "doc": "The display of line endings"
            },
            "stroke-gamma": {
                "css": "line-gamma",
                "type": "float",
                "default-value": 1,
                "default-meaning": "fully antialiased",
                "range": "0-1",
                "doc": "Level of antialiasing of stroke line"
            },
            "stroke-gamma-method": {
                "css": "line-gamma-method",
                "type": [
                    "power",
                    "linear",
                    "none",
                    "threshold",
                    "multiply"
                ],
                "default-value": "power",
                "default-meaning": "pow(x,gamma) is used to calculate pixel gamma, which produces slightly smoother line and polygon antialiasing than the 'linear' method, while other methods are usually only used to disable AA",
                "doc": "An Antigrain Geometry specific rendering hint to control the quality of antialiasing. Under the hood in Mapnik this method is used in combination with the 'gamma' value (which defaults to 1). The methods are in the AGG source at https://github.com/mapnik/mapnik/blob/master/deps/agg/include/agg_gamma_functions.h"
            },
            "stroke-dasharray": {
                "css": "line-dasharray",
                "type": "numbers",
                "doc": "A pair of length values [a,b], where (a) is the dash length and (b) is the gap length respectively. More than two values are supported for more complex patterns.",
                "default-value": "none",
                "default-meaning": "solid line"
            },
            "stroke-dashoffset": {
                "css": "line-dash-offset",
                "type": "numbers",
                "doc": "valid parameter but not currently used in renderers (only exists for experimental svg support in Mapnik which is not yet enabled)",
                "default-value": "none",
                "default-meaning": "solid line"
            },
            "stroke-miterlimit": {
                "css": "line-miterlimit",
                "type": "float",
                "doc": "The limit on the ratio of the miter length to the stroke-width. Used to automatically convert miter joins to bevel joins for sharp angles to avoid the miter extending beyond the thickness of the stroking path. Normally will not need to be set, but a larger value can sometimes help avoid jaggy artifacts.",
                "default-value": 4.0,
                "default-meaning": "Will auto-convert miters to bevel line joins when theta is less than 29 degrees as per the SVG spec: 'miterLength / stroke-width = 1 / sin ( theta / 2 )'"
            },
            "clip": {
                "css": "line-clip",
                "type": "boolean",
                "default-value": true,
                "default-meaning": "geometry will be clipped to map bounds before rendering",
                "doc": "geometries are clipped to map bounds by default for best rendering performance. In some cases users may wish to disable this to avoid rendering artifacts."
            },
            "smooth": {
                "css": "line-smooth",
                "type": "float",
                "default-value": 0,
                "default-meaning": "no smoothing",
                "range": "0-1",
                "doc": "Smooths out geometry angles. 0 is no smoothing, 1 is fully smoothed. Values greater than 1 will produce wild, looping geometries."
            },
            "offset": {
                "css": "line-offset",
                "type": "float",
                "default-value": 0,
                "default-meaning": "no offset",
                "doc": "Offsets a line a number of pixels parallel to its actual path. Postive values move the line left, negative values move it right (relative to the directionality of the line)."
            },
            "rasterizer": {
                "css": "line-rasterizer",
                "type": [
                    "full",
                    "fast"
                ],
                "default-value": "full",
                "doc": "Exposes an alternate AGG rendering method that sacrifices some accuracy for speed."
            },
            "geometry-transform": {
                "css": "line-geometry-transform",
                "type": "functions",
                "default-value": "none",
                "default-meaning": "geometry will not be transformed",
                "doc": "Allows transformation functions to be applied to the geometry.",
                "functions": [
                    ["matrix", 6],
                    ["translate", 2],
                    ["scale", 2],
                    ["rotate", 3],
                    ["skewX", 1],
                    ["skewY", 1]
                ]
            },
            "comp-op": {
                "css": "line-comp-op",
                "default-value": "src-over",
                "default-meaning": "add the current symbolizer on top of other symbolizer",
                "doc": "Composite operation. This defines how this symbolizer should behave relative to symbolizers atop or below it.",
                "type": ["clear",
                    "src",
                    "dst",
                    "src-over",
                    "dst-over",
                    "src-in",
                    "dst-in",
                    "src-out",
                    "dst-out",
                    "src-atop",
                    "dst-atop",
                    "xor",
                    "plus",
                    "minus",
                    "multiply",
                    "screen",
                    "overlay",
                    "darken",
                    "lighten",
                    "color-dodge",
                    "color-burn",
                    "hard-light",
                    "soft-light",
                    "difference",
                    "exclusion",
                    "contrast",
                    "invert",
                    "invert-rgb",
                    "grain-merge",
                    "grain-extract",
                    "hue",
                    "saturation",
                    "color",
                    "value"
                ]
            }
        },
        "markers": {
            "file": {
                "css": "marker-file",
                "doc": "An SVG file that this marker shows at each placement. If no file is given, the marker will show an ellipse.",
                "default-value": "",
                "default-meaning": "An ellipse or circle, if width equals height",
                "type": "uri"
            },
            "opacity": {
                "css": "marker-opacity",
                "doc": "The overall opacity of the marker, if set, overrides both the opacity of both the fill and stroke",
                "default-value": 1,
                "default-meaning": "The stroke-opacity and fill-opacity will be used",
                "type": "float"
            },
            "fill-opacity": {
                "css": "marker-fill-opacity",
                "doc": "The fill opacity of the marker",
                "default-value": 1,
                "default-meaning": "opaque",
                "type": "float"
            },
            "stroke": {
                "css": "marker-line-color",
                "doc": "The color of the stroke around a marker shape.",
                "default-value": "black",
                "type": "color"
            },
            "stroke-width": {
                "css": "marker-line-width",
                "doc": "The width of the stroke around a marker shape, in pixels. This is positioned on the boundary, so high values can cover the area itself.",
                "type": "float"
            },
            "stroke-opacity": {
                "css": "marker-line-opacity",
                "default-value": 1,
                "default-meaning": "opaque",
                "doc": "The opacity of a line",
                "type": "float"
            },
            "placement": {
                "css": "marker-placement",
                "type": [
                    "point",
                    "line",
                    "interior"
                ],
                "default-value": "point",
                "default-meaning": "Place markers at the center point (centroid) of the geometry",
                "doc": "Attempt to place markers on a point, in the center of a polygon, or if markers-placement:line, then multiple times along a line. 'interior' placement can be used to ensure that points placed on polygons are forced to be inside the polygon interior"
            },
            "multi-policy": {
                "css": "marker-multi-policy",
                "type": [
                    "each",
                    "whole",
                    "largest"
                ],
                "default-value": "each",
                "default-meaning": "If a feature contains multiple geometries and the placement type is either point or interior then a marker will be rendered for each",
                "doc": "A special setting to allow the user to control rendering behavior for 'multi-geometries' (when a feature contains multiple geometries). This setting does not apply to markers placed along lines. The 'each' policy is default and means all geometries will get a marker. The 'whole' policy means that the aggregate centroid between all geometries will be used. The 'largest' policy means that only the largest (by bounding box areas) feature will get a rendered marker (this is how text labeling behaves by default)."
            },
            "marker-type": {
                "css": "marker-type",
                "type": [
                    "arrow",
                    "ellipse"
                ],
                "default-value": "ellipse",
                "doc": "The default marker-type. If a SVG file is not given as the marker-file parameter, the renderer provides either an arrow or an ellipse (a circle if height is equal to width)"
            },
            "width": {
                "css": "marker-width",
                "default-value": 10,
                "doc": "The width of the marker, if using one of the default types.",
                "type": "expression"
            },
            "height": {
                "css": "marker-height",
                "default-value": 10,
                "doc": "The height of the marker, if using one of the default types.",
                "type": "expression"
            },
            "fill": {
                "css": "marker-fill",
                "default-value": "blue",
                "doc": "The color of the area of the marker.",
                "type": "color"
            },
            "allow-overlap": {
                "css": "marker-allow-overlap",
                "type": "boolean",
                "default-value": false,
                "doc": "Control whether overlapping markers are shown or hidden.",
                "default-meaning": "Do not allow makers to overlap with each other - overlapping markers will not be shown."
            },
            "ignore-placement": {
                "css": "marker-ignore-placement",
                "type": "boolean",
                "default-value": false,
                "default-meaning": "do not store the bbox of this geometry in the collision detector cache",
                "doc": "value to control whether the placement of the feature will prevent the placement of other features"
            },
            "spacing": {
                "css": "marker-spacing",
                "doc": "Space between repeated labels",
                "default-value": 100,
                "type": "float"
            },
            "max-error": {
                "css": "marker-max-error",
                "type": "float",
                "default-value": 0.2,
                "doc": "The maximum difference between actual marker placement and the marker-spacing parameter. Setting a high value can allow the renderer to try to resolve placement conflicts with other symbolizers."
            },
            "transform": {
                "css": "marker-transform",
                "type": "functions",
                "functions": [
                    ["matrix", 6],
                    ["translate", 2],
                    ["scale", 2],
                    ["rotate", 3],
                    ["skewX", 1],
                    ["skewY", 1]
                ],
                "default-value": "",
                "default-meaning": "No transformation",
                "doc": "SVG transformation definition"
            },
            "clip": {
                "css": "marker-clip",
                "type": "boolean",
                "default-value": true,
                "default-meaning": "geometry will be clipped to map bounds before rendering",
                "doc": "geometries are clipped to map bounds by default for best rendering performance. In some cases users may wish to disable this to avoid rendering artifacts."
            },
            "smooth": {
                "css": "marker-smooth",
                "type": "float",
                "default-value": 0,
                "default-meaning": "no smoothing",
                "range": "0-1",
                "doc": "Smooths out geometry angles. 0 is no smoothing, 1 is fully smoothed. Values greater than 1 will produce wild, looping geometries."
            },
            "geometry-transform": {
                "css": "marker-geometry-transform",
                "type": "functions",
                "default-value": "none",
                "default-meaning": "geometry will not be transformed",
                "doc": "Allows transformation functions to be applied to the geometry.",
                "functions": [
                    ["matrix", 6],
                    ["translate", 2],
                    ["scale", 2],
                    ["rotate", 3],
                    ["skewX", 1],
                    ["skewY", 1]
                ]
            },
            "comp-op": {
                "css": "marker-comp-op",
                "default-value": "src-over",
                "default-meaning": "add the current symbolizer on top of other symbolizer",
                "doc": "Composite operation. This defines how this symbolizer should behave relative to symbolizers atop or below it.",
                "type": ["clear",
                    "src",
                    "dst",
                    "src-over",
                    "dst-over",
                    "src-in",
                    "dst-in",
                    "src-out",
                    "dst-out",
                    "src-atop",
                    "dst-atop",
                    "xor",
                    "plus",
                    "minus",
                    "multiply",
                    "screen",
                    "overlay",
                    "darken",
                    "lighten",
                    "color-dodge",
                    "color-burn",
                    "hard-light",
                    "soft-light",
                    "difference",
                    "exclusion",
                    "contrast",
                    "invert",
                    "invert-rgb",
                    "grain-merge",
                    "grain-extract",
                    "hue",
                    "saturation",
                    "color",
                    "value"
                ]
            }
        },
        "shield": {
            "name": {
                "css": "shield-name",
                "type": "expression",
                "serialization": "content",
                "doc": "Value to use for a shield\"s text label. Data columns are specified using brackets like [column_name]"
            },
            "file": {
                "css": "shield-file",
                "required": true,
                "type": "uri",
                "default-value": "none",
                "doc": "Image file to render behind the shield text"
            },
            "face-name": {
                "css": "shield-face-name",
                "type": "string",
                "validate": "font",
                "doc": "Font name and style to use for the shield text",
                "default-value": "",
                "required": true
            },
            "unlock-image": {
                "css": "shield-unlock-image",
                "type": "boolean",
                "doc": "This parameter should be set to true if you are trying to position text beside rather than on top of the shield image",
                "default-value": false,
                "default-meaning": "text alignment relative to the shield image uses the center of the image as the anchor for text positioning."
            },
            "size": {
                "css": "shield-size",
                "type": "float",
                "doc": "The size of the shield text in pixels"
            },
            "fill": {
                "css": "shield-fill",
                "type": "color",
                "doc": "The color of the shield text"
            },
            "placement": {
                "css": "shield-placement",
                "type": [
                    "point",
                    "line",
                    "vertex",
                    "interior"
                ],
                "default-value": "point",
                "doc": "How this shield should be placed. Point placement attempts to place it on top of points, line places along lines multiple times per feature, vertex places on the vertexes of polygons, and interior attempts to place inside of polygons."
            },
            "avoid-edges": {
                "css": "shield-avoid-edges",
                "doc": "Tell positioning algorithm to avoid labeling near intersection edges.",
                "type": "boolean",
                "default-value": false
            },
            "allow-overlap": {
                "css": "shield-allow-overlap",
                "type": "boolean",
                "default-value": false,
                "doc": "Control whether overlapping shields are shown or hidden.",
                "default-meaning": "Do not allow shields to overlap with other map elements already placed."
            },
            "minimum-distance": {
                "css": "shield-min-distance",
                "type": "float",
                "default-value": 0,
                "doc": "Minimum distance to the next shield symbol, not necessarily the same shield."
            },
            "spacing": {
                "css": "shield-spacing",
                "type": "float",
                "default-value": 0,
                "doc": "The spacing between repeated occurrences of the same shield on a line"
            },
            "minimum-padding": {
                "css": "shield-min-padding",
                "default-value": 0,
                "doc": "Determines the minimum amount of padding that a shield gets relative to other shields",
                "type": "float"
            },
            "wrap-width": {
                "css": "shield-wrap-width",
                "type": "unsigned",
                "default-value": 0,
                "doc": "Length of a chunk of text in characters before wrapping text"
            },
            "wrap-before": {
                "css": "shield-wrap-before",
                "type": "boolean",
                "default-value": false,
                "doc": "Wrap text before wrap-width is reached. If false, wrapped lines will be a bit longer than wrap-width."
            },
            "wrap-character": {
                "css": "shield-wrap-character",
                "type": "string",
                "default-value": " ",
                "doc": "Use this character instead of a space to wrap long names."
            },
            "halo-fill": {
                "css": "shield-halo-fill",
                "type": "color",
                "default-value": "#FFFFFF",
                "default-meaning": "white",
                "doc": "Specifies the color of the halo around the text."
            },
            "halo-radius": {
                "css": "shield-halo-radius",
                "doc": "Specify the radius of the halo in pixels",
                "default-value": 0,
                "default-meaning": "no halo",
                "type": "float"
            },
            "character-spacing": {
                "css": "shield-character-spacing",
                "type": "unsigned",
                "default-value": 0,
                "doc": "Horizontal spacing between characters (in pixels). Currently works for point placement only, not line placement."
            },
            "line-spacing": {
                "css": "shield-line-spacing",
                "doc": "Vertical spacing between lines of multiline labels (in pixels)",
                "type": "unsigned"
            },
            "dx": {
                "css": "shield-text-dx",
                "type": "float",
                "doc": "Displace text within shield by fixed amount, in pixels, +/- along the X axis.  A positive value will shift the text right",
                "default-value": 0
            },
            "dy": {
                "css": "shield-text-dy",
                "type": "float",
                "doc": "Displace text within shield by fixed amount, in pixels, +/- along the Y axis.  A positive value will shift the text down",
                "default-value": 0
            },
            "shield-dx": {
                "css": "shield-dx",
                "type": "float",
                "doc": "Displace shield by fixed amount, in pixels, +/- along the X axis.  A positive value will shift the text right",
                "default-value": 0
            },
            "shield-dy": {
                "css": "shield-dy",
                "type": "float",
                "doc": "Displace shield by fixed amount, in pixels, +/- along the Y axis.  A positive value will shift the text down",
                "default-value": 0
            },
            "opacity": {
                "css": "shield-opacity",
                "type": "float",
                "doc": "(Default 1.0) - opacity of the image used for the shield",
                "default-value": 1
            },
            "text-opacity": {
                "css": "shield-text-opacity",
                "type": "float",
                "doc": "(Default 1.0) - opacity of the text placed on top of the shield",
                "default-value": 1
            },
            "horizontal-alignment": {
                "css": "shield-horizontal-alignment",
                "type": [
                    "left",
                    "middle",
                    "right",
                    "auto"
                ],
                "doc": "The shield's horizontal alignment from its centerpoint",
                "default-value": "auto"
            },
            "vertical-alignment": {
                "css": "shield-vertical-alignment",
                "type": [
                    "top",
                    "middle",
                    "bottom",
                    "auto"
                ],
                "doc": "The shield's vertical alignment from its centerpoint",
                "default-value": "middle"
            },
            "text-transform": {
                "css": "shield-text-transform",
                "type": [
                    "none",
                    "uppercase",
                    "lowercase",
                    "capitalize"
                ],
                "doc": "Transform the case of the characters",
                "default-value": "none"
            },
            "justify-alignment": {
                "css": "shield-justify-alignment",
                "type": [
                    "left",
                    "center",
                    "right",
                    "auto"
                ],
                "doc": "Define how text in a shield's label is justified",
                "default-value": "auto"
            },
            "clip": {
                "css": "shield-clip",
                "type": "boolean",
                "default-value": true,
                "default-meaning": "geometry will be clipped to map bounds before rendering",
                "doc": "geometries are clipped to map bounds by default for best rendering performance. In some cases users may wish to disable this to avoid rendering artifacts."
            },
            "comp-op": {
                "css": "shield-comp-op",
                "default-value": "src-over",
                "default-meaning": "add the current symbolizer on top of other symbolizer",
                "doc": "Composite operation. This defines how this symbolizer should behave relative to symbolizers atop or below it.",
                "type": ["clear",
                    "src",
                    "dst",
                    "src-over",
                    "dst-over",
                    "src-in",
                    "dst-in",
                    "src-out",
                    "dst-out",
                    "src-atop",
                    "dst-atop",
                    "xor",
                    "plus",
                    "minus",
                    "multiply",
                    "screen",
                    "overlay",
                    "darken",
                    "lighten",
                    "color-dodge",
                    "color-burn",
                    "hard-light",
                    "soft-light",
                    "difference",
                    "exclusion",
                    "contrast",
                    "invert",
                    "invert-rgb",
                    "grain-merge",
                    "grain-extract",
                    "hue",
                    "saturation",
                    "color",
                    "value"
                ]
            }
        },
        "line-pattern": {
            "file": {
                "css": "line-pattern-file",
                "type": "uri",
                "default-value": "none",
                "required": true,
                "doc": "An image file to be repeated and warped along a line"
            },
            "clip": {
                "css": "line-pattern-clip",
                "type": "boolean",
                "default-value": true,
                "default-meaning": "geometry will be clipped to map bounds before rendering",
                "doc": "geometries are clipped to map bounds by default for best rendering performance. In some cases users may wish to disable this to avoid rendering artifacts."
            },
            "smooth": {
                "css": "line-pattern-smooth",
                "type": "float",
                "default-value": 0,
                "default-meaning": "no smoothing",
                "range": "0-1",
                "doc": "Smooths out geometry angles. 0 is no smoothing, 1 is fully smoothed. Values greater than 1 will produce wild, looping geometries."
            },
            "geometry-transform": {
                "css": "line-pattern-geometry-transform",
                "type": "functions",
                "default-value": "none",
                "default-meaning": "geometry will not be transformed",
                "doc": "Allows transformation functions to be applied to the geometry.",
                "functions": [
                    ["matrix", 6],
                    ["translate", 2],
                    ["scale", 2],
                    ["rotate", 3],
                    ["skewX", 1],
                    ["skewY", 1]
                ]
            },
            "comp-op": {
                "css": "line-pattern-comp-op",
                "default-value": "src-over",
                "default-meaning": "add the current symbolizer on top of other symbolizer",
                "doc": "Composite operation. This defines how this symbolizer should behave relative to symbolizers atop or below it.",
                "type": ["clear",
                    "src",
                    "dst",
                    "src-over",
                    "dst-over",
                    "src-in",
                    "dst-in",
                    "src-out",
                    "dst-out",
                    "src-atop",
                    "dst-atop",
                    "xor",
                    "plus",
                    "minus",
                    "multiply",
                    "screen",
                    "overlay",
                    "darken",
                    "lighten",
                    "color-dodge",
                    "color-burn",
                    "hard-light",
                    "soft-light",
                    "difference",
                    "exclusion",
                    "contrast",
                    "invert",
                    "invert-rgb",
                    "grain-merge",
                    "grain-extract",
                    "hue",
                    "saturation",
                    "color",
                    "value"
                ]
            }
        },
        "polygon-pattern": {
            "file": {
                "css": "polygon-pattern-file",
                "type": "uri",
                "default-value": "none",
                "required": true,
                "doc": "Image to use as a repeated pattern fill within a polygon"
            },
            "alignment": {
                "css": "polygon-pattern-alignment",
                "type": [
                    "local",
                    "global"
                ],
                "default-value": "local",
                "doc": "Specify whether to align pattern fills to the layer or to the map."
            },
            "gamma": {
                "css": "polygon-pattern-gamma",
                "type": "float",
                "default-value": 1,
                "default-meaning": "fully antialiased",
                "range": "0-1",
                "doc": "Level of antialiasing of polygon pattern edges"
            },
            "opacity": {
                "css": "polygon-pattern-opacity",
                "type": "float",
                "doc": "(Default 1.0) - Apply an opacity level to the image used for the pattern",
                "default-value": 1,
                "default-meaning": "The image is rendered without modifications"
            },
            "clip": {
                "css": "polygon-pattern-clip",
                "type": "boolean",
                "default-value": true,
                "default-meaning": "geometry will be clipped to map bounds before rendering",
                "doc": "geometries are clipped to map bounds by default for best rendering performance. In some cases users may wish to disable this to avoid rendering artifacts."
            },
            "smooth": {
                "css": "polygon-pattern-smooth",
                "type": "float",
                "default-value": 0,
                "default-meaning": "no smoothing",
                "range": "0-1",
                "doc": "Smooths out geometry angles. 0 is no smoothing, 1 is fully smoothed. Values greater than 1 will produce wild, looping geometries."
            },
            "geometry-transform": {
                "css": "polygon-pattern-geometry-transform",
                "type": "functions",
                "default-value": "none",
                "default-meaning": "geometry will not be transformed",
                "doc": "Allows transformation functions to be applied to the geometry.",
                "functions": [
                    ["matrix", 6],
                    ["translate", 2],
                    ["scale", 2],
                    ["rotate", 3],
                    ["skewX", 1],
                    ["skewY", 1]
                ]
            },
            "comp-op": {
                "css": "polygon-pattern-comp-op",
                "default-value": "src-over",
                "default-meaning": "add the current symbolizer on top of other symbolizer",
                "doc": "Composite operation. This defines how this symbolizer should behave relative to symbolizers atop or below it.",
                "type": ["clear",
                    "src",
                    "dst",
                    "src-over",
                    "dst-over",
                    "src-in",
                    "dst-in",
                    "src-out",
                    "dst-out",
                    "src-atop",
                    "dst-atop",
                    "xor",
                    "plus",
                    "minus",
                    "multiply",
                    "screen",
                    "overlay",
                    "darken",
                    "lighten",
                    "color-dodge",
                    "color-burn",
                    "hard-light",
                    "soft-light",
                    "difference",
                    "exclusion",
                    "contrast",
                    "invert",
                    "invert-rgb",
                    "grain-merge",
                    "grain-extract",
                    "hue",
                    "saturation",
                    "color",
                    "value"
                ]
            }
        },
        "raster": {
            "opacity": {
                "css": "raster-opacity",
                "default-value": 1,
                "default-meaning": "opaque",
                "type": "float",
                "doc": "The opacity of the raster symbolizer on top of other symbolizers."
            },
            "filter-factor": {
                "css": "raster-filter-factor",
                "default-value": -1,
                "default-meaning": "Allow the datasource to choose appropriate downscaling.",
                "type": "float",
                "doc": "This is used by the Raster or Gdal datasources to pre-downscale images using overviews. Higher numbers can sometimes cause much better scaled image output, at the cost of speed."
            },
            "scaling": {
                "css": "raster-scaling",
                "type": [
                    "near",
                    "fast",
                    "bilinear",
                    "bilinear8",
                    "bicubic",
                    "spline16",
                    "spline36",
                    "hanning",
                    "hamming",
                    "hermite",
                    "kaiser",
                    "quadric",
                    "catrom",
                    "gaussian",
                    "bessel",
                    "mitchell",
                    "sinc",
                    "lanczos",
                    "blackman"
                ],
                "default-value": "near",
                "doc": "The scaling algorithm used to making different resolution versions of this raster layer. Bilinear is a good compromise between speed and accuracy, while lanczos gives the highest quality."
            },
            "mesh-size": {
                "css": "raster-mesh-size",
                "default-value": 16,
                "default-meaning": "Reprojection mesh will be 1/16 of the resolution of the source image",
                "type": "unsigned",
                "doc": "A reduced resolution mesh is used for raster reprojection, and the total image size is divided by the mesh-size to determine the quality of that mesh. Values for mesh-size larger than the default will result in faster reprojection but might lead to distortion."
            },
            "comp-op": {
                "css": "raster-comp-op",
                "default-value": "src-over",
                "default-meaning": "add the current symbolizer on top of other symbolizer",
                "doc": "Composite operation. This defines how this symbolizer should behave relative to symbolizers atop or below it.",
                "type": ["clear",
                    "src",
                    "dst",
                    "src-over",
                    "dst-over",
                    "src-in",
                    "dst-in",
                    "src-out",
                    "dst-out",
                    "src-atop",
                    "dst-atop",
                    "xor",
                    "plus",
                    "minus",
                    "multiply",
                    "screen",
                    "overlay",
                    "darken",
                    "lighten",
                    "color-dodge",
                    "color-burn",
                    "hard-light",
                    "soft-light",
                    "difference",
                    "exclusion",
                    "contrast",
                    "invert",
                    "invert-rgb",
                    "grain-merge",
                    "grain-extract",
                    "hue",
                    "saturation",
                    "color",
                    "value"
                ]
            }
        },
        "point": {
            "file": {
                "css": "point-file",
                "type": "uri",
                "required": false,
                "default-value": "none",
                "doc": "Image file to represent a point"
            },
            "allow-overlap": {
                "css": "point-allow-overlap",
                "type": "boolean",
                "default-value": false,
                "doc": "Control whether overlapping points are shown or hidden.",
                "default-meaning": "Do not allow points to overlap with each other - overlapping markers will not be shown."
            },
            "ignore-placement": {
                "css": "point-ignore-placement",
                "type": "boolean",
                "default-value": false,
                "default-meaning": "do not store the bbox of this geometry in the collision detector cache",
                "doc": "value to control whether the placement of the feature will prevent the placement of other features"
            },
            "opacity": {
                "css": "point-opacity",
                "type": "float",
                "default-value": 1.0,
                "default-meaning": "Fully opaque",
                "doc": "A value from 0 to 1 to control the opacity of the point"
            },
            "placement": {
                "css": "point-placement",
                "type": [
                    "centroid",
                    "interior"
                ],
                "doc": "How this point should be placed. Centroid calculates the geometric center of a polygon, which can be outside of it, while interior always places inside of a polygon.",
                "default-value": "centroid"
            },
            "transform": {
                "css": "point-transform",
                "type": "functions",
                "functions": [
                    ["matrix", 6],
                    ["translate", 2],
                    ["scale", 2],
                    ["rotate", 3],
                    ["skewX", 1],
                    ["skewY", 1]
                ],
                "default-value": "",
                "default-meaning": "No transformation",
                "doc": "SVG transformation definition"
            },
            "comp-op": {
                "css": "point-comp-op",
                "default-value": "src-over",
                "default-meaning": "add the current symbolizer on top of other symbolizer",
                "doc": "Composite operation. This defines how this symbolizer should behave relative to symbolizers atop or below it.",
                "type": ["clear",
                    "src",
                    "dst",
                    "src-over",
                    "dst-over",
                    "src-in",
                    "dst-in",
                    "src-out",
                    "dst-out",
                    "src-atop",
                    "dst-atop",
                    "xor",
                    "plus",
                    "minus",
                    "multiply",
                    "screen",
                    "overlay",
                    "darken",
                    "lighten",
                    "color-dodge",
                    "color-burn",
                    "hard-light",
                    "soft-light",
                    "difference",
                    "exclusion",
                    "contrast",
                    "invert",
                    "invert-rgb",
                    "grain-merge",
                    "grain-extract",
                    "hue",
                    "saturation",
                    "color",
                    "value"
                ]
            }
        },
        "text": {
            "name": {
                "css": "text-name",
                "type": "expression",
                "required": true,
                "default-value": "",
                "serialization": "content",
                "doc": "Value to use for a text label. Data columns are specified using brackets like [column_name]"
            },
            "face-name": {
                "css": "text-face-name",
                "type": "string",
                "validate": "font",
                "doc": "Font name and style to render a label in",
                "required": true
            },
            "size": {
                "css": "text-size",
                "type": "float",
                "default-value": 10,
                "doc": "Text size in pixels"
            },
            "text-ratio": {
                "css": "text-ratio",
                "doc": "Define the amount of text (of the total) present on successive lines when wrapping occurs",
                "default-value": 0,
                "type": "unsigned"
            },
            "wrap-width": {
                "css": "text-wrap-width",
                "doc": "Length of a chunk of text in characters before wrapping text",
                "default-value": 0,
                "type": "unsigned"
            },
            "wrap-before": {
                "css": "text-wrap-before",
                "type": "boolean",
                "default-value": false,
                "doc": "Wrap text before wrap-width is reached. If false, wrapped lines will be a bit longer than wrap-width."
            },
            "wrap-character": {
                "css": "text-wrap-character",
                "type": "string",
                "default-value": " ",
                "doc": "Use this character instead of a space to wrap long text."
            },
            "spacing": {
                "css": "text-spacing",
                "type": "unsigned",
                "doc": "Distance between repeated text labels on a line (aka. label-spacing)"
            },
            "character-spacing": {
                "css": "text-character-spacing",
                "type": "float",
                "default-value": 0,
                "doc": "Horizontal spacing adjustment between characters in pixels"
            },
            "line-spacing": {
                "css": "text-line-spacing",
                "default-value": 0,
                "type": "unsigned",
                "doc": "Vertical spacing adjustment between lines in pixels"
            },
            "label-position-tolerance": {
                "css": "text-label-position-tolerance",
                "default-value": 0,
                "type": "unsigned",
                "doc": "Allows the label to be displaced from its ideal position by a number of pixels (only works with placement:line)"
            },
            "max-char-angle-delta": {
                "css": "text-max-char-angle-delta",
                "type": "float",
                "default-value": "22.5",
                "doc": "The maximum angle change, in degrees, allowed between adjacent characters in a label. This value internally is converted to radians to the default is 22.5*math.pi/180.0. The higher the value the fewer labels will be placed around around sharp corners."
            },
            "fill": {
                "css": "text-fill",
                "doc": "Specifies the color for the text",
                "default-value": "#000000",
                "type": "color"
            },
            "opacity": {
                "css": "text-opacity",
                "doc": "A number from 0 to 1 specifying the opacity for the text",
                "default-value": 1.0,
                "default-meaning": "Fully opaque",
                "type": "float"
            },
            "halo-fill": {
                "css": "text-halo-fill",
                "type": "color",
                "default-value": "#FFFFFF",
                "default-meaning": "white",
                "doc": "Specifies the color of the halo around the text."
            },
            "halo-radius": {
                "css": "text-halo-radius",
                "doc": "Specify the radius of the halo in pixels",
                "default-value": 0,
                "default-meaning": "no halo",
                "type": "float"
            },
            "dx": {
                "css": "text-dx",
                "type": "float",
                "doc": "Displace text by fixed amount, in pixels, +/- along the X axis.  A positive value will shift the text right",
                "default-value": 0
            },
            "dy": {
                "css": "text-dy",
                "type": "float",
                "doc": "Displace text by fixed amount, in pixels, +/- along the Y axis.  A positive value will shift the text down",
                "default-value": 0
            },
            "vertical-alignment": {
                "css": "text-vertical-alignment",
                "type": [
                    "top",
                    "middle",
                    "bottom",
                    "auto"
                ],
                "doc": "Position of label relative to point position.",
                "default-value": "auto",
                "default-meaning": "Default affected by value of dy; \"bottom\" for dy>0, \"top\" for dy<0."
            },
            "avoid-edges": {
                "css": "text-avoid-edges",
                "doc": "Tell positioning algorithm to avoid labeling near intersection edges.",
                "default-value": false,
                "type": "boolean"
            },
            "minimum-distance": {
                "css": "text-min-distance",
                "doc": "Minimum permitted distance to the next text symbolizer.",
                "type": "float"
            },
            "minimum-padding": {
                "css": "text-min-padding",
                "doc": "Determines the minimum amount of padding that a text symbolizer gets relative to other text",
                "type": "float"
            },
            "minimum-path-length": {
                "css": "text-min-path-length",
                "type": "float",
                "default-value": 0,
                "default-meaning": "place labels on all paths",
                "doc": "Place labels only on paths longer than this value."
            },
            "allow-overlap": {
                "css": "text-allow-overlap",
                "type": "boolean",
                "default-value": false,
                "doc": "Control whether overlapping text is shown or hidden.",
                "default-meaning": "Do not allow text to overlap with other text - overlapping markers will not be shown."
            },
            "orientation": {
                "css": "text-orientation",
                "type": "expression",
                "doc": "Rotate the text."
            },
            "placement": {
                "css": "text-placement",
                "type": [
                    "point",
                    "line",
                    "vertex",
                    "interior"
                ],
                "default-value": "point",
                "doc": "Control the style of placement of a point versus the geometry it is attached to."
            },
            "placement-type": {
                "css": "text-placement-type",
                "doc": "Re-position and/or re-size text to avoid overlaps. \"simple\" for basic algorithm (using text-placements string,) \"dummy\" to turn this feature off.",
                "type": [
                    "dummy",
                    "simple"
                ],
                "default-value": "dummy"
            },
            "placements": {
                "css": "text-placements",
                "type": "string",
                "default-value": "",
                "doc": "If \"placement-type\" is set to \"simple\", use this \"POSITIONS,[SIZES]\" string. An example is `text-placements: \"E,NE,SE,W,NW,SW\";` "
            },
            "text-transform": {
                "css": "text-transform",
                "type": [
                    "none",
                    "uppercase",
                    "lowercase",
                    "capitalize"
                ],
                "doc": "Transform the case of the characters",
                "default-value": "none"
            },
            "horizontal-alignment": {
                "css": "text-horizontal-alignment",
                "type": [
                    "left",
                    "middle",
                    "right",
                    "auto"
                ],
                "doc": "The text's horizontal alignment from its centerpoint",
                "default-value": "auto"
            },
            "justify-alignment": {
                "css": "text-align",
                "type": [
                    "left",
                    "right",
                    "center",
                    "auto"
                ],
                "doc": "Define how text is justified",
                "default-value": "auto",
                "default-meaning": "Auto alignment means that text will be centered by default except when using the `placement-type` parameter - in that case either right or left justification will be used automatically depending on where the text could be fit given the `text-placements` directives"
            },
            "clip": {
                "css": "text-clip",
                "type": "boolean",
                "default-value": true,
                "default-meaning": "geometry will be clipped to map bounds before rendering",
                "doc": "geometries are clipped to map bounds by default for best rendering performance. In some cases users may wish to disable this to avoid rendering artifacts."
            },
            "comp-op": {
                "css": "text-comp-op",
                "default-value": "src-over",
                "default-meaning": "add the current symbolizer on top of other symbolizer",
                "doc": "Composite operation. This defines how this symbolizer should behave relative to symbolizers atop or below it.",
                "type": ["clear",
                    "src",
                    "dst",
                    "src-over",
                    "dst-over",
                    "src-in",
                    "dst-in",
                    "src-out",
                    "dst-out",
                    "src-atop",
                    "dst-atop",
                    "xor",
                    "plus",
                    "minus",
                    "multiply",
                    "screen",
                    "overlay",
                    "darken",
                    "lighten",
                    "color-dodge",
                    "color-burn",
                    "hard-light",
                    "soft-light",
                    "difference",
                    "exclusion",
                    "contrast",
                    "invert",
                    "invert-rgb",
                    "grain-merge",
                    "grain-extract",
                    "hue",
                    "saturation",
                    "color",
                    "value"
                ]
            }
        },
        "building": {
            "fill": {
                "css": "building-fill",
                "default-value": "#FFFFFF",
                "doc": "The color of the buildings walls.",
                "type": "color"
            },
            "fill-opacity": {
                "css": "building-fill-opacity",
                "type": "float",
                "doc": "The opacity of the building as a whole, including all walls.",
                "default-value": 1
            },
            "height": {
                "css": "building-height",
                "doc": "The height of the building in pixels.",
                "type": "expression",
                "default-value": "0"
            }
        }
    },
    "colors": {
        "aliceblue": [240, 248, 255],
        "antiquewhite": [250, 235, 215],
        "aqua": [0, 255, 255],
        "aquamarine": [127, 255, 212],
        "azure": [240, 255, 255],
        "beige": [245, 245, 220],
        "bisque": [255, 228, 196],
        "black": [0, 0, 0],
        "blanchedalmond": [255, 235, 205],
        "blue": [0, 0, 255],
        "blueviolet": [138, 43, 226],
        "brown": [165, 42, 42],
        "burlywood": [222, 184, 135],
        "cadetblue": [95, 158, 160],
        "chartreuse": [127, 255, 0],
        "chocolate": [210, 105, 30],
        "coral": [255, 127, 80],
        "cornflowerblue": [100, 149, 237],
        "cornsilk": [255, 248, 220],
        "crimson": [220, 20, 60],
        "cyan": [0, 255, 255],
        "darkblue": [0, 0, 139],
        "darkcyan": [0, 139, 139],
        "darkgoldenrod": [184, 134, 11],
        "darkgray": [169, 169, 169],
        "darkgreen": [0, 100, 0],
        "darkgrey": [169, 169, 169],
        "darkkhaki": [189, 183, 107],
        "darkmagenta": [139, 0, 139],
        "darkolivegreen": [85, 107, 47],
        "darkorange": [255, 140, 0],
        "darkorchid": [153, 50, 204],
        "darkred": [139, 0, 0],
        "darksalmon": [233, 150, 122],
        "darkseagreen": [143, 188, 143],
        "darkslateblue": [72, 61, 139],
        "darkslategrey": [47, 79, 79],
        "darkturquoise": [0, 206, 209],
        "darkviolet": [148, 0, 211],
        "deeppink": [255, 20, 147],
        "deepskyblue": [0, 191, 255],
        "dimgray": [105, 105, 105],
        "dimgrey": [105, 105, 105],
        "dodgerblue": [30, 144, 255],
        "firebrick": [178, 34, 34],
        "floralwhite": [255, 250, 240],
        "forestgreen": [34, 139, 34],
        "fuchsia": [255, 0, 255],
        "gainsboro": [220, 220, 220],
        "ghostwhite": [248, 248, 255],
        "gold": [255, 215, 0],
        "goldenrod": [218, 165, 32],
        "gray": [128, 128, 128],
        "grey": [128, 128, 128],
        "green": [0, 128, 0],
        "greenyellow": [173, 255, 47],
        "honeydew": [240, 255, 240],
        "hotpink": [255, 105, 180],
        "indianred": [205, 92, 92],
        "indigo": [75, 0, 130],
        "ivory": [255, 255, 240],
        "khaki": [240, 230, 140],
        "lavender": [230, 230, 250],
        "lavenderblush": [255, 240, 245],
        "lawngreen": [124, 252, 0],
        "lemonchiffon": [255, 250, 205],
        "lightblue": [173, 216, 230],
        "lightcoral": [240, 128, 128],
        "lightcyan": [224, 255, 255],
        "lightgoldenrodyellow": [250, 250, 210],
        "lightgray": [211, 211, 211],
        "lightgreen": [144, 238, 144],
        "lightgrey": [211, 211, 211],
        "lightpink": [255, 182, 193],
        "lightsalmon": [255, 160, 122],
        "lightseagreen": [32, 178, 170],
        "lightskyblue": [135, 206, 250],
        "lightslategray": [119, 136, 153],
        "lightslategrey": [119, 136, 153],
        "lightsteelblue": [176, 196, 222],
        "lightyellow": [255, 255, 224],
        "lime": [0, 255, 0],
        "limegreen": [50, 205, 50],
        "linen": [250, 240, 230],
        "magenta": [255, 0, 255],
        "maroon": [128, 0, 0],
        "mediumaquamarine": [102, 205, 170],
        "mediumblue": [0, 0, 205],
        "mediumorchid": [186, 85, 211],
        "mediumpurple": [147, 112, 219],
        "mediumseagreen": [60, 179, 113],
        "mediumslateblue": [123, 104, 238],
        "mediumspringgreen": [0, 250, 154],
        "mediumturquoise": [72, 209, 204],
        "mediumvioletred": [199, 21, 133],
        "midnightblue": [25, 25, 112],
        "mintcream": [245, 255, 250],
        "mistyrose": [255, 228, 225],
        "moccasin": [255, 228, 181],
        "navajowhite": [255, 222, 173],
        "navy": [0, 0, 128],
        "oldlace": [253, 245, 230],
        "olive": [128, 128, 0],
        "olivedrab": [107, 142, 35],
        "orange": [255, 165, 0],
        "orangered": [255, 69, 0],
        "orchid": [218, 112, 214],
        "palegoldenrod": [238, 232, 170],
        "palegreen": [152, 251, 152],
        "paleturquoise": [175, 238, 238],
        "palevioletred": [219, 112, 147],
        "papayawhip": [255, 239, 213],
        "peachpuff": [255, 218, 185],
        "peru": [205, 133, 63],
        "pink": [255, 192, 203],
        "plum": [221, 160, 221],
        "powderblue": [176, 224, 230],
        "purple": [128, 0, 128],
        "red": [255, 0, 0],
        "rosybrown": [188, 143, 143],
        "royalblue": [65, 105, 225],
        "saddlebrown": [139, 69, 19],
        "salmon": [250, 128, 114],
        "sandybrown": [244, 164, 96],
        "seagreen": [46, 139, 87],
        "seashell": [255, 245, 238],
        "sienna": [160, 82, 45],
        "silver": [192, 192, 192],
        "skyblue": [135, 206, 235],
        "slateblue": [106, 90, 205],
        "slategray": [112, 128, 144],
        "slategrey": [112, 128, 144],
        "snow": [255, 250, 250],
        "springgreen": [0, 255, 127],
        "steelblue": [70, 130, 180],
        "tan": [210, 180, 140],
        "teal": [0, 128, 128],
        "thistle": [216, 191, 216],
        "tomato": [255, 99, 71],
        "turquoise": [64, 224, 208],
        "violet": [238, 130, 238],
        "wheat": [245, 222, 179],
        "white": [255, 255, 255],
        "whitesmoke": [245, 245, 245],
        "yellow": [255, 255, 0],
        "yellowgreen": [154, 205, 50],
        "transparent": [0, 0, 0, 0]
    },
    "filter": {
        "value": [
            "true",
            "false",
            "null",
            "point",
            "linestring",
            "polygon",
            "collection"
        ]
    }
};

CartoCSS['mapnik_reference'] = {
    version: {
        latest: _mapnik_reference_latest,
        '2.1.1': _mapnik_reference_latest
    }
};

CartoCSS.Tree = {};
CartoCSS.Tree.operate = function(op, a, b) {
    switch (op) {
        case '+': return a + b;
        case '-': return a - b;
        case '*': return a * b;
        case '%': return a % b;
        case '/': return a / b;
    }
};
CartoCSS.Tree.functions = {
    rgb: function (r, g, b) {
        return this.rgba(r, g, b, 1.0);
    },
    rgba: function (r, g, b, a) {
        var me = this;
        var rgb = [r, g, b].map(function (c) {
            return me.number(c);
        });
        a = me.number(a);
        if (rgb.some(isNaN) || isNaN(a)) {return null;}
        return new CartoCSS.Tree.Color(rgb, a);
    },
    // Only require val
    stop: function (val) {
        var color, mode;
        if (arguments.length > 1) {color = arguments[1];}
        if (arguments.length > 2) {mode = arguments[2];}

        return {
            is: 'tag',
            val: val,
            color: color,
            mode: mode,
            toString(env) {
                return '\n\t<stop value="' + val.ev(env) + '"' +
                    (color ? ' color="' + color.ev(env) + '" ' : '') +
                    (mode ? ' mode="' + mode.ev(env) + '" ' : '') +
                    '/>';
            }
        };
    },
    hsl: function (h, s, l) {
        return this.hsla(h, s, l, 1.0);
    },
    hsla: function (h, s, l, a) {
        h = (this.number(h) % 360) / 360;
        s = this.number(s);
        l = this.number(l);
        a = this.number(a);
        if ([h, s, l, a].some(isNaN)) {return null;}

        var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s,
            m1 = l * 2 - m2;

        return this.rgba(hue(h + 1 / 3) * 255,
            hue(h) * 255,
            hue(h - 1 / 3) * 255,
            a);

        function hue(h) {
            h = h < 0 ? h + 1 : (h > 1 ? h - 1 : h);
            if (h * 6 < 1) {return m1 + (m2 - m1) * h * 6;} else if (h * 2 < 1) {return m2;} else if (h * 3 < 2) {return m1 + (m2 - m1) * (2 / 3 - h) * 6;} else {return m1;}
        }
    },
    hue: function (color) {
        if (!('toHSL' in color)) {return null;}
        return new CartoCSS.Tree.Dimension(Math.round(color.toHSL().h));
    },
    saturation: function (color) {
        if (!('toHSL' in color)) {return null;}
        return new CartoCSS.Tree.Dimension(Math.round(color.toHSL().s * 100), '%');
    },
    lightness: function (color) {
        if (!('toHSL' in color)) {return null;}
        return new CartoCSS.Tree.Dimension(Math.round(color.toHSL().l * 100), '%');
    },
    alpha: function (color) {
        if (!('toHSL' in color)) {return null;}
        return new CartoCSS.Tree.Dimension(color.toHSL().a);
    },
    saturate: function (color, amount) {
        if (!('toHSL' in color)) {return null;}
        var hsl = color.toHSL();

        hsl.s += amount.value / 100;
        hsl.s = this.clamp(hsl.s);
        return this.hsla_simple(hsl);
    },
    desaturate: function (color, amount) {
        if (!('toHSL' in color)) {return null;}
        var hsl = color.toHSL();

        hsl.s -= amount.value / 100;
        hsl.s = this.clamp(hsl.s);
        return this.hsla_simple(hsl);
    },
    lighten: function (color, amount) {
        if (!('toHSL' in color)) {return null;}
        var hsl = color.toHSL();

        hsl.l += amount.value / 100;
        hsl.l = this.clamp(hsl.l);
        return this.hsla_simple(hsl);
    },
    darken: function (color, amount) {
        if (!('toHSL' in color)) {return null;}
        var hsl = color.toHSL();

        hsl.l -= amount.value / 100;
        hsl.l = this.clamp(hsl.l);
        return this.hsla_simple(hsl);
    },
    fadein: function (color, amount) {
        if (!('toHSL' in color)) {return null;}
        var hsl = color.toHSL();

        hsl.a += amount.value / 100;
        hsl.a = this.clamp(hsl.a);
        return this.hsla_simple(hsl);
    },
    fadeout: function (color, amount) {
        if (!('toHSL' in color)) {return null;}
        var hsl = color.toHSL();

        hsl.a -= amount.value / 100;
        hsl.a = this.clamp(hsl.a);
        return this.hsla_simple(hsl);
    },
    spin: function (color, amount) {
        if (!('toHSL' in color)) {return null;}
        var hsl = color.toHSL();
        var hue = (hsl.h + amount.value) % 360;

        hsl.h = hue < 0 ? 360 + hue : hue;

        return this.hsla_simple(hsl);
    },
    replace: function (entity, a, b) {
        if (entity.is === 'field') {
            return entity.toString + '.replace(' + a.toString() + ', ' + b.toString() + ')';
        } else {
            return entity.replace(a, b);
        }
    },
    //
    // Copyright (c) 2006-2009 Hampton Catlin, Nathan Weizenbaum, and Chris Eppstein
    // http://sass-lang.com
    //
    mix: function (color1, color2, weight) {
        var p = weight.value / 100.0;
        var w = p * 2 - 1;
        var a = color1.toHSL().a - color2.toHSL().a;

        var w1 = (((w * a == -1) ? w : (w + a) / (1 + w * a)) + 1) / 2.0;
        var w2 = 1 - w1;

        var rgb = [color1.rgb[0] * w1 + color2.rgb[0] * w2,
            color1.rgb[1] * w1 + color2.rgb[1] * w2,
            color1.rgb[2] * w1 + color2.rgb[2] * w2];

        var alpha = color1.alpha * p + color2.alpha * (1 - p);

        return new CartoCSS.Tree.Color(rgb, alpha);
    },
    greyscale: function (color) {
        return this.desaturate(color, new CartoCSS.Tree.Dimension(100));
    },
    '%': function (quoted /* arg, arg, ...*/) {
        var args = Array.prototype.slice.call(arguments, 1),
            str = quoted.value;

        for (var i = 0; i < args.length; i++) {
            str = str.replace(/%s/, args[i].value)
                .replace(/%[da]/, args[i].toString());
        }
        str = str.replace(/%%/g, '%');
        return new CartoCSS.Tree.Quoted(str);
    },

    hsla_simple: function (h) {
        return this.hsla(h.h, h.s, h.l, h.a);
    },

    number: function (n) {
        if (n instanceof CartoCSS.Tree.Dimension) {
            return parseFloat(n.unit === '%' ? n.value / 100 : n.value);
        } else if (typeof(n) === 'number') {
            return n;
        } else {
            return NaN;
        }
    },

    clamp: function (val) {
        return Math.min(1, Math.max(0, val));
    }
};

CartoCSS.Tree.Call = class Call {

    constructor(name, args, index) {
        this.is = 'call';
        this.name = name;
        this.args = args;
        this.index = index;
    }

    // When evuating a function call,
    // we either find the function in `tree.functions` [1],
    // in which case we call it, passing the  evaluated arguments,
    // or we simply print it out as it appeared originally [2].
    // The *functions.js* file contains the built-in functions.
    // The reason why we evaluate the arguments, is in the case where
    // we try to pass a variable to a function, like: `saturate(@color)`.
    // The function should receive the value, not the variable.
    'ev'(env) {
        var args = this.args.map(function (a) {
            return a.ev(env);
        });

        for (var i = 0; i < args.length; i++) {
            if (args[i].is === 'undefined') {
                return {
                    is: 'undefined',
                    value: 'undefined'
                };
            }
        }

        if (this.name in CartoCSS.Tree.functions) {
            if (CartoCSS.Tree.functions[this.name].length <= args.length) {
                var val = CartoCSS.Tree.functions[this.name].apply(CartoCSS.Tree.functions, args);
                if (val === null) {
                    env.error({
                        message: 'incorrect arguments given to ' + this.name + '()',
                        index: this.index,
                        type: 'runtime',
                        filename: this.filename
                    });
                    return {is: 'undefined', value: 'undefined'};
                }
                return val;
            } else {
                env.error({
                    message: 'incorrect number of arguments for ' + this.name +
                    '(). ' + CartoCSS.Tree.functions[this.name].length + ' expected.',
                    index: this.index,
                    type: 'runtime',
                    filename: this.filename
                });
                return {
                    is: 'undefined',
                    value: 'undefined'
                };
            }
        } else {
            var fn = CartoCSS.Tree.Reference.mapnikFunctions[this.name];
            if (fn === undefined) {
                var functions = lodash_topairs_default()(CartoCSS.Tree.Reference.mapnikFunctions);
                // cheap closest, needs improvement.
                var name = this.name;
                var mean = functions.map(function (f) {
                    return [f[0], CartoCSS.Tree.Reference.editDistance(name, f[0]), f[1]];
                }).sort(function (a, b) {
                    return a[1] - b[1];
                });
                env.error({
                    message: 'unknown function ' + this.name + '(), did you mean ' +
                    mean[0][0] + '(' + mean[0][2] + ')',
                    index: this.index,
                    type: 'runtime',
                    filename: this.filename
                });
                return {
                    is: 'undefined',
                    value: 'undefined'
                };
            }
            if (fn !== args.length &&
                // support variable-arg functions like `colorize-alpha`
                fn !== -1) {
                env.error({
                    message: 'function ' + this.name + '() takes ' +
                    fn + ' arguments and was given ' + args.length,
                    index: this.index,
                    type: 'runtime',
                    filename: this.filename
                });
                return {
                    is: 'undefined',
                    value: 'undefined'
                };
            } else {
                // Save the evaluated versions of arguments
                this.args = args;
                return this;
            }
        }
    }

    toString(env, format) {
        if (this.args.length) {
            return this.name + '(' + this.args.join(',') + ')';
        } else {
            return this.name;
        }
    }
};

CartoCSS.Tree.Color = class Color {

    constructor(rgb, a) {
        this.is = 'color';
        // The end goal here, is to parse the arguments
        // into an integer triplet, such as `128, 255, 0`
        //
        // This facilitates operations and conversions.
        if (Array.isArray(rgb)) {
            this.rgb = rgb.slice(0, 3);
        } else if (rgb.length == 6) {
            this.rgb = rgb.match(/.{2}/g).map(function (c) {
                return parseInt(c, 16);
            });
        } else {
            this.rgb = rgb.split('').map(function (c) {
                return parseInt(c + c, 16);
            });
        }

        if (typeof(a) === 'number') {
            this.alpha = a;
        } else if (rgb.length === 4) {
            this.alpha = rgb[3];
        } else {
            this.alpha = 1;
        }
    }

    'ev'() {
        return this;
    }

    // If we have some transparency, the only way to represent it
    // is via `rgba`. Otherwise, we use the hex representation,
    // which has better compatibility with older browsers.
    // Values are capped between `0` and `255`, rounded and zero-padded.
    toString() {
        /* if (this.alpha < 1.0) {*/
        return 'rgba(' + this.rgb.map(function (c) {
            return Math.round(c);
        }).concat(this.alpha).join(', ') + ')';
        /*} else {
         return '#' + this.rgb.map(function(i) {
         i = Math.round(i);
         i = (i > 255 ? 255 : (i < 0 ? 0 : i)).toString(16);
         return i.length === 1 ? '0' + i : i;
         }).join('');
         }*/
    }

    // Operations have to be done per-channel, if not,
    // channels will spill onto each other. Once we have
    // our result, in the form of an integer triplet,
    // we create a new Color node to hold the result.
    operate(env, op, other) {
        var result = [];

        if (!(other instanceof CartoCSS.Tree.Color)) {
            other = other.toColor();
        }

        for (var c = 0; c < 3; c++) {
            result[c] = CartoCSS.Tree.operate(op, this.rgb[c], other.rgb[c]);
        }
        return new CartoCSS.Tree.Color(result);
    }

    toHSL() {
        var r = this.rgb[0] / 255,
            g = this.rgb[1] / 255,
            b = this.rgb[2] / 255,
            a = this.alpha;

        var max = Math.max(r, g, b), min = Math.min(r, g, b);
        var h, s, l = (max + min) / 2, d = max - min;

        if (max === min) {
            h = s = 0;
        } else {
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);

            switch (max) {
                case r:
                    h = (g - b) / d + (g < b ? 6 : 0);
                    break;
                case g:
                    h = (b - r) / d + 2;
                    break;
                case b:
                    h = (r - g) / d + 4;
                    break;
                default:
                    break;
            }
            h /= 6;
        }
        return {h: h * 360, s: s, l: l, a: a};
    }
};

CartoCSS.Tree.Comment = class Comment {
    constructor(value, silent) {
        this.value = value;
        this.silent = !!silent;
    }

    toString(env) {
        return '<!--' + this.value + '-->';
    }

    'ev'() {
        return this;
    }
};

CartoCSS.Tree.Definition = class Definition {
    constructor(selector, rules) {
        this.elements = selector.elements;
        //assert.ok(selector.filters instanceof CartoCSS.Tree.Filterset);
        this.rules = rules;
        this.ruleIndex = {};
        for (var i = 0; i < this.rules.length; i++) {
            if ('zoom' in this.rules[i]) {this.rules[i] = this.rules[i].clone();}
            this.rules[i].zoom = selector.zoom;
            this.ruleIndex[this.rules[i].updateID()] = true;
        }
        this.filters = selector.filters;
        this.zoom = selector.zoom;
        this.attachment = selector.attachment || '__default__';
        this.specificity = selector.specificity();
    }

    toString() {
        var str = this.filters.toString();
        for (var i = 0; i < this.rules.length; i++) {
            str += '\n    ' + this.rules[i];
        }
        return str;
    }

    toJS(env) {
        var shaderAttrs = {};

        // merge conditions from filters with zoom condition of the
        // definition
        var zoom = this.zoom;
        //var frame_offset = this.frame_offset;
        var _if = this.filters.toJS(env);
        var filters = [zoom];
        if (_if) {filters.push(_if);}
        //if(frame_offset) filters.push('ctx["frame-offset"] === ' + frame_offset);
        _if = filters.join(" && ");

        function eachRule(rule) {
            if (rule instanceof CartoCSS.Tree.Rule) {
                shaderAttrs[rule.name] = shaderAttrs[rule.name] || [];
                if (_if) {
                    shaderAttrs[rule.name].push(
                        "if(" + _if + "){" + rule.value.toJS(env) + "}"
                    );
                } else {
                    shaderAttrs[rule.name].push(rule.value.toJS(env));
                }
            } else {
                if (rule instanceof CartoCSS.Tree.Ruleset) {
                    var sh = rule.toJS(env);
                    for (var v in sh) {
                        shaderAttrs[v] = shaderAttrs[v] || [];
                        for (var attr in sh[v]) {
                            shaderAttrs[v].push(sh[v][attr]);
                        }
                    }
                }
            }
        }
        for (var id in this.rules) {
            eachRule(this.rules[id]);
        }
        return shaderAttrs;
    }
};

CartoCSS.Tree.Dimension = class Dimension {


    constructor(value, unit, index) {
        this.is = 'float';
        this.physical_units = ['m', 'cm', 'in', 'mm', 'pt', 'pc'];
        this.screen_units = ['px', '%'];
        this.all_units = ['m', 'cm', 'in', 'mm', 'pt', 'pc', 'px', '%'];
        this.densities = {
            m: 0.0254,
            mm: 25.4,
            cm: 2.54,
            pt: 72,
            pc: 6
        };
        this.value = parseFloat(value);
        this.unit = unit || null;
        this.index = index;
    }

    ev(env) {
        if (this.unit && this.all_units.indexOf(this.unit)<0) {
            env.error({
                message: "Invalid unit: '" + this.unit + "'",
                index: this.index
            });
            return {is: 'undefined', value: 'undefined'};
        }

        // normalize units which are not px or %
        if (this.unit && this.physical_units.indexOf(this.unit)>=0) {
            if (!env.ppi) {
                env.error({
                    message: "ppi is not set, so metric units can't be used",
                    index: this.index
                });
                return {is: 'undefined', value: 'undefined'};
            }
            // convert all units to inch
            // convert inch to px using ppi
            this.value = (this.value / this.densities[this.unit]) * env.ppi;
            this.unit = 'px';
        }

        return this;
    }

    toColor() {
        return new CartoCSS.Tree.Color([this.value, this.value, this.value]);
    }

    round() {
        this.value = Math.round(this.value);
        return this;
    }

    toString() {
        return this.value.toString();
    }

    operate(env, op, other) {
        if (this.unit === '%' && other.unit !== '%') {
            env.error({
                message: 'If two operands differ, the first must not be %',
                index: this.index
            });
            return {
                is: 'undefined',
                value: 'undefined'
            };
        }

        if (this.unit !== '%' && other.unit === '%') {
            if (op === '*' || op === '/' || op === '%') {
                env.error({
                    message: 'Percent values can only be added or subtracted from other values',
                    index: this.index
                });
                return {
                    is: 'undefined',
                    value: 'undefined'
                };
            }

            return new CartoCSS.Tree.Dimension(CartoCSS.Tree.operate(op,
                this.value, this.value * other.value * 0.01),
                this.unit);
        }

        //here the operands are either the same (% or undefined or px), or one is undefined and the other is px
        return new CartoCSS.Tree.Dimension(CartoCSS.Tree.operate(op, this.value, other.value),
            this.unit || other.unit);
    }
};

CartoCSS.Tree.Element = class Element {
    constructor(value) {
        this.value = value.trim();
        if (this.value[0] === '#') {
            this.type = 'id';
            this.clean = this.value.replace(/^#/, '');
        }
        if (this.value[0] === '.') {
            this.type = 'class';
            this.clean = this.value.replace(/^\./, '');
        }
        if (this.value.indexOf('*') !== -1) {
            this.type = 'wildcard';
        }
    }

    specificity() {
        return [
            (this.type === 'id') ? 1 : 0, // a
            (this.type === 'class') ? 1 : 0  // b
        ];
    }

    toString() {
        return this.value;
    }
};

CartoCSS.Tree.Expression = class Expression {


    constructor(value) {
        this.is = 'expression';
        this.value = value;
    }

    ev(env) {
        if (this.value.length > 1) {
            return new CartoCSS.Tree.Expression(this.value.map(function (e) {
                return e.ev(env);
            }));
        } else {
            return this.value[0].ev(env);
        }
    }

    toString(env) {
        return this.value.map(function (e) {
            return e.toString(env);
        }).join(' ');
    }
};

CartoCSS.Tree.Field = class Field {

    constructor(content) {
        this.is = 'field';
        this.value = content || '';
    }

    toString() {
        return '["' + this.value.toUpperCase() + '"]';
    }

    'ev'() {
        return this;
    }
};

CartoCSS.Tree.Filter = class Filter {

    constructor(key, op, val, index, filename) {
        this.ops = {
            '<': [' &lt; ', 'numeric'],
            '>': [' &gt; ', 'numeric'],
            '=': [' = ', 'both'],
            '!=': [' != ', 'both'],
            '<=': [' &lt;= ', 'numeric'],
            '>=': [' &gt;= ', 'numeric'],
            '=~': ['.match(', 'string', ')']
        };

        this.key = key;
        this.op = op;
        this.val = val;
        this.index = index;
        this.filename = filename;

        this.id = this.key + this.op + this.val;
    }

    ev(env) {
        this.key = this.key.ev(env);
        this.val = this.val.ev(env);
        return this;
    }

    toString() {
        return '[' + this.id + ']';
    }
};

CartoCSS.Tree.Filterset = class Filterset {
    constructor() {
        this.filters = {};
    }

    toJS(env) {
        function eachFilter(filter) {
            var op = filter.op;
            if (op === "=") {
                op = "==";
            }
            var val = filter.val;
            if (filter._val !== undefined) {
                val = filter._val.toString(true);
            }

            //对scale进行特殊处理，将值转换成数值
            if (filter.key && filter.key.value === 'scale') {
                val = +val;
            } else if (typeof val === 'string' || typeof val === 'object') {
                val = "'" + val + "'";
            }
            var attrs = "attributes";
            return attrs + "&&" + attrs + filter.key + "&&" + attrs + filter.key + " " + op + val;
        }
        var results = [];
        for (var id in this.filters) {
            results.push(eachFilter(this.filters[id]));
        }
        return results.join(' && ');
    }

    toString() {
        var arr = [];
        for (var id in this.filters) {arr.push(this.filters[id].id);}
        return arr.sort().join('\t');
    }

    ev(env) {
        for (var i in this.filters) {
            this.filters[i].ev(env);
        }
        return this;
    }

    clone() {
        var clone = new CartoCSS.Tree.Filterset();
        for (var id in this.filters) {
            clone.filters[id] = this.filters[id];
        }
        return clone;
    }

    cloneWith(other) {
        var additions = [];
        for (var id in other.filters) {
            var status = this.addable(other.filters[id]);
            // status is true, false or null. if it's null we don't fail this
            // clone nor do we add the filter.
            if (status === false) {
                return false;
            }
            if (status === true) {
                // Adding the filter will override another value.
                additions.push(other.filters[id]);
            }
        }

        // Adding the other filters doesn't make this filterset invalid, but it
        // doesn't add anything to it either.
        if (!additions.length) {
            return null;
        }

        // We can successfully add all filters. Now clone the filterset and add the
        // new rules.
        var clone = new CartoCSS.Tree.Filterset();

        // We can add the rules that are already present without going through the
        // add function as a Filterset is always in it's simplest canonical form.
        for (id in this.filters) {
            clone.filters[id] = this.filters[id];
        }

        // Only add new filters that actually change the filter.
        while (id = additions.shift()) {
            clone.add(id);
        }

        return clone;
    }

    addable(filter) {
        var key = filter.key.toString(),
            value = filter.val.toString();

        if (value.match(/^[0-9]+(\.[0-9]*)?_match/)) {value = parseFloat(value);}

        switch (filter.op) {
            case '=':
                // if there is already foo= and we're adding foo=
                if (this.filters[key + '='] !== undefined) {
                    if (this.filters[key + '='].val.toString() != value) {
                        return false;
                    } else {
                        return null;
                    }
                }
                if (this.filters[key + '!=' + value] !== undefined) {return false;}
                if (this.filters[key + '>'] !== undefined && this.filters[key + '>'].val >= value) {return false;}
                if (this.filters[key + '<'] !== undefined && this.filters[key + '<'].val <= value) {return false;}
                if (this.filters[key + '>='] !== undefined && this.filters[key + '>='].val > value) {return false;}
                if (this.filters[key + '<='] !== undefined && this.filters[key + '<='].val < value) {return false;}
                return true;

            case '=~':
                return true;

            case '!=':
                if (this.filters[key + '='] !== undefined) {return (this.filters[key + '='].val === value) ? false : null;}
                if (this.filters[key + '!=' + value] !== undefined) {return null;}
                if (this.filters[key + '>'] !== undefined && this.filters[key + '>'].val >= value) {return null;}
                if (this.filters[key + '<'] !== undefined && this.filters[key + '<'].val <= value) {return null;}
                if (this.filters[key + '>='] !== undefined && this.filters[key + '>='].val > value) {return null;}
                if (this.filters[key + '<='] !== undefined && this.filters[key + '<='].val < value) {return null;}
                return true;

            case '>':
                if (key + '=' in this.filters) {
                    if (this.filters[key + '='].val <= value) {
                        return false;
                    } else {
                        return null;
                    }
                }
                if (this.filters[key + '<'] !== undefined && this.filters[key + '<'].val <= value) {return false;}
                if (this.filters[key + '<='] !== undefined && this.filters[key + '<='].val <= value) {return false;}
                if (this.filters[key + '>'] !== undefined && this.filters[key + '>'].val >= value) {return null;}
                if (this.filters[key + '>='] !== undefined && this.filters[key + '>='].val > value) {return null;}
                return true;

            case '>=':
                if (this.filters[key + '='] !== undefined) {return (this.filters[key + '='].val < value) ? false : null;}
                if (this.filters[key + '<'] !== undefined && this.filters[key + '<'].val <= value) {return false;}
                if (this.filters[key + '<='] !== undefined && this.filters[key + '<='].val < value) {return false;}
                if (this.filters[key + '>'] !== undefined && this.filters[key + '>'].val >= value) {return null;}
                if (this.filters[key + '>='] !== undefined && this.filters[key + '>='].val >= value) {return null;}
                return true;

            case '<':
                if (this.filters[key + '='] !== undefined) {return (this.filters[key + '='].val >= value) ? false : null;}
                if (this.filters[key + '>'] !== undefined && this.filters[key + '>'].val >= value) {return false;}
                if (this.filters[key + '>='] !== undefined && this.filters[key + '>='].val >= value) {return false;}
                if (this.filters[key + '<'] !== undefined && this.filters[key + '<'].val <= value) {return null;}
                if (this.filters[key + '<='] !== undefined && this.filters[key + '<='].val < value) {return null;}
                return true;

            case '<=':
                if (this.filters[key + '='] !== undefined) {return (this.filters[key + '='].val > value) ? false : null;}
                if (this.filters[key + '>'] !== undefined && this.filters[key + '>'].val >= value) {return false;}
                if (this.filters[key + '>='] !== undefined && this.filters[key + '>='].val > value) {return false;}
                if (this.filters[key + '<'] !== undefined && this.filters[key + '<'].val <= value) {return null;}
                if (this.filters[key + '<='] !== undefined && this.filters[key + '<='].val <= value) {return null;}
                return true;

            default:
                break;
        }
    }

    conflict(filter) {
        var key = filter.key.toString(),
            value = filter.val.toString();

        if (!isNaN(parseFloat(value))) {value = parseFloat(value);}

        // if (a=b) && (a=c)
        // if (a=b) && (a!=b)
        // or (a!=b) && (a=b)
        if ((filter.op === '=' && this.filters[key + '='] !== undefined &&
                value != this.filters[key + '='].val.toString()) ||
            (filter.op === '!=' && this.filters[key + '='] !== undefined &&
                value == this.filters[key + '='].val.toString()) ||
            (filter.op === '=' && this.filters[key + '!='] !== undefined &&
                value === this.filters[key + '!='].val.toString())) {
            return filter.toString() + ' added to ' + this.toString() + ' produces an invalid filter';
        }

        return false;
    }

    add(filter, env) {
        var key = filter.key.toString(),
            op = filter.op,
            conflict = this.conflict(filter),
            numval;
        if (conflict) {return conflict;}

        if (op === '=') {
            for (var i in this.filters) {
                if (this.filters[i].key === key) {delete this.filters[i];}
            }
            this.filters[key + '='] = filter;
        } else if (op === '!=') {
            this.filters[key + '!=' + filter.val] = filter;
        } else if (op === '=~') {
            this.filters[key + '=~' + filter.val] = filter;
        } else if (op === '>') {
            // If there are other filters that are also >
            // but are less than this one, they don't matter, so
            // remove them.
            for (var j in this.filters) {
                if (this.filters[j].key === key && this.filters[j].val <= filter.val) {
                    delete this.filters[j];
                }
            }
            this.filters[key + '>'] = filter;
        } else if (op === '>=') {
            for (var k in this.filters) {
                numval = (+this.filters[k].val.toString());
                if (this.filters[k].key === key && numval < filter.val) {
                    delete this.filters[k];
                }
            }
            if (this.filters[key + '!=' + filter.val] !== undefined) {
                delete this.filters[key + '!=' + filter.val];
                filter.op = '>';
                this.filters[key + '>'] = filter;
            } else {
                this.filters[key + '>='] = filter;
            }
        } else if (op === '<') {
            for (var l in this.filters) {
                numval = (+this.filters[l].val.toString());
                if (this.filters[l].key === key && numval >= filter.val) {
                    delete this.filters[l];
                }
            }
            this.filters[key + '<'] = filter;
        } else if (op === '<=') {
            for (var m in this.filters) {
                numval = (+this.filters[m].val.toString());
                if (this.filters[m].key === key && numval > filter.val) {
                    delete this.filters[m];
                }
            }
            if (this.filters[key + '!=' + filter.val] !== undefined) {
                delete this.filters[key + '!=' + filter.val];
                filter.op = '<';
                this.filters[key + '<'] = filter;
            } else {
                this.filters[key + '<='] = filter;
            }
        }
    }
};

CartoCSS.Tree.Fontset = class Fontset {
    constructor(env, fonts) {
        this.fonts = fonts;
        this.name = 'fontset-' + env.effects.length;
    }
};
CartoCSS.Tree.Invalid = class Invalid {

    constructor(chunk, index, message) {
        this.is = 'invalid';
        this.chunk = chunk;
        this.index = index;
        this.type = 'syntax';
        this.message = message || "Invalid code: " + this.chunk;
    }

    ev(env) {
        env.error({
            chunk: this.chunk,
            index: this.index,
            type: 'syntax',
            message: this.message || "Invalid code: " + this.chunk
        });
        return {
            is: 'undefined'
        };
    }
};

CartoCSS.Tree.Keyword = class Keyword {
    ev() {
        return this;
    }

    constructor(value) {
        this.value = value;
        var special = {
            'transparent': 'color',
            'true': 'boolean',
            'false': 'boolean'
        };
        this.is = special[value] ? special[value] : 'keyword';
    }

    toString() {
        return this.value;
    }
};

/*Layer:class Invalid ),*/

CartoCSS.Tree.Literal = class Literal {
    constructor(content) {
        this.value = content || '';
        this.is = 'field';
    }

    toString() {
        return this.value;
    }

    'ev'() {
        return this;
    }
};

CartoCSS.Tree.Operation = class Operation {

    constructor(op, operands, index) {
        this.is = 'operation';
        this.op = op.trim();
        this.operands = operands;
        this.index = index;
    }

    ev(env) {
        var a = this.operands[0].ev(env),
            b = this.operands[1].ev(env),
            temp;

        if (a.is === 'undefined' || b.is === 'undefined') {
            return {
                is: 'undefined',
                value: 'undefined'
            };
        }

        if (a instanceof CartoCSS.Tree.Dimension && b instanceof CartoCSS.Tree.Color) {
            if (this.op === '*' || this.op === '+') {
                temp = b;
                b = a;
                a = temp;
            } else {
                env.error({
                    name: "OperationError",
                    message: "Can't substract or divide a color from a number",
                    index: this.index
                });
            }
        }

        // Only concatenate plain strings, because this is easily
        // pre-processed
        if (a instanceof CartoCSS.Tree.Quoted && b instanceof CartoCSS.Tree.Quoted && this.op !== '+') {
            env.error({
                message: "Can't subtract, divide, or multiply strings.",
                index: this.index,
                type: 'runtime',
                filename: this.filename
            });
            return {
                is: 'undefined',
                value: 'undefined'
            };
        }

        // Fields, literals, dimensions, and quoted strings can be combined.
        if (a instanceof CartoCSS.Tree.Field || b instanceof CartoCSS.Tree.Field ||
            a instanceof CartoCSS.Tree.Literal || b instanceof CartoCSS.Tree.Literal) {
            if (a.is === 'color' || b.is === 'color') {
                env.error({
                    message: "Can't subtract, divide, or multiply colors in expressions.",
                    index: this.index,
                    type: 'runtime',
                    filename: this.filename
                });
                return {
                    is: 'undefined',
                    value: 'undefined'
                };
            } else {
                return new CartoCSS.Tree.Literal(a.ev(env).toString(true) + this.op + b.ev(env).toString(true));
            }
        }

        if (a.operate === undefined) {
            env.error({
                message: 'Cannot do math with type ' + a.is + '.',
                index: this.index,
                type: 'runtime',
                filename: this.filename
            });
            return {
                is: 'undefined',
                value: 'undefined'
            };
        }

        return a.operate(env, this.op, b);
    }
};

CartoCSS.Tree.Quoted = class Quoted {

    constructor(content) {
        this.is = 'string';
        this.value = content || '';
    }

    toString(quotes) {
        var escapedValue = this.value
            .replace(/&/g, '&amp;')
        var xmlvalue = escapedValue
            .replace(/\'/g, '\\\'')
            .replace(/\"/g, '&quot;')
            .replace(/</g, '&lt;')
            .replace(/\>/g, '&gt;');
        return (quotes === true) ? "'" + xmlvalue + "'" : escapedValue;
    }

    ev() {
        return this;
    }

    operate(env, op, other) {
        return new CartoCSS.Tree.Quoted(CartoCSS.Tree.operate(op, this.toString(), other.toString(this.contains_field)));
    }
};

CartoCSS.Tree.Reference = {
    _validateValue: {
        'font': function (env, value) {
            if (env.validation_data && env.validation_data.fonts) {
                return env.validation_data.fonts.indexOf(value) != -1;
            } else {
                return true;
            }
        }
    },
    setData: function (data) {
        this.data = data;
        this.selector_cache = generateSelectorCache(data);
        this.mapnikFunctions = generateMapnikFunctions(data);
        this.required_cache = generateRequiredProperties(data);

        function generateSelectorCache(data) {
            var index = {};
            for (var i in data.symbolizers) {
                for (var j in data.symbolizers[i]) {
                    if (data.symbolizers[i][j].hasOwnProperty('css')) {
                        index[data.symbolizers[i][j].css] = [data.symbolizers[i][j], i, j];
                    }
                }
            }
            return index;
        }

        function generateMapnikFunctions(data) {
            var functions = {};
            for (var i in data.symbolizers) {
                for (var j in data.symbolizers[i]) {
                    if (data.symbolizers[i][j].type === 'functions') {
                        for (var k = 0; k < data.symbolizers[i][j].functions.length; k++) {
                            var fn = data.symbolizers[i][j].functions[k];
                            functions[fn[0]] = fn[1];
                        }
                    }
                }
            }
            return functions;
        }

        function generateRequiredProperties(data) {
            var cache = {};
            for (var symbolizer_name in data.symbolizers) {
                cache[symbolizer_name] = [];
                for (var j in data.symbolizers[symbolizer_name]) {
                    if (data.symbolizers[symbolizer_name][j].required) {
                        cache[symbolizer_name].push(data.symbolizers[symbolizer_name][j].css);
                    }
                }
            }
            return cache;
        }
    },
    setVersion: function (version) {
        if (CartoCSS.mapnik_reference.version.hasOwnProperty(version)) {
            this.setData(CartoCSS.mapnik_reference.version[version]);
            return true;
        }
        return false;
    },
    selectorData: function (selector, i) {
        if (this.selector_cache && this.selector_cache[selector]) {return this.selector_cache[selector][i];}
    },
    validSelector: function (selector) {
        return !!this.selector_cache[selector];
    },
    selectorName: function (selector) {
        return this.selectorData(selector, 2);
    },
    selector: function (selector) {
        return this.selectorData(selector, 0);
    },
    symbolizer: function (selector) {
        return this.selectorData(selector, 1);
    },
    requiredProperties: function (symbolizer_name, rules) {
        var req = this.required_cache[symbolizer_name];
        for (var i in req) {
            if (!(req[i] in rules)) {
                return 'Property ' + req[i] + ' required for defining ' +
                    symbolizer_name + ' styles.';
            }
        }
    },
    isFont: function (selector) {
        return this.selector(selector).validate === 'font';
    },
    editDistance: function (a, b) {
        if (a.length === 0) {return b.length;}
        if (b.length === 0) {return a.length;}
        var matrix = [];
        for (var i = 0; i <= b.length; i++) {
            matrix[i] = [i];
        }
        for (var j = 0; j <= a.length; j++) {
            matrix[0][j] = j;
        }
        for (i = 1; i <= b.length; i++) {
            for (j = 1; j <= a.length; j++) {
                if (b.charAt(i - 1) === a.charAt(j - 1)) {
                    matrix[i][j] = matrix[i - 1][j - 1];
                } else {
                    matrix[i][j] = Math.min(matrix[i - 1][j - 1] + 1, // substitution
                        Math.min(matrix[i][j - 1] + 1, // insertion
                            matrix[i - 1][j] + 1)); // deletion
                }
            }
        }
        return matrix[b.length][a.length];
    },
    validValue: function (env, selector, value) {
        function validateFunctions(value, selector) {
            if (value.value[0].is === 'string') {return true;}
            for (var i in value.value) {
                for (var j in value.value[i].value) {
                    if (value.value[i].value[j].is !== 'call') {return false;}
                    var f = find(this.selector(selector).functions, function (x) {//NOSONAR
                        return x[0] === value.value[i].value[j].name;
                    });
                    if (!(f && f[1] === -1)) {
                        // This filter is unknown or given an incorrect number of arguments
                        if (!f || f[1] !== value.value[i].value[j].args.length) {return false;}
                    }
                }
            }
            return true;
        }

        function validateKeyword(value, selector) {
            if (typeof this.selector(selector).type === 'object') {
                return this.selector(selector).type
                    .indexOf(value.value[0].value) !== -1;
            } else {
                // allow unquoted keywords as strings
                return this.selector(selector).type === 'string';
            }
        }

        var i;
        if (!this.selector(selector)) {
            return false;
        } else if (value.value[0].is === 'keyword') {
            return validateKeyword(value, selector);
        } else if (value.value[0].is === 'undefined') {
            // caught earlier in the chain - ignore here so that
            // error is not overridden
            return true;
        } else if (this.selector(selector).type === 'numbers') {
            for (i in value.value) {
                if (value.value[i].is !== 'float') {
                    return false;
                }
            }
            return true;
        } else if (this.selector(selector).type === 'tags') {
            if (!value.value) {return false;}
            if (!value.value[0].value) {
                return value.value[0].is === 'tag';
            }
            for (i = 0; i < value.value[0].value.length; i++) {
                if (value.value[0].value[i].is !== 'tag') {return false;}
            }
            return true;
        } else if (this.selector(selector).type == 'functions') {
            // For backwards compatibility, you can specify a string for `functions`-compatible
            // values, though they will not be validated.
            return validateFunctions(value, selector);
        } else if (this.selector(selector).type === 'expression') {
            return true;
        } else if (this.selector(selector).type === 'unsigned') {
            if (value.value[0].is === 'float') {
                value.value[0].round();
                return true;
            } else {
                return false;
            }
        } else {
            if (this.selector(selector).validate) {
                var valid = false;
                for (i = 0; i < value.value.length; i++) {
                    if (this.selector(selector).type === value.value[i].is &&
                        this._validateValue[this.selector(selector).validate](env, value.value[i].value)) {
                        return true;
                    }
                }
                return valid;
            } else {
                return this.selector(selector).type === value.value[0].is;
            }
        }
    }
};
CartoCSS.Tree.Reference.setVersion("latest");

CartoCSS.Tree.Rule = class Rule {

    constructor(name, value, index, filename) {
        this.is = 'rule';
        var parts = name.split('/');
        this.name = parts.pop();
        this.instance = parts.length ? parts[0] : '__default__';
        this.value = (value instanceof CartoCSS.Tree.Value) ?
            value : new CartoCSS.Tree.Value([value]);
        this.index = index;
        this.symbolizer = CartoCSS.Tree.Reference.symbolizer(this.name);
        this.filename = filename;
        this.variable = (name.charAt(0) === '@');
    }

    clone() {
        var clone = Object.create(CartoCSS.Tree.Rule.prototype);
        clone.name = this.name;
        clone.value = this.value;
        clone.index = this.index;
        clone.instance = this.instance;
        clone.symbolizer = this.symbolizer;
        clone.filename = this.filename;
        clone.variable = this.variable;
        return clone;
    }

    updateID() {
        return this.id = this.zoom + '#' + this.instance + '#' + this.name;
    }

    toString() {
        return '[' + CartoCSS.Tree.Zoom.toString(this.zoom) + '] ' + this.name + ': ' + this.value;
    }
    ev(context) {
        return new CartoCSS.Tree.Rule(this.name,
            this.value.ev(context),
            this.index,
            this.filename);
    }
};

CartoCSS.Tree.Ruleset = class Ruleset {

    constructor(selectors, rules) {
        this.is = 'ruleset';
        this.selectors = selectors;
        this.rules = rules;
        // static cache of find() function
        this._lookups = {};
    }

    ev(env) {
        var i,
            rule,
            ruleset = new CartoCSS.Tree.Ruleset(this.selectors, this.rules.slice(0));
        ruleset.root = this.root;

        // push the current ruleset to the frames stack
        env.frames.unshift(ruleset);

        // Evaluate everything else
        for (i = 0, rule; i < ruleset.rules.length; i++) {
            rule = ruleset.rules[i];
            ruleset.rules[i] = rule.ev ? rule.ev(env) : rule;
        }

        // Pop the stack
        env.frames.shift();

        return ruleset;
    }

    match(args) {
        return !args || args.length === 0;
    }

    variables() {
        if (this._variables) {
            return this._variables;
        } else {
            return this._variables = this.rules.reduce(function (hash, r) {
                if (r instanceof CartoCSS.Tree.Rule && r.variable === true) {
                    hash[r.name] = r;
                }
                return hash;
            }, {});
        }
    }

    variable(name) {
        return this.variables()[name];
    }

    rulesets() {
        if (this._rulesets) {
            return this._rulesets;
        } else {
            return this._rulesets = this.rules.filter(function (r) {
                return (r instanceof CartoCSS.Tree.Ruleset);
            });
        }
    }

    find(selector, self) {
        self = self || this;
        var rules = [], match,
            key = selector.toString();

        if (key in this._lookups) {
            return this._lookups[key];
        }

        this.rulesets().forEach(function (rule) {
            if (rule !== self) {
                for (var j = 0; j < rule.selectors.length; j++) {
                    match = selector.match(rule.selectors[j]);
                    if (match) {
                        if (selector.elements.length > 1) {
                            Array.prototype.push.apply(rules, rule.find(
                                new CartoCSS.Tree.Selector(null, null, selector.elements.slice(1)), self));
                        } else {
                            rules.push(rule);
                        }
                        break;
                    }
                }
            }
        });
        return this._lookups[key] = rules;
    }

    // Zooms can use variables. This replaces CartoCSS.Tree.Zoom objects on selectors
    // with simple bit-arrays that we can compare easily.
    evZooms(env) {
        for (var i = 0; i < this.selectors.length; i++) {
            var zval = CartoCSS.Tree.Zoom.all;
            for (var z = 0; z < this.selectors[i].zoom.length; z++) {
                zval = this.selectors[i].zoom[z].ev(env).zoom;
            }
            this.selectors[i].zoom = zval;
        }
    }

    flatten(result, parents, env) {
        var selectors = [], i, j;
        if (this.selectors.length === 0) {
            env.frames = env.frames.concat(this.rules);
        }
        // evaluate zoom variables on this object.
        this.evZooms(env);
        for (i = 0; i < this.selectors.length; i++) {
            var child = this.selectors[i];

            if (!child.filters) {
                // This is an invalid filterset.
                continue;
            }

            if (parents.length) {
                for (j = 0; j < parents.length; j++) {
                    var parent = parents[j];

                    var mergedFilters = parent.filters.cloneWith(child.filters);
                    if (mergedFilters === null) {
                        // Filters could be added, but they didn't change the
                        // filters. This means that we only have to clone when
                        // the zoom levels or the attachment is different too.
                        if (parent.zoom === child.zoom &&
                            parent.attachment === child.attachment &&
                            parent.elements.join() === child.elements.join()) {
                            selectors.push(parent);
                            continue;
                        } else {
                            mergedFilters = parent.filters;
                        }
                    } else if (!mergedFilters) {
                        // The merged filters are invalid, that means we don't
                        // have to clone.
                        continue;
                    }

                    var clone = Object.create(CartoCSS.Tree.Selector.prototype);
                    clone.filters = mergedFilters;
                    clone.zoom = child.zoom;
                    clone.elements = parent.elements.concat(child.elements);
                    if (parent.attachment && child.attachment) {
                        clone.attachment = parent.attachment + '/' + child.attachment;
                    } else {clone.attachment = child.attachment || parent.attachment;}
                    clone.conditions = parent.conditions + child.conditions;
                    clone.index = child.index;
                    selectors.push(clone);
                }
            } else {
                selectors.push(child);
            }
        }

        var rules = [];
        for (i = 0; i < this.rules.length; i++) {
            var rule = this.rules[i];

            // Recursively flatten any nested rulesets
            if (rule instanceof CartoCSS.Tree.Ruleset) {
                rule.flatten(result, selectors, env);
            } else if (rule instanceof CartoCSS.Tree.Rule) {
                rules.push(rule);
            } else if (rule instanceof CartoCSS.Tree.Invalid) {
                env.error(rule);
            }
        }

        var index = rules.length ? rules[0].index : false;
        for (i = 0; i < selectors.length; i++) {
            // For specificity sort, use the position of the first rule to allow
            // defining attachments that are under current element as a descendant
            // selector.
            if (index !== false) {
                selectors[i].index = index;
            }
            result.push(new CartoCSS.Tree.Definition(selectors[i], rules.slice()));
        }

        return result;
    }
};

CartoCSS.Tree.Selector = class Selector {
    constructor(filters, zoom, elements, attachment, conditions, index) {
        this.elements = elements || [];
        this.attachment = attachment;
        this.filters = filters || {};
        this.zoom = typeof zoom !== 'undefined' ? zoom : CartoCSS.Tree.Zoom.all;
        this.conditions = conditions;
        this.index = index;
    }

    specificity() {
        return this.elements.reduce(function (memo, e) {
            var spec = e.specificity();
            memo[0] += spec[0];
            memo[1] += spec[1];
            return memo;
        }, [0, 0, this.conditions, this.index]);
    }
};

/*style:class Invalid ),*/

CartoCSS.Tree.URL = class URL {

    constructor(val, paths) {
        this.is = 'uri';
        this.value = val;
        this.paths = paths;
    }

    toString() {
        return this.value.toString();
    }

    ev(ctx) {
        return new CartoCSS.Tree.URL(this.value.ev(ctx), this.paths);
    }
};

CartoCSS.Tree.Value = class Value {

    constructor(value) {
        this.is = 'value';
        this.value = value;
    }

    ev(env) {
        if (this.value.length === 1) {
            return this.value[0].ev(env);
        } else {
            return new CartoCSS.Tree.Value(this.value.map(function (v) {
                return v.ev(env);
            }));
        }
    }

    toJS(env) {
        //var v = this.value[0].value[0];
        var val = this.ev(env);
        var v = val.toString();
        if (val.is === "color" || val.is === 'uri' || val.is === 'string' || val.is === 'keyword') {
            v = "'" + v + "'";
        } else if (val.is === 'field') {
            // replace [varuable] by ctx['variable']
            v = v.replace(/\[(.*)\]/g, "attributes['\_match1']")
        } else if (val.value && typeof val.value === "object") {
            v = "[" + v + "]";
        }

        return "_value = " + v + ";";
    }

    toString(env, selector, sep, format) {
        return this.value.map(function (e) {
            return e.toString(env, format);
        }).join(sep || ', ');
    }

    clone() {
        var obj = Object.create(CartoCSS.Tree.Value.prototype);
        if (Array.isArray(obj)) {obj.value = this.value.slice();} else {obj.value = this.value;}
        obj.is = this.is;
        return obj;
    }
};

CartoCSS.Tree.Variable = class Variable {
    constructor(name, index, filename) {
        this.is = 'variable';
        this.name = name;
        this.index = index;
        this.filename = filename;
    }

    toString() {
        return this.name;
    }

    ev(env) {
        if (this._css) {return this._css;}

        var thisframe = env.frames.filter(function (f) {
            return f.name === this.name;
        }.bind(this));
        if (thisframe.length) {
            return thisframe[0].value.ev(env);
        } else {
            env.error({
                message: 'variable ' + this.name + ' is undefined',
                index: this.index,
                type: 'runtime',
                filename: this.filename
            });
            return {
                is: 'undefined',
                value: 'undefined'
            };
        }
    }
};

CartoCSS.Tree.Zoom = class Zoom {
    constructor(op, value, index) {
        this.op = op;
        this.value = value;
        this.index = index;
    }

    setZoom(zoom) {
        this.zoom = zoom;
        return this;
    }

    ev(env) {
        var value = parseInt(this.value.ev(env).toString(), 10);


        if (value > CartoCSS.Tree.Zoom.maxZoom || value < 0) {
            env.error({
                message: 'Only zoom levels between 0 and ' +
                CartoCSS.Tree.Zoom.maxZoom + ' supported.',
                index: this.index
            });
        }

        switch (this.op) {
            case '=':
                this.zoom = "zoom && zoom === " + value;
                return this;
            case '>':
                this.zoom = "zoom && zoom > " + value;
                break;
            case '>=':
                this.zoom = "zoom && zoom >= " + value;
                break;
            case '<':
                this.zoom = "zoom && zoom < " + value;
                break;
            case '<=':
                this.zoom = "zoom && zoom <= " + value;
                break;
            default:
                break;
        }
        /*
         for (var i = 0; i <= CartoCSS.Tree.Zoom.maxZoom; i++) {
         if (i >= start && i <= end) {
         zoom |= (1 << i);
         }
         }
         this.zoom = zoom;
         this.zoom=value+this.op+"zoom";*/
        return this;
    }

    toString() {
        var str = '';
        for (var i = 0; i <= CartoCSS.Tree.Zoom.maxZoom; i++) {
            str += (this.zoom & (1 << i)) ? 'X' : '.';
        }
        return str;
    }
};

// Covers all zoomlevels from 0 to 22
CartoCSS.Tree.Zoom.all = 23;

CartoCSS.Tree.Zoom.maxZoom = 22;

CartoCSS.Tree.Zoom.ranges = {
    0: 1000000000,
    1: 500000000,
    2: 200000000,
    3: 100000000,
    4: 50000000,
    5: 25000000,
    6: 12500000,
    7: 6500000,
    8: 3000000,
    9: 1500000,
    10: 750000,
    11: 400000,
    12: 200000,
    13: 100000,
    14: 50000,
    15: 25000,
    16: 12500,
    17: 5000,
    18: 2500,
    19: 1500,
    20: 750,
    21: 500,
    22: 250,
    23: 100
};

;// CONCATENATED MODULE: ./src/common/style/ThemeStyle.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


/**
 * @class ThemeStyle
 * @deprecatedclass SuperMap.ThemeStyle
 * @classdesc 客户端专题图风格类。
 * @modulecategory Overlay
 * @category Visualization Theme
 * @param {Object} options - 可选参数。
 * @param {boolean} [options.fill=true] - 是否填充，不需要填充则设置为 false。如果 fill 与 stroke 同时为 false，将按 fill 与 stroke 的默认值渲染图层。
 * @param {string} [options.fillColor='#000000'] - 十六进制填充颜色。
 * @param {number} [options.fillOpacity=1] - 填充不透明度。取值范围[0, 1]。
 * @param {boolean} [options.stroke=false] -  是否描边，不需要描边则设置为false。如果 fill 与 stroke 同时为 false，将按 fill 与 stroke 的默认值渲染图层。
 * @param {string} [options.strokeColor='#000000'] - 十六进制描边颜色。
 * @param {number} [options.strokeOpacity=1] - 描边的不透明度。取值范围[0, 1]。
 * @param {number} [options.strokeWidth=1] - 线宽度/描边宽度。
 * @param {string} [options.strokeLinecap='butt'] - 线帽样式。strokeLinecap 有三种类型 “butt", "round", "square"。
 * @param {string} [options.strokeLineJoin='iter'] - 线段连接样式。strokeLineJoin 有三种类型 “miter", "round", "bevel"。
 * @param {string} [options.strokeDashstyle='solid'] - 虚线类型。strokeDashstyle 有八种类型 “dot",“dash",“dashdot",“longdash",“longdashdot",“solid", "dashed", "dotted"。solid 表示实线。
 * @param {number} [options.pointRadius=6] - 点半径，单位为像素。
 * @param {number} [options.shadowBlur=0] - 阴影模糊度，（大于 0 有效）。注：请将 shadowColor 属性与 shadowBlur 属性一起使用，来创建阴影。
 * @param {string} [options.shadowColor='#000000'] - 阴影颜色。注：请将 shadowColor 属性与 shadowBlur 属性一起使用，来创建阴影。
 * @param {number} [options.shadowOffsetX=0] - 阴影 X 方向偏移值。
 * @param {number} [options.shadowOffsetY=0] - 阴影 Y 方向偏移值。
 * @param {string} options.label - 专题要素附加文本标签内容。
 * @param {string} [options.fontColor] - 附加文本字体颜色。
 * @param {number} [options.fontSize=12] - 附加文本字体大小，单位是像素。
 * @param {string} [options.fontStyle='normal'] - 附加文本字体样式。可设值："normal", "italic", "oblique"。
 * @param {string} [options.fontVariant='normal'] - 附加文本字体变体。可设值："normal", "small-caps"。
 * @param {string} [options.fontWeight='normal'] - 附加文本字体粗细。可设值："normal", "bold", "bolder", "lighter"。
 * @param {string} [options.fontFamily='arial,sans-serif'] - 附加文本字体系列。fontFamily 值是字体族名称或/及类族名称的一个优先表，每个值逗号分割，
 *                             浏览器会使用它可识别的第一个可以使用具体的字体名称（"times"、"courier"、"arial"）或字体系列名称
 *                              （"serif"、"sans-serif"、"cursive"、"fantasy"、"monospace"）。
 * @param {string} [options.labelPosition='top'] - 附加文本位置，可以是 'inside', 'left', 'right', 'top', 'bottom'。
 * @param {string} [options.labelAlign='center'] - 附加文本水平对齐。可以是 'left', 'right', 'center'。
 * @param {string} [options.labelBaseline='middle'] - 附加文本垂直对齐。可以是 'top', 'bottom', 'middle' 。
 * @param {number} [options.labelXOffset=0] - 附加文本在x轴方向的偏移量。
 * @param {number} [options.labelYOffset=0] - 附加文本在y轴方向的偏移量。
 * @usage
 */
class ThemeStyle {


    constructor(options) {
        options = options || {};
        /**
         * @member {boolean} [ThemeStyle.prototype.fill=true]
         * @description 是否填充，不需要填充则设置为 false。如果 fill 与 stroke 同时为 false，将按 fill 与 stroke 的默认值渲染图层。
         */
        this.fill = true;
        /**
         * @member {string} [ThemeStyle.prototype.fillColor="#000000"]
         * @description 十六进制填充颜色。
         */
        this.fillColor = "#000000";
        /**
         *  @member {number} [ThemeStyle.prototype.fillOpacity=1]
         *  @description 填充不透明度。取值范围[0, 1]。
         */
        this.fillOpacity = 1;
        /**
         * @member {boolean} [ThemeStyle.prototype.stroke=false]
         * @description  是否描边，不需要描边则设置为false。如果 fill 与 stroke 同时为 false，将按 fill 与 stroke 的默认值渲染图层。
         */
        this.stroke = false;
        /**
         * @member {string} [ThemeStyle.prototype.strokeColor="#000000"]
         * @description  十六进制描边颜色。
         */
        this.strokeColor = "#000000";
        /**
         * @member {number} [ThemeStyle.prototype.strokeOpacity=1]
         * @description  描边的不透明度。取值范围[0, 1]。
         */
        this.strokeOpacity = 1;
        /**
         * @member {number} [ThemeStyle.prototype.strokeWidth=1]
         * @description  线宽度/描边宽度。
         */
        this.strokeWidth = 1;
        /**
         * @member {string} [ThemeStyle.prototype.strokeLinecap="butt"]
         * @description  线帽样式；strokeLinecap 有三种类型 “butt", "round", "square" 。
         */
        this.strokeLinecap = "butt";
        /**
         * @member {string} [ThemeStyle.prototype.strokeLineJoin="miter"]
         * @description  线段连接样式；strokeLineJoin 有三种类型 “miter", "round", "bevel"。
         */
        this.strokeLineJoin = "miter";
        /**
         * @member {string} [ThemeStyle.prototype.strokeDashstyle="solid"]
         * @description   虚线类型；strokeDashstyle 有八种类型 “dot",“dash",“dashdot",“longdash",“longdashdot",“solid", "dashed", "dotted";
         * solid 表示实线。
         */
        this.strokeDashstyle = "solid";
        /**
         * @member {number} [ThemeStyle.prototype.pointRadius=6]
         * @description   点半径。单位为像素。
         */
        this.pointRadius = 6;
        /**
         * @member {number} [ThemeStyle.prototype.shadowBlur=0]
         * @description   阴影模糊度，（大于 0 有效）。注：请将 shadowColor 属性与 shadowBlur 属性一起使用，来创建阴影。
         */
        this.shadowBlur = 0;
        /**
         * @member {string} [ThemeStyle.prototype.shadowColor='#000000']
         * @description  阴影颜色。注：请将 shadowColor 属性与 shadowBlur 属性一起使用，来创建阴影。
         */
        this.shadowColor = "#000000";
        /**
         * @member {number} [ThemeStyle.prototype.shadowOffsetX=0]
         * @description 阴影 X 方向偏移值。
         */
        this.shadowOffsetX = 0;
        /**
         * @member {number} ThemeStyle.prototype.shadowOffsetY
         * @description Y 方向偏移值。
         */
        this.shadowOffsetY = 0;
        /**
         * @member {string} [ThemeStyle.prototype.label]
         * @description 专题要素附加文本标签内容。
         */
        this.label = "";
        /**
         * @member {boolean} [ThemeStyle.prototype.labelRect=false]
         * @description 是否显示文本标签矩形背景。
         */
        this.labelRect = false;
        /**
         * @member {string} [ThemeStyle.prototype.fontColor]
         * @description 附加文本字体颜色。
         */
        this.fontColor = "";
        /**
         * @member {number} [ThemeStyle.prototype.fontSize=12]
         * @description 附加文本字体大小，单位是像素。
         */
        this.fontSize = 12;
        /**
         * @member {string} [ThemeStyle.prototype.fontStyle="normal"]
         * @description 附加文本字体样式。可设值："normal", "italic", "oblique"。
         */
        this.fontStyle = "normal";
        /**
         * @member {string} [ThemeStyle.prototype.fontVariant="normal"]
         * @description 附加文本字体变体。可设值："normal", "small-caps"。
         */
        this.fontVariant = "normal";
        /**
         * @member {string} [ThemeStyle.prototype.fontWeight="normal"]
         * @description 附加文本字体粗细。可设值："normal", "bold", "bolder", "lighter"。
         */
        this.fontWeight = "normal";
        /**
         * @member {string} [ThemeStyle.prototype.fontFamily="arial,sans-serif"]
         * @description 附加文本字体系列。fontFamily 值是字体族名称或/及类族名称的一个优先表，每个值逗号分割，浏览器会使用它可识别的第一个
         * 可以使用具体的字体名称（"times"、"courier"、"arial"）或字体系列名称（"serif"、"sans-serif"、"cursive"、"fantasy"、"monospace"）。
         */
        this.fontFamily = "arial,sans-serif";
        /**
         * @member {string} [ThemeStyle.prototype.labelPosition='top']
         * @description 附加文本位置，可以是 'inside', 'left', 'right', 'top', 'bottom'。
         */
        this.labelPosition = "top";
        /**
         * @member {string} [ThemeStyle.prototype.labelAlign='center']
         * @description 附加文本水平对齐。可以是 'left', 'right', 'center'。
         */
        this.labelAlign = "center";
        /**
         * @member {string} [ThemeStyle.prototype.labelBaseline='middle']
         * @description  附加文本垂直对齐。可以是 'top', 'bottom', 'middle'。
         */
        this.labelBaseline = "middle";
        /**
         * @member {number} [ThemeStyle.prototype.labelXOffset=0]
         * @description  附加文本在 X 轴方向的偏移量。
         */
        this.labelXOffset = 0;
        /**
         * @member {number} [ThemeStyle.prototype.labelYOffset=0]
         * @description 附加文本在 Y 轴方向的偏移量。
         */
        this.labelYOffset = 0;

        Util_Util.extend(this, options);
    }
}


;// CONCATENATED MODULE: ./src/common/style/index.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/






;// CONCATENATED MODULE: ./src/common/overlay/Graph.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/




/**
 * @class FeatureThemeGraph
 * @aliasclass Feature.Theme.Graph
 * @deprecatedclass SuperMap.Feature.Theme.Graph
 * @category Visualization Theme
 * @classdesc 统计专题要素基类。
 * 此类定义了统计专题要素基础模型，具体的图表模型通过继承此类，在子类中实现 assembleShapes 方法。
 * 统计专题要素模型采用了可视化图形大小自适应策略，用较少的参数控制着图表诸多图形，图表配置对象 <FeatureThemeGraph.setting> 的基础属性只有 7 个，
 * 它们控制着图表结构、值域范围、数据小数位等基础图表形态。构成图表的图形必须在图表结构里自适应大小。
 * 此类不可实例化，此类的可实例化子类必须实现 assembleShapes() 方法。
 * @extends FeatureTheme
 * @param {FeatureVector} data - 用户数据。
 * @param {SuperMap.Layer.Theme} layer - 此专题要素所在图层。
 * @param {Array.<string>} fields - data 中的参与此图表生成的字段名称。
 * @param {Object} setting - 图表配置对象。
 * @param {LonLat} [lonlat] - 专题要素地理位置。默认为 data 指代的地理要素 Bounds 中心。
 * @usage
 */
class Graph_Graph extends Theme {


    constructor(data, layer, fields, setting, lonlat, options) {
        super(data, layer, fields, setting, lonlat, options);

        /**
         * @member {FeatureShapeFactory} FeatureThemeGraph.prototype.shapeFactory
         * @description 内置的图形工厂对象，调用其 createShape 方法创建图形。
         */
        this.shapeFactory = new ShapeFactory();

        /**
         * @member {Object} FeatureThemeGraph.prototype.shapeParameters
         * @description 当前图形参数对象，<{@link ShapeParameters}> 的子类对象。
         */
        this.shapeParameters = null;

        /**
         * @member {boolean} [FeatureThemeGraph.prototype.RelativeCoordinate]
         * @description 图形是否已经计算了相对坐标。
         */
        this.RelativeCoordinate = false;

        /**
         * @member {Object} FeatureThemeGraph.prototype.setting
         * @description 图表配置对象，该对象控制着图表的可视化显示。
         * @param {number} width - 专题要素（图表）宽度。
         * @param {number} height - 专题要素（图表）高度。
         * @param {Array.<number>} codomain - 值域，长度为 2 的一维数组，第一个元素表示值域下限，第二个元素表示值域上限。
         * @param {number} [XOffset] - 专题要素（图表）在 X 方向上的偏移值，单位像素。
         * @param {number} [YOffset] - 专题要素（图表）在 Y 方向上的偏移值，单位像素。
         * @param {Array.<number>} [dataViewBoxParameter] - 数据视图框 dataViewBox 参数，它是指图表框 chartBox
         *                                                    （由图表位置、图表宽度、图表高度构成的图表范围框）在左、下，右，上四个方向上的内偏距值。
         * @param {number} [decimalNumber] - 数据值数组 dataValues 元素值小数位数，数据的小数位处理参数，取值范围：[0, 16]。
         *                                       如果不设置此参数，在取数据值时不对数据做小数位处理。
         *
         */
        this.setting = null;

        /**
         * @readonly
         * @member {Array.<number>} FeatureThemeGraph.prototype.origonPoint
         * @description 专题要素（图表）原点，图表左上角点像素坐标，是长度为 2 的一维数组，第一个元素表示 x 坐标，第二个元素表示 y 坐标。
         */
        this.origonPoint = null;

        /**
         * @readonly
         * @member {Array.<number>} FeatureThemeGraph.prototype.chartBox
         * @description 专题要素（图表）区域，即图表框，长度为 4 的一维数组，数组的 4 个元素依次表示图表框左端 x 坐标值、
         *              下端 y坐标值、右端 x坐标值、上端 y 坐标值；[left, bottom, right, top]。
         */
        this.chartBox = null;

        /**
         * @readonly
         * @member {Bounds} FeatureThemeGraph.prototype.chartBounds
         * @description 图表 Bounds 随着 lonlat、XOffset、YOffset 更新，注意 chartBounds 是图表像素范围，不是地理范围。
         */
        this.chartBounds = null;

        /**
         * @readonly
         * @member {number} FeatureThemeGraph.prototype.width
         * @description 专题要素（图表）宽度 。
         */
        this.width = null;

        /**
         * @readonly
         * @member {number} FeatureThemeGraph.prototype.height
         * @description 专题要素（图表）高度 。
         */
        this.height = null;

        /**
         * @readonly
         * @member {number} FeatureThemeGraph.prototype.XOffset
         * @description 专题要素（图表）在 X 方向上的偏移值，单位像素。
         */
        this.XOffset = 0;

        /**
         * @readonly
         * @member {number} FeatureThemeGraph.prototype.YOffset
         * @description 专题要素（图表）在 Y 方向上的偏移值，单位像素。
         */
        this.YOffset = 0;

        /**
         * @readonly
         * @member {Array.<number>} FeatureThemeGraph.prototype.DVBParameter
         * @description 数据视图框参数，长度为 4 的一维数组（数组元素值 >= 0），[leftOffset, bottomOffset, rightOffset, topOffset]，chartBox 内偏距值。
         *               此属性用于指定数据视图框 dataViewBox 的范围。
         */
        this.DVBParameter = null;

        /**
         * @readonly
         * @member {Array.<number>} FeatureThemeGraph.prototype.dataViewBox
         * @description 数据视图框，长度为 4 的一维数组，[left, bottom, right, top]。
         *              dataViewBox 是统计专题要素最核心的内容，它负责解释数据在一个像素区域里的数据可视化含义，
         *              这种含义用可视化图形表达出来，这些表示数据的图形和一些辅助图形组合在一起构成统计专题图表。
         */
        this.dataViewBox = null;

        /**
         * @readonly
         * @member {Array.<number>} FeatureThemeGraph.prototype.DVBCodomain
         * @description 数据视图框的内允许展示的数据值域，长度为 2 的一维数组，第一个元素表示值域下限，第二个元素表示值域上限。
         *              dataViewBox 中允许的数据范围，对数据溢出值域范围情况的处理需要在 assembleShapes 中进行。
         */
        this.DVBCodomain = null;

        /**
         * @readonly
         * @member {Array.<number>} FeatureThemeGraph.prototype.DVBCenterPoint
         * @description 数据视图框中心点，长度为 2 的一维数组，第一个元素表示 x 坐标，第二个元素表示 y 坐标。
         */
        this.DVBCenterPoint = null;

        /**
         * @readonly
         * @member {string} FeatureThemeGraph.prototype.DVBUnitValue
         * @description 单位值。在 assembleShapes() 中初始化其具体意义，例如：饼图的 DVBUnitValue 可以定义为"360/数据总和"，
         *              折线图的 DVBUnitValue 可以定义为 "DVBCodomain/DVBHeight"。
         */
        this.DVBUnitValue = null;

        /**
         * @readonly
         * @member {Array.<number>} FeatureThemeGraph.prototype.DVBOrigonPoint
         * @description 数据视图框原点，数据视图框左上角点，长度为 2 的一维数组，第一个元素表示 x 坐标，第二个元素表示 y 坐标。
         */
        this.DVBOrigonPoint = null;

        /**
         * @readonly
         * @member {number} FeatureThemeGraph.prototype.DVBWidth
         * @description 数据视图框宽度。
         */
        this.DVBWidth = null;

        /**
         * @readonly
         * @member {number} FeatureThemeGraph.prototype.DVBHeight
         * @description 数据视图框高度。
         */
        this.DVBHeight = null;

        /**
         * @readonly
         * @member {Array.<number>} FeatureThemeGraph.prototype.origonPointOffset
         * @description 数据视图框原点相对于图表框的原点偏移量，长度为 2 的一维数组，第一个元素表示 x 偏移量，第二个元素表示 y 偏移量。
         */
        this.origonPointOffset = null;

        /**
         * @readonly
         * @member {Array.<string>} FeatureThemeGraph.prototype.fields
         * @description 数据{FeatureVector}属性字段。
         */
        this.fields = fields || [];

        /**
         * @readonly
         * @member {Array.<number>} FeatureThemeGraph.prototype.dataValues
         * @description 图表展示的数据值，通过 fields 从数据 feature 属性中获得。
         */
        this.dataValues = null;
        // 图表位置
        if (lonlat) {
            this.lonlat = lonlat;
        } else {
            // 默认使用 bounds 中心
            this.lonlat = this.data.geometry.getBounds().getCenterLonLat();
        }

        // 配置项检测与赋值
        if (setting && setting.width && setting.height && setting.codomain) {
            this.setting = setting;
        }
        this.CLASS_NAME = "SuperMap.Feature.Theme.Graph";

    }

    /**
     * @function FeatureThemeGraph.prototype.destroy
     * @description 销毁专题要素。
     */
    destroy() {
        this.shapeFactory = null;
        this.shapeParameters = null;
        this.width = null;
        this.height = null;
        this.origonPoint = null;
        this.chartBox = null;
        this.dataViewBox = null;
        this.chartBounds = null;
        this.DVBParameter = null;
        this.DVBOrigonPoint = null;
        this.DVBCenterPoint = null;
        this.DVBWidth = null;
        this.DVBHeight = null;
        this.DVBCodomain = null;
        this.DVBUnitValue = null;
        this.origonPointOffset = null;
        this.XOffset = null;
        this.YOffset = null;
        this.fields = null;
        this.dataValues = null;
        this.setting = null;
        super.destroy();
    }


    /**
     * @function FeatureThemeGraph.prototype.initBaseParameter
     * @description 初始化专题要素（图表）基础参数。在调用此方法前，此类的图表模型相关属性都是不可用的 ，此方法在 assembleShapes 函数中调用。
     *              调用此函数关系到 setting 对象的以下属性。
     * @param {number} width - 专题要素（图表）宽度。
     * @param {number} height - 专题要素（图表）高度。
     * @param {Array.<number>} codomain - 值域，长度为 2 的一维数组，第一个元素表示值域下限，第二个元素表示值域上限。
     * @param {number} [XOffset] - 专题要素（图表）在 X 方向上的偏移值，单位像素。
     * @param {number} [YOffset] - 专题要素（图表）在 Y 方向上的偏移值，单位像素。
     * @param {Array.<number>} [dataViewBoxParameter] - 数据视图框 dataViewBox 参数，它是指图表框 chartBox。
     *                                     （由图表位置、图表宽度、图表高度构成的图表范围框）在左、下，右，上四个方向上的内偏距值。
     * @param {number} [decimalNumber] - 数据值数组 dataValues 元素值小数位数，数据的小数位处理参数，取值范围：[0, 16]。如果不设置此参数，在取数据值时不对数据做小数位处理。
     * @returns {boolean} 初始化参数是否成功。
     */
    initBaseParameter() {
        // 参数初始化是否成功
        var isSuccess = true;

        // setting 属性是否已成功赋值
        if (!this.setting) {
            return false;
        }
        var sets = this.setting;
        // 检测 setting 的必设参数
        if (!(sets.width && sets.height && sets.codomain)) {
            return false;
        }

        // 数据
        var decimalNumber = (typeof(sets.decimalNumber) !== "undefined" && !isNaN(sets.decimalNumber)) ? sets.decimalNumber : -1;
        var dataEffective = Theme.getDataValues(this.data, this.fields, decimalNumber);
        this.dataValues = dataEffective ? dataEffective : [];

        // 基础参数  width, height, codomain
        this.width = parseFloat(sets.width);
        this.height = parseFloat(sets.height);
        this.DVBCodomain = sets.codomain;

        // 图表偏移
        // if(sets.XOffset) {this.XOffset = sets.XOffset};
        // if(sets.YOffset) {this.YOffset = sets.YOffset};
        this.XOffset = sets.XOffset ? sets.XOffset : 0;
        this.YOffset = sets.YOffset ? sets.YOffset : 0;

        // 其他默认值
        this.origonPoint = [];
        this.chartBox = [];
        this.dataViewBox = [];

        this.DVBParameter = sets.dataViewBoxParameter ? sets.dataViewBoxParameter : [0, 0, 0, 0];

        this.DVBOrigonPoint = [];
        this.DVBCenterPoint = [];
        this.origonPointOffset = [];

        // 图表位置
        this.resetLocation();

        // 专题要素宽度 w
        var w = this.width;
        // 专题要素高度 h
        var h = this.height;
        // 专题要素像素位置 loc
        var loc = this.location;

        // 专题要素像素位置 loc
        this.origonPoint = [loc[0] - w / 2, loc[1] - h / 2];
        // 专题要素原点（左上角）
        var op = this.origonPoint;

        // 图表框（[left, bottom, right, top]）
        this.chartBox = [op[0], op[1] + h, op[0] + w, op[1]];
        // 图表框
        var cb = this.chartBox;

        // 数据视图框参数，它是图表框各方向对应的内偏距
        var dbbP = this.DVBParameter;
        // 数据视图框 （[left, bottom, right, top]）
        this.dataViewBox = [cb[0] + dbbP[0], cb[1] - dbbP[1], cb[2] - dbbP[2], cb[3] + dbbP[3]];
        // 数据视图框
        var dvb = this.dataViewBox;
        //检查数据视图框是否合法
        if (dvb[0] >= dvb[2] || dvb[1] <= dvb[3]) {
            return false;
        }

        // 数据视图框原点
        this.DVBOrigonPoint = [dvb[0], dvb[3]];
        // 数据视图框宽度
        this.DVBWidth = Math.abs(dvb[2] - dvb[0]);
        // 数据视图框高度
        this.DVBHeight = Math.abs(dvb[1] - dvb[3]);
        // 数据视图框中心点
        this.DVBCenterPoint = [this.DVBOrigonPoint[0] + this.DVBWidth / 2, this.DVBOrigonPoint[1] + this.DVBHeight / 2]

        // 数据视图框原点与图表框的原点偏移量
        this.origonPointOffset = [this.DVBOrigonPoint[0] - op[0], this.DVBOrigonPoint[1] - op[1]];

        return isSuccess;
    }

    /**
     * @function FeatureThemeGraph.prototype.resetLocation
     * @description 根据地理位置 lonlat 重置专题要素（图表）位置。
     * @param {LonLat} lonlat - 专题要素新的像素中心位置。
     * @returns {Array.<number>} 新专题要素像素参考位置。长度为 2 的数组，第一个元素表示 x 坐标，第二个元素表示 y 坐标。
     */
    resetLocation(lonlat) {
        if (lonlat) {
            this.lonlat = lonlat;
        }

        // 获取地理位置对应的像素坐标 newLocalLX
        var newLocalLX = this.getLocalXY(this.lonlat);
        // 处理偏移量 XOffset, YOffset
        newLocalLX[0] += this.XOffset;
        newLocalLX[1] += this.YOffset;
        // 将图形位置赋予  location 属性（注意 location 属性表示的是专题要素中心位置）
        this.location = newLocalLX;

        // 更新图表像素 Bounds
        var w = this.width;
        var h = this.height;
        var loc = this.location;
        this.chartBounds = new Bounds(loc[0] - w / 2, loc[1] + h / 2, loc[0] + w / 2, loc[1] - h / 2);

        //重新计算当前渐变色
        this.resetLinearGradient();

        return loc;
    }

    /**
     * @function FeatureThemeGraph.prototype.resetLinearGradient
     * @description resetLocation 中调用 图表的相对坐标存在的时候，重新计算渐变的颜色（目前用于二维柱状图渐变色 所以子类实现此方法）。
     */
    resetLinearGradient() {
        //子类实现此方法
    }

    /**
     * @function FeatureThemeGraph.prototype.shapesConvertToRelativeCoordinate
     * @description 将（构成图表）图形的节点转为相对坐标表示，此函数必须且只能在 assembleShapes() 结束时调用。
     */
    shapesConvertToRelativeCoordinate() {
        var shapes = this.shapes;
        var shapeROP = this.location;
        for (var i = 0, len = shapes.length; i < len; i++) {
            shapes[i].refOriginalPosition = shapeROP;

            var style = shapes[i].style;

            for (var sty in style) {
                switch (sty) {
                    case "pointList":
                        var pl = style[sty];
                        for (var j = 0, len2 = pl.length; j < len2; j++) {
                            pl[j][0] -= shapeROP[0];
                            pl[j][1] -= shapeROP[1];
                        }
                        break;
                    case "x":
                        style[sty] -= shapeROP[0];
                        break;
                    case "y":
                        style[sty] -= shapeROP[1];
                        break;
                    default:
                        break;
                }
            }
        }
        this.RelativeCoordinate = true;
    }


    /**
     * @function FeatureThemeGraph.prototype.assembleShapes
     * @description 图形装配函数。抽象方法，可视化子类必须实现此方法。<br>
     *              重写此方法的步骤：<br>
     *              1. 图表的某些特殊配置项（setting）处理，例如多数图表模型需要重新指定 dataViewBoxParameter 的默认值。<br>
     *              2. 调用 initBaseParameter() 方法初始化模型属性值，此步骤必须执行，只有当 initBaseParameter 返回 true 时才可以允许进行后续步骤。<br>
     *              3. 计算图形参数，制作图形，图形组合。在组装图表过程中，应该特别注意数据视图框单位值的定义、数据值溢出值域范围的处理和图形大小自适应。<br>
     *              4. 调用 shapesConvertToRelativeCoordinate() 方法，将图形的坐标值转为相对坐标，此步骤必须执行。
     * @example
     *  //子类实现 assembleShapes() 接口的步骤示例：
     *  assembleShapes: function(){
     *    // 第一步：图表的某些特殊配置项（setting）处理，例如多数图表模型需要重新指定 dataViewBoxParameter 的默认值。此步骤是非必须过程。
     *
     *    // 图表配置对象
     *    var sets = this.setting;
     *    // 默认数据视图框，这里展示在使用坐标轴和不使用坐标轴情况下对数据视图框参数赋予不同的默认值
     *    if(!sets.dataViewBoxParameter){
     *          if(typeof(sets.useAxis) === "undefined" || sets.useAxis){
     *              sets.dataViewBoxParameter = [45, 15, 15, 15];
     *          }
     *          else{
     *                  sets.dataViewBoxParameter = [5, 5, 5, 5];
     *          }
     *    }
     *
     *    // 第二步：初始化图表模型基本参数，只有在图表模型基本参数初始化成功时才可模型相关属性，如 this.dataViewBox、 this.DVBCodomain等。此步骤是必须过程。
     *    if(!this.initBaseParameter()) return;
     *
     *    // 第三步：用图形组装图表，在组装图表过程中，应该特别注意数据视图框单位值的定义、数据值溢出值域范围的处理和图形大小自适应。
     *    // 定义图表数据视图框中单位值的含义，下面行代码表示将数据视图框单位值定义为数据视图框高度上每像素代表的数据值
     *    this.DVBUnitValue =  (this.codomain[1] - this.codomain[0])/this.DVBHeight;
     *    var uv = this.DVBUnitValue;
     *
     *    // 图形参数计算代码......
     *
     *    // 关于图形装配，实际上就是利用图形工程对象 this.shapeFactory 的 createShape() 方法通过图形参数对象创建可视化的图形对象，并把这些图形对象按序添加到模型的图形库（his.shapes）中。下面的代码演示创建一个面图形参数对象，并允许通过图形配置对象设置图形的 style 和 highlightStyle，
     *    var barParams = new ShapeParametersPolygon(poiLists);
     *    barParams.style = sets.barStyle? sets.barStyle:{fillColor: "lightblue"};
     *    barParams.highlightStyle = sets.barHoverStyle? sets.barHoverStyle:{fillColor: "blue"};
     *    // 图形携带数据ID信息
     *    barParams.refDataID = this.data.id;
     *    // 创建图形并添加到图表图形数组中
     *    this.shapes.push(this.shapeFactory.createShape(barParams));
     *
     *    // 第四步：调用 shapesConvertToRelativeCoordinate() 方法，将图形库（his.shapes）中的图形转为由相对坐标表示的图形，客户端统计专题图模块从结构上要求可视化图形使用相对坐标，assembleShapes() 函数必须在图形装配完成后调用 shapesConvertToRelativeCoordinate() 函数。此步骤是必须过程。
     *    this.shapesConvertToRelativeCoordinate();
     * },
     */
    assembleShapes() {
        //子类必须实现此方法
    }

    /**
     * @function FeatureThemeGraph.prototype.getLocalXY
     * @description 地理坐标转为像素坐标。
     * @param {LonLat} lonlat - 带转换的地理坐标。
     * @returns 屏幕像素坐标。
     */
    getLocalXY(lonlat) {
        return this.layer.getLocalXY(lonlat);
    }

}

/**
 * @function FeatureTheme.getDataValues
 * @description 根据字段名数组获取指定数据（feature）的属性值数组。属性值类型必须为 Number。
 * @param {FeatureVector} data - 数据。
 * @param {Array.<string>} [fields] - 字段名数组。
 * @param {number} [decimalNumber] - 小数位处理参数，对获取到的属性数据值进行小数位处理。
 * @returns {Array.<string>} 字段名数组对应的属性数据值数组。
 */
Theme.getDataValues = function (data, fields, decimalNumber) {
    if (!data.attributes) {
        return false;
    }

    var fieldsValue = [];

    var attrs = data.attributes;
    for (var i = 0; i < fields.length; i++) {
        for (var field in attrs) {
            if (field !== fields[i]) {
                continue
            }
            // 数字转换判断
            try {
                if (!isNaN(decimalNumber) && decimalNumber >= 0) {
                    fieldsValue.push(parseFloat(attrs[field].toString()).toFixed(decimalNumber));
                } else {
                    fieldsValue.push(parseFloat(attrs[field].toString()));
                }
            } catch (e) {
                throw new Error("not a number")
            }
        }
    }

    if (fieldsValue.length === fields.length) {
        return fieldsValue;
    } else {
        return false;
    }
};

;// CONCATENATED MODULE: ./src/common/overlay/Bar.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/








/**
 * @class FeatureThemeBar
 * @aliasclass Feature.Theme.Bar
 * @deprecatedclass SuperMap.Feature.Theme.Bar
 * @classdesc 柱状图 。
 * @category Visualization Theme
 * @example
 * // barStyleByCodomain参数用法如下：
 * // barStyleByCodomain 的每个元素是个包含值域信息和与值域对应样式信息的对象，该对象（必须）有三个属性：
 * // start: 值域值下限（包含）;
 * // end: 值域值上限（不包含）;
 * // style: 数据可视化图形的 style，这个样式对象的可设属性： <ShapeParametersPolygon.style> 。
 * // barStyleByCodomain 数组形如：
 * [
 *   {
 *     start:0,
 *     end:250,
 *     style:{
 *          fillColor:"#00CD00"
 *      }
 *  },
 *   {
 *     start:250,
 *     end:500,
 *     style:{
 *          fillColor:"#00EE00"
 *      }
 *  },
 *   {
 *     start:500,
 *     end:750,
 *     style:{
 *          fillColor:"#00FF7F"
 *      }
 *  },
 *   {
 *     start:750,
 *     end:1500,
 *     style:{
 *          fillColor:"#00FF00"
 *      }
 *  }
 * ]
 * @extends FeatureThemeGraph
 * @param {FeatureVector} data - 用户数据。
 * @param {SuperMap.Layer.Graph} layer - 此专题要素所在图层。
 * @param {Array.<string>} fields - data 属性中的参与此图表生成的属性字段名称。
 * @param {FeatureThemeBar.setting} setting - 图表配置对象。
 * @param {LonLat} [lonlat] - 专题要素地理位置。默认为 data 指代的地理要素 Bounds 中心。
 * @usage
 * @private
 */
class Bar extends Graph_Graph {

    constructor(data, layer, fields, setting, lonlat) {
        super(data, layer, fields, setting, lonlat);
        this.CLASS_NAME = "SuperMap.Feature.Theme.Bar";
    }

    /**
     * @function FeatureThemeBar.prototype.destroy
     * @override
     */
    destroy() {
        super.destroy();
    }

    /**
     * @function FeatureThemeBar.prototype.assembleShapes
     * @description 图表图形装配函数。
     */
    assembleShapes() {
        //默认渐变颜色数组
        var deafaultColors = [["#00FF00", "#00CD00"], ["#00CCFF", "#5E87A2"], ["#00FF66", "#669985"], ["#CCFF00", "#94A25E"], ["#FF9900", "#A2945E"]];

        //默认阴影
        var deafaultShawdow = {
            showShadow: true,
            shadowBlur: 8,
            shadowColor: "rgba(100,100,100,0.8)",
            shadowOffsetX: 2,
            shadowOffsetY: 2
        };

        // 图表配置对象
        var sets = this.setting;

        if (!sets.barLinearGradient) {
            sets.barLinearGradient = deafaultColors;
        }

        // 默认数据视图框
        if (!sets.dataViewBoxParameter) {
            if (typeof(sets.useAxis) === "undefined" || sets.useAxis) {
                sets.dataViewBoxParameter = [45, 15, 15, 15];
            } else {
                sets.dataViewBoxParameter = [5, 5, 5, 5];
            }
        }

        // 重要步骤：初始化参数
        if (!this.initBaseParameter()) {
            return;
        }
        // 值域
        var codomain = this.DVBCodomain;
        // 重要步骤：定义图表 BaFeatureThemeBarr 数据视图框中单位值的含义
        this.DVBUnitValue = (codomain[1] - codomain[0]) / this.DVBHeight;

        // 数据视图域
        var dvb = this.dataViewBox;
        // 用户数据值
        var fv = this.dataValues;
        if (fv.length < 1) {
            return;
        }       // 没有数据

        // 数据溢出值域范围处理
        for (let i = 0, fvLen = fv.length; i < fvLen; i++) {
            if (fv[i] < codomain[0] || fv[i] > codomain[1]) {
                return;
            }
        }

        // 获取 x 轴上的图形信息
        var xShapeInfo = this.calculateXShapeInfo();
        if (!xShapeInfo) {
            return;
        }
        // 每个柱条 x 位置
        var xsLoc = xShapeInfo.xPositions;
        // 柱条宽度
        var xsWdith = xShapeInfo.width;

        // 背景框，默认启用
        if (typeof(sets.useBackground) === "undefined" || sets.useBackground) {
            // 将背景框图形添加到模型的 shapes 数组，注意添加顺序，后添加的图形在先添加的图形之上。
            this.shapes.push(ShapeFactory.Background(this.shapeFactory, this.chartBox, sets));
        }

        // 坐标轴, 默认启用
        if (typeof(sets.useAxis) === "undefined" || sets.useAxis) {
            // 添加坐标轴图形数组
            this.shapes = this.shapes.concat(ShapeFactory.GraphAxis(this.shapeFactory, dvb, sets, xShapeInfo));
        }

        for (var i = 0; i < fv.length; i++) {
            // 计算柱条 top 边的 y 轴坐标值
            var yPx = dvb[1] - (fv[i] - codomain[0]) / this.DVBUnitValue;

            // 柱条节点数组
            var poiLists = [
                [xsLoc[i] - xsWdith / 2, dvb[1] - 1],
                [xsLoc[i] + xsWdith / 2, dvb[1] - 1],
                [xsLoc[i] + xsWdith / 2, yPx],
                [xsLoc[i] - xsWdith / 2, yPx]
            ];

            // 柱条参数对象（一个面参数对象）
            var barParams = new feature_Polygon_Polygon(poiLists);

            // 柱条 阴影 style
            if (typeof(sets.showShadow) === "undefined" || sets.showShadow) {
                if (sets.barShadowStyle) {
                    var sss = sets.barShadowStyle;
                    if (sss.shadowBlur) {
                        deafaultShawdow.shadowBlur = sss.shadowBlur;
                    }
                    if (sss.shadowColor) {
                        deafaultShawdow.shadowColor = sss.shadowColor;
                    }
                    if (sss.shadowOffsetX) {
                        deafaultShawdow.shadowOffsetX = sss.shadowOffsetX;
                    }
                    if (sss.shadowOffsetY) {
                        deafaultShawdow.shadowOffsetY = sss.shadowOffsetY;
                    }
                }
                barParams.style = {};
                Util_Util.copyAttributesWithClip(barParams.style, deafaultShawdow);
            }

            // 图形携带的数据信息
            barParams.refDataID = this.data.id;
            barParams.dataInfo = {
                field: this.fields[i],
                value: fv[i]
            };

            // 柱条 hover click
            if (typeof(sets.barHoverAble) !== "undefined") {
                barParams.hoverable = sets.barHoverAble;
            }
            if (typeof(sets.barClickAble) !== "undefined") {
                barParams.clickable = sets.barClickAble;
            }

            // 创建柱条并添加到图表图形数组中
            this.shapes.push(this.shapeFactory.createShape(barParams));
        }

        // 重要步骤：将图形转为由相对坐标表示的图形，以便在地图平移缩放过程中快速重绘图形
        // （统计专题图模块从结构上要求使用相对坐标，assembleShapes() 函数必须在图形装配完成后调用 shapesConvertToRelativeCoordinate() 函数）
        this.shapesConvertToRelativeCoordinate();
    }

    /**
     * @function FeatureThemeBar.prototype.calculateXShapeInfo
     * @description 计算 X 轴方向上的图形信息，此信息是一个对象，包含两个属性，
     *              属性 xPositions 是一个一维数组，该数组元素表示图形在 x 轴方向上的像素坐标值，
     *              如果图形在 x 方向上有一定宽度，通常取图形在 x 方向上的中心点为图形在 x 方向上的坐标值。
     *              width 表示图形的宽度（特别注意：点的宽度始终为 0，而不是其直径）。
     *              本函数中图形配置对象 setting 可设属性：
     *              xShapeBlank - {Array.<number>} 水平方向上的图形空白间隔参数。
     *              长度为 3 的数组，第一元素表示第一个图形左端与数据视图框左端的空白间距，第二个元素表示图形间空白间距，
     *              第三个元素表示最后一个图形右端与数据视图框右端端的空白间距 。
     * @returns {Object} 如果计算失败，返回 null；如果计算成功，返回 X 轴方向上的图形信息，此信息是一个对象，包含以下两个属性：
     *         xPositions - {Array.<number>} 表示图形在 x 轴方向上的像素坐标值，如果图形在 x 方向上有一定宽度，通常取图形在 x 方向上的中心点为图形在 x 方向上的坐标值。
     *         width - {number} 表示图形的宽度（特别注意：点的宽度始终为 0，而不是其直径）。
     *
     */
    calculateXShapeInfo() {
        var dvb = this.dataViewBox;     // 数据视图框
        var sets = this.setting;     // 图表配置对象
        var fvc = this.dataValues.length;      // 数组值个数

        if (fvc < 1) {
            return null;
        }

        var xBlank;        // x 轴空白间隔参数
        var xShapePositions = [];         // x 轴上图形的位置
        var xShapeWidth = 0;          // x 轴上图形宽度(自适应)
        var dvbWidth = this.DVBWidth;            // 数据视图框宽度

        //  x 轴空白间隔参数处理
        if (sets.xShapeBlank && sets.xShapeBlank.length && sets.xShapeBlank.length == 3) {
            xBlank = sets.xShapeBlank;
            var xsLen = dvbWidth - (xBlank[0] + xBlank[2] + (fvc - 1) * xBlank[1]);
            if (xsLen <= fvc) {
                return null;
            }
            xShapeWidth = xsLen / fvc
        } else {
            // 默认使用等距离空白间隔，空白间隔为图形宽度
            xShapeWidth = dvbWidth / (2 * fvc + 1);
            xBlank = [xShapeWidth, xShapeWidth, xShapeWidth];
        }

        // 图形 x 轴上的位置计算
        var xOffset = 0
        for (var i = 0; i < fvc; i++) {
            if (i == 0) {
                xOffset = xBlank[0] + xShapeWidth / 2;
            } else {
                xOffset += (xShapeWidth + xBlank[1]);
            }

            xShapePositions.push(dvb[0] + xOffset);
        }

        return {
            "xPositions": xShapePositions,
            "width": xShapeWidth
        };
    }

    /**
     * @function FeatureThemeBar.prototype.resetLinearGradient
     * @description 图表的相对坐标存在的时候，重新计算渐变的颜色(目前用于二维柱状图 所以子类实现此方法)。
     */
    resetLinearGradient() {
        if (this.RelativeCoordinate) {
            var shpelength = this.shapes.length;
            var barLinearGradient = this.setting.barLinearGradient;
            var index = -1;
            for (var i = 0; i < shpelength; i++) {
                var shape = this.shapes[i];
                if (shape.CLASS_NAME === "SuperMap.LevelRenderer.Shape.SmicPolygon") {
                    var style = shape.style;
                    //计算出当前的绝对 x y
                    var x1 = this.location[0] + style.pointList[0][0];
                    var x2 = this.location[0] + style.pointList[1][0];

                    //渐变颜色
                    index++;
                    //以防定义的颜色数组不够用
                    if (index >= barLinearGradient.length) {
                        index = index % barLinearGradient.length;
                    }
                    var color1 = barLinearGradient[index][0];
                    var color2 = barLinearGradient[index][1];

                    //颜色
                    var zcolor = new Color();
                    var linearGradient = zcolor.getLinearGradient(x1, 0, x2, 0,
                        [[0, color1], [1, color2]]);

                    //赋值
                    shape.style.color = linearGradient;
                }
            }
        }
    }

}

;// CONCATENATED MODULE: ./src/common/overlay/Bar3D.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/





/**
 * @class FeatureThemeBar3D
 * @aliasclass Feature.Theme.Bar3D
 * @deprecatedclass SuperMap.Feature.Theme.Bar3D
 * @classdesc 三维柱状图 。
 * @category Visualization Theme
 * @extends FeatureThemeGraph
 * @param {FeatureVector} data - 用户数据。
 * @param {SuperMap.Layer.Graph} layer - 此专题要素所在图层。
 * @param {Array.<string>} fields - data 中的参与此图表生成的字段名称。
 * @param {FeatureThemeBar3D.setting} setting - 图表配置对象。
 * @param {LonLat} [lonlat] - 专题要素地理位置，默认为 data 指代的地理要素 Bounds 中心。
 *

 *
 * @example
 * // barFaceStyleByCodomain 用法示例如下：
 * // barFaceStyleByCodomain 的每个元素是个包含值域信息和与值域对应样式信息的对象，该对象（必须）有三个属性：
 * // start: 值域值下限（包含）;
 * // end: 值域值上限（不包含）;
 * // style: 数据可视化图形的 style，这个样式对象的可设属性： <ShapeParametersPolygon.style> 。
 * // barFaceStyleByCodomain 数组形如：
 * [
 *   {
 *     start:0,
 *     end:250,
 *     style:{
 *          fillColor:"#00CD00"
 *      }
 *  },
 *   {
 *     start:250,
 *     end:500,
 *     style:{
 *          fillColor:"#00EE00"
 *      }
 *  },
 *   {
 *     start:500,
 *     end:750,
 *     style:{
 *          fillColor:"#00FF7F"
 *      }
 *  },
 *   {
 *     start:750,
 *     end:1500,
 *     style:{
 *          fillColor:"#00FF00"
 *      }
 *  }
 * ]
 *
 * @example
 * // barSideStyleByCodomain 用法示例如下：
 * // barSideStyleByCodomain 的每个元素是个包含值域信息和与值域对应样式信息的对象，该对象（必须）有三个属性：
 * // start: 值域值下限（包含）;
 * // end: 值域值上限（不包含）;
 * // style: 数据可视化图形的 style，这个样式对象的可设属性： <ShapeParametersPolygon.style> 。
 * // barSideStyleByCodomain 数组形如：
 * [
 *   {
 *     start:0,
 *     end:250,
 *     style:{
 *          fillColor:"#00CD00"
 *      }
 *  },
 *   {
 *     start:250,
 *     end:500,
 *     style:{
 *          fillColor:"#00EE00"
 *      }
 *  },
 *   {
 *     start:500,
 *     end:750,
 *     style:{
 *          fillColor:"#00FF7F"
 *      }
 *  },
 *   {
 *     start:750,
 *     end:1500,
 *     style:{
 *          fillColor:"#00FF00"
 *      }
 *  }
 * ]
 *
 * @example
 * // barTopStyleByCodomain 用法示例如下：
 * // barTopStyleByCodomain 的每个元素是个包含值域信息和与值域对应样式信息的对象，该对象（必须）有三个属性：
 * // start: 值域值下限（包含）;
 * // end: 值域值上限（不包含）;
 * // style: 数据可视化图形的 style，这个样式对象的可设属性：<ShapeParametersPolygon.style> 。
 * // barTopStyleByCodomain 数组形如：
 * [
 *   {
 *     start:0,
 *     end:250,
 *     style:{
 *          fillColor:"#00CD00"
 *      }
 *  },
 *   {
 *     start:250,
 *     end:500,
 *     style:{
 *          fillColor:"#00EE00"
 *      }
 *  },
 *   {
 *     start:500,
 *     end:750,
 *     style:{
 *          fillColor:"#00FF7F"
 *      }
 *  },
 *   {
 *     start:750,
 *     end:1500,
 *     style:{
 *          fillColor:"#00FF00"
 *      }
 *  }
 * ]
 * @usage
 * @private
 */

class Bar3D extends Graph_Graph {

    constructor(data, layer, fields, setting, lonlat) {
        super(data, layer, fields, setting, lonlat);
        this.CLASS_NAME = "SuperMap.Feature.Theme.Bar3D";
    }

    /**
     * @function FeatureThemeBar3D.prototype.destroy
     * @override
     */
    destroy() {
        super.destroy();
    }

    /**
     * @function FeatureThemeBar3D.prototype.assembleShapes
     * @description 图形装配实现（扩展接口）。
     */
    assembleShapes() {
        // 图表配置对象
        var sets = this.setting;

        // 默认数据视图框
        if (!sets.dataViewBoxParameter) {
            if (typeof(sets.useAxis) === "undefined" || sets.useAxis) {
                sets.dataViewBoxParameter = [45, 25, 20, 20];
            } else {
                sets.dataViewBoxParameter = [5, 5, 5, 5];
            }
        }

        // 3d 柱图的坐标轴默认使用坐标轴箭头
        sets.axisUseArrow = (typeof(sets.axisUseArrow) !== "undefined") ? sets.axisUseArrow : true;
        sets.axisXLabelsOffset = (typeof(sets.axisXLabelsOffset) !== "undefined") ? sets.axisXLabelsOffset : [-10, 10];

        // 重要步骤：初始化参数
        if (!this.initBaseParameter()) {
            return;
        }

        // 值域
        var codomain = this.DVBCodomain;
        // 重要步骤：定义图表 FeatureThemeBar 数据视图框中单位值的含义
        this.DVBUnitValue = (codomain[1] - codomain[0]) / this.DVBHeight;
        // 数据视图域
        var dvb = this.dataViewBox;
        // 用户数据值
        var fv = this.dataValues;
        if (fv.length < 1) {
            return;
        }       // 没有数据

        // 数据溢出值域范围处理
        for (let i = 0, fvLen = fv.length; i < fvLen; i++) {
            if (fv[i] < codomain[0] || fv[i] > codomain[1]) {
                return;
            }
        }

        // 获取 x 轴上的图形信息
        var xShapeInfo = this.calculateXShapeInfo();
        if (!xShapeInfo) {
            return;
        }
        // 每个柱条 x 位置
        var xsLoc = xShapeInfo.xPositions;
        // 柱条宽度
        var xsWdith = xShapeInfo.width;

        // 坐标轴, 默认启用
        if (typeof(sets.useBackground) === "undefined" || sets.useBackground) {
            this.shapes.push(ShapeFactory.Background(this.shapeFactory, this.chartBox, sets));
        }

        // 坐标轴
        if (!sets.axis3DParameter || isNaN(sets.axis3DParameter) || sets.axis3DParameter < 15) {
            sets.axis3DParameter = 20;
        }
        if (typeof(sets.useAxis) === "undefined" || sets.useAxis) {
            this.shapes = this.shapes.concat(ShapeFactory.GraphAxis(this.shapeFactory, dvb, sets, xShapeInfo));
        }

        // 3d 偏移量, 默认值 10;
        var offset3d = (sets.bar3DParameter && !isNaN(sets.bar3DParameter)) ? sets.bar3DParameter : 10;

        for (let i = 0; i < fv.length; i++) {
            // 无 3d 偏移量时的柱面顶部 y 坐标
            var yPx = dvb[1] - (fv[i] - codomain[0]) / this.DVBUnitValue;
            // 无 3d 偏移量时的柱面的左、右端 x 坐标
            var iPoiL = xsLoc[i] - xsWdith / 2;
            var iPoiR = xsLoc[i] + xsWdith / 2;

            // 3d 柱顶面节点
            var bar3DTopPois = [
                [iPoiL, yPx],
                [iPoiR, yPx],
                [iPoiR - offset3d, yPx + offset3d],
                [iPoiL - offset3d, yPx + offset3d]
            ];

            // 3d 柱侧面节点
            var bar3DSidePois = [
                [iPoiR, yPx],
                [iPoiR - offset3d, yPx + offset3d],
                [iPoiR - offset3d, dvb[1] + offset3d],
                [iPoiR, dvb[1]]
            ];

            // 3d 柱正面节点
            var bar3DFacePois = [
                [iPoiL - offset3d, dvb[1] + offset3d],
                [iPoiR - offset3d, dvb[1] + offset3d],
                [iPoiR - offset3d, yPx + offset3d],
                [iPoiL - offset3d, yPx + offset3d]
            ];
            if (offset3d <= 0) {  // offset3d <= 0 时正面不偏移
                bar3DFacePois = [
                    [iPoiL, dvb[1]],
                    [iPoiR, dvb[1]],
                    [iPoiR, yPx],
                    [iPoiL, yPx]
                ];
            }

            // 新建 3d 柱面顶面、侧面、正面图形参数对象
            var polyTopSP = new feature_Polygon_Polygon(bar3DTopPois);
            var polySideSP = new feature_Polygon_Polygon(bar3DSidePois);
            var polyFaceSP = new feature_Polygon_Polygon(bar3DFacePois);


            // 侧面、正面图形 style 默认值
            sets.barSideStyle = sets.barSideStyle ? sets.barSideStyle : sets.barFaceStyle;
            sets.barSideStyleByFields = sets.barSideStyleByFields ? sets.barSideStyleByFields : sets.barFaceStyleByFields;
            sets.barSideStyleByCodomain = sets.barSideStyleByCodomain ? sets.barSideStyleByCodomain : sets.barFaceStyleByCodomain;
            sets.barTopStyle = sets.barTopStyle ? sets.barTopStyle : sets.barFaceStyle;
            sets.barTopStyleByFields = sets.barTopStyleByFields ? sets.barTopStyleByFields : sets.barFaceStyleByFields;
            sets.barTopStyleByCodomain = sets.barTopStyleByCodomain ? sets.barTopStyleByCodomain : sets.barFaceStyleByCodomain;
            // 顶面、侧面、正面图形 style
            polyFaceSP.style = ShapeFactory.ShapeStyleTool({
                    stroke: true,
                    strokeColor: "#ffffff",
                    fillColor: "#ee9900"
                },
                sets.barFaceStyle, sets.barFaceStyleByFields, sets.barFaceStyleByCodomain, i, fv[i]);
            polySideSP.style = ShapeFactory.ShapeStyleTool({
                    stroke: true,
                    strokeColor: "#ffffff",
                    fillColor: "#ee9900"
                },
                sets.barSideStyle, sets.barSideStyleByFields, sets.barSideStyleByCodomain, i, fv[i]);
            polyTopSP.style = ShapeFactory.ShapeStyleTool({
                    stroke: true,
                    strokeColor: "#ffffff",
                    fillColor: "#ee9900"
                },
                sets.barTopStyle, sets.barTopStyleByFields, sets.barTopStyleByCodomain, i, fv[i]);

            // 3d 柱条高亮样式
            sets.barSideHoverStyle = sets.barSideHoverStyle ? sets.barSideHoverStyle : sets.barFaceHoverStyle;
            sets.barTopHoverStyle = sets.barTopHoverStyle ? sets.barTopHoverStyle : sets.barFaceHoverStyle;
            polyFaceSP.highlightStyle = ShapeFactory.ShapeStyleTool({stroke: true}, sets.barFaceHoverStyle);
            polySideSP.highlightStyle = ShapeFactory.ShapeStyleTool({stroke: true}, sets.barSideHoverStyle);
            polyTopSP.highlightStyle = ShapeFactory.ShapeStyleTool({stroke: true}, sets.barTopHoverStyle);

            // 图形携带的数据 id 信息 & 高亮模式
            polyTopSP.refDataID = polySideSP.refDataID = polyFaceSP.refDataID = this.data.id;
            // hover 模式（组合）
            polyTopSP.isHoverByRefDataID = polySideSP.isHoverByRefDataID = polyFaceSP.isHoverByRefDataID = true;
            // 高亮组(当鼠标 hover 到组内任何一个图形，整个组的图形都会高亮。refDataHoverGroup 在 isHoverByRefDataID 为 true 时有效)
            polyTopSP.refDataHoverGroup = polySideSP.refDataHoverGroup = polyFaceSP.refDataHoverGroup = Util_Util.createUniqueID("lr_shg");
            // 图形携带的数据信息
            polyTopSP.dataInfo = polySideSP.dataInfo = polyFaceSP.dataInfo = {
                field: this.fields[i],
                value: fv[i]
            };

            // 3d 柱条顶面、侧面、正面图形 hover click 设置
            if (typeof(sets.barHoverAble) !== "undefined") {
                polyTopSP.hoverable = polySideSP.hoverable = polyFaceSP.hoverable = sets.barHoverAble;
            }
            if (typeof(sets.barClickAble) !== "undefined") {
                polyTopSP.clickable = polySideSP.clickable = polyFaceSP.clickable = sets.barClickAble;
            }

            // 创建3d 柱条的顶面、侧面、正面图形并添加到图表的图形列表数组
            this.shapes.push(this.shapeFactory.createShape(polySideSP));
            this.shapes.push(this.shapeFactory.createShape(polyTopSP));
            this.shapes.push(this.shapeFactory.createShape(polyFaceSP));
        }

        // 重要步骤：将图形转为由相对坐标表示的图形，以便在地图平移缩放过程中快速重绘图形
        // （统计专题图模块从结构上要求使用相对坐标，assembleShapes() 函数必须在图形装配完成后调用 shapesConvertToRelativeCoordinate() 函数）
        this.shapesConvertToRelativeCoordinate();
    }

    /**
     * @function FeatureThemeBar3D.prototype.calculateXShapeInfo
     * @description 计算 X 轴方向上的图形信息，此信息是一个对象，包含两个属性，
     *              属性 xPositions 是一个一维数组，该数组元素表示图形在 x 轴方向上的像素坐标值，
     *              如果图形在 x 方向上有一定宽度，通常取图形在 x 方向上的中心点为图形在 x 方向上的坐标值。
     *              width 表示图形的宽度（特别注意：点的宽度始终为 0，而不是其直径）。
     *              本函数中图形配置对象 setting 可设属性:
     *              xShapeBlank - {Array.<number>} 水平方向上的图形空白间隔参数。
     *              长度为 3 的数组，第一元素表示第一个图形左端与数据视图框左端的空白间距，第二个元素表示图形间空白间距，
     *              第三个元素表示最后一个图形右端与数据视图框右端端的空白间距 。
     * @returns {Object} 如果计算失败，返回 null；如果计算成功，返回 X 轴方向上的图形信息，此信息是一个对象，包含以下两个属性:
     *                  xPositions - {Array.<number>} 表示图形在 x 轴方向上的像素坐标值，如果图形在 x 方向上有一定宽度，通常取图形在 x 方向上的中心点为图形在 x 方向上的坐标值。
     *                  width - {number} 表示图形的宽度（特别注意：点的宽度始终为 0，而不是其直径）。
     */
    calculateXShapeInfo() {
        var dvb = this.dataViewBox;     // 数据视图框
        var sets = this.setting;     // 图表配置对象
        var fvc = this.dataValues.length;      // 数组值个数

        if (fvc < 1) {
            return null;
        }

        var xBlank;        // x 轴空白间隔参数
        var xShapePositions = [];         // x 轴上图形的位置
        var xShapeWidth = 0;          // x 轴上图形宽度(自适应)
        var dvbWidth = this.DVBWidth;            // 数据视图框宽度

        //  x 轴空白间隔参数处理
        if (sets.xShapeBlank && sets.xShapeBlank.length && sets.xShapeBlank.length == 3) {
            xBlank = sets.xShapeBlank;
            var xsLen = dvbWidth - (xBlank[0] + xBlank[2] + (fvc - 1) * xBlank[1])
            if (xsLen <= fvc) {
                return null;
            }
            xShapeWidth = xsLen / fvc
        } else {
            // 默认使用等距离空白间隔，空白间隔为图形宽度
            xShapeWidth = dvbWidth / (2 * fvc + 1);
            xBlank = [xShapeWidth, xShapeWidth, xShapeWidth];
        }

        // 图形 x 轴上的位置计算
        var xOffset = 0
        for (var i = 0; i < fvc; i++) {
            if (i == 0) {
                xOffset = xBlank[0] + xShapeWidth / 2;
            } else {
                xOffset += (xShapeWidth + xBlank[1]);
            }

            xShapePositions.push(dvb[0] + xOffset);
        }

        return {
            "xPositions": xShapePositions,
            "width": xShapeWidth
        };
    }
}

;// CONCATENATED MODULE: ./src/common/overlay/RankSymbol.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


/**
 * @class FeatureThemeRankSymbol
 * @aliasclass Feature.Theme.RankSymbol
 * @deprecatedclass SuperMap.Feature.Theme.RankSymbol
 * @category Visualization Theme
 * @classdesc 符号专题要素基类。此类定义了符号专题要素基础模型，具体的图表模型通过继承此类，在子类中实现 assembleShapes 方法。
 * 符号专题要素模型采用了可视化图形大小自适应策略，用较少的参数控制着图表诸多图形，图表配置对象 <FeatureThemeRankSymbol.setting> 的基础属性只有 5 个，
 * 它们控制着图表结构、值域范围、数据小数位等基础图表形态。构成图表的图形必须在图表结构里自适应大小。
 * 此类不可实例化，此类的可实例化子类必须实现 assembleShapes() 方法。
 * @param {FeatureVector} data - 用户数据。
 * @param {SuperMap.Layer.RankSymbol} layer - 此专题要素所在图层。
 * @param {Array.<string>} fields - data 中的参与此图表生成的字段名称。
 * @param {LonLat} [lonlat] - 专题要素地理位置。默认为 data 指代的地理要素 Bounds 中心。
 * @param {Object} setting - 图表配置对象。除了以下 5 个基础属性，此对象的可设属性在不同子类中有较大差异，不同子类中对同一属性的解释也可能不同，请在此类的子类中查看 setting 对象的可设属性和属性含义。
 * @param {Array.<number>} setting.codomain - 值域，长度为 2 的一维数组，第一个元素表示值域下限，第二个元素表示值域上限。
 * @param {number} [setting.XOffset] - 专题要素（图表）在 X 方向上的偏移值，单位像素。
 * @param {number} [setting.YOffset] - 专题要素（图表）在 Y 方向上的偏移值，单位像素。
 * @param {Array.<number>} [setting.dataViewBoxParameter] - 数据视图框 dataViewBox 参数，它是指图表框 chartBox （由图表位置、图表宽度、图表高度构成的图表范围框）在左、下，右，上四个方向上的内偏距值。
 * @param {number} [setting.decimalNumber] - 数据值数组 dataValues 元素值小数位数，数据的小数位处理参数，取值范围：[0, 16]。如果不设置此参数，在取数据值时不对数据做小数位处理。
 * @extends FeatureThemeGraph
 * @usage
 */
class RankSymbol_RankSymbol extends Graph_Graph {

    constructor(data, layer, fields, setting, lonlat, options) {
        super(data, layer, fields, setting, lonlat, options);
        /**
         * @member {Object} FeatureThemeRankSymbol.prototype.setting
         * @description 符号配置对象，该对象控制着图表的可视化显示。
         */
        this.setting = null;
        // 配置项检测与赋值
        if (setting && setting.codomain) {
            this.setting = setting;
            this.DVBCodomain = this.setting.codomain;
        }
        this.CLASS_NAME = "SuperMap.Feature.Theme.RankSymbol";
    }

    /**
     * @function FeatureThemeRankSymbol.prototype.destroy
     * @description 销毁专题要素。
     */
    destroy() {
        this.setting = null;
        super.destroy();
    }


    /**
     * @function FeatureThemeRankSymbol.prototype.initBaseParameter
     * @description 初始化专题要素（图形）基础参数。
     * 在调用此方法前，此类的图表模型相关属性都是不可用的 ，此方法在 assembleShapes 函数中调用。
     * 调用此函数关系到 setting 对象的以下属性。
     * @param {Array.<number>} codomain - 值域，长度为 2 的一维数组，第一个元素表示值域下限，第二个元素表示值域上限。
     * @param {number} [XOffset] - 专题要素（图形）在 X 方向上的偏移值，单位像素。
     * @param {number} [YOffset] - 专题要素（图形）在 Y 方向上的偏移值，单位像素。
     * @param {Array.<number>} [dataViewBoxParameter] - 数据视图框 dataViewBox 参数，它是指图形框 chartBox （由图表位置、图表宽度、图表高度构成的图表范围框）在左、下，右，上四个方向上的内偏距值。
     * @param {number} [decimalNumber] - 数据值数组 dataValues 元素值小数位数，数据的小数位处理参数，取值范围：[0, 16]。如果不设置此参数，在取数据值时不对数据做小数位处理。
     * @returns {boolean} 初始化参数是否成功。
     */
    initBaseParameter() {
        // 参数初始化是否成功
        var isSuccess = true;

        // setting 属性是否已成功赋值
        if (!this.setting) {
            return false;
        }
        var sets = this.setting;

        // 图表偏移
        if (sets.XOffset) {
            this.XOffset = sets.XOffset;
        }
        if (sets.YOffset) {
            this.YOffset = sets.YOffset;
        }
        this.XOffset = sets.XOffset ? sets.XOffset : 0;
        this.YOffset = sets.YOffset ? sets.YOffset : 0;

        // 其他默认值
        this.origonPoint = [];
        this.chartBox = [];
        this.dataViewBox = [];

        this.DVBParameter = sets.dataViewBoxParameter ? sets.dataViewBoxParameter : [0, 0, 0, 0];

        this.DVBOrigonPoint = [];
        this.DVBCenterPoint = [];
        this.origonPointOffset = [];

        // 图表位置
        this.resetLocation();

        // 专题要素宽度 w
        var w = this.width;
        // 专题要素高度 h
        var h = this.height;
        // 专题要素像素位置 loc
        var loc = this.location;

        // 专题要素像素位置 loc
        this.origonPoint = [loc[0] - w / 2, loc[1] - h / 2];
        // 专题要素原点（左上角）
        var op = this.origonPoint;

        // 图表框（[left, bottom, right, top]）
        this.chartBox = [op[0], op[1] + h, op[0] + w, op[1]];
        // 图表框
        var cb = this.chartBox;

        // 数据视图框参数，它是图表框各方向对应的内偏距
        var dbbP = this.DVBParameter;
        // 数据视图框 （[left, bottom, right, top]）
        this.dataViewBox = [cb[0] + dbbP[0], cb[1] - dbbP[1], cb[2] - dbbP[2], cb[3] + dbbP[3]];
        // 数据视图框
        var dvb = this.dataViewBox;
        //检查数据视图框是否合法
        if (dvb[0] >= dvb[2] || dvb[1] <= dvb[3]) {
            return false;
        }

        // 数据视图框原点
        this.DVBOrigonPoint = [dvb[0], dvb[3]];
        // 数据视图框宽度
        this.DVBWidth = Math.abs(dvb[2] - dvb[0]);
        // 数据视图框高度
        this.DVBHeight = Math.abs(dvb[1] - dvb[3]);
        // 数据视图框中心点
        this.DVBCenterPoint = [this.DVBOrigonPoint[0] + this.DVBWidth / 2, this.DVBOrigonPoint[1] + this.DVBHeight / 2];

        // 数据视图框原点与图表框的原点偏移量
        this.origonPointOffset = [this.DVBOrigonPoint[0] - op[0], this.DVBOrigonPoint[1] - op[1]];

        return isSuccess;
    }
}

;// CONCATENATED MODULE: ./src/common/overlay/Circle.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/





/**
 * @class FeatureThemeCircle
 * @aliasclass Feature.Theme.Circle
 * @deprecatedclass SuperMap.Feature.Theme.Circle
 * @classdesc 圆类。
 * @category Visualization Theme
 * @extends FeatureThemeRankSymbol
 * @param {FeatureVector} data - 用户数据。
 * @param {SuperMap.Layer.RankSymbol} layer - 此专题要素所在图层。
 * @param {Array.<string>} fields - data 中的参与此图表生成的字段名称。
 * @param {FeatureThemeCircle.setting} setting - 图表配置对象。
 * @param {LonLat} [lonlat] - 专题要素地理位置，默认为 data 指代的地理要素 Bounds 中心。
 * @usage
 * @private
 */
class Circle extends RankSymbol_RankSymbol {

    constructor(data, layer, fields, setting, lonlat) {
        super(data, layer, fields, setting, lonlat);
        this.CLASS_NAME = "SuperMap.Feature.Theme.Circle";
    }

    /**
     * @function FeatureThemeCircle.prototype.destroy
     * @override
     */
    destroy() {
        super.destroy();
    }

    /**
     * @function FeatureThemeCircle.prototype.assembleShapes
     * @description 装配图形（扩展接口）。
     */
    assembleShapes() {
        //默认填充颜色
        var defaultFillColor = "#ff9277";

        // setting 属性是否已成功赋值
        if (!this.setting) {
            return false;
        }
        var sets = this.setting;
        // 检测 setting 的必设参数
        if (!(sets.codomain)) {
            return false;
        }

        // 数据
        var decimalNumber = (typeof(sets.decimalNumber) !== "undefined" && !isNaN(sets.decimalNumber)) ? sets.decimalNumber : -1;
        var dataEffective = Theme.getDataValues(this.data, this.fields, decimalNumber);
        this.dataValues = dataEffective ? dataEffective : [];

        // 数据值数组
        var fv = this.dataValues;
        //if(fv.length != 1) return;       // 没有数据 或者数据不唯一
        //if(fv[0] < 0) return;            //数据为负值

        //用户应该定义最大 最小半径  默认最大半径MaxR:100 最小半径MinR:0;
        if (!sets.maxR) {
            sets.maxR = 100;
        }
        if (!sets.minR) {
            sets.minR = 0;
        }

        // 值域范围
        var codomain = this.DVBCodomain;

        // 重要步骤：定义Circle数据视图框中单位值的含义，单位值：1所代表的长度
        // 用户定义了值域范围
        if (codomain && codomain[1] - codomain[0] > 0) {
            this.DVBUnitValue = sets.maxR / (codomain[1] - codomain[0]);
        } else {
            //this.DVBUnitValue = sets.maxR / maxValue;
            this.DVBUnitValue = sets.maxR;
        }

        var uv = this.DVBUnitValue;
        //圆半径
        var r = fv[0] * uv + sets.minR;
        this.width = 2 * r;
        this.height = 2 * r;

        // 重要步骤：初始化参数
        if (!this.initBaseParameter()) {
            return;
        }

        //假如用户设置了值域范围 没有在值域范围直接返回
        if (codomain) {
            if (fv[0] < codomain[0] || fv[0] > codomain[1]) {
                return;
            }
        }

        var dvbCenter = this.DVBCenterPoint;        // 数据视图框中心作为圆心

        //圆形对象参数
        var circleSP = new Circle_Circle(dvbCenter[0], dvbCenter[1], r);

        //circleSP.sytle 初始化
        circleSP.style = ShapeFactory.ShapeStyleTool(null, sets.circleStyle, null, null, 0);
        //图形的填充颜色
        if (typeof (sets.fillColor) !== "undefined") {
            //用户自定义
            circleSP.style.fillColor = sets.fillColor;
        } else {
            //当前默认
            circleSP.style.fillColor = defaultFillColor;
        }
        //圆形 Hover样式
        circleSP.highlightStyle = ShapeFactory.ShapeStyleTool(null, sets.circleHoverStyle);
        //圆形 Hover 与 click 设置
        if (typeof(sets.circleHoverAble) !== "undefined") {
            circleSP.hoverable = sets.circleHoverAble;
        }
        if (typeof(sets.circleClickAble) !== "undefined") {
            circleSP.clickable = sets.circleClickAble;
        }

        //图形携带的数据信息
        circleSP.refDataID = this.data.id;
        circleSP.dataInfo = {
            field: this.fields[0],
            r: r,
            value: fv[0]
        };

        // 创建扇形并把此扇形添加到图表图形数组
        this.shapes.push(this.shapeFactory.createShape(circleSP));

        // 重要步骤：将图形转为由相对坐标表示的图形，以便在地图平移缩放过程中快速重绘图形
        // （统计专题图模块从结构上要求使用相对坐标，assembleShapes() 函数必须在图形装配完成后调用 shapesConvertToRelativeCoordinate() 函数）
        this.shapesConvertToRelativeCoordinate();
    }

}

;// CONCATENATED MODULE: ./src/common/overlay/Line.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/





/**
 * @class FeatureThemeLine
 * @aliasclass Feature.Theme.Line
 * @deprecatedclass SuperMap.Feature.Theme.Line
 * @classdesc 折线图。
 * @category Visualization Theme
 * @example
 * // pointStyleByCodomain 参数用法示例
 * // pointStyleByCodomain 的每个元素是个包含值域信息和与值域对应样式信息的对象，该对象（必须）有三个属性：
 * // start: 值域值下限（包含）;
 * // end: 值域值上限（不包含）;
 * // style: 数据可视化图形的 style，这个样式对象的可设属性： <Point.style> 。
 * // pointStyleByCodomain 数组形如：
 * [
 *   {
 *     start:0,
 *     end:250,
 *     style:{
 *          fillColor:"#00CD00"
 *      }
 *  },
 *   {
 *     start:250,
 *     end:500,
 *     style:{
 *          fillColor:"#00EE00"
 *      }
 *  },
 *   {
 *     start:500,
 *     end:750,
 *     style:{
 *          fillColor:"#00FF7F"
 *      }
 *  },
 *   {
 *     start:750,
 *     end:1500,
 *     style:{
 *          fillColor:"#00FF00"
 *      }
 *  }
 * ]
 *
 * @extends FeatureThemeGraph
 * @param {FeatureVector} data - 用户数据。
 * @param {SuperMap.Layer.Graph} layer - 此专题要素所在图层。
 * @param {Array.<string>} fields - data 中的参与此图表生成的字段名称。
 * @param {FeatureThemeLine.setting} setting - 图表配置对象。
 * @param {LonLat} [lonlat] - 专题要素地理位置。默认为 data 指代的地理要素 Bounds 中心。
 * @usage
 * @private
 */
class Line extends Graph_Graph {

    constructor(data, layer, fields, setting, lonlat, options) {
        super(data, layer, fields, setting, lonlat, options);
        this.CLASS_NAME = "SuperMap.Feature.Theme.Line";
    }

    /**
     * @function FeatureThemeLine.prototype.destroy
     * @override
     */
    destroy() {
        super.destroy();
    }

    /**
     * @function FeatureThemeLine.prototype.assembleShapes
     * @description 装配图形（扩展接口）。
     */
    assembleShapes() {
        // 图表配置对象
        var sets = this.setting;

        // 默认数据视图框
        if (!sets.dataViewBoxParameter) {
            if (typeof(sets.useAxis) === "undefined" || sets.useAxis) {
                sets.dataViewBoxParameter = [45, 15, 15, 15];
            } else {
                sets.dataViewBoxParameter = [5, 5, 5, 5];
            }
        }

        // 重要步骤：初始化参数
        if (!this.initBaseParameter()) {
            return;
        }

        var dvb = this.dataViewBox;

        // 值域
        var codomain = this.DVBCodomain;
        // 重要步骤：定义图表 FeatureThemeBar 数据视图框中单位值的含义
        this.DVBUnitValue = (codomain[1] - codomain[0]) / this.DVBHeight;
        var uv = this.DVBUnitValue;
        // 数据值数组
        var fv = this.dataValues;
        if (fv.length < 1) {
            return;
        }       // 没有数据

        // 获取 x 轴上的图形信息
        var xShapeInfo = this.calculateXShapeInfo();
        if (!xShapeInfo) {
            return;
        }
        // 折线每个节点的 x 位置
        var xsLoc = xShapeInfo.xPositions;

        // 背景框，默认启用
        if (typeof(sets.useBackground) === "undefined" || sets.useBackground) {
            // 将背景框图形添加到模型的 shapes 数组，注意添加顺序，后添加的图形在先添加的图形之上。
            this.shapes.push(ShapeFactory.Background(this.shapeFactory, this.chartBox, sets));
        }

        // 折线图必须使用坐标轴
        this.shapes = this.shapes.concat(ShapeFactory.GraphAxis(this.shapeFactory, dvb, sets, xShapeInfo));

        // var isDataEffective = true;

        var xPx;        // 折线节点 x 坐标
        var yPx;        // 折线节点 y 坐标
        var poiLists = [];        // 折线节点数组

        var shapePois = [];     // 折线节点图形数组
        for (var i = 0, len = fv.length; i < len; i++) {
            // 数据溢出值域检查
            if (fv[i] < codomain[0] || fv[i] > codomain[1]) {
                // isDataEffective = false;
                return null;
            }

            xPx = xsLoc[i];
            yPx = dvb[1] - (fv[i] - codomain[0]) / uv;

            // 折线节点参数对象
            var poiSP = new Point_Point(xPx, yPx);
            // 折线节点 style
            poiSP.style = ShapeFactory.ShapeStyleTool({fillColor: "#ee9900"}, sets.pointStyle, sets.pointStyleByFields, sets.pointStyleByCodomain, i, fv[i]);
            // 折线节点 hover 样式
            poiSP.highlightStyle = ShapeFactory.ShapeStyleTool(null, sets.pointHoverStyle);

            // 折线节点 hover click
            if (typeof(sets.pointHoverAble) !== "undefined") {
                poiSP.hoverable = sets.pointHoverAble;
            }
            if (typeof(sets.pointClickAble) !== "undefined") {
                poiSP.clickable = sets.pointClickAble;
            }

            // 图形携带的数据信息
            poiSP.refDataID = this.data.id;
            poiSP.dataInfo = {
                field: this.fields[i],
                value: fv[i]
            };

            // 创建图形并把此图形添加到折线节点图形数组
            shapePois.push(this.shapeFactory.createShape(poiSP));

            // 添加折线节点到折线节点数组
            var poi = [xPx, yPx];
            poiLists.push(poi);
        }

        // 折线参数对象
        var lineSP = new Line_Line(poiLists);
        lineSP.style = ShapeFactory.ShapeStyleTool({strokeColor: "#ee9900"}, sets.lineStyle);
        // 禁止事件响应
        lineSP.clickable = false;
        lineSP.hoverable = false;
        var shapeLine = this.shapeFactory.createShape(lineSP);
        this.shapes.push(shapeLine);

        // 添加节点到图表图形数组
        this.shapes = this.shapes.concat(shapePois);

        // // 数据范围检测未通过，清空图形
        // if (isDataEffective === false) {
        //     this.shapes = [];
        // }

        // 重要步骤：将图形转为由相对坐标表示的图形，以便在地图平移缩放过程中快速重绘图形
        // （统计专题图模块从结构上要求使用相对坐标，assembleShapes() 函数必须在图形装配完成后调用 shapesConvertToRelativeCoordinate() 函数）
        this.shapesConvertToRelativeCoordinate();
    }

    /**
     * @function FeatureThemeLine.prototype.calculateXShapeInfo
     * @description 计算 X 轴方向上的图形信息，此信息是一个对象，包含两个属性，
     *              属性 xPositions 是一个一维数组，该数组元素表示图形在 x 轴方向上的像素坐标值，
     *              如果图形在 x 方向上有一定宽度，通常取图形在 x 方向上的中心点为图形在 x 方向上的坐标值。
     *              width 表示图形的宽度（特别注意：点的宽度始终为 0，而不是其直径）。
     *              本函数中图形配置对象 setting 可设属性：<br>
     *              xShapeBlank - {Array.<number>} 水平方向上的图形空白间隔参数。
     *              长度为 2 的数组，第一元素表示第折线左端点与数据视图框左端的空白间距，第二个元素表示折线右端点右端与数据视图框右端端的空白间距 。
     * @returns {Object} 如果计算失败，返回 null；如果计算成功，返回 X 轴方向上的图形信息，此信息是一个对象，包含以下两个属性：<br>
     *         xPositions - {Array.<number>} 表示图形在 x 轴方向上的像素坐标值，如果图形在 x 方向上有一定宽度，通常取图形在 x 方向上的中心点为图形在 x 方向上的坐标值。<br>
     *         width - {number} 表示图形的宽度（特别注意：点的宽度始终为 0，而不是其直径）。
     */
    calculateXShapeInfo() {
        var dvb = this.dataViewBox;     // 数据视图框
        var sets = this.setting;     // 图表配置对象
        var fvc = this.dataValues.length;      // 数组值个数

        if (fvc < 1) {
            return null;
        }

        var xBlank;        // x 轴空白间隔参数
        var xShapePositions = [];         // x 轴上图形的位置
        var xShapeWidth = 0;          // x 轴上图形宽度(自适应)
        var dvbWidth = this.DVBWidth;            // 数据视图框宽度
        var unitOffset = 0;               // 单位偏移量

        //  x 轴空白间隔参数处理
        if (sets.xShapeBlank && sets.xShapeBlank.length && sets.xShapeBlank.length == 2) {
            xBlank = sets.xShapeBlank;
            var xsLen = dvbWidth - (xBlank[0] + xBlank[1]);
            if (xsLen <= fvc) {
                return null;
            }
            unitOffset = xsLen / (fvc - 1);
        } else {
            // 默认使用等距离空白间隔，空白间隔为图形宽度
            unitOffset = dvbWidth / (fvc + 1);
            xBlank = [unitOffset, unitOffset, unitOffset];
        }

        // 图形 x 轴上的位置计算
        var xOffset = 0
        for (var i = 0; i < fvc; i++) {
            if (i == 0) {
                xOffset = xBlank[0];
            } else {
                xOffset += unitOffset;
            }

            xShapePositions.push(dvb[0] + xOffset);
        }

        return {
            "xPositions": xShapePositions,
            "width": xShapeWidth
        };
    }

}

;// CONCATENATED MODULE: ./src/common/overlay/Pie.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/




/**
 * @class FeatureThemePie
 * @aliasclass Feature.Theme.Pie
 * @deprecatedclass SuperMap.Feature.Theme.Pie
 * @classdesc 饼图。
 * @category Visualization Theme
 * @param {FeatureVector} data - 用户数据。
 * @param {SuperMap.Layer.Graph} layer - 此专题要素所在图层。
 * @param {Array.<string>} fields - data 中的参与此图表生成的字段名称。
 * @param {FeatureThemePoint.setting} setting - 图表配置对象。
 * @param {LonLat} [lonlat] - 专题要素地理位置。默认为 data 指代的地理要素 Bounds 中心。
 * @extends FeatureThemeGraph
 * @example
 * // sectorStyleByCodomain 的每个元素是个包含值域信息和与值域对应样式信息的对象，该对象（必须）有三个属性：
 * // start: 值域值下限（包含）;
 * // end: 值域值上限（不包含）;
 * // style: 数据可视化图形的 style，这个样式对象的可设属性： <ShapeParametersSector.style> 。
 * // sectorStyleByCodomain 数组形如：
 * [
 *   {
 *     start:0,
 *     end:250,
 *     style:{
 *          fillColor:"#00CD00"
 *      }
 *  },
 *   {
 *     start:250,
 *     end:500,
 *     style:{
 *          fillColor:"#00EE00"
 *      }
 *  },
 *   {
 *     start:500,
 *     end:750,
 *     style:{
 *          fillColor:"#00FF7F"
 *      }
 *  },
 *   {
 *     start:750,
 *     end:1500,
 *     style:{
 *          fillColor:"#00FF00"
 *      }
 *  }
 * ]
 * @usage
 * @private
 */
class Pie extends Graph_Graph {

    constructor(data, layer, fields, setting, lonlat) {
        super(data, layer, fields, setting, lonlat);
        this.CLASS_NAME = "SuperMap.Feature.Theme.Pie";
    }

    /**
     * @function FeatureThemePie.prototype.destroy
     * @description 销毁此专题要素。调用 destroy 后此对象所以属性置为 null。
     */
    destroy() {
        super.destroy();
    }

    /**
     * @function FeatureThemePie.prototype.assembleShapes
     * @description 装配图形（扩展接口）。
     */
    assembleShapes() {
        // 图表配置对象
        var sets = this.setting;

        // 一个默认 style 组
        var defaultStyleGroup = [
            {fillColor: "#ff9277"}, {fillColor: "#dddd00"}, {fillColor: "#ffc877"}, {fillColor: "#bbe3ff"}, {fillColor: "#d5ffbb"},
            {fillColor: "#bbbbff"}, {fillColor: "#ddb000"}, {fillColor: "#b0dd00"}, {fillColor: "#e2bbff"}, {fillColor: "#ffbbe3"},
            {fillColor: "#ff7777"}, {fillColor: "#ff9900"}, {fillColor: "#83dd00"}, {fillColor: "#77e3ff"}, {fillColor: "#778fff"},
            {fillColor: "#c877ff"}, {fillColor: "#ff77ab"}, {fillColor: "#ff6600"}, {fillColor: "#aa8800"}, {fillColor: "#77c7ff"},
            {fillColor: "#ad77ff"}, {fillColor: "#ff77ff"}, {fillColor: "#dd0083"}, {fillColor: "#777700"}, {fillColor: "#00aa00"},
            {fillColor: "#0088aa"}, {fillColor: "#8400dd"}, {fillColor: "#aa0088"}, {fillColor: "#dd0000"}, {fillColor: "#772e00"}
        ];

        // 重要步骤：初始化参数
        if (!this.initBaseParameter()) {
            return;
        }

        // 背景框，默认不启用
        if (sets.useBackground) {
            this.shapes.push(ShapeFactory.Background(this.shapeFactory, this.chartBox, sets));
        }

        // 数据值数组
        var fv = this.dataValues;
        if (fv.length < 1) {
            return;
        }       // 没有数据

        // 值域范围
        var codomain = this.DVBCodomain;
        // 值域范围检测
        for (let i = 0; i < fv.length; i++) {
            if (fv[i] < codomain[0] || fv[i] > codomain[1]) {
                return;
            }
        }

        // 值的绝对值总和
        var valueSum = 0;
        for (let i = 0; i < fv.length; i++) {
            valueSum += Math.abs(fv[i]);
        }

        // 重要步骤：定义图表 FeatureThemePie 数据视图框中单位值的含义，单位值：每度代表的数值
        this.DVBUnitValue = 360 / valueSum;
        var uv = this.DVBUnitValue;

        var dvbCenter = this.DVBCenterPoint;        // 数据视图框中心作为扇心

        var startAngle = 0;         // 扇形起始边角度
        var endAngle = 0;          // 扇形终止边角度
        var startAngleTmp = startAngle;           // 扇形临时起始边角度
        // 扇形（自适应）半径
        var r = this.DVBHeight < this.DVBWidth ? this.DVBHeight / 2 : this.DVBWidth / 2;

        for (var i = 0; i < fv.length; i++) {
            var fvi = Math.abs(fv[i]);
            //计算终止角
            if (i === 0) {
                endAngle = startAngle + fvi * uv;
            } else if (i === fvi.length - 1) {
                endAngle = startAngleTmp;
            } else {
                endAngle = startAngle + fvi * uv;
            }
            //矫正误差计算
            if ((endAngle - startAngle) >= 360) {
                endAngle = 359.9999999;
            }

            // 扇形参数对象
            var sectorSP = new Sector(dvbCenter[0], dvbCenter[1], r, startAngle, endAngle);
            // 扇形样式
            if (typeof(sets.sectorStyleByFields) === "undefined") {
                // 使用默认 style 组
                var colorIndex = i % defaultStyleGroup.length;
                sectorSP.style = ShapeFactory.ShapeStyleTool(null, sets.sectorStyle, defaultStyleGroup, null, colorIndex);
            } else {
                sectorSP.style = ShapeFactory.ShapeStyleTool(null, sets.sectorStyle, sets.sectorStyleByFields, sets.sectorStyleByCodomain, i, fv[i]);
            }

            // 扇形 hover 样式
            sectorSP.highlightStyle = ShapeFactory.ShapeStyleTool(null, sets.sectorHoverStyle);
            // 扇形 hover 与 click 设置
            if (typeof(sets.sectorHoverAble) !== "undefined") {
                sectorSP.hoverable = sets.sectorHoverAble;
            }
            if (typeof(sets.sectorClickAble) !== "undefined") {
                sectorSP.clickable = sets.sectorClickAble;
            }
            // 图形携带的数据信息
            sectorSP.refDataID = this.data.id;
            sectorSP.dataInfo = {
                field: this.fields[i],
                value: fv[i]
            };

            // 创建扇形并把此扇形添加到图表图形数组
            this.shapes.push(this.shapeFactory.createShape(sectorSP));

            // 把上一次的结束角度作为下一次的起始角度
            startAngle = endAngle;
        }

        // 重要步骤：将图形转为由相对坐标表示的图形，以便在地图平移缩放过程中快速重绘图形
        // （统计专题图模块从结构上要求使用相对坐标，assembleShapes() 函数必须在图形装配完成后调用 shapesConvertToRelativeCoordinate() 函数）
        this.shapesConvertToRelativeCoordinate();
    }

}

;// CONCATENATED MODULE: ./src/common/overlay/Point.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/




/**
 * @class FeatureThemePoint
 * @aliasclass Feature.Theme.Point
 * @deprecatedclass SuperMap.Feature.Theme.Point
 * @classdesc 点状图。
 * @category Visualization Theme
 * @param {FeatureVector} data - 用户数据。
 * @param {SuperMap.Layer.Graph} layer - 此专题要素所在图层。
 * @param {Array.<string>} fields - data 中的参与此图表生成的字段名称。
 * @param {FeatureThemePoint.setting} setting - 图表配置对象。
 * @param {LonLat} [lonlat] - 专题要素地理位置。默认为 data 指代的地理要素 Bounds 中心。
 * @example
 * // pointStyleByCodomain 的每个元素是个包含值域信息和与值域对应样式信息的对象，该对象（必须）有三个属性：
 * // start: 值域值下限（包含）;
 * // end: 值域值上限（不包含）;
 * // style: 数据可视化图形的 style，这个样式对象的可设属性： <Point.style> 。
 * // pointStyleByCodomain 数组形如：
 * [
 *   {
 *     start:0,
 *     end:250,
 *     style:{
 *          fillColor:"#00CD00"
 *      }
 *  },
 *   {
 *     start:250,
 *     end:500,
 *     style:{
 *          fillColor:"#00EE00"
 *      }
 *  },
 *   {
 *     start:500,
 *     end:750,
 *     style:{
 *          fillColor:"#00FF7F"
 *      }
 *  },
 *   {
 *     start:750,
 *     end:1500,
 *     style:{
 *          fillColor:"#00FF00"
 *      }
 *  }
 * ]
 * @extends FeatureThemeGraph
 * @usage
 * @private
 */
class overlay_Point_Point extends Graph_Graph {

    constructor(data, layer, fields, setting, lonlat, options) {
        super(data, layer, fields, setting, lonlat, options);
        this.CLASS_NAME = "SuperMap.Feature.Theme.Point";
    }

    /**
     * @function FeatureThemePoint.prototype.destroy
     * @description 销毁此专题要素。调用 destroy 后此对象所以属性置为 null。
     */
    destroy() {
        super.destroy();
    }

    /**
     * @function FeatureThemePoint.prototype.Point.assembleShapes
     * @description 装配图形（扩展接口）。
     */
    assembleShapes() {
        // 图表配置对象
        var sets = this.setting;

        // 默认数据视图框
        if (!sets.dataViewBoxParameter) {
            if (typeof(sets.useAxis) === "undefined" || sets.useAxis) {
                sets.dataViewBoxParameter = [45, 15, 15, 15];
            } else {
                sets.dataViewBoxParameter = [5, 5, 5, 5];
            }
        }

        // 重要步骤：初始化参数
        if (!this.initBaseParameter()) {
            return;
        }

        var dvb = this.dataViewBox;

        // 值域
        var codomain = this.DVBCodomain;
        // 重要步骤：定义图表 FeatureThemeBar 数据视图框中单位值的含义
        this.DVBUnitValue = (codomain[1] - codomain[0]) / this.DVBHeight;
        var uv = this.DVBUnitValue;
        var fv = this.dataValues;

        // 获取 x 轴上的图形信息
        var xShapeInfo = this.calculateXShapeInfo();
        if (!xShapeInfo) {
            return;
        }
        // 折线每个节点的 x 位置
        var xsLoc = xShapeInfo.xPositions;

        // 背景框，默认启用
        if (typeof(sets.useBackground) === "undefined" || sets.useBackground) {
            // 将背景框图形添加到模型的 shapes 数组，注意添加顺序，后添加的图形在先添加的图形之上。
            this.shapes.push(ShapeFactory.Background(this.shapeFactory, this.chartBox, sets));
        }

        // 点状图必须使用坐标轴
        this.shapes = this.shapes.concat(ShapeFactory.GraphAxis(this.shapeFactory, dvb, sets, xShapeInfo));

        var xPx;        // 图形点 x 坐标
        var yPx;        // 图形点 y 坐标
        for (var i = 0, len = fv.length; i < len; i++) {
            // 数据溢出值域检查
            if (fv[i] < codomain[0] || fv[i] > codomain[1]) {
                //isDataEffective = false;
                return null;
            }

            xPx = xsLoc[i];
            yPx = dvb[1] - (fv[i] - codomain[0]) / uv;

            // 图形点参数对象
            var poiSP = new Point_Point(xPx, yPx);
            // 图形点 style
            poiSP.style = ShapeFactory.ShapeStyleTool({fillColor: "#ee9900"}, sets.pointStyle, sets.pointStyleByFields, sets.pointStyleByCodomain, i, fv[i]);
            // 图形点 hover 样式
            poiSP.highlightStyle = ShapeFactory.ShapeStyleTool(null, sets.pointHoverStyle);

            // 图形点 hover click
            if (typeof(sets.pointHoverAble) !== "undefined") {
                poiSP.hoverable = sets.pointHoverAble;
            }
            if (typeof(sets.pointClickAble) !== "undefined") {
                poiSP.clickable = sets.pointClickAble;
            }

            // 图形携带的数据信息
            poiSP.refDataID = this.data.id;
            poiSP.dataInfo = {
                field: this.fields[i],
                value: fv[i]
            };

            // 创建图形点并把此图形添加到图表图形数组
            this.shapes.push(this.shapeFactory.createShape(poiSP));
        }

        // 数据范围检测未通过，清空图形
        // if (isDataEffective === false) {
        //     this.shapes = [];
        // }

        // 重要步骤：将图形转为由相对坐标表示的图形，以便在地图平移缩放过程中快速重绘图形
        // （统计专题图模块从结构上要求使用相对坐标，assembleShapes() 函数必须在图形装配完成后调用 shapesConvertToRelativeCoordinate() 函数）
        this.shapesConvertToRelativeCoordinate();
    }

    /**
     * @function FeatureThemePoint.prototype.calculateXShapeInfo
     * @description 计算 X 轴方向上的图形信息，此信息是一个对象，包含两个属性，
     *              属性 xPositions 是一个一维数组，该数组元素表示图形在 x 轴方向上的像素坐标值，
     *              如果图形在 x 方向上有一定宽度，通常取图形在 x 方向上的中心点为图形在 x 方向上的坐标值。
     *              width 表示图形的宽度（特别注意：点的宽度始终为 0，而不是其直径）。
     *              本函数中图形配置对象 setting 可设属性：<br>
     *              xShapeBlank - {Array.<number>} 水平方向上的图形空白间隔参数。
     *              长度为 2 的数组，第一元素表示第折线左端点与数据视图框左端的空白间距，第二个元素表示折线右端点右端与数据视图框右端端的空白间距 。
     * @returns {Object} 如果计算失败，返回 null；如果计算成功，返回 X 轴方向上的图形信息，此信息是一个对象，包含以下两个属性：<br>
     *         xPositions - {Array.<number>} 表示图形在 x 轴方向上的像素坐标值，如果图形在 x 方向上有一定宽度，通常取图形在 x 方向上的中心点为图形在 x 方向上的坐标值。
     *         width - {number}表示图形的宽度（特别注意：点的宽度始终为 0，而不是其直径）。
     */
    calculateXShapeInfo() {
        var dvb = this.dataViewBox;     // 数据视图框
        var sets = this.setting;     // 图表配置对象
        var fvc = this.dataValues.length;      // 数组值个数

        if (fvc < 1) {
            return null;
        }

        var xBlank;        // x 轴空白间隔参数
        var xShapePositions = [];         // x 轴上图形的位置
        var xShapeWidth = 0;          // x 轴上图形宽度(自适应)
        var dvbWidth = this.DVBWidth;            // 数据视图框宽度
        var unitOffset = 0;               // 单位偏移量

        //  x 轴空白间隔参数处理
        if (sets.xShapeBlank && sets.xShapeBlank.length && sets.xShapeBlank.length == 2) {
            xBlank = sets.xShapeBlank;
            var xsLen = dvbWidth - (xBlank[0] + xBlank[1]);
            if (xsLen <= fvc) {
                return null;
            }
            unitOffset = xsLen / (fvc - 1);
        } else {
            // 默认使用等距离空白间隔，空白间隔为图形宽度
            unitOffset = dvbWidth / (fvc + 1);
            xBlank = [unitOffset, unitOffset, unitOffset];
        }

        // 图形 x 轴上的位置计算
        var xOffset = 0
        for (var i = 0; i < fvc; i++) {
            if (i == 0) {
                xOffset = xBlank[0];
            } else {
                xOffset += unitOffset;
            }

            xShapePositions.push(dvb[0] + xOffset);
        }

        return {
            "xPositions": xShapePositions,
            "width": xShapeWidth
        };
    }

}

;// CONCATENATED MODULE: ./src/common/overlay/Ring.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/




/**
 * @class FeatureThemeRing
 * @aliasclass Feature.Theme.Ring
 * @deprecatedclass SuperMap.Feature.Theme.Ring
 * @classdesc 环状图。
 * @category Visualization Theme
 * @description 基于路由对象计算指定点 M 值操作的参数类。通过该类提供参数信息。

 * @param {FeatureVector} data - 用户数据。
 * @param {SuperMap.Layer.Graph} layer - 此专题要素所在图层。
 * @param {Array.<string>} fields - data 中的参与此图表生成的字段名称。
 * @param {FeatureThemeRing.setting} setting - 图表配置对象。
 * @param {LonLat} [lonlat] - 专题要素地理位置。默认为 data 指代的地理要素 Bounds 中心。
 * @example
 * // sectorStyleByCodomain 的每个元素是个包含值域信息和与值域对应样式信息的对象，该对象（必须）有三个属性：
 * // start: 值域值下限（包含）;
 * // end: 值域值上限（不包含）;
 * // style: 数据可视化图形的 style，这个样式对象的可设属性： <ShapeParametersSector.style> 。
 * // sectorStyleByCodomain 数组形如：
 * [
 *   {
 *     start:0,
 *     end:250,
 *     style:{
 *          fillColor:"#00CD00"
 *      }
 *  },
 *   {
 *     start:250,
 *     end:500,
 *     style:{
 *          fillColor:"#00EE00"
 *      }
 *  },
 *   {
 *     start:500,
 *     end:750,
 *     style:{
 *          fillColor:"#00FF7F"
 *      }
 *  },
 *   {
 *     start:750,
 *     end:1500,
 *     style:{
 *          fillColor:"#00FF00"
 *      }
 *  }
 * ]
 * @param {Object} [sectorHoverStyle=true] - 环状图扇形 hover 状态时的样式，sectorHoverAble 为 true 时有效。
 * @param {boolean} [sectorHoverAble=true] - 是否允许环状图扇形使用 hover 状态。同时设置 sectorHoverAble 和 sectorClickAble 为 false，可以直接屏蔽环状图扇形对专题图层事件的响应。
 * @param {boolean} [sectorClickAble=true] - 是否允许环状图扇形被点击。同时设置 sectorHoverAble 和 sectorClickAble 为 false，可以直接屏蔽环状图扇形对专题图层事件的响应。
 *
 * @extends FeatureThemeGraph
 * @usage
 * @private
 */
class Ring extends Graph_Graph {

    constructor(data, layer, fields, setting, lonlat) {
        super(data, layer, fields, setting, lonlat);
        this.CLASS_NAME = "SuperMap.Feature.Theme.Ring";
    }

    /**
     * @function FeatureThemeRing.prototype.destroy
     * @description 销毁此专题要素。调用 destroy 后此对象所以属性置为 null。
     */
    destroy() {
        super.destroy();
    }

    /**
     * @function FeatureThemeRing.prototype.assembleShapes
     * @description 装配图形（扩展接口）。
     */
    assembleShapes() {
        // 重要步骤：初始化参数
        if (!this.initBaseParameter()) {
            return;
        }

        // 一个默认 style 组
        var defaultStyleGroup = [
            {fillColor: "#ff9277"}, {fillColor: "#dddd00"}, {fillColor: "#ffc877"}, {fillColor: "#bbe3ff"}, {fillColor: "#d5ffbb"},
            {fillColor: "#bbbbff"}, {fillColor: "#ddb000"}, {fillColor: "#b0dd00"}, {fillColor: "#e2bbff"}, {fillColor: "#ffbbe3"},
            {fillColor: "#ff7777"}, {fillColor: "#ff9900"}, {fillColor: "#83dd00"}, {fillColor: "#77e3ff"}, {fillColor: "#778fff"},
            {fillColor: "#c877ff"}, {fillColor: "#ff77ab"}, {fillColor: "#ff6600"}, {fillColor: "#aa8800"}, {fillColor: "#77c7ff"},
            {fillColor: "#ad77ff"}, {fillColor: "#ff77ff"}, {fillColor: "#dd0083"}, {fillColor: "#777700"}, {fillColor: "#00aa00"},
            {fillColor: "#0088aa"}, {fillColor: "#8400dd"}, {fillColor: "#aa0088"}, {fillColor: "#dd0000"}, {fillColor: "#772e00"}
        ];

        // 图表配置对象
        var sets = this.setting;

        // 背景框，默认不启用
        if (sets.useBackground) {
            this.shapes.push(ShapeFactory.Background(this.shapeFactory, this.chartBox, sets));
        }

        // 数据值数组
        var fv = this.dataValues;
        if (fv.length < 1) {
            return;
        }       // 没有数据

        // 值域范围
        var codomain = this.DVBCodomain;
        // 值域范围检测
        for (let i = 0; i < fv.length; i++) {
            if (fv[i] < codomain[0] || fv[i] > codomain[1]) {
                return;
            }
        }

        // 值的绝对值总和
        var valueSum = 0;
        for (let i = 0; i < fv.length; i++) {
            valueSum += Math.abs(fv[i]);
        }

        // 重要步骤：定义图表 FeatureThemeRing 数据视图框中单位值的含义，单位值：每度代表的数值
        this.DVBUnitValue = 360 / valueSum;
        var uv = this.DVBUnitValue;

        var dvbCenter = this.DVBCenterPoint;        // 数据视图框中心作为扇心

        var startAngle = 0;         // 扇形起始边角度
        var endAngle = 0;          // 扇形终止边角度
        var startAngleTmp = startAngle;           // 扇形临时起始边角度
        // 扇形外环（自适应）半径
        var r = this.DVBHeight < this.DVBWidth ? this.DVBHeight / 2 : this.DVBWidth / 2;

        // 扇形内环（自适应）半径
        var isInRange = sets.innerRingRadius >= 0 && sets.innerRingRadius < r;
        var r0 = (
            typeof(sets.innerRingRadius) !== "undefined"
            && !isNaN(sets.innerRingRadius)
            && isInRange
        ) ? sets.innerRingRadius : 0;

        for (var i = 0; i < fv.length; i++) {
            var fvi = Math.abs(fv[i]);

            // 计算结束角度
            if (i === 0) {
                endAngle = startAngle + fvi * uv;
            } else if (i === fvi.length - 1) {
                endAngle = startAngleTmp;
            } else {
                endAngle = startAngle + fvi * uv;
            }

            // 扇形参数对象
            var sectorSP = new Sector(dvbCenter[0], dvbCenter[1], r, startAngle, endAngle, r0);
            // 扇形样式
            if (typeof(sets.sectorStyleByFields) === "undefined") {
                // 使用默认 style 组
                var colorIndex = i % defaultStyleGroup.length;
                sectorSP.style = ShapeFactory.ShapeStyleTool(null, sets.sectorStyle, defaultStyleGroup, null, colorIndex);
            } else {
                sectorSP.style = ShapeFactory.ShapeStyleTool(null, sets.sectorStyle, sets.sectorStyleByFields, sets.sectorStyleByCodomain, i, fv[i]);
            }
            // 扇形 hover 样式
            sectorSP.highlightStyle = ShapeFactory.ShapeStyleTool(null, sets.sectorHoverStyle);
            // 扇形 hover 与 click 设置
            if (typeof(sets.sectorHoverAble) !== "undefined") {
                sectorSP.hoverable = sets.sectorHoverAble;
            }
            if (typeof(sets.sectorClickAble) !== "undefined") {
                sectorSP.clickable = sets.sectorClickAble;
            }
            // 图形携带的数据信息
            sectorSP.refDataID = this.data.id;
            sectorSP.dataInfo = {
                field: this.fields[i],
                value: fv[i]
            };

            // 创建扇形并把此扇形添加到图表图形数组
            this.shapes.push(this.shapeFactory.createShape(sectorSP));

            // 把上一次的结束角度作为下一次的起始角度
            startAngle = endAngle;
        }

        // 重要步骤：将图形转为由相对坐标表示的图形，以便在地图平移缩放过程中快速重绘图形
        // （统计专题图模块从结构上要求使用相对坐标，assembleShapes() 函数必须在图形装配完成后调用 shapesConvertToRelativeCoordinate() 函数）
        this.shapesConvertToRelativeCoordinate();
    }

}

;// CONCATENATED MODULE: ./src/common/overlay/feature/index.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/

































;// CONCATENATED MODULE: ./src/common/overlay/levelRenderer/SmicEllipse.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


/**
 * @private
 * @class  LevelRenderer.Shape.SmicEllipse
 * @category Visualization Theme
 * @classdesc 椭圆。
 * @extends LevelRenderer.Shape
 * @example
 *   var shape = new LevelRenderer.Shape.SmicEllipse({
 *       style: {
 *           x: 100,
 *           y: 100,
 *           a: 40,
 *           b: 20,
 *           brushType: 'both',
 *           color: 'blue',
 *           strokeColor: 'red',
 *           lineWidth: 3,
 *           text: 'SmicEllipse'
 *       }
 *   });
 *   levelRenderer.addShape(shape);
 * @param {Array} options - shape 的配置（options）项，可以是 shape 的自有属性，也可以是自定义的属性。
 *
 */
class SmicEllipse extends (/* unused pure expression or super */ null && (Shape)) {
    constructor(options) {
        super(options);

        /**
         * @member {string} LevelRenderer.Shape.SmicEllipse.prototype.type
         * @description 图形类型。
         */
        this.type = 'smicellipse';

        if (!this.refOriginalPosition || this.refOriginalPosition.length !== 2) {
            this.refOriginalPosition = [0, 0];
        }

        this.CLASS_NAME = "SuperMap.LevelRenderer.Shape.SmicEllipse";
    }


    /**
     * @function LevelRenderer.Shape.SmicEllipse.prototype.destroy
     * @description 销毁对象，释放资源。调用此函数后所有属性将被置为 null。
     */
    destroy() {
        this.type = null;
        super.destroy();
    }


    /**
     * @function LevelRenderer.Shape.SmicEllipse.prototype.buildPath
     * @description 构建椭圆的 Path。
     *
     * @param {CanvasRenderingContext2D} ctx - Context2D 上下文。
     * @param {Object} style - style。
     *
     */
    buildPath(ctx, style) {
        if (!this.refOriginalPosition || this.refOriginalPosition.length !== 2) {
            this.refOriginalPosition = [0, 0];
        }
        var __OP = this.refOriginalPosition;

        var k = 0.5522848;
        var x = style.x + __OP[0];
        var y = style.y + __OP[1];
        var a = style.a;
        var b = style.b;
        var ox = a * k; // 水平控制点偏移量
        var oy = b * k; // 垂直控制点偏移量
        // 从椭圆的左端点开始顺时针绘制四条三次贝塞尔曲线
        ctx.moveTo(x - a, y);
        ctx.bezierCurveTo(x - a, y - oy, x - ox, y - b, x, y - b);
        ctx.bezierCurveTo(x + ox, y - b, x + a, y - oy, x + a, y);
        ctx.bezierCurveTo(x + a, y + oy, x + ox, y + b, x, y + b);
        ctx.bezierCurveTo(x - ox, y + b, x - a, y + oy, x - a, y);
        ctx.closePath();
    }


    /**
     * @function LevelRenderer.Shape.SmicEllipse.prototype.getRect
     * @description 计算返回椭圆包围盒矩形
     *
     * @param {Object} style - style
     * @return {Object} 边框对象。包含属性：x，y，width，height。
     *
     */
    getRect(style) {
        if (style.__rect) {
            return style.__rect;
        }

        if (!this.refOriginalPosition || this.refOriginalPosition.length !== 2) {
            this.refOriginalPosition = [0, 0];
        }
        var __OP = this.refOriginalPosition;

        var lineWidth;
        if (style.brushType == 'stroke' || style.brushType == 'fill') {
            lineWidth = style.lineWidth || 1;
        } else {
            lineWidth = 0;
        }
        style.__rect = {
            x: Math.round((style.x + __OP[0]) - style.a - lineWidth / 2),
            y: Math.round((style.x + __OP[1]) - style.b - lineWidth / 2),
            width: style.a * 2 + lineWidth,
            height: style.b * 2 + lineWidth
        };

        return style.__rect;
    }

}

;// CONCATENATED MODULE: ./src/common/overlay/levelRenderer/SmicIsogon.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/



/**
 * @private
 * @class  LevelRenderer.Shape.SmicIsogon
 * @category Visualization Theme
 * @classdesc 正多边形。
 * @extends LevelRenderer.Shape
 * @param {Array} options - shape 的配置（options）项，可以是 shape 的自有属性，也可以是自定义的属性。
 */
class SmicIsogon extends (/* unused pure expression or super */ null && (Shape)) {
    constructor(options) {
        super(options);
        /**
         * @member {string} LevelRenderer.Shape.SmicIsogon.prototype.type
         * @description 图形类型。
         */
        this.type = 'smicisogon';
        if (!this.refOriginalPosition || this.refOriginalPosition.length !== 2) {
            this.refOriginalPosition = [0, 0];
        }
        this.CLASS_NAME = "SuperMap.LevelRenderer.Shape.SmicIsogon";
    }


    /**
     * @function LevelRenderer.Shape.SmicIsogon.prototype.destroy
     * @description 销毁对象，释放资源。调用此函数后所有属性将被置为 null。
     */
    destroy() {
        this.type = null;
        super.destroy();
    }


    /**
     * @function LevelRenderer.Shape.SmicIsogon.prototype.buildPath
     * @description 创建n角星（n>=3）路径。
     *
     * @param {CanvasRenderingContext2D} ctx - Context2D 上下文。
     * @param {Object} style - style。
     *
     */
    buildPath(ctx, style) {
        if (!this.refOriginalPosition || this.refOriginalPosition.length !== 2) {
            this.refOriginalPosition = [0, 0];
        }
        var __OP = this.refOriginalPosition;

        var sin = SUtil.Util_math.sin;
        var cos = SUtil.Util_math.cos;
        var PI = Math.PI;

        var n = style.n;
        if (!n || n < 2) {
            return;
        }

        var x = style.x + __OP[0];
        var y = style.y + __OP[1];
        var r = style.r;

        var dStep = 2 * PI / n;
        var deg = -PI / 2;
        var xStart = x + r * cos(deg);
        var yStart = y + r * sin(deg);
        deg += dStep;

        // 记录边界点，用于判断insight
        var pointList = style.pointList = [];
        pointList.push([xStart, yStart]);
        for (let i = 0, end = n - 1; i < end; i++) {
            pointList.push([x + r * cos(deg), y + r * sin(deg)]);
            deg += dStep;
        }
        pointList.push([xStart, yStart]);

        // 绘制
        ctx.moveTo(pointList[0][0], pointList[0][1]);
        for (let i = 0; i < pointList.length; i++) {
            ctx.lineTo(pointList[i][0], pointList[i][1]);
        }
        ctx.closePath();

        return;
    }


    /**
     * @function LevelRenderer.Shape.SmicIsogon.prototype.getRect
     * @description 计算返回正多边形的包围盒矩形。
     *
     * @param {Object} style - style
     * @return {Object} 边框对象。包含属性：x，y，width，height。
     */
    getRect(style) {
        if (style.__rect) {
            return style.__rect;
        }

        if (!this.refOriginalPosition || this.refOriginalPosition.length !== 2) {
            this.refOriginalPosition = [0, 0];
        }
        var __OP = this.refOriginalPosition;

        var lineWidth;
        if (style.brushType == 'stroke' || style.brushType == 'fill') {
            lineWidth = style.lineWidth || 1;
        } else {
            lineWidth = 0;
        }
        style.__rect = {
            x: Math.round((style.x + __OP[0]) - style.r - lineWidth / 2),
            y: Math.round((style.y + __OP[1]) - style.r - lineWidth / 2),
            width: style.r * 2 + lineWidth,
            height: style.r * 2 + lineWidth
        };

        return style.__rect;
    }

}

;// CONCATENATED MODULE: ./src/common/overlay/levelRenderer/SmicRing.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


/**
 * @private
 * @class  LevelRenderer.Shape.SmicRing
 * @category Visualization Theme
 * @classdesc 圆环。
 * @extends LevelRenderer.Shape
 * @example
 *   var shape = new LevelRenderer.Shape.SmicRing({
 *         style: {
 *             x: 100,
 *             y: 100,
 *             r0: 30,
 *             r: 50
 *         }
 *     });
 *   levelRenderer.addShape(shape);
 * @param {Array} options - shape 的配置（options）项，可以是 shape 的自有属性，也可以是自定义的属性。
 */
class SmicRing extends (/* unused pure expression or super */ null && (Shape)) {
    constructor(options) {
        super(options);
        /**
         * @member {string} LevelRenderer.Shape.SmicRing.prototype.type
         * @description 图形类型。
         */
        this.type = 'smicring';
        if (!this.refOriginalPosition || this.refOriginalPosition.length !== 2) {
            this.refOriginalPosition = [0, 0];
        }
        this.CLASS_NAME = "SuperMap.LevelRenderer.Shape.SmicRing";

    }


    /**
     * @function LevelRenderer.Shape.SmicRing.prototype.destroy
     * @description 销毁对象，释放资源。调用此函数后所有属性将被置为 null。
     */
    destroy() {
        this.type = null;
        super.destroy();
    }


    /**
     * @function LevelRenderer.Shape.SmicRing.prototype.buildPath
     * @description 创建圆环路径。
     *
     * @param {CanvasRenderingContext2D} ctx - Context2D 上下文。
     * @param {Object} style - style。
     *
     */
    buildPath(ctx, style) {
        if (!this.refOriginalPosition || this.refOriginalPosition.length !== 2) {
            this.refOriginalPosition = [0, 0];
        }
        var __OP = this.refOriginalPosition;

        // 非零环绕填充优化
        ctx.arc(style.x + __OP[0], style.y + __OP[1], style.r, 0, Math.PI * 2, false);
        ctx.moveTo((style.x + __OP[0]) + style.r0, style.y + __OP[1]);
        ctx.arc(style.x + __OP[0], style.y + __OP[1], style.r0, 0, Math.PI * 2, true);
        return;
    }


    /**
     * @function LevelRenderer.Shape.SmicRing.prototype.getRect
     * @description 计算返回圆环包围盒矩阵
     *
     * @param {Object} style - style
     * @return {Object} 边框对象。包含属性：x，y，width，height。
     */
    getRect(style) {
        if (style.__rect) {
            return style.__rect;
        }

        if (!this.refOriginalPosition || this.refOriginalPosition.length !== 2) {
            this.refOriginalPosition = [0, 0];
        }
        var __OP = this.refOriginalPosition;

        var lineWidth;
        if (style.brushType == 'stroke' || style.brushType == 'fill') {
            lineWidth = style.lineWidth || 1;
        } else {
            lineWidth = 0;
        }
        style.__rect = {
            x: Math.round((style.x + __OP[0]) - style.r - lineWidth / 2),
            y: Math.round((style.y + __OP[1]) - style.r - lineWidth / 2),
            width: style.r * 2 + lineWidth,
            height: style.r * 2 + lineWidth
        };

        return style.__rect;
    }

}

;// CONCATENATED MODULE: ./src/common/overlay/levelRenderer/SmicStar.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/



/**
 * @private
 * @class  LevelRenderer.Shape.SmicStar
 * @category Visualization Theme
 * @classdesc n 角星（n>3）。
 * @extends LevelRenderer.Shape
 * @example
 *   var shape = new LevelRenderer.Shape.SmicStar({
 *         style: {
 *             x: 200,
 *             y: 100,
 *             r: 150,
 *             n: 5,
 *             text: '五角星'
 *         }
 *   });
 *   levelRenderer.addShape(shape);
 * @param {Array} options - shape 的配置（options）项，可以是 shape 的自有属性，也可以是自定义的属性。
 *
 */
class SmicStar extends (/* unused pure expression or super */ null && (Shape)) {
    constructor(options) {
        super(options);
        /**
         * @member {string} LevelRenderer.Shape.SmicStar.prototype.type
         * @description 图形类型。
         */
        this.type = 'smicstar';

        if (!this.refOriginalPosition || this.refOriginalPosition.length !== 2) {
            this.refOriginalPosition = [0, 0];
        }

        this.CLASS_NAME = "SuperMap.LevelRenderer.Shape.SmicStar";
    }

    /**
     * @function LevelRenderer.Shape.SmicStar.prototype.destroy
     * @description 销毁对象，释放资源。调用此函数后所有属性将被置为 null。
     */
    destroy() {
        this.type = null;
        super.destroy();
    }

    /**
     * @function LevelRenderer.Shape.SmicStar.prototype.buildPath
     * @description 创建n  角星（n>3）路径。
     *
     * @param {CanvasRenderingContext2D} ctx - Context2D 上下文。
     * @param {Object} style - style。
     *
     */
    buildPath(ctx, style) {
        if (!this.refOriginalPosition || this.refOriginalPosition.length !== 2) {
            this.refOriginalPosition = [0, 0];
        }
        var __OP = this.refOriginalPosition;

        var n = style.n;
        if (!n || n < 2) {
            return;
        }

        var sin = SUtil.Util_math.sin;
        var cos = SUtil.Util_math.cos;
        var PI = Math.PI;

        var x = style.x + __OP[0];
        var y = style.y + __OP[1];
        var r = style.r;
        var r0 = style.r0;

        // 如果未指定内部顶点外接圆半径，则自动计算
        if (r0 == null) {
            r0 = n > 4
                // 相隔的外部顶点的连线的交点，
                // 被取为内部交点，以此计算r0
                ? r * cos(2 * PI / n) / cos(PI / n)
                // 二三四角星的特殊处理
                : r / 3;
        }

        var dStep = PI / n;
        var deg = -PI / 2;
        var xStart = x + r * cos(deg);
        var yStart = y + r * sin(deg);
        deg += dStep;

        // 记录边界点，用于判断inside
        var pointList = style.pointList = [];
        pointList.push([xStart, yStart]);
        for (var i = 0, end = n * 2 - 1, ri; i < end; i++) {
            ri = i % 2 === 0 ? r0 : r;
            pointList.push([x + ri * cos(deg), y + ri * sin(deg)]);
            deg += dStep;
        }
        pointList.push([xStart, yStart]);

        // 绘制
        ctx.moveTo(pointList[0][0], pointList[0][1]);
        for (let i = 0; i < pointList.length; i++) {
            ctx.lineTo(pointList[i][0], pointList[i][1]);
        }

        ctx.closePath();

        return;
    }

    /**
     * @function LevelRenderer.Shape.SmicStar.prototype.getRect
     * @description 返回 n 角星包围盒矩形。
     *
     * @param {Object} style - style
     * @return {Object} 边框对象。包含属性：x，y，width，height。
     */
    getRect(style) {
        if (style.__rect) {
            return style.__rect;
        }

        if (!this.refOriginalPosition || this.refOriginalPosition.length !== 2) {
            this.refOriginalPosition = [0, 0];
        }
        var __OP = this.refOriginalPosition;

        var lineWidth;
        if (style.brushType == 'stroke' || style.brushType == 'fill') {
            lineWidth = style.lineWidth || 1;
        } else {
            lineWidth = 0;
        }
        style.__rect = {
            x: Math.round((style.x + __OP[0]) - style.r - lineWidth / 2),
            y: Math.round((style.y + __OP[1]) - style.r - lineWidth / 2),
            width: style.r * 2 + lineWidth,
            height: style.r * 2 + lineWidth
        };

        return style.__rect;
    }

}

;// CONCATENATED MODULE: ./src/common/overlay/levelRenderer/index.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/













































































;// CONCATENATED MODULE: ./src/common/overlay/index.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/




























;// CONCATENATED MODULE: ./src/common/components/CommonTypes.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/
/**
 * @description 该文件用于存储一些公用常量
 * @private
 */
const CommonTypes_FileTypes = {
    EXCEL: "EXCEL",
    CSV: "CSV",
    ISERVER: "ISERVER",
    GEOJSON: "GEOJSON",
    JSON: 'JSON'
};
const CommonTypes_FileConfig = {
    fileMaxSize: 10 * 1024 * 1024
};

;// CONCATENATED MODULE: ./src/common/components/openfile/FileModel.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


/**
 * @class FileModel
 * @deprecatedclass SuperMap.FileModel
 * @description 文件数据组件数据模型，用于存储一些文件数据或状态，todo 结构待完善
 * @category Components OpenFile
 * @private
 */
class FileModel {
    constructor(options) {
        this.FileTypes = FileTypes;
        this.FileConfig = FileConfig;
        this.loadFileObject = options && options.loadFileObject ? options.loadFileObject : [];
    }

    /**
     * @function FileModel.prototype.set
     * @description 设置属性值
     * @param {string} key - 属性名称
     * @param {string|Object} value - 属性值
     */
    set(key, value) {
        this[key] = value;
    }

    /**
     * @function FileModel.prototype.get
     * @description 获取数据值
     * @param {string} key - 属性名称
     * @returns {string|Object} value - 返回属性值
     */
    get(key) {
        return this[key];
    }

}

;// CONCATENATED MODULE: ./src/common/components/messagebox/MessageBox.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/

/**
 * @class MessageBox
 * @aliasclass Components.MessageBox
 * @deprecatedclass SuperMap.Components.MessageBox
 * @version 9.1.1
 * @classdesc 组件信息提示框。
 * @category Components Common
 * @usage
 */
class MessageBox {

    constructor() {
        this._initView();
    }

    _initView() {
        //原生js形式
        const messageBoxContainer = document.createElement("div");
        messageBoxContainer.hidden = true;
        messageBoxContainer.setAttribute("class", "component-messageboxcontainer component-border-bottom-orange");

        //图标
        const iconContainer = document.createElement("div");
        iconContainer.setAttribute("class", "icon");
        this.icon = document.createElement("span");
        this.icon.setAttribute("class", "supermapol-icons-message-warning");
        iconContainer.appendChild(this.icon);
        messageBoxContainer.appendChild(iconContainer);

        //内容：
        const messageBox = document.createElement("div");
        messageBox.setAttribute("class", "component-messagebox");
        messageBox.innerHTML = "";
        messageBoxContainer.appendChild(messageBox);
        this.messageBox = messageBox;

        //关闭按钮
        const cancelContainer = document.createElement("div");
        cancelContainer.setAttribute("class", "component-messagebox__cancelbtncontainer");
        const cancelBtn = document.createElement("button");
        cancelBtn.setAttribute("class", "component-messagebox__cancelBtn");
        cancelBtn.innerHTML = "x";
        cancelBtn.onclick = this.closeView.bind(this);
        cancelContainer.appendChild(cancelBtn);
        messageBoxContainer.appendChild(cancelContainer);

        this.messageBoxContainer = messageBoxContainer;
        document.body.appendChild(this.messageBoxContainer);
    }

    /**
     * @function MessageBox.prototype.closeView
     * @description 关闭提示框。
     */
    closeView() {
        this.messageBoxContainer.hidden = true;
    }

    /**
     * @function MessageBox.prototype.showView
     * @description 显示提示框。
     * @param {string} message - 提示框显示内容。
     * @param {string}[type="warring"] 提示框类型，如 "warring", "failure", "success"。
     */
    showView(message, type = 'warring') {
        //设置提示框的样式：
        if (type === "success") {
            this.icon.setAttribute("class", "supermapol-icons-message-success");
            this.messageBoxContainer.setAttribute("class", "component-messageboxcontainer component-border-bottom-green");

        } else if (type === "failure") {
            this.icon.setAttribute("class", "supermapol-icons-message-failure");
            this.messageBoxContainer.setAttribute("class", "component-messageboxcontainer component-border-bottom-red");
        } else if (type === "warring") {
            this.icon.setAttribute("class", "supermapol-icons-message-warning");
            this.messageBoxContainer.setAttribute("class", "component-messageboxcontainer component-border-bottom-orange");
        }
        this.messageBox.innerHTML = message;
        this.messageBoxContainer.hidden = false;
    }
}

;// CONCATENATED MODULE: external "function(){try{return echarts}catch(e){return {}}}()"
const external_function_try_return_echarts_catch_e_return_namespaceObject = function(){try{return echarts}catch(e){return {}}}();
;// CONCATENATED MODULE: ./src/common/lang/locales/en-US.js
﻿
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/
/**
 * Namespace: SuperMap.Lang["en"]
 * Dictionary for English.  Keys for entries are used in calls to
 *     <SuperMap.Lang.translate>.  Entry bodies are normal strings or
 *     strings formatted for use with <SuperMap.String.format> calls.
 */
let en = {
    'title_dataFlowService': 'Data Flow Service',
    'title_distributedAnalysis': 'Distributed Analysis',
    'title_clientComputing': 'Client Computing',
    'title_dataServiceQuery': 'Data Service Query',
    'title_searchCity':'Search city',
    'title_searchLayer':' Search layer',

    'text_input_value_inputDataFlowUrl': 'Please enter the data stream service address such as: ws://{serviceRoot}/{dataFlowName}/dataflow/subscribe',
    'text_displayFeaturesInfo': 'Display feature information',
    'text_subscribe': 'subscribe',
    'text_cancelSubscribe': 'unsubscribe',

    'text_densityAnalysis': 'Density Analysis',
    'text_CalculateTheValuePerUnitArea': 'Calculate the value per unit area within the neighborhood shape',
    'text_option_selectDataset':'Please select a dataset',
    'text_label_dataset': 'Dataset',
    'text_option_simplePointDensityAnalysis': 'Simple point density analysis',
    'text_option_nuclearDensityAnalysis': 'Nuclear density analysis',
    'text_label_analyticalMethod': 'Analytical method',
    'text_option_quadrilateral': 'Quadrilateral',
    'text_option_hexagon': 'hexagon',
    'text_label_meshType': 'Mesh type',
    'text_option_notSet': 'Not set',
    'text_label_weightField': 'Weight field',
    'text_label_gridSizeInMeters': 'Grid size',
    'text_label_searchRadius': 'Search radius',
    'text_label_queryRange': 'Scope of analysis',
    'text_label_areaUnit': 'Area unit',
    'text_option_equidistantSegmentation': 'Equidistant segmentation',
    'text_option_logarithm': 'Logarithm',
    'text_option_equalCountingSegment': 'Equal counting segment',
    'text_option_squareRootSegmentation': 'Square root segmentation',
    'text_label_thematicMapSegmentationMode': 'Thematic map segmentation mode',
    'text_label_thematicMapSegmentationParameters': 'Thematic map segmentation parameters',
    'text_option_greenOrangePurpleGradient': 'Green orange purple gradient',
    'text_option_greenOrangeRedGradient': 'Green orange red gradient',
    'text_option_rainbowGradient': 'Rainbow gradient',
    'text_option_spectralGradient': 'Spectral gradient',
    'text_option_terrainGradient': 'Terrain gradient',
    'text_label_thematicMapColorGradientMode': 'Thematic map color gradient mode',
    'text_label_resultLayerName': 'Result layer name',
    'text_chooseFile': 'Open File',
    'text_isoline': 'Isoline',
    'text_extractDiscreteValue': 'Extract discrete value generation curve',
    'text_buffer': 'Buffer',
    'text_specifyTheDistance': 'Specify the distance to create the surrounding area',
    'text_label_analysisLayer': 'Analysis layer',
    'text_label_extractField': 'Extract field',
    'text_label_extractedValue': 'Extracted value',
    'text_label_distanceAttenuation': 'Distance attenuation',
    'text_label_gridSize': 'gridSize',
    'text_label_bufferRadius': 'Buffer radius',
    'text_label_defaultkilometers': 'Default 10 kilometers',
    'text_label_kilometer': 'kilometer',
    'text_label_unit': 'unit',
    'text_retainOriginal': 'Retain original object field',
    'text_mergeBuffer': 'Merge buffer',
    'text_label_color': 'Color',
    'text_label_buffer': '[Buffer]',
    'text_label_isolines': '[Isolines]',
    'text_label_queryRangeTips': 'The default is the full range of input data. Example: -74.050, 40.650, -73.850, 40.850',
    'text_label_queryModel': 'Query mode',
    'text_label_IDArrayOfFeatures': 'ID array of features',
    'text_label_maxFeatures': 'The maximum number of features that can be returned',
    'text_label_bufferDistance': 'Buffer distance',
    'text_label_queryRange1': 'Query range',
    'text_label_spatialQueryMode': 'Spatial query mode',
    'text_label_featureFilter': 'Feature filter',
    'text_label_geometricObject': 'Geometric object',
    'text_label_queryMode': 'Query mode',
    'text_label_searchTips': 'Search for city locations or layer features',
    'text_label_chooseSearchLayers': 'Select a query layer',
    'text_loadSearchCriteria': 'Load search criteria',
    'text_saveSearchCriteria': 'Save search criteria',

    "btn_analyze": "Analyze",
    "btn_analyzing": "Analyzing",
    "btn_emptyTheAnalysisLayer": "Empty the analysis layer",
    "btn_cancelAnalysis": "Cancel",
    "btn_query": "Query",
    "btn_querying": "Querying",
    "btn_emptyTheRresultLayer": "Clear all result layers",

    'msg_dataReturnedIsEmpty.': 'The request is successful and the data returned by the query is empty.',
    'msg_dataFlowServiceHasBeenSubscribed': 'The data stream service has been subscribed to.',
    'msg_inputDataFlowUrlFirst': 'Please enter the data stream service address first.',
    'msg_datasetOrMethodUnsupport': 'This dataset does not support this analysis type. Please reselect the dataset.',
    'msg_selectDataset': 'Please select a data set!',
    'msg_setTheWeightField': 'Please set the weight field!',
    'msg_theFieldNotSupportAnalysis': 'The field you currently select does not support analysis!',
    'msg_resultIsEmpty': 'The result of the analysis is empty!',
    'msg_openFileFail': 'Failed to open file!',
    'msg_fileTypeUnsupported': 'File format is not supported!',
    'msg_fileSizeExceeded': 'File size exceeded! The file size should not exceed 10M!',
    'msg_dataInWrongGeoJSONFormat': 'Wrong data format! Non standard GEOJSON format data!',
    'msg_dataInWrongFormat': 'Wrong data format! Non standard EXCEL, CSV or GEOJSON format data!',
    'msg_searchKeywords': "Search keywords cannot be empty. Please enter your search criteria.",
    'msg_searchGeocodeField':"Did not match the address matching service data!",
    'msg_cityGeocodeField':"The address matching service of the current city is not configured.",
    'msg_getFeatureField':"No related vector features found!",
    'msg_dataflowservicesubscribed':'The data stream service has been subscribed to.',
    'msg_subscribesucceeded':'The data stream service subscription was successful.',
    'msg_crsunsupport':'Does not support the coordinate system of the current map',
    'msg_tilematrixsetunsupport':'Incoming TileMatrixSet is not supported',
    'msg_jsonResolveFiled': 'JSON format parsing failure！',
    'msg_requestContentFiled': 'Failed to request data through iportal!',
    'msg_getdatafailed': 'Failed to get data!'

};



;// CONCATENATED MODULE: ./src/common/lang/locales/zh-CN.js
﻿/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/

/**
 * Namespace: SuperMap.Lang["zh-CN"]
 * Dictionary for Simplified Chinese.  Keys for entries are used in calls to
 *     <SuperMap.Lang.translate>.  Entry bodies are normal strings or
 *     strings formatted for use with <SuperMap.String.format> calls.
 */
let zh = {
    'title_dataFlowService': '数据流服务',
    'title_distributedAnalysis': '分布式分析',
    'title_clientComputing': '客户端计算',
    'title_dataServiceQuery': '数据服务查询',
    'title_searchCity':'搜索城市',
    'title_searchLayer':'搜索图层',

    'text_input_value_inputDataFlowUrl': '请输入数据流服务地址如:ws://{serviceRoot}/{dataFlowName}/dataflow/subscribe',
    'text_displayFeaturesInfo': '显示要素信息',
    'text_subscribe': '订阅',
    'text_cancelSubscribe': '取消订阅',
    
    'text_densityAnalysis': '密度分析',
    'text_CalculateTheValuePerUnitArea': '计算点指定邻域形状内的每单位面积量值',
    'text_option_selectDataset':'请选择数据集',
    'text_label_dataset': '数据集',
    'text_option_simplePointDensityAnalysis': '简单点密度分析',
    'text_option_nuclearDensityAnalysis': '核密度分析',
    'text_label_analyticalMethod': '分析方法',
    'text_option_quadrilateral': '四边形',
    'text_option_hexagon': '六边形',
    'text_label_meshType': '网格面类型',
    'text_option_notSet': '未设置',
    'text_label_weightField': '权重字段',
    'text_label_gridSizeInMeters': '网格大小',
    'text_label_searchRadius': '搜索半径',
    'text_label_queryRange': '分析范围',
    'text_label_areaUnit': '面积单位',
    'text_option_equidistantSegmentation': '等距离分段',
    'text_option_logarithm': '对数',
    'text_option_equalCountingSegment': '等计数分段',
    'text_option_squareRootSegmentation': '平方根分段',
    'text_label_thematicMapSegmentationMode': '专题图分段模式',
    'text_label_thematicMapSegmentationParameters': '专题图分段参数',
    'text_option_greenOrangePurpleGradient': '绿橙紫渐变',
    'text_option_greenOrangeRedGradient': '绿橙红渐变',
    'text_option_rainbowGradient': '彩虹渐变',
    'text_option_spectralGradient': '光谱渐变',
    'text_option_terrainGradient': '地形渐变',
    'text_label_thematicMapColorGradientMode': '专题图颜色渐变模式',
    'text_label_resultLayerName': '结果图层名称',
    'text_chooseFile': '选择文件',
    'text_isoline': '等值线',
    'text_extractDiscreteValue': '提取离散值生成曲线',
    'text_buffer': '缓冲区',
    'text_specifyTheDistance': '指定距离创建周边区域',
    'text_label_analysisLayer': '分析图层',
    'text_label_extractField': '提取字段',
    'text_label_extractedValue': '提取值',
    'text_label_distanceAttenuation': '距离衰减',
    'text_label_gridSize': '栅格大小',
    'text_label_bufferRadius': '缓冲半径',
    'text_label_defaultkilometers': '默认10千米',
    'text_option_kilometer': '千米',
    'text_label_unit': '单位',
    'text_retainOriginal': '保留原对象字段属性',
    'text_mergeBuffer': '合并缓冲区',
    'text_label_color': '颜色',
    'text_label_buffer': '[缓冲区]',
    'text_label_isolines': '[等值线]',
    'text_label_queryRangeTips': '默认为输入数据的全幅范围。范例：-74.050,40.650,-73.850,40.850',
    'text_label_IDArrayOfFeatures': '要素 ID 数组',
    'text_label_maxFeatures': '最多可返回的要素数量',
    'text_label_bufferDistance': '缓冲区距离',
    'text_label_queryRange1': '查询范围',
    'text_label_spatialQueryMode': '空间查询模式',
    'text_label_featureFilter': '要素过滤器',
    'text_label_geometricObject': '几何对象',
    'text_label_queryMode': '查询模式',
    'text_label_searchTips': '搜索城市地点或图层要素',
    'text_label_chooseSearchLayers': '选择查询图层',
    'text_loadSearchCriteria': '加载搜索条件',
    'text_saveSearchCriteria': '保存搜索条件',


    "btn_analyze": "分析",
    "btn_analyzing": "分析中",
    "btn_emptyTheAnalysisLayer": "清空分析图层",
    "btn_cancelAnalysis": "取消",
    "btn_query": "查询",
    "btn_querying": "查询中",
    "btn_emptyTheRresultLayer": "清除所有结果图层",
    

    'msg_dataFlowServiceHasBeenSubscribed': '已订阅该数据流服务。',
    'msg_inputDataFlowUrlFirst': '请先输入数据流服务地址。',
    'msg_datasetOrMethodUnsupport': '该数据集不支持本分析类型，请重新选择数据集',
    'msg_selectDataset': '请选择数据集！',
    'msg_setTheWeightField': '请设置权重字段！',
    'msg_theFieldNotSupportAnalysis': '您当前选择的字段不支持分析！',
    'msg_resultIsEmpty': '分析的结果为空！',
    'msg_dataReturnedIsEmpty': '请求成功，查询返回的数据为空。',
    'msg_openFileFail': '打开文件失败！',
    'msg_fileTypeUnsupported': '不支持该文件格式！',
    'msg_fileSizeExceeded': '文件大小超限！文件大小不得超过 10M！',
    'msg_dataInWrongGeoJSONFormat': '数据格式错误！非标准的 GEOJSON 格式数据！',
    'msg_dataInWrongFormat': '数据格式错误！非标准的 EXCEL, CSV 或 GEOJSON 格式数据！',
    'msg_searchKeywords': "搜索关键字不能为空，请输入搜索条件。",
    'msg_searchGeocodeField':"未匹配到地址匹配服务数据！",
    'msg_cityGeocodeField':"未配置当前城市的地址匹配服务。",
    'msg_getFeatureField':"未查找到相关矢量要素！",
    'msg_dataflowservicesubscribed':'已订阅该数据流服务。',
    'msg_subscribesucceeded':'数据流服务订阅成功。',
    'msg_crsunsupport':'不支持当前地图的坐标系',
    'msg_tilematrixsetunsupport':'不支持传入的TileMatrixSet',
    'msg_jsonResolveFiled': 'json格式解析失败！',
    'msg_requestContentFiled': '通过iportal请求数据失败！',
    'msg_getdatafailed': '获取数据失败！'
};



;// CONCATENATED MODULE: ./src/common/lang/Lang.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/
 
 
/**
 * @name Lang
 * @namespace
 * @category BaseTypes Internationalization
 * @description 国际化的命名空间，包含多种语言和方法库来设置和获取当前的语言。
 * @usage
 * ```
 * // 浏览器
 * <script type="text/javascript" src="{cdn}"></script>
 * <script>
 *   const result = {namespace}.Lang.getCode();
 *
 *   // 弃用的写法
 *   const result = SuperMap.Lang.getCode();
 *
 * </script>
 *
 * // ES6 Import
 * import { Lang } from '{npm}';
 * 
 * const result = Lang.getCode();
 *
 * ```
 */
let Lang = {
   'en-US': en,
   "zh-CN": zh,
    /**
     * @member {string} Lang.code
     * @description 当前所使用的语言类型。
     */
    code: null,

    /**
     * @member {string} [Lang.defaultCode='en-US']
     * @description 默认使用的语言类型。
     */
    defaultCode: "en-US",

    /**
     * @function Lang.getCode
     * @description 获取当前的语言代码。
     * @returns {string} 当前的语言代码。
     */
    getCode: function () {
        if (!Lang.code) {
            Lang.setCode();
        }
        return Lang.code;
    },

    /**
     * @function Lang.setCode
     * @description 设置语言代码。
     * @param {string} code - 此参数遵循IETF规范。
     */
    setCode: function () {
        var lang = this.getLanguageFromCookie();
        if (!lang) {
            lang = Lang.defaultCode;
            if (navigator.appName === 'Netscape') {
                lang = navigator.language;
            } else {
                lang = navigator.browserLanguage;
            }
        }
        if (lang.indexOf('zh') === 0) {
            lang = 'zh-CN';
        }
        if (lang.indexOf('en') === 0) {
            lang = 'en-US';
        }

        Lang.code = lang;
    },
    /**
     * @function Lang.getLanguageFromCookie
     * @description 从 cookie 中获取语言类型。
     */
    getLanguageFromCookie() {
        var name = 'language=';
        var ca = document.cookie.split(';');
        for (var i = 0; i < ca.length; i++) {
            var c = ca[i];
            while (c.charAt(0) === ' ') {
                c = c.substring(1)
            }
            if (c.indexOf(name) !== -1) {
                return c.substring(name.length, c.length)
            }
        }
        return "";
    },

    /**
     * @function Lang.i18n
     * @description 从当前语言字符串的字典查找 key。
     * @param {string} key - 字典中 i18n 字符串值的关键字。
     * @returns {string} 国际化的字符串。
     */
    i18n: function (key) {
        var dictionary = Lang[Lang.getCode()];
        var message = dictionary && dictionary[key];
        if (!message) {
            // Message not found, fall back to message key
            message = key;
        }
        return message;
    }

};




;// CONCATENATED MODULE: external "function(){try{return XLSX}catch(e){return {}}}()"
const external_function_try_return_XLSX_catch_e_return_namespaceObject = function(){try{return XLSX}catch(e){return {}}}();
;// CONCATENATED MODULE: ./src/common/components/util/FileReaderUtil.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/




/**
 * @name FileReaderUtil
 * @namespace
 * @category Components OpenFile
 * @description 组件读取文件工具类。
 * @version 9.1.1
 * @type {{rABS: (boolean|*), rABF: (boolean|*), rAT: (boolean|*), readFile: (function(*, *=, *=, *=, *=)), readTextFile: (function(*, *=, *=, *=)), readXLSXFile: (function(*, *=, *=, *=)), processDataToGeoJson: (function(string, Object): GeoJSONObject), processExcelDataToGeoJson: (function(Object): GeoJSONObject), isXField: (function(*)), isYField: (function(*)), string2Csv: (function(*, *=))}}
 * @usage
 * ```
 * // 浏览器
 * <script type="text/javascript" src="{cdn}"></script>
 * <script>
 *   const result = {namespace}.Components.FileReaderUtil.isXField(data);
 *
 *   // 弃用的写法
 *   const result = SuperMap.Components.FileReaderUtil.isXField(data);
 *
 * </script>
 *
 * // ES6 Import
 * import { FileReaderUtil } from '{npm}';
 *
 * const result = FileReaderUtil.isXField(data);
 * ```
 */
let FileReaderUtil = {
    rABS: typeof FileReader !== 'undefined' && FileReader.prototype && FileReader.prototype.readAsBinaryString,
    rABF: typeof FileReader !== 'undefined' && FileReader.prototype && FileReader.prototype.readAsArrayBuffer,
    rAT: typeof FileReader !== 'undefined' && FileReader.prototype && FileReader.prototype.readAsText,
    /**
     * @function FileReaderUtil.prototype.readFile
     * @description 读取文件。
     * @param {string} fileType - 当前读取的文件类型。
     *
     * @param {Object} file - 读取回来的文件内容对象。
     * @param {function} success - 读取文件成功回调函数。
     * @param {function} failed - 读取文件失败回调函数。
     * @param {Object} context - 回调重定向对象。
     */
    readFile(fileType, file, success, failed, context) {
        if (CommonTypes_FileTypes.JSON === fileType || CommonTypes_FileTypes.GEOJSON === fileType) {
            this.readTextFile(file, success, failed, context)
        } else if (CommonTypes_FileTypes.EXCEL === fileType || CommonTypes_FileTypes.CSV === fileType) {
            this.readXLSXFile(file, success, failed, context)
        }
    },

    /**
     * @description 读取文本文件。
     * @param {Object} file 文件内容对象。
     * @param {function} success 读取文件成功回调函数。
     * @param {function} failed 读取文件失败回调函数。
     * @param {Object} context - 回调重定向对象。
     */
    readTextFile(file, success, failed, context) {
        let reader = new FileReader();
        reader.onloadend = function (evt) {
            success && success.call(context, evt.target.result);
        };
        reader.onerror = function (error) {
            failed && failed.call(context, error)
        };
        this.rAT ? reader.readAsText(file.file, 'utf-8') : reader.readAsBinaryString(file.file);
    },

    /**
     * @description 读取excel或csv文件。
     * @param {Object} file 文件内容对象。
     * @param {function} success 读取文件成功回调函数。
     * @param {function} failed 读取文件失败回调函数。
     * @param {Object} context - 回调重定向对象。
     */
    readXLSXFile(file, success, failed, context) {
        let reader = new FileReader();
        reader.onloadend = function (evt) {
            let xLSXData = new Uint8Array(evt.target.result);
            let workbook = external_function_try_return_XLSX_catch_e_return_namespaceObject.read(xLSXData, {type: "array"});
            try {
                if (workbook && workbook.SheetNames && workbook.SheetNames.length > 0) {
                    //暂时只读取第一个sheets的内容
                    let sheetName = workbook.SheetNames[0];
                    let xLSXCSVString = external_function_try_return_XLSX_catch_e_return_namespaceObject.utils.sheet_to_csv(workbook.Sheets[sheetName]);
                    success && success.call(context, xLSXCSVString);
                }
            } catch (error) {
                failed && failed.call(context, error);
            }
        };
        reader.onerror = function (error) {
            failed && failed.call(context, error)
        };
        this.rABF && reader.readAsArrayBuffer(file.file);
    },

    /**
     * @function FileReaderUtil.prototype.processDataToGeoJson
     * @description 将读取回来得数据统一处理为 GeoJSON 格式。
     * @param {string} type - 文件类型。
     * @param {Object} data - 读取返回的数据对象。
     * @param {function} success - 数据处理成功的回调。
     * @param {function} failed - 数据处理失败的回调。
     * @param {Object} context - 回调重定向对象。
     * @returns {GeoJSONObject} 返回标准 GeoJSON 规范格式数据。
     * @private
     */
    processDataToGeoJson(type, data, success, failed, context) {
        let geojson = null;
        if (type === "EXCEL" || type === "CSV") {
            geojson = this.processExcelDataToGeoJson(data);
            success && success.call(context, geojson);
        } else if (type === 'JSON' || type === 'GEOJSON') {
            let result = data;
            //geojson、json未知，通过类容来判断
            if ((typeof result) === "string") {
                result = JSON.parse(result);
            }
            if (result.type === 'ISERVER') {
                geojson = result.data.recordsets[0].features;
            } else if (result.type === 'FeatureCollection') {
                //geojson
                geojson = result;
            } else {
                //不支持数据
                failed && failed.call(context, Lang.i18n('msg_dataInWrongGeoJSONFormat'));
            }
            success && success.call(context, geojson);
        } else {
            failed && failed.call(context, Lang.i18n('msg_dataInWrongFormat'));
        }
    },
    /**
     * @function FileReaderUtil.prototype.processExcelDataToGeoJson
     * @description 表格文件数据处理。
     * @param {Object} data - 读取的表格文件数据。
     * @returns {GeoJSONObject} 返回标准 GeoJSON 规范格式数据。
     * @private
     */
    processExcelDataToGeoJson(data) {
        //处理为对象格式转化
        let dataContent = this.string2Csv(data);
        let fieldCaptions = dataContent.colTitles;

        //位置属性处理
        let xfieldIndex = -1,
            yfieldIndex = -1;
        for (let i = 0, len = fieldCaptions.length; i < len; i++) {
            if (this.isXField(fieldCaptions[i])) {
                xfieldIndex = i;
            }
            if (this.isYField(fieldCaptions[i])) {
                yfieldIndex = i;
            }
        }
        // feature 构建后期支持坐标系 4326/3857
        let features = [];
        for (let i = 0, len = dataContent.rows.length; i < len; i++) {
            let row = dataContent.rows[i];
            //if (featureFrom === "LonLat") {
            let x = Number(row[xfieldIndex]),
                y = Number(row[yfieldIndex]);

            //属性信息
            let attributes = {};
            for (let index in dataContent.colTitles) {
                let key = dataContent.colTitles[index];
                attributes[key] = dataContent.rows[i][index];
            }

            //目前csv 只支持处理点，所以先生成点类型的 geojson
            let feature = {
                "type": "Feature",
                "geometry": {
                    "type": "Point",
                    "coordinates": [x, y]
                },
                "properties": attributes
            };
            features.push(feature);
        }
        return features;
    },
    /**
     * @description 判断是否地理X坐标。
     * @param {string} data 字段名。
     */
    isXField(data) {
        var lowerdata = data.toLowerCase();
        return (lowerdata === "x" || lowerdata === "smx" ||
            lowerdata === "jd" || lowerdata === "经度" || lowerdata === "东经" || lowerdata === "longitude" ||
            lowerdata === "lot" || lowerdata === "lon" || lowerdata === "lng" || lowerdata === "x坐标");
    },

    /**
     * @description 判断是否地理Y坐标。
     * @param {string} data 字段名。
     */
    isYField(data) {
        var lowerdata = data.toLowerCase();
        return (lowerdata === "y" || lowerdata === "smy" ||
            lowerdata === "wd" || lowerdata === "纬度" || lowerdata === "北纬" ||
            lowerdata === "latitude" || lowerdata === "lat" || lowerdata === "y坐标");
    },
    /**
     * @description 字符串转为dataEditor 支持的csv格式数据。
     * @param {string} string 待转化的字符串。
     * @param {boolean} withoutTitle 是否需要列标题。
     */
    string2Csv(string, withoutTitle) {
        // let rows = string.split('\r\n');
        let rows = string.split('\n');
        let result = {};
        if (!withoutTitle) {
            result["colTitles"] = rows[0].split(',');
        } else {
            result["colTitles"] = [];
        }
        result['rows'] = [];
        for (let i = (withoutTitle) ? 0 : 1; i < rows.length; i++) {
            rows[i] && result['rows'].push(rows[i].split(','));
        }
        return result;
    }

};



;// CONCATENATED MODULE: ./src/common/components/chart/ChartModel.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/











/**
 * @class ChartModel
 * @classdesc 图表组件数据模型
 * @private
 * @param {Object} datasets - 数据来源。
 * @category Components Chart
 * @fires ChartModel#getdatafailed
 */

class ChartModel {
    constructor(datasets) {
        this.datasets = datasets;
        this.EVENT_TYPES = ['getdatafailed'];
        this.events = new Events(this, null, this.EVENT_TYPES);
    }
    /**
     * @private
     * @function ChartModel.prototype.getDatasetInfo
     * @description 获得数据集数据。
     * @param {string} datasetUrl - 数据集资源地址。
     */
    getDatasetInfo(success) {
        let datasetUrl = this.datasets.url;
        let me = this;
        FetchRequest.get(datasetUrl)
            .then(function (response) {
                return response.json();
            })
            .then(function (results) {
                if (results.datasetInfo) {
                    let datasetInfo = results.datasetInfo;
                    me.datasetsInfo = {
                        dataSourceName: datasetInfo.dataSourceName,
                        datasetName: datasetInfo.name,
                        mapName: results.name
                    };
                    success({
                        result: me.datasetsInfo
                    });
                }
            })
            .catch(function (error) {
                console.log(error);
                me._fireFailedEvent(error);
            });
    }

    /**
     * @private
     * @function ChartModel.prototype.getDataFeatures
     * @description 请求数据集的数据信息
     * @param {Object} results - 数据集信息。
     * @param {function} success - 成功回调函数。
     */
    getDataFeatures(results, success) {
        let datasetsInfo = results.result;
        let getFeatureParam, getFeatureBySQLParams, getFeatureBySQLService;
        let params = {
            name: datasetsInfo.datasetName + '@' + datasetsInfo.dataSourceName
        };
        Object.assign(params, this.datasets.queryInfo);
        getFeatureParam = new FilterParameter(params);
        getFeatureBySQLParams = new GetFeaturesBySQLParameters({
            queryParameter: getFeatureParam,
            datasetNames: [datasetsInfo.dataSourceName + ':' + datasetsInfo.datasetName],
            fromIndex: 0,
            toIndex: 100000
        });
        getFeatureBySQLService = new GetFeaturesBySQLService(datasetsInfo.dataUrl);
        getFeatureBySQLService.processAsync(getFeatureBySQLParams, success);
    }

    /**
     * @private
     * @function ChartModel.prototype.getLayerFeatures
     * @description 请求图层要素的数据信息
     * @param {Object} results - 数据集信息。
     * @param {Callbacks} success - 成功回调函数。
     */
    getLayerFeatures(results, success) {
        let datasetsInfo = results.result;
        let queryParam, queryBySQLParams, queryBySQLService;
        let params = {
            name: datasetsInfo.mapName
        };
        Object.assign(params, this.datasets.queryInfo);
        queryParam = new FilterParameter(params);
        queryBySQLParams = new QueryBySQLParameters({
            queryParams: [queryParam],
            expectCount: 100000
        });
        queryBySQLService = new QueryBySQLService(datasetsInfo.dataUrl);
        queryBySQLService.processAsync(queryBySQLParams, success);
    }

    /**
     * @private
     * @function ChartModel.prototype.getDataInfoByIptl
     * @description 用dataId获取iportal的数据。
     * @param {Callbacks} success - 成功回调函数。
     *
     */
    getDataInfoByIptl(success) {
        // success是chart的回调
        this.getServiceInfo(this.datasets.url, success);
    }

    /**
     * @private
     * @function ChartModel.prototype.getServiceInfo
     * @description 用iportal获取dataItemServices。
     * @param {string} url
     * @param {Callbacks} success - 成功回调函数。
     * */
    getServiceInfo(url, success) {
        let me = this;
        FetchRequest.get(url, null, {
            withCredentials: this.datasets.withCredentials
        })
            .then((response) => {
                return response.json();
            })
            .then((data) => {
                if (data.succeed === false) {
                    //请求失败
                    me._fireFailedEvent(data);
                    return;
                }
                // 是否有rest服务
                if (data.dataItemServices && data.dataItemServices.length > 0) {
                    let dataItemServices = data.dataItemServices,
                        resultData;

                    dataItemServices.forEach((item) => {
                        // 如果有restdata并且发布成功，就请求restdata服务
                        // 如果有restmap并且发布成功，就请求restmap服务
                        // 其他情况就请求iportal/content.json
                        if (item.serviceType === 'RESTDATA' && item.serviceStatus === 'PUBLISHED') {
                            resultData = item;
                        } else if (item.serviceType === 'RESTMAP' && item.serviceStatus === 'PUBLISHED') {
                            resultData = item;
                        } else {
                            me.getDatafromContent(url, success);
                            return;
                        }
                    });
                    // 如果有服务，获取数据源和数据集, 然后请求rest服务
                    resultData && me.getDatafromRest(resultData.serviceType, resultData.address, success);
                } else {
                    me.getDatafromContent(url, success);
                    return;
                }
            })
            .catch((error) => {
                console.log(error);
                me._fireFailedEvent(error);
            });
    }
    /**
     * @private
     * @function ChartModel.prototype.getDatafromURL
     * @description 用iportal获取数据。（通过固定的url来请求，但是不能请求工作空间的数据）
     * @param {string} url
     * @param {Callbacks} success - 成功回调函数。
     */
    getDatafromContent(url, success) {
        // 成功回调传入的results
        let results = {
                result: {}
            },
            me = this;
        url += '/content.json?pageSize=9999999&currentPage=1';
        // 获取图层数据
        FetchRequest.get(url, null, {
            withCredentials: this.datasets.withCredentials
        })
            .then((response) => {
                return response.json();
            })
            .then((data) => {
                if (data.succeed === false) {
                    //请求失败
                    me._fireFailedEvent(data);
                    return;
                }
                if (data.type) {
                    if (data.type === 'JSON' || data.type === 'GEOJSON') {
                        // 将字符串转换成json
                        data.content = JSON.parse(data.content.trim());
                        // 如果是json文件 data.content = {type:'fco', features},格式不固定
                        if (!data.content.features) {
                            //json格式解析失败
                            console.log(Lang.i18n('msg_jsonResolveFiled'));
                            return;
                        }
                        let features = this._formatGeoJSON(data.content);
                        results.result.features = {
                            type: data.content.type,
                            features
                        };
                    } else if (data.type === 'EXCEL' || data.type === 'CSV') {
                        let features = this._excelData2Feature(data.content);
                        results.result.features = {
                            type: 'FeatureCollection',
                            features
                        };
                    }
                    success(results, 'content');
                }
            }, this)
            .catch((error) => {
                console.log(error);
                me._fireFailedEvent(error);
            });
    }

    /**
     * @private
     * @function ChartModel.prototype._getDataSource
     * @description 获取数据源名和数据集名。
     * @param {string} serviceType 服务类型
     * @param {string} address 地址
     * @param {Callbacks} success - 成功回调函数。
     * @return {Array.<string>} ["数据源名:数据集名"]
     * @return {string} 图层名
     */
    getDatafromRest(serviceType, address, success) {
        let me = this,
            withCredentials = this.datasets.withCredentials;
        if (serviceType === 'RESTDATA') {
            let url = `${address}/data/datasources`,
                sourceName,
                datasetName;
            // 请求获取数据源名
            FetchRequest.get(url, null, {
                withCredentials
            })
                .then((response) => {
                    return response.json();
                })
                .then((data) => {
                    sourceName = data.datasourceNames[0];
                    url = `${address}/data/datasources/${sourceName}/datasets`;
                    // 请求获取数据集名
                    FetchRequest.get(url, null, {
                        withCredentials
                    })
                        .then((response) => {
                            return response.json();
                        })
                        .then((data) => {
                            datasetName = data.datasetNames[0];
                            // 请求restdata服务
                            me.getDatafromRestData(`${address}/data`, [sourceName + ':' + datasetName], success);
                            return [sourceName + ':' + datasetName];
                        })
                        .catch(function (error) {
                            me._fireFailedEvent(error);
                        });
                })
                .catch(function (error) {
                    me._fireFailedEvent(error);
                });
        } else {
            // 如果是地图服务
            let url = `${address}/maps`,
                mapName,
                layerName,
                path;
            // 请求获取地图名
            FetchRequest.get(url, null, {
                withCredentials
            })
                .then((response) => {
                    return response.json();
                })
                .then((data) => {
                    mapName = data[0].name;
                    path = data[0].path;
                    url = url = `${address}/maps/${mapName}/layers`;
                    // 请求获取图层名
                    FetchRequest.get(url, null, {
                        withCredentials
                    })
                        .then((response) => {
                            return response.json();
                        })
                        .then((data) => {
                            layerName = data[0].subLayers.layers[0].caption;
                            // 请求restmap服务
                            me.getDatafromRestMap(layerName, path, success);
                            return layerName;
                        })
                        .catch(function (error) {
                            me._fireFailedEvent(error);
                        });
                })
                .catch(function (error) {
                    me._fireFailedEvent(error);
                });
        }
    }

    /**
     * @private
     * @function ChartModel.prototype.getDatafromRestData
     * @description 请求restdata服务
     * @param {string} url
     * @param {Array<string>} dataSource [数据源名:数据集名]
     * @param {Callbacks} success - 成功回调函数。
     */
    getDatafromRestData(url, dataSource, success) {
        let me = this;
        this.datasets.queryInfo.attributeFilter = this.datasets.queryInfo.attributeFilter || 'SmID>0';
        this._getFeatureBySQL(
            url,
            dataSource,
            this.datasets.queryInfo,
            (results) => {
                // 此时的features已经处理成geojson了
                success(results, 'RESTDATA');
            },
            (error) => {
                console.log(error);
                me._fireFailedEvent(error);
            }
        );
    }

    /**
     * @private
     * @function ChartModel.prototype.getDatafromRestMap
     * @description 请求restmap服务
     * @param {string} dataSource layerName
     * @param {string} path - map服务地址。
     * @param {Callbacks} success - 成功回调函数。
     */
    getDatafromRestMap(dataSource, path, success) {
        let me = this;
        this.datasets.queryInfo.attributeFilter = this.datasets.queryInfo.attributeFilter || 'smid=1';
        this._queryFeatureBySQL(
            path,
            dataSource,
            this.datasets.queryInfo,
            null,
            null,
            (results) => {
                // let features = result.result.recordsets[0].features;
                success(results, 'RESTMAP');
            },
            (error) => {
                console.log(error);
                me._fireFailedEvent(error);
            }
        );
    }

    /**
     * @private
     * @function ChartModel.prototype._getFeatureBySQL
     * @description 通过 sql 方式查询数据。
     */
    _getFeatureBySQL(url, datasetNames, queryInfo, processCompleted, processFaild) {
        let getFeatureParam, getFeatureBySQLService, getFeatureBySQLParams;
        let params = {
            name: datasetNames.join().replace(':', '@')
        };
        Object.assign(params, queryInfo);
        getFeatureParam = new FilterParameter(params);
        getFeatureBySQLParams = new GetFeaturesBySQLParameters({
            queryParameter: getFeatureParam,
            datasetNames: datasetNames,
            fromIndex: 0,
            toIndex: 100000,
            returnContent: true
        });
        getFeatureBySQLService = new GetFeaturesBySQLService(url);
        getFeatureBySQLService.processAsync(getFeatureBySQLParams, function(getFeaturesEventArgs) {
          if (getFeaturesEventArgs.type === 'processCompleted') {
            processCompleted && processCompleted(getFeaturesEventArgs);
          } else {
            processFaild && processFaild(getFeaturesEventArgs);
          }
        });
    }

    /**
     * @private
     * @function ChartModel.prototype._queryFeatureBySQL
     * @description 通过 sql 方式查询数据。
     */
    _queryFeatureBySQL(
        url,
        layerName,
        queryInfo,
        fields,
        epsgCode,
        processCompleted,
        processFaild,
        startRecord,
        recordLength,
        onlyAttribute
    ) {
        var queryParam, queryBySQLParams;
        var filterParams = {
            name: layerName
        };
        Object.assign(filterParams, queryInfo);
        queryParam = new FilterParameter(filterParams);
        if (fields) {
            queryParam.fields = fields;
        }
        var params = {
            queryParams: [queryParam]
        };
        if (onlyAttribute) {
            params.queryOption = QueryOption.ATTRIBUTE;
        }
        startRecord && (params.startRecord = startRecord);
        recordLength && (params.expectCount = recordLength);
        if (epsgCode) {
            params.prjCoordSys = {
                epsgCode: epsgCode
            };
        }
        queryBySQLParams = new QueryBySQLParameters(params);
        this._queryBySQL(url, queryBySQLParams, (data) => {
            data.type === 'processCompleted' ? processCompleted(data) : processFaild(data);
        });
    }
    /**
     * @function ChartModel.prototype._queryBySQL
     * @description  SQL 查询服务。
     * @param {QueryBySQLParameters} params - SQL 查询相关参数类。
     * @param {RequestCallback} callback - 回调函数。
     * @param {DataFormat} [resultFormat=DataFormat.GEOJSON] - 结果类型。
     */
    _queryBySQL(url, params, callback, resultFormat) {
        var me = this;
        var queryBySQLService = new QueryBySQLService(url, {
            format: me._processFormat(resultFormat)
        });

        queryBySQLService.processAsync(params, callback);
    }
    /**
     * @function ChartModel.prototype._processFormat
     * @description 将数据转换成geojson。
     * @param {Object} resultFormat - 返回结果集。
     * @return {Object} [resultFormat=DataFormat.GEOJSON] - 结果类型。
     */
    _processFormat(resultFormat) {
        return resultFormat ? resultFormat : DataFormat.GEOJSON;
    }

    /**
     * @private
     * @function ChartModel.prototype._formatGeoJSON
     * @description 格式 GeoJSON。
     * @param {GeoJSON} data - GeoJSON 数据。
     */
    _formatGeoJSON(data) {
        let features = data.features;
        features.forEach((row, index) => {
            row.properties['index'] = index;
        });
        return features;
    }

    /**
     * @private
     * @description 将 csv 和 xls 文件内容转换成 geojson
     * @function ChartModel.prototype._excelData2Feature
     * @param content  文件内容
     * @param layerInfo  图层信息
     * @returns {Array}  feature的数组集合
     */
    _excelData2Feature(dataContent) {
        let fieldCaptions = dataContent.colTitles;
        //位置属性处理
        let xfieldIndex = -1,
            yfieldIndex = -1;
        for (let i = 0, len = fieldCaptions.length; i < len; i++) {
            if (FileReaderUtil.isXField(fieldCaptions[i])) {
                xfieldIndex = i;
            }
            if (FileReaderUtil.isYField(fieldCaptions[i])) {
                yfieldIndex = i;
            }
        }

        // feature 构建后期支持坐标系 4326/3857
        let features = [];

        for (let i = 0, len = dataContent.rows.length; i < len; i++) {
            let row = dataContent.rows[i];

            let x = Number(row[xfieldIndex]),
                y = Number(row[yfieldIndex]);
            //属性信息
            let attributes = {};
            for (let index in dataContent.colTitles) {
                let key = dataContent.colTitles[index];
                attributes[key] = dataContent.rows[i][index];
            }
            attributes['index'] = i + '';
            //目前csv 只支持处理点，所以先生成点类型的 geojson
            let feature = {
                type: 'Feature',
                geometry: {
                    type: 'Point',
                    coordinates: [x, y]
                },
                properties: attributes
            };
            features.push(feature);
        }
        return features;
    }
    /**
     * @private
     * @description 请求数据失败的事件
     * @function ChartModel.prototype._fireFailedEvent
     * @param {Object} error  错误信息
     */
    _fireFailedEvent(error) {
        let errorData = error
            ? {
                  error,
                  message: Lang.i18n('msg_getdatafailed')
              }
            : {
                  message: Lang.i18n('msg_getdatafailed')
              };
        /**
         * @event ChartModel#getdatafailed
         * @description 监听到获取数据失败事件后触发
         * @property {Object} error  - 事件对象。
         */
        this.events.triggerEvent('getdatafailed', errorData);
    }
}

;// CONCATENATED MODULE: ./src/common/components/chart/ChartViewModel.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/



/**
 * @class ChartViewModel
 * @aliasclass Components.ChartViewModel
 * @deprecatedclass SuperMap.Components.ChartViewModel
 * @classdesc 图表组件功能类。
 * @category Components Chart
 * @version 10.0.0
 * @param {Object} options - 可选参数。
 * @param {string} options.type - 图表类型。
 * @param {ChartView.Datasets} options.datasets - 数据来源。
 * @param {Array.<Object>} options.chartOptions - 图表可选配置。
 * @param {Array.<Object>} options.chartOptions.xAxis - X轴可选参数。
 * @param {string} options.chartOptions.xAxis.field - X轴字段名。
 * @param {string} options.chartOptions.xAxis.name - X轴名称。
 * @param {Array.<Object>} options.chartOptions.yAxis - Y轴可选参数。
 * @param {string} options.chartOptions.yAxis.field - Y轴字段名。
 * @param {string} options.chartOptions.yAxis.name - Y轴名称。
 * @fires ChartViewModel#getdatafailed
 * @usage
 */

class ChartViewModel {

    constructor(options) {
        this.datasets = options.datasets;
        this.xField = [];
        this.yField = [];
        this.grid = {
            top: "50px",
            bottom: "50px",
            left: "50px",
            right: "60px"
        };
        this.chartType = options.type || "bar";
        this._initXYField(options.chartOptions);
        this.EVENT_TYPES = ["getdatafailed"];
        this.events = new Events(this, null, this.EVENT_TYPES);
    }

    /**
     * @function ChartViewModel.prototype._initXYField
     * @description 初始化XY字段。
     * @private
     * @param {Object} chartOptions - options里的图表参数。
     */
    _initXYField(chartOptions) {
        let me = this;
        if (chartOptions && chartOptions.length > 0) {
            chartOptions.forEach(function (option) {
                if (option.xAxis) {
                    me.xField.push({
                        field: option.xAxis.field,
                        name: option.xAxis.name
                    });
                }
                if (option.yAxis) {
                    me.yField.push({
                        field: option.yAxis.field,
                        name: option.yAxis.name
                    });
                }
            });
        }
    }
    /**
     * @function ChartViewModel.prototype.getDatasetInfo
     * @description 获得数据集数据。
     * @param {function} success - 成功回调函数。
     */
    getDatasetInfo(success) {
        this.createChart = success;
        if (this.datasets && this._checkUrl(this.datasets.url)) {
            this.chartModel = new ChartModel(this.datasets);
            if(this.datasets.type === 'iServer'){
                this.chartModel.getDatasetInfo(this._getDatasetInfoSuccess.bind(this));
            }else if(this.datasets.type === 'iPortal'){
                this.chartModel.getDataInfoByIptl(this._getDataInfoSuccess.bind(this));
            }
            /**
             * @event ChartViewModel#getdatafailed
             * @description 监听到获取数据失败事件后触发。
             * @property {Object} error  - 事件对象。
             */
            this.chartModel.events.on({"getdatafailed":  (error) => {
                this.events.triggerEvent("getdatafailed", error)
            }});
        }
    }

    /**
     * @function ChartViewModel.prototype._getDatasetInfoSuccess
     * @description 成功回调函数。
     * @private
     * @param {Object} results - 数据集信息。
     */
    _getDatasetInfoSuccess(results) {
        let datasetUrl = this.datasets.url;
        //判断服务为地图服务 或者 数据服务
        let restIndex = datasetUrl.indexOf("rest");
        if (restIndex > 0) {
            let index = datasetUrl.indexOf("/", restIndex + 5);
            let type = datasetUrl.substring(restIndex + 5, index);
            let dataUrl = datasetUrl.substring(0, restIndex + 4) + "/data";

            if (type === "maps") {
                let mapIndex = datasetUrl.indexOf("/", index + 1);
                let mapName = datasetUrl.substring(index + 1, mapIndex);
                dataUrl = datasetUrl.substring(0, restIndex + 4) + "/maps/" + mapName;
                results.result.dataUrl = dataUrl;
                this._getLayerFeatures(results);
            } else if (type === "data") {
                results.result.dataUrl = dataUrl;
                this._getDataFeatures(results);
            }
        }
    }

    /**
     * @function ChartViewModel.prototype._getDataInfoSuccess
     * @description 请求iportal数据成功之后的回调。
     * @private
     */
    _getDataInfoSuccess(results, type) {
        let me = this;
        if(type === 'RESTMAP'){
            me._getChartDatasFromLayer(results);
        }else{
            me._getChartDatas(results);
        }
    }

    /**
     * @function ChartViewModel.prototype._getDataFeatures
     * @description 请求数据集的数据信息
     * @private
     * @param {Object} results - 数据集信息
     */
    _getDataFeatures(results) {
        this.chartModel.getDataFeatures(results, this._getChartDatas.bind(this));
    }

    /**
     * @function ChartViewModel.prototype._getLayerFeatures
     * @description 请求图层的数据信息。
     * @private
     * @param {Object} results - 数据集信息。
     */
    _getLayerFeatures(results) {
        this.chartModel.getLayerFeatures(results, this._getChartDatasFromLayer.bind(this));
    }

    /**
     * @function ChartViewModel.prototype._getChartDatas
     * @description 将请求回来的数据转换为图表所需的数据格式。
     * @private
     * @param {Object} results - 数据要素信息。
     */
    _getChartDatas(results) {
        if (results) {
            // 数据来自restdata---results.result.features
            this.features = results.result.features;
            let features = this.features.features;
            let data = {};
            if (features.length) {
                let feature = features[0];
                let attrFields = [],
                    itemTypes = [];
                for (let attr in feature.properties) {
                    attrFields.push(attr);
                    itemTypes.push(this._getDataType(feature.properties[attr]));
                }
                data = {
                    features,
                    fieldCaptions: attrFields,
                    fieldTypes: itemTypes,
                    fieldValues: []
                }
                for (let m in itemTypes) {
                    let fieldValue = [];

                    for (let j in features) {
                        let feature = features[j];
                        let caption = data.fieldCaptions[m];
                        let value = feature.properties[caption];
                        fieldValue.push(value);
                    }
                    data.fieldValues.push(fieldValue);
                }
                this.createChart(data);
            }
        }
    }
    /**
     * @function ChartViewModel.prototype._getChartDatasFromLayer
     * @description 将请求回来的数据转换为图表所需的数据格式。
     * @private
     * @param {Object} results - 图层数据要素信息。
     */
    _getChartDatasFromLayer(results) {
        if (results.result.recordsets) {
            let recordsets = results.result.recordsets[0];
            let features = recordsets.features.features;
            this.features = recordsets.features;
            let data = {};
            if (features.length) {
                data = {
                    features: recordsets.features,
                    fieldCaptions: recordsets.fieldCaptions,
                    fieldTypes: recordsets.fieldTypes,
                    fieldValues: []
                }
                for (let m in data.fieldCaptions) {
                    let fieldValue = [];

                    for (let j in features) {
                        let feature = features[j];
                        let caption = data.fieldCaptions[m];
                        let value = feature.properties[caption];
                        fieldValue.push(value);
                    }
                    data.fieldValues.push(fieldValue);
                }
                this.createChart(data);
            }
        }
    }

    /**
     * @function ChartViewModel.prototype._createChartOptions
     * @description 创建图表所需参数。
     * @private
     * @param {Object} data - 图表数据。
     */
    _createChartOptions(data) {
        this.calculatedData = this._createChartDatas(data);
        return this.updateChartOptions(this.chartType);
    }

    /**
     * @function ChartViewModel.prototype.changeType
     * @description 改变图表类型。
     * @param {string} type - 图表类型。
     */
    changeType(type) {
        if (type !== this.chartType) {
            this.chartType = type;
            return this.updateChartOptions(this.chartType);
        }
    }

    /**
     * @function ChartViewModel.prototype.updateData
     * @description 改变图表类型。
     * @param {ChartView.Datasets} datasets - 数据来源。
     * @param {function} success 成功回调函数。
     */
    updateData(datasets, chartOption, success) {
        this.updateChart = success;
        this.xField = [];
        this.yField = [];
        this._initXYField(chartOption);
        // type的设置默认值
        datasets.type = datasets.type || 'iServer';
        // withCredentials的设置默认值
        datasets.withCredentials = datasets.withCredentials || false;
        this.datasets = datasets;
        this.getDatasetInfo(this._updateDataSuccess.bind(this));
    }

    /**
     * @function ChartViewModel.prototype._updateDataSuccess
     * @description 改变图表类型。
     * @private
     * @param {Object} data - 图表数据。
     */
    _updateDataSuccess(data) {
        let options = this._createChartOptions(data);
        this.updateChart(options);
    }

    /**
     * @function ChartViewModel.prototype.updateChartOptions
     * @description 更新图表所需参数。
     * @param {string} type - 图表类型。
     * @param {Object} style - 图表样式。
     */
    updateChartOptions(type, style) {
        if (this.calculatedData) {
            let grid = this.grid;
            let series = this._createChartSeries(this.calculatedData, type);
            let datas = [];
            for (let i in this.calculatedData.XData) {
                datas.push({
                    value: this.calculatedData.XData[i].fieldsData
                });
            }
            let xAxis = {
                type: "category",
                name: this.xField[0].name || "X",
                data: datas,
                nameTextStyle: {
                    color: '#fff',
                    fontSize: 14
                },
                splitLine: {
                    show: false
                },
                axisLine: {
                    lineStyle: {
                        color: '#eee'
                    }
                }
            }
            let yAxis = {
                type: "value",
                name: this.yFieldName || "Y",
                data: {},
                nameTextStyle: {
                    color: '#fff',
                    fontSize: 14
                },
                splitLine: {
                    show: false
                },
                axisLine: {
                    lineStyle: {
                        color: '#eee'
                    }
                }
            }
            let tooltip = {
                formatter: '{b0}: {c0}'
            };
            let backgroundColor = '#404a59';
            if (style) {
                if (style.grid) {
                    grid = style.grid;
                }
                if (style.tooltip) {
                    tooltip = style.tooltip;
                }
                if (style.backgroundColor) {
                    backgroundColor = style.backgroundColor;
                }
            }
            return {
                backgroundColor: backgroundColor,
                grid: grid,
                series: series,
                xAxis: xAxis,
                yAxis: yAxis,
                tooltip: tooltip
            }
        }
    }

    /**
     * @function ChartViewModel.prototype._createChartDatas
     * @description 构建图表数据。
     * @private
     * @param {Object} data - 源数据。
     */
    _createChartDatas(data) {
        let fieldIndex = 0, yfieldIndexs = [];
        let fieldCaptions = data.fieldCaptions;
        let me = this;
        //X
        fieldCaptions.forEach(function (field, index) {
            if (me.xField[0] && field === me.xField[0].field) {
                fieldIndex = index;
            }
        });
        //Y
        this.yFieldName = "";
        this.yField.forEach(function (value, index) {
            if (index !== 0) {
                me.yFieldName = me.yFieldName + ",";
            }
            me.yFieldName = me.yFieldName + value.name;
            fieldCaptions.forEach(function (field, index) {
                if (field === value.field) {
                    yfieldIndexs.push(index);
                }
            });
        })
        let datas = this._getAttrData(data, fieldIndex);
        let yDatas = [];
        if (yfieldIndexs.length > 0) {
            yfieldIndexs.forEach(function (yfieldIndex) {
                let yData = [];
                for (let i in data.fieldValues[yfieldIndex]) {
                    yData.push({
                        value: data.fieldValues[yfieldIndex][i]
                    });
                }
                yDatas.push(yData);
            });
        } else {                     //未指定Y字段时，y轴计数
            let YData = [],
                XData = [],
                len = datas.length;

            //计算X轴，Y轴数据，并去重
            for (let i = 0; i < len; i++) {
                let isSame = false;
                for (let j = 0, leng = XData.length; j < leng; j++) {
                    if (datas[i].fieldsData === XData[j].fieldsData) {
                        YData[j].value++;
                        XData[j].recordIndexs.push(i);
                        isSame = true;
                        break;
                    }
                }
                if (!isSame) {
                    if (datas[i].fieldsData) {
                        XData.push({ fieldsData: datas[i].fieldsData, recordIndexs: [i] });
                        YData.push({ value: 1 });
                    }
                }
            }
            datas = XData;
            yDatas = [YData];
        }
        return {
            XData: datas,
            YData: yDatas
        }
    }

    /**
     * @function ChartViewModel.prototype._getAttrData
     * @description 选中字段数据。
     * @private
     * @param {Object} datacontent - 图表数据。
     * @param {number} index - 字段索引。
     */
    _getAttrData(datacontent, index) {
        if (index === 0) {
            this.xField = [{
                field: datacontent.fieldCaptions[index],
                name: datacontent.fieldCaptions[index]
            }];
        }
        let fieldsDatas = [];
        for (let i = 0, len = datacontent.fieldValues[index].length; i < len; i++) {
            let value = datacontent.fieldValues[index][i];
            fieldsDatas.push({
                recordIndexs: i,
                fieldsData: value
            });
        }
        return fieldsDatas;
    }

    /**
     * @function ChartViewModel.prototype._createChartSeries
     * @description 图表数据。
     * @private
     * @param {Object} calculatedData - 图表数据。
     * @param {string} chartType - 图表类型。
     */
    _createChartSeries(calculatedData, chartType) {
        let series = [];
        let yDatas = calculatedData.YData;
        yDatas.forEach(function (yData) {
            let value = 0;
            let serieData = [];
            for (let data of yData) {
                value = data.value;
                serieData.push({
                    value: value
                });
            }
            let serie = {
                type: chartType,
                data: serieData,
                name: "y"
            };

            series.push(serie);
        });
        return series;
    }

    /**
     * @function ChartViewModel.prototype._isDate
     * @description 判断是否为日期。
     * @private
     * @param {string} data - 字符串。
     */
    _isDate(data) {
        let reg = /((^((1[8-9]\d{2})|([2-9]\d{3}))([-\/\._])(10|12|0?[13578])([-\/\._])(3[01]|[12][0-9]|0?[1-9])$)|(^((1[8-9]\d{2})|([2-9]\d{3}))([-\/\._])(11|0?[469])([-\/\._])(30|[12][0-9]|0?[1-9])$)|(^((1[8-9]\d{2})|([2-9]\d{3}))([-\/\._])(0?2)([-\/\._])(2[0-8]|1[0-9]|0?[1-9])$)|(^([2468][048]00)([-\/\._])(0?2)([-\/\._])(29)$)|(^([3579][26]00)([-\/\._])(0?2)([-\/\._])(29)$)|(^([1][89][0][48])([-\/\._])(0?2)([-\/\._])(29)$)|(^([2-9][0-9][0][48])([-\/\._])(0?2)([-\/\._])(29)$)|(^([1][89][2468][048])([-\/\._])(0?2)([-\/\._])(29)$)|(^([2-9][0-9][2468][048])([-\/\._])(0?2)([-\/\._])(29)$)|(^([1][89][13579][26])([-\/\._])(0?2)([-\/\._])(29)$)|(^([2-9][0-9][13579][26])([-\/\._])(0?2)([-\/\._])(29)$))/ig;
        return reg.test(data);
    }

    /**
     * @function ChartViewModel.prototype._isNumber
     * @description 判断是否为数值。
     * @private
     * @param {string} data - 字符串。
     */
    _isNumber(data) {
        let mdata = Number(data);
        if (mdata === 0) {
            return true;
        }
        return !isNaN(mdata);
    }

    /**
     * @function ChartViewModel.prototype._getDataType
     * @description 判断数据的类型。
     * @private
     * @param {string} data - 字符串。
     */
    _getDataType(data) {
        if (data !== null && data !== undefined && data !== '') {
            if (this._isDate(data)) {
                return "DATE";
            }
            if (this._isNumber(data)) {
                return "NUMBER";
            }
        }
        return "STRING";
    }

    /**
     * @function ChartViewModel.prototype._checkUrl
     * @description 检查url是否符合要求。
     * @private
     * @param {string} url。
     */
    _checkUrl(url) {
        let match;
        if (url === '' || !this._isMatchUrl(url)) {
            match = false;
        } else if (/^http[s]?:\/\/localhost/.test(url) || /^http[s]?:\/\/127.0.0.1/.test(url)) {
            //不是实际域名
            match = false;
        } else {
            match = true;
        }
        return match;
    }

    /**
     * @function ChartViewModel.prototype._isMatchUrl
     * @description 判断输入的地址是否符合地址格式。
     * @private
     * @param {string} str - url。
     */
    _isMatchUrl(str) {
        var reg = new RegExp('(https?|http|file|ftp)://[-A-Za-z0-9+&@#/%?=~_|!:,.;]+[-A-Za-z0-9+&@#/%=~_|]');
        return reg.test(str);
    }

    /**
     * @function ChartViewModel.prototype.getStyle
     * @description 获取图表样式。
     */
    getStyle() {
        let style = {
            grid: this.grid,
            tooltip: this.tooltip,
            backgroundColor: this.backgroundColor
        }
        return style;
    }

    /**
     * @function ChartViewModel.prototype.getFeatures
     * @description 获取地图服务，数据服务请求返回的数据。
     */
    getFeatures() {
        return this.features;
    }

    /**
     * @function ChartViewModel.prototype.setStyle
     * @description 设置图表样式。
     * @param {Object} style - 图表样式
     */
    setStyle(style) {
        return this.updateChartOptions(this.chartType, style);
    }
}

;// CONCATENATED MODULE: ./src/common/components/chart/ChartView.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/




/**
 * @class ChartView
 * @aliasclass Components.ChartView
 * @deprecatedclass SuperMap.Components.Chart
 * @classdesc 图表组件。
 * @modulecategory Components
 * @version 9.1.2
 * @param {string} domID - 图表dom元素ID。
 * @param {Object} options - 可选参数。
 * @param {string} options.type - 图表类型。
 * @param {ChartView.Datasets} options.datasets - 数据来源。
 * @param {Array.<Object>} options.chartOptions - 图表可选参数。
 * @param {Array.<Object>} options.chartOptions.xAxis - 图表X轴。
 * @param {string} options.chartOptions.xAxis.field - 图表X轴字段名。
 * @param {string} options.chartOptions.xAxis.name - 图表X轴名称。
 * @param {Array.<Object>} options.chartOptions.yAxis - 图表Y轴。
 * @param {string} options.chartOptions.yAxis.field - 图表Y轴字段名。
 * @param {string} options.chartOptions.yAxis.name - 图表Y轴名称。
 * @category Components Chart
 * @usage
 */
/**
 * @typedef {Object} ChartView.Datasets  - 数据来源。
 * @property {string} [type = 'iServer'] - 服务类型 iServer, iPortal。
 * @property {string} url - 服务地址。
 * @property {boolean} [withCredentials = false] - 设置请求是否带cookie。
 * @property {FilterParameter} queryInfo - 查询条件。
 */
class ChartView {

    constructor(domID, options) {
        this.domID = domID;
        this.chartType = options.type || "bar";
        // 设置options.datasets.type的默认值是iServer
        options.datasets.type = options.datasets.type || 'iServer';
        // 设置withCredentials的默认值为false
        options.datasets.withCredentials = options.datasets.withCredentials || false;
        this.viewModel = new ChartViewModel(options);
        //添加控件。
        this._fillDataToView();
    }

    /**
     * @function ChartView.prototype.onAdd
     * @description 创建图表之后成功回调。
     * @param {function} addChart - 回调函数。
     */
    onAdd(addChart) {
        this.addChart = addChart;
    }

    /**
     * @function ChartView.prototype._fillDataToView
     * @description 填充数据到 view。
     * @private
     */
    _fillDataToView() {
        let messageboxs = new MessageBox();
        //iclient 绑定createChart事件成功回调
        this.viewModel.getDatasetInfo(this._createChart.bind(this));
        this.viewModel.events.on({
            "getdatafailed": (error) => {
                messageboxs.showView(error.message);
            }
        });
    }

    /**
     * @function ChartView.prototype.getStyle
     * @description 获取图表样式。
     */
    getStyle() {
        return this.viewModel.getStyle()
    }

    /**
     * @function ChartView.prototype.getFeatures
     * @description 获取地图服务，数据服务请求返回的数据。
     */
    getFeatures() {
        return this.viewModel.getFeatures();
    }

    /**
     * @function ChartView.prototype.setStyle
     * @description 设置图表样式。
     * @param {Object} style - 图表样式，参考Echarts-options样式设置。
     */
    setStyle(style) {
        let newOptions = this.viewModel.setStyle(style);
        this._updateChart(newOptions);
    }

    /**
     * @function ChartView.prototype.changeType
     * @description 改变图表类型。
     * @param {string} type - 图表类型。
     */
    changeType(type) {
        if (this.chartType !== type) {
            this.chartType = type;
            let newOptions = this.viewModel.changeType(type);
            this._updateChart(newOptions);
        }
    }

    /**
     * @function ChartView.prototype.updateData
     * @description 更新图表数据。
     * @param {ChartView.Datasets} datasets - 数据来源。
     * @param {Object} chartOption - X,Y轴信息。
     */
    updateData(datasets, chartOption) {
        let me = this;
        this.viewModel.updateData(datasets, chartOption, function (options) {
            me._updateChart(options);
            if (me.addChart) {
                me.addChart();
            }
        });
    }

    /**
     * @function ChartView.prototype._createChart
     * @description 创建图表。
     * @private
     * @param {Object} data - 图表数据。
     */
    _createChart(data) {
        this.echart = external_function_try_return_echarts_catch_e_return_namespaceObject.init(
            document.getElementById(this.domID),
            null, {
                renderer: "canvas"
            }
        )
        let options = this.viewModel._createChartOptions(data);
        this.echart.setOption(options);
        if (this.addChart) {
            this.addChart();
        }
    }

    /**
     * @function ChartView.prototype._updateChart
     * @description 更新图表。
     * @private
     * @param {Object} options - 图表参数。
     */
    _updateChart(options) {
        if (this.echart) {
            this.echart.clear();
            this.echart.setOption(options);
        }
    }
}

;// CONCATENATED MODULE: ./src/common/components/templates/TemplateBase.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/

/**
 * @class TemplateBase
 * @aliasclass Components.TemplateBase
 * @deprecatedclass SuperMap.Components.TemplateBase
 * @classdesc 组件公用组件父类，用于约束统一封装的公用组件结构。
 * @version 9.1.1
 * @param {Object} options - 组件配置参数。
 * @param {string} options.id - 组件 dom 元素 id。
 * @category Components Common
 * @usage
 */
class TemplateBase {
    constructor(options) {
        options = options ? options : {};
        /**
         * @member {string} [TemplateBase.prototype.id=null]
         * @description  组件 dom 元素 id。
         */
        this.id = options.id ? options.id : null;

        /**
         * @member {HTMLElement} [TemplateBase.prototype.rootContainer=null]
         * @description  组件 dom 元素对象。
         */
        this.rootContainer = null;
    }

    /**
     * @function TemplateBase.prototype.getElement
     * @description 获取当前组件元素对象。
     * @return {HTMLElement} 组件 dom 元素对象
     */
    getElement() {
        //todo 其实感觉再这里给组件设置不太合理
        if (this.id) {
            this.rootContainer.id = this.id;
        }

        return this.rootContainer;
    }

    /**
     * @function TemplateBase.prototype._initView
     * @private
     * @description 初始化模板。
     */
    _initView() {
        //子类实现此方法
    }

    /**
     * @function TemplateBase.prototype.showView
     * @description 显示组件。
     */
    showView() {
        this.rootContainer.hidden = false;
    }

    /**
     * @function TemplateBase.prototype.closeView
     * @description 隐藏组件。
     */
    closeView() {
        this.rootContainer.hidden = true;
    }
}

;// CONCATENATED MODULE: ./src/common/components/templates/CommonContainer.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


/**
 * @class CommonContainer
 * @aliasclass Components.CommonContainer
 * @deprecatedclass SuperMap.Components.CommonContainer
 * @classdesc 组件统一外框。
 * @version 9.1.1
 * @param {Object} options - 组件配置参数。
 * @param {string} options.id - 组件 dom 元素 id。
 * @param {string} options.title - 标题。
 * @category Components Common
 * @extends {TemplateBase}
 * @usage
 */
class CommonContainer extends TemplateBase {
    constructor(options) {
        super(options);
        let title = options.title ? options.title : "";
        this._initView(title);
    }

    /**
     * @private
     * @override
     */
    _initView(title) {
        const container = document.createElement("div");
        container.setAttribute("class", "component-container");

        //title
        const titleContainer = document.createElement("div");
        titleContainer.setAttribute("class", "component-title");
        const titleContent = document.createElement("div");
        titleContent.innerHTML = title;
        titleContainer.appendChild(titleContent);
        container.appendChild(titleContainer);
        //container
        const componentContent = document.createElement("div");
        componentContent.setAttribute("class", "component-content");
        container.appendChild(componentContent);
        this.content = componentContent;

        this.rootContainer = container;
        return container;
    }

    /**
     * @function CommonContainer.prototype.getContentElement
     * @description 获取内容元素容器。
     */
    getContentElement() {
        return this.content;
    }

    /**
     * @function CommonContainer.prototype.appendContent
     * @description 填充内容元素。
     */
    appendContent(element) {
        this.content.appendChild(element);
    }
}

;// CONCATENATED MODULE: ./src/common/components/templates/Select.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


/**
 * @class Select
 * @aliasclass Components.Select
 * @deprecatedclass SuperMap.Components.Select
 * @classdesc 组件统一的文字下拉框。
 * @version 9.1.1
 * @param {Array.<string|Array>} options - 组件配置参数数组。
 * @param {string} options.id - 组件 dom 元素 id。
 * @param {string} [options.labelName] - label 名称。
 * @param {Array.<string>} options.optionsArr - 需要创建的 option 数据数组。
 * @param {function} [options.optionsClickCb] - option 点击事件回调函数。
 * @extends {TemplateBase}
 * @category Components Common
 * @usage
 */
class Select extends TemplateBase {
    constructor(options) {
        super(options);
        this._initView(options);
    }

    _initView(options) {
        let selectTool = this._createElement('div', "component-selecttool");

        if (options.labelName) {
            let label = this._createElement('label', 'component-selecttool__lable--describe', selectTool);
            label.innerHTML = options.labelName;
        }

        let chartSelect = this._createElement('div', 'component-selecttool--chart', selectTool);
        chartSelect.setAttribute('tabindex', '1');

        let selectName = this._createElement('div', "component-selecttool__name", chartSelect);
        selectName.title = options.optionsArr[0];
        selectName.innerHTML = options.optionsArr[0];

        let chartTriangleBtn = this._createElement('div', 'component-selecttool__trianglebtn--chart', chartSelect);
        let triangleBtn = this._createElement('div', 'component-triangle-down-img', chartTriangleBtn);
        let selectContent = this._createElement('div', 'component-selecttool__content', chartSelect);
        let scrollarea = this._createElement('div', 'component-selecttool__content--chart', selectContent);
        let scrollareaContent = this._createElement('div', 'component-selecttool__scrollarea__content', scrollarea);
        scrollareaContent.setAttribute('tabindex', '1');
        this.createOptions(scrollareaContent, options.optionsArr);
        this.optionClickEvent(scrollareaContent, selectName, options.optionsClickCb);
        // 下拉框显示 & 隐藏事件
        this._selectClickEvent(chartSelect, selectContent, triangleBtn);
        this.rootContainer = selectTool;
    }

    /**
     * @function Select.prototype.createOptions
     * @description 创建所属下拉框选项。
     */
    createOptions(container, optionsArr) {
        for (let i in optionsArr) {
            let option = this._createElement('div', 'component-selecttool__option', container);
            option.title = optionsArr[i];
            option.innerHTML = optionsArr[i];
        }
    }

    /**
     * @function Select.prototype._selectClickEvent
     * @description select 点击显示&隐藏事件。
     * @private
     */
    _selectClickEvent(eventElement, contentElement, triangleBtn) {
        eventElement.onclick = function (e) {
            if (contentElement.style.display === "block") {
                contentElement.style.display = "none";
                triangleBtn.className = "component-triangle-down-img";
            } else {
                contentElement.style.display = "block";
                triangleBtn.className = "triangle-up-img";
            }
            e.preventDefault();
            e.stopPropagation();
        };
        eventElement.onmousedown = function (evt) {
            //console.log('dropdownbox onmousedown '+evt.target.className);
            if (evt.target !== this) {
                this.focus();
                evt.preventDefault();
                evt.stopPropagation()
            }
        };
        eventElement.onblur = function () {

            contentElement.style.display = "none";
            triangleBtn.className = "component-triangle-down-img";
        }
    }

    /**
     * @function Select.prototype._createElement
     * @description 通用创建元素。
     * @private
     */
    _createElement(tagName, className, parentEle) {
        let ele = document.createElement(tagName || 'div');
        className && (ele.className = className);
        parentEle && parentEle.appendChild(ele);
        return ele;
    }

    /**
     * @function Select.prototype.optionClickEvent
     * @description 下拉框的 option 的点击事件。
     */
    optionClickEvent(optionEleArr, selectNameEle, optionsClickCb) {
        for (let i = 0; i < optionEleArr.children.length; i++) {
            let childEle = optionEleArr.children[i];
            childEle.onclick = function () {
                selectNameEle.innerHTML = childEle.innerHTML;
                selectNameEle.title = childEle.title;
                if (childEle.getAttribute('data-value')) {
                    selectNameEle.setAttribute('data-value', childEle.getAttribute('data-value'))
                }
                optionsClickCb && optionsClickCb(childEle);
            }
        }
    }
}

;// CONCATENATED MODULE: ./src/common/components/templates/DropDownBox.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


/**
 * @class DropDownBox
 * @aliasclass Components.DropDownBox
 * @deprecatedclass SuperMap.Components.DropDownBox
 * @classdesc 组件统一的图片下拉框。
 * @version 9.1.1
 * @param {Array.<Object>} options - 组件配置参数数组。
 * @param {string} options.id - 组件 dom 元素 id。
 * @param {string} options.title - 下拉框 title。
 * @param {string} options.remark - 下拉框解释标记文本。
 * @param {string} [options.dataValue] - 下拉框 attribute 名为 data-value 的值 。
 * @param {string} [options.icon] - 下拉框图标。
 * @param {string} [options.icon.className] - 下拉框图标类名。
 * @param {string} [options.icon.background] - 下拉框图标背景 url。
 * @category Components Common
 * @extends {TemplateBase}
 * @usage
 */
class DropDownBox extends TemplateBase {
    constructor(optionsArr) {
        super(optionsArr);
        this._initView(optionsArr);
    }

    /**
     * @function DropDownBox.prototype._initView
     * @description 初始化下拉框。
     * @private
     * @override
     */
    _initView(optionsArr) {
        let dropDownContainer = document.createElement('div');
        dropDownContainer.className = 'component-dropdownbox--container';
        let dropDownBox = document.createElement('div');
        dropDownBox.setAttribute('tabindex', '1');
        dropDownBox.className = "component-dropdownbox";
        dropDownContainer.appendChild(dropDownBox);

        let dropDownTopContainer = document.createElement('div');
        dropDownBox.appendChild(dropDownTopContainer);

        this._createDropDownOption(optionsArr[0], dropDownTopContainer);

        let triangleBtnContainer = document.createElement('div');
        triangleBtnContainer.className = 'component-dropdownbox__triangle-btn';
        dropDownBox.appendChild(triangleBtnContainer);

        let triangleBtn = document.createElement('div');
        triangleBtn.className = 'component-triangle-down-img';
        triangleBtnContainer.appendChild(triangleBtn);

        let createDropDownBoxParam = {
            "parentEle": dropDownBox,
            "dropDownContent": ['component-dropdownbox__content component-dropdownbox__content--chart', 'dropDownContent'],
            "scrollareaContent": 'component-selecttool__scrollarea__content',
            "optionsArr": optionsArr,
            "triangleBtn": triangleBtn,
            "dropDownTopContainer": dropDownTopContainer
        };
        this._createDropDownBox(createDropDownBoxParam);

        this.rootContainer = dropDownContainer;

    }

    /**
     * @function DropDownBox.prototype._createDropDownBox
     * @description 创建下拉框。
     * @private
     */
    _createDropDownBox(createDropDownBoxParam) {
        let dropDownBox = createDropDownBoxParam.parentEle;
        let dropDownTopContainer = createDropDownBoxParam.dropDownTopContainer;
        let dropDownContent = document.createElement('div');
        dropDownContent.className = createDropDownBoxParam.dropDownContent[0];
        dropDownBox.appendChild(dropDownContent);

        let scrollareaContent = document.createElement('div');
        scrollareaContent.className = createDropDownBoxParam.scrollareaContent;
        dropDownContent.appendChild(scrollareaContent);

        let optionsArr = createDropDownBoxParam.optionsArr;
        for (let i = 0; i < optionsArr.length; i++) {
            this._createDropDownOption(optionsArr[i], scrollareaContent)
        }
        // 下拉框显示 & 隐藏事件
        let triangleBtn = createDropDownBoxParam.triangleBtn;
        this._dropDownClickEvent(dropDownBox, dropDownContent, triangleBtn);

        this._eleOnblur(dropDownBox, dropDownContent, triangleBtn);

        // 下拉框 options 点击事件
        let scrollareaOptions = scrollareaContent.children;
        for (let i = 0; i < scrollareaOptions.length; i++) {
            scrollareaOptions[i].onclick = function () {
                dropDownTopContainer.innerHTML = scrollareaOptions[i].outerHTML;
                //evt.stopPropagation();
            }
        }
    }

    /**
     * @function DropDownBox.prototype._createDropDownOption
     * @description 创建下拉框子元素。
     * @private
     */
    _createDropDownOption(data, parentElement) {
        let ele = document.createElement('div');
        ele.className = 'component-dropdownbox__item';
        let dataItem = data;
        if (dataItem['dataValue']) {
            ele.setAttribute('data-value', dataItem['dataValue']);
        }
        parentElement.appendChild(ele);

        let imgContainer = document.createElement('div');
        imgContainer.className = 'component-dropdownbox__item__img';
        ele.appendChild(imgContainer);

        let img = document.createElement('div');
        if (dataItem.icon.className) {
            img.className = dataItem.icon.className;
        }
        if (dataItem.icon.background) {
            img.style.background = dataItem.icon.background;
        }
        imgContainer.appendChild(img);

        let title = document.createElement('div');
        title.className = 'component-dropdownbox__item__title';
        title.title = dataItem.title;
        title.innerHTML = dataItem.title;
        ele.appendChild(title);

        let remark = document.createElement('div');
        remark.className = 'component-dropdownbox__item__remark';
        remark.title = dataItem.remark;
        remark.innerHTML = dataItem.remark;
        ele.appendChild(remark);
    }

    /**
     * @function DropDownBox.prototype._dropDownClickEvent
     * @description 下拉框点击事件。
     * @private
     */
    _dropDownClickEvent(eventElement, contentElement, triangleBtn) {
        eventElement.onclick = function (e) {
            if (contentElement.style.display === "block") {
                contentElement.style.display = "none";
                triangleBtn.className = "component-triangle-down-img";
            } else {
                contentElement.style.display = "block";
                triangleBtn.className = "triangle-up-img";
            }
            e.preventDefault();
            e.stopPropagation()
        };
        eventElement.onmousedown = function (evt) {
            //console.log('dropdownbox onmousedown '+evt.target.className);
            if (evt.target !== this) {
                this.focus();
                evt.preventDefault();
                evt.stopPropagation()
            }
        }
    }

    /**
     * @function DropDownBox.prototype._eleOnblur
     * @description 下拉框失焦事件。
     * @private
     */
    _eleOnblur(eventElement, contentElement, triangleBtn) {
        eventElement.onblur = function () {
            contentElement.style.display = "none";
            triangleBtn.className = "component-triangle-down-img";
        }
    }

    /**
     * @function DropDownBox.prototype._createElement
     * @description 通用创建元素。
     * @private
     */
    _createElement(tagName, className, parentEle) {
        let ele = document.createElement(tagName || 'div');
        className && (ele.className = className);
        parentEle && parentEle.appendChild(ele);
        return ele;
    }

}


;// CONCATENATED MODULE: ./src/common/components/templates/PopContainer.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


/**
 * @class PopContainer
 * @aliasclass Components.PopContainer
 * @deprecatedclass SuperMap.Components.PopContainer
 * @classdesc 弹框组件。
 * @version 9.1.1
 * @param {Object} options - 组件配置参数。
 * @param {string} options.id - 组件 dom 元素 id。
 * @param {string} options.title - 弹框组件名称。
 * @extends {TemplateBase}
 * @category Components Common
 * @usage
 */
class PopContainer extends TemplateBase {
    constructor(options) {
        options = options ? options : {};
        super(options);
        options.title = options.title ? options.title : "";
        this._initView(options.title);
    }

    /**
     * @private
     * @override
     */
    _initView(titile) {
        const container = document.createElement("div");
        container.setAttribute("class", "component-popcontainer");

        //header
        const header = document.createElement("div");
        header.setAttribute("class", "component-popcontainer__header");
        const title = document.createElement("label");
        title.setAttribute("class", "component-popcontainer__header__title");
        title.innerHTML = titile;
        header.appendChild(title);

        const closeBtn = document.createElement("span");
        closeBtn.setAttribute("class", "supermapol-icons-clear component-popcontainer__header__close");
        closeBtn.onclick = this.closeView.bind(this);
        container.appendChild(closeBtn);
        container.appendChild(header);

        //content
        const content = document.createElement("div");
        content.setAttribute("class", "component-popcontainer__content");
        this.content = content;

        container.appendChild(content);

        this.rootContainer = container;

    }

    /**
     * @function PopContainer.prototype.appendContent
     * @description 追加内容。
     * @param {HTMLElement} dom - 内容元素。
     */
    appendContent(dom) {
        this.content.appendChild(dom);
    }

}

;// CONCATENATED MODULE: ./src/common/components/templates/AttributesPopContainer.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


/**
 * @class AttributesPopContainer
 * @aliasclass Components.AttributesPopContainer
 * @deprecatedclass SuperMap.Components.AttributesPopContainer
 * @classdesc 属性弹框组件
 * @version 9.1.1
 * @param {Object} options - 组件配置参数。
 * @param {string} options.id - 组件 dom 元素 id。
 * @param {Object} options.title - 属性弹框组件名称。
 * @param {Object} options.attributes - 组件需要显示的属性内容。
 * @extends {PopContainer}
 * @category Components Common
 * @usage
 */
class AttributesPopContainer extends PopContainer {
    constructor(options) {
        //默认为属性：
        options.title = options.title ? options.title : "属性";

        super(options);
        this.rootContainer.firstChild.hidden = true;
        options.attributes = options.attributes ? options.attributes : [];
        this._createAttributesTable(options.attributes);
    }

    _createAttributesTable(attributes) {
        const table = document.createElement("table");
        table.setAttribute("class", "component-popcontainer__content__table");

        const tbody = document.createElement("tbody");

        let single = true;
        for (let name in attributes) {
            const tr = document.createElement("tr");
            if (single) {
                tr.setAttribute("class", "component-popcontainer__content__td--color");
            }
            const title = document.createElement("td");
            const titleSpan = document.createElement("Span");
            titleSpan.innerHTML = name;
            title.appendChild(titleSpan);
            const value = document.createElement("td");
            value.innerHTML = attributes[name];

            tr.appendChild(title);
            tr.appendChild(value);
            tbody.appendChild(tr);
            single = !single;
        }
        table.appendChild(tbody);

        this.appendContent(table);
    }
}

;// CONCATENATED MODULE: ./src/common/components/templates/IndexTabsPageContainer.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


/**
 * @class IndexTabsPageContainer
 * @aliasclass Components.IndexTabsPageContainer
 * @deprecatedclass SuperMap.Components.IndexTabsPageContainer
 * @classdesc 标签索引组件。
 * @version 9.1.1
 * @param {Object} options - 组件配置参数。
 * @param {string} options.id - 组件 dom 元素 id。
 * @category Components Common
 * @extends {TemplateBase}
 * @usage
 */
class IndexTabsPageContainer extends TemplateBase {
    constructor(options) {
        super(options);
        this._initView();
    }

    /**
     * @private
     * @override
     */
    _initView() {
        const container = document.createElement("div");
        container.setAttribute("class", "component-tabpage");

        const header = document.createElement("ul");
        this.header = header;

        const content = document.createElement("div");
        content.setAttribute("class", "component-tabpage__content");
        this.content = content;

        container.appendChild(header);
        container.appendChild(content);
        this.rootContainer = container;

    }

    /**
     * @function IndexTabsPageContainer.prototype.setTabs
     * @description 设置标签元素。
     * @param {Array.<HTMLElement>} tabs
     */
    setTabs(tabs) {
        this.removeAllTabs();
        this.appendTabs(tabs);
    }

    /**
     * @function IndexTabsPageContainer.prototype.appendTabs
     * @description 追加标签元素。
     * @param {Array.<HTMLElement>} tabs
     */
    appendTabs(tabs) {
        for (let i = 0; i < tabs.length; i++) {
            let title = document.createElement("span");
            title.index = i;
            title.appendChild(document.createTextNode(tabs[i].title));
            //绑定标签切换对应页面：
            title.onclick = this._changeTabsPage.bind(this);
            let content = tabs[i].content;
            content.index = i;
            content.hidden = true;

            this.header.appendChild(title);
            this.content.appendChild(content);
        }
        //todo 确认是否两个子元素的 index 相互对应
        //默认显示第一个标签对象
        this.header.firstChild.setAttribute("class", "on");
        this.content.firstChild.hidden = false;
    }

    /**
     * @function IndexTabsPageContainer.prototype.removeTab
     * @description 删除某个标签页面。
     * @param {number} index - 标签索引号。
     */
    removeTab(index) {
        this.header.removeChild(this.header.children[index]);
        this.content.removeChild(this.content.children[index]);
    }

    /**
     * @function IndexTabsPageContainer.prototype.removeAllTabs
     * @description 删除所有标签。
     */
    removeAllTabs() {
        for (let i = this.header.children.length; i > 0; i--) {
            this.header.removeChild(this.header.children[i]);
            this.content.removeChild(this.content.children[i]);
        }
    }

    _changeTabsPage(e) {
        const index = e.target.index;
        for (let i = 0; i < this.header.children.length; i++) {
            this.header.children[i].setAttribute("class", "");
            this.content.children[i].hidden = true;
            if (i === index) {
                this.header.children[i].setAttribute("class", "on");
                this.content.children[i].hidden = false;
            }
        }
    }

}

;// CONCATENATED MODULE: ./src/common/components/templates/CityTabsPage.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/



/**
 * @class CityTabsPage
 * @aliasclass Components.CityTabsPage
 * @deprecatedclass SuperMap.Components.CityTabsPage
 * @classdesc 城市地址匹配组件模板
 * @version 9.1.1
 * @param {Object} options - 组件配置参数。
 * @param {string} options.id - 组件 dom 元素 id。
 * @param {Object|Array.<string>} options.config - 城市名称配置列表，支持两种格式：{key1:{A:[],B:[]}, key2:{C:[],D:[]}} 或
 *                               ["成都市","北京市"]，用户可根据自己的项目需求进行配置
 * @extends {IndexTabsPageContainer}
 * @category Components Common
 * @usage
 */
class CityTabsPage extends IndexTabsPageContainer {
    constructor(options) {
        super(options);
        //去掉默认的边框阴影样式：
        this.rootContainer.classList.add("component-citytabpage--noneBoxShadow");
        this.config = options.config;
        //header，若 config为城市名称数组，则直接加载内容
        if (Util_Util.isArray(this.config)) {
            this.header.hidden = true;
            this._createCityItem("城市", this.config);
            this.content.style.border = "none";
        } else {
            this._createTabs();
            this.header.onclick = (e) => {
                //关闭所有元素 是否有更简化的写法？
                for (let i = 0; i < this.header.children.length; i++) {
                    this.header.children[i].setAttribute("class", "");
                }
                //打开点击内容元素
                e.target.setAttribute("class", "on");
                this._createCityContent(e.target.innerHTML);
            };
        }

    }

    /**
     * @function CityTabsPage.prototype._createTabs
     * @description 创建 Tabs
     * @private
     */
    _createTabs() {
        //header
        if (Util_Util.isArray(this.config)) {
            for (let i = 0; i < this.config.length; i++) {
                let innerHTML = "";
                for (const key in this.config[i]) {
                    innerHTML += key;
                }
                let li = document.createElement("li");
                li.innerHTML = innerHTML;
                this.header.appendChild(li);
            }
        } else {
            for (const key in this.config) {
                let li = document.createElement("li");
                li.innerHTML = key;
                this.header.appendChild(li);
            }
        }
        this.header.firstChild.setAttribute("class", "on");
        this._createCityContent(this.header.firstChild.innerHTML);
    }

    /**
     * @function CityTabsPage.prototype._createCityContent
     * @description 创建列表容器
     * @private
     */
    _createCityContent(keyName) {
        //清除元素：
        for (let i = this.content.children.length; i > 0; i--) {
            this.content.removeChild(this.content.children[i - 1]);
        }
        //创建对应元素
        const cities = this.config[keyName];
        for (let key in cities) {
            this._createCityItem(key, cities[key]);
        }
    }

    /**
     * @function CityTabsPage.prototype._createCityContent
     * @description 创建列表容器
     * @private
     */
    _createCityItem(key, cities) {
        const city = document.createElement("div");

        const cityClass = document.createElement("div");
        cityClass.setAttribute("class", "component-citytabpag__py-key");
        cityClass.innerHTML = key;
        city.appendChild(cityClass);

        const cityContent = document.createElement("div");
        cityContent.setAttribute("class", "component-citytabpag__content");

        for (let i = 0; i < cities.length; i++) {
            let span = document.createElement("span");
            span.innerHTML = cities[i];
            cityContent.appendChild(span);
        }
        //HOT 元素长度单独微调：
        if (key === "HOT") {
            cityContent.style.width = "428px";
        }
        city.appendChild(cityContent);
        this.content.appendChild(city);
    }

}

;// CONCATENATED MODULE: ./src/common/components/templates/NavTabsPage.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


/**
 * @class NavTabsPage
 * @aliasclass Components.NavTabsPage
 * @deprecatedclass SuperMap.Components.NavTabsPage
 * @classdesc 标签页面组件。
 * @version 9.1.1
 * @param {Object} options - 组件配置参数。
 * @param {string} options.id - 组件 dom 元素 id。
 * @param {Array.<Object>} [options.tabs=[]] - 标签对象数组，形如：[{title: "",content: HTMLElement}]，初始时，传入则创建页面。
 * @extends {TemplateBase}
 * @category Components Common
 * @usage
 */
//  todo 思考拆分的控件应该以哪种方式使用
class NavTabsPage extends TemplateBase {
    constructor(options) {
        super(options);
        this.navTabsTitle = null;
        this.navTabsContent = null;
        options.tabs = options.tabs ? options.tabs : [];
        this._initView(options.tabs);
    }

    /**
     * @override
     * @private
     */
    _initView(tabs) {
        const navTabsPage = document.createElement("div");
        navTabsPage.setAttribute("class", "component-navtabspage");

        //关闭按钮
        const closeBtn = document.createElement("span");
        closeBtn.setAttribute("class", "supermapol-icons-close");
        closeBtn.onclick = this.closeView.bind(this);
        navTabsPage.appendChild(closeBtn);

        //标签
        const navTabsTitle = document.createElement("div");
        this.navTabsTitle = navTabsTitle;
        navTabsTitle.setAttribute("class", "component-navtabspage__title");
        navTabsPage.appendChild(navTabsTitle);

        //内容
        const navTabsContent = document.createElement("div");
        this.navTabsContent = navTabsContent;
        navTabsContent.setAttribute("class", "component-navtabspage__content");
        navTabsPage.appendChild(navTabsContent);

        //若 tabs 初始传入值，则
        if (tabs.length > 0) {
            this.appendTabs(tabs);
        }

        this.rootContainer = navTabsPage;
    }

    /**
     * @function NavTabsPage.prototype.setTabs
     * @description 设置标签。
     * @param {Array.<Object>} tabs - 标签对象数组，形如：[{title: "",content: {}}]。
     */
    setTabs(tabs) {
        this.removeAllTabs();
        this.appendTabs(tabs);
    }

    /**
     * @function NavTabsPage.prototype.appendTabs
     * @description 添加标签页面。
     * @param {Array.<Object>} tabs - 标签对象数组，形如：[{title: "",content: {}}]。
     */
    appendTabs(tabs) {
        for (let i = 0; i < tabs.length; i++) {
            let title = document.createElement("span");
            title.index = i;
            title.appendChild(document.createTextNode(tabs[i].title));
            //绑定标签切换对应页面：
            title.onclick = this._changeTabsPage.bind(this);
            let content = tabs[i].content;
            content.index = i;
            content.hidden = true;

            this.navTabsTitle.appendChild(title);
            this.navTabsContent.appendChild(content);
        }
        //todo 确认是否两个子元素的 index 相互对应
        //默认显示第一个标签对象
        this.navTabsTitle.firstChild.setAttribute("class", "component-navtabspage__tabs--select");
        this.navTabsContent.firstChild.hidden = false;
    }

    /**
     * @function NavTabsPage.prototype.removeTab
     * @description 删除某个标签页面。
     * @param {number} index - 标签索引号。
     */
    removeTab(index) {
        this.navTabsTitle.removeChild(this.navTabsTitle.children[index]);
        this.navTabsContent.removeChild(this.navTabsContent.children[index]);
    }

    /**
     * @function NavTabsPage.prototype.removeAllTabs
     * @description 删除所有标签。
     */
    removeAllTabs() {
        for (let i = this.navTabsTitle.children.length; i > 0; i--) {
            this.navTabsTitle.removeChild(this.navTabsTitle.children[i]);
            this.navTabsContent.removeChild(this.navTabsContent.children[i]);
        }
    }

    _changeTabsPage(e) {
        const index = e.target.index;
        for (let i = 0; i < this.navTabsTitle.children.length; i++) {
            this.navTabsTitle.children[i].setAttribute("class", "");
            this.navTabsContent.children[i].hidden = true;
            if (i === index) {
                this.navTabsTitle.children[i].setAttribute("class", "component-navtabspage__tabs--select");
                this.navTabsContent.children[i].hidden = false;
            }
        }
    }

}

;// CONCATENATED MODULE: ./src/common/components/templates/PaginationContainer.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


/**
 * @class PaginationContainer
 * @aliasclass Components.PaginationContainer
 * @deprecatedclass SuperMap.Components.PaginationContainer
 * @classdesc 分页组件模板。
 * @version 9.1.1
 * @param {Object} options - 组件配置参数。
 * @param {string} options.id - 组件 dom 元素 id。
 * @param {HTMLElement} options.contents - 页面填充的 DOM 元素对象。
 * @param {number} options.pageCounts - 页数。
 * @extends {TemplateBase}
 * @category Components Common
 * @usage
 */
class PaginationContainer extends TemplateBase {
    constructor(options) {
        options = options ? options : {};
        super(options);
        this.currentPage = 0;
        this.pageNumberLis = [];
        this.currentPageNumberLis = [];
        this.linkageEvent = null;

        options.contents = options.contents ? options.contents : null;
        options.pageCounts = options.pageCounts ? options.pageCounts : 0;
        this._initView(options.contents, options.pageCounts);
    }

    /**
     * @function PaginationContainer.prototype.setLinkageEvent
     * @description 设置页面联动方法。
     * @param {function} linkageEvent - 联动方法，实现指定功能。
     */
    setLinkageEvent(linkageEvent) {
        this.linkageEvent = linkageEvent;
    }

    /**
     * @private
     * @override
     */
    _initView(contents, pageCounts) {
        const container = document.createElement("div");
        container.setAttribute("class", "component-pagination");

        //content
        const content = document.createElement("div");
        content.setAttribute("class", "component-pagination__content");
        container.appendChild(content);
        this.content = content;

        //link
        const link = document.createElement("ul");
        link.setAttribute("class", "component-pagination__link");
        link.onclick = this._changePageEvent.bind(this);
        container.appendChild(link);
        this._createLink(link);
        this.link = link;
        //填充内容：
        if (contents) {
            this.setContent(contents);
        }
        if (pageCounts !== 0) {
            this.setPageLink(pageCounts);
        }
        this.rootContainer = container;
    }

    /**---------以下是页面相关操作 **/
    /**
     * @function PaginationContainer.prototype.setContent
     * @description 设置页面内容。
     * @param {HTMLElement} element - 页面内容元素。
     */
    setContent(element) {
        this.clearContent();
        this.appendContent(element);
    }

    /**
     * @function PaginationContainer.prototype.appendContent
     * @description 追加内容。
     * @param {HTMLElement} element - 页面内容元素。
     */
    appendContent(element) {
        this.content.appendChild(element);
    }

    /**
     * @function PaginationContainer.prototype.clearContent
     * @description 清空内容元素。
     */
    clearContent() {
        for (let i = this.content.children.length - 1; i >= 0; i--) {
            this.content.removeChild(this.content.children[i]);
        }
    }

    /** -----以下是页码相关的操作：**/
    /**
     * @function PaginationContainer.prototype.setPageLink
     * @description 设置页码数。
     * @param {number} pageNumber - 页码数。
     */
    setPageLink(pageNumber) {
        //清空当前页码
        this.pageNumberLis = [];
        this.currentPageNumberLis = [];
        this.clearPageLink();

        //创建页码
        this._createPageLi(pageNumber);
        //添加页码到页码列表
        this._appendPageLink();
    }

    /**
     * @description 创建页码。
     * @param pageNumber
     * @private
     */
    _createPageLi(pageNumber) {
        for (let i = 0; i < pageNumber; i++) {
            const pageLi = document.createElement("li");
            pageLi.innerHTML = i + 1;
            /*const liContent = document.createElement("span");
            liContent.innerHTML = i + 1;*/
            // pageLi.appendChild(liContent);
            this.pageNumberLis.push(pageLi);
        }
        this.pageNumberLis[0].setAttribute("class", "active");
        this.currentPage = 1;
        if (pageNumber < 5) {
            this.currentPageNumberLis = this.pageNumberLis;
        } else {
            for (let i = 0; i < 5; i++) {
                this.currentPageNumberLis.push(this.pageNumberLis[i]);
            }
        }
    }

    /**
     * @description 添加页码到页码列表。
     * @private
     */
    _appendPageLink() {
        //todo 如何插入中间
        for (let i = 0; i < this.currentPageNumberLis.length; i++) {
            this.link.insertBefore(this.currentPageNumberLis[i], this.link.childNodes[this.link.children.length - 2]);
        }

        for (let i = 0; i < this.currentPageNumberLis.length; i++) {
            //清空 active 状态
            this.currentPageNumberLis[i].setAttribute("class", "");
            //给当前选中的 li 赋值  active 状态
            if (Number(this.currentPageNumberLis[i].innerHTML) === this.currentPage) {
                this.currentPageNumberLis[i].setAttribute("class", "active");
            }
        }

        //根据 currentPage 改变按钮状态
        this._changeDisableState();

        if (this.linkageEvent) {
            this.linkageEvent(this.currentPage);
        }

    }

    /**
     * @function PaginationContainer.prototype.clearPageLink
     * @description 清除页码列表。
     */
    clearPageLink() {
        for (let i = this.link.children.length - 3; i > 1; i--) {
            this.link.removeChild(this.link.children[i]);
        }
    }

    /**
     * @description 创建页码按钮。
     * @param ul
     * @private
     */
    _createLink(ul) {
        for (let i = 0; i < 4; i++) {
            const li = document.createElement("li");
            li.setAttribute("class", "disable");
            const liContent = document.createElement("span");
            li.appendChild(liContent);
            if (i === 0) {
                liContent.id = "first";
                liContent.setAttribute("class", "supermapol-icons-first");
            } else if (i === 1) {
                liContent.id = "prev";
                liContent.setAttribute("class", "supermapol-icons-prev");
            } else if (i === 2) {
                liContent.id = "next";
                liContent.setAttribute("class", "supermapol-icons-next");
            } else if (i === 3) {
                liContent.id = "last";
                liContent.setAttribute("class", "supermapol-icons-last");
            }

            ul.appendChild(li);
        }
    }

    /**
     * @description 点击页码事件。
     * @param e
     * @private
     */
    _changePageEvent(e) {
        //todo
        const trigger = e.target;
        //若列表禁用，点击无效
        if (trigger.parentElement.classList[0] === "disable") {
            return;
        }
        let targetLi;
        if (trigger.id) {
            targetLi = trigger.id;
        } else if (Number(trigger.innerHTML)) {
            targetLi = Number(trigger.innerHTML);
        } else {
            return;
        }

        //页码预处理：
        this._prePageNum(targetLi);


        //根据 currentPageNumberLis 创建页码列表
        this.clearPageLink();
        this._appendPageLink();
    }

    /**
     * @description 根据 currentPage 改变按钮状态。
     * @private
     */
    _changeDisableState() {
        this.link.children[0].setAttribute("class", "");
        this.link.children[1].setAttribute("class", "");
        this.link.children[this.link.children.length - 1].setAttribute("class", "");
        this.link.children[this.link.children.length - 2].setAttribute("class", "");

        if (this.currentPage === 1) {
            this.link.children[0].setAttribute("class", "disable");
            this.link.children[1].setAttribute("class", "disable");
        }
        if (this.currentPage === this.pageNumberLis.length) {
            this.link.children[this.link.children.length - 1].setAttribute("class", "disable");
            this.link.children[this.link.children.length - 2].setAttribute("class", "disable");
        }

    }

    /**
     * @description 根据点击页码列表事件准备需展现的页码列表。
     * @param {string|number} targetLi - 被点击的列表对象 id 或 被点击的页码值。
     * @private
     */
    _prePageNum(targetLi) {
        const currentPageNumberLis = [];
        if (targetLi === "first") {
            this.currentPage = 1;
        } else if (targetLi === "last") {
            this.currentPage = this.pageNumberLis.length;
        } else if (targetLi === "prev") {
            this.currentPage = this.currentPage - 1;

        } else if (targetLi === "next") {
            this.currentPage = this.currentPage + 1;
        } else {
            this.currentPage = targetLi;
        }

        if (this.pageNumberLis.length <= 5) {
            for (let i = 0; i < this.pageNumberLis.length; i++) {
                currentPageNumberLis.push(this.pageNumberLis[i]);
            }
        } else {
            //当前点击前三，都取前五
            if (this.currentPage <= 3) {
                for (let i = 0; i < 5; i++) {
                    currentPageNumberLis.push(this.pageNumberLis[i]);
                }
            } else if (this.currentPage >= this.pageNumberLis.length - 3) {
                //点击后三，都取后5
                for (let i = this.pageNumberLis.length - 5; i < this.pageNumberLis.length; i++) {
                    currentPageNumberLis.push(this.pageNumberLis[i]);
                }
            } else {
                //其他，取中间：
                for (let i = this.currentPage - 3; i <= this.currentPage + 1; i++) {
                    currentPageNumberLis.push(this.pageNumberLis[i]);
                }
            }

        }
        if (currentPageNumberLis.length > 0) {
            this.currentPageNumberLis = currentPageNumberLis;
        }
    }

}

;// CONCATENATED MODULE: ./src/common/components/util/Util.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


/**
 * @name ComponentsUtil
 * @namespace
 * @category BaseTypes Util
 * @description 获取文件类型工具类。
 * @usage
 * ```
 * // 浏览器
 * <script type="text/javascript" src="{cdn}"></script>
 * <script>
 *   const result = {namespace}.ComponentsUtil.getFileType(fileName);
 *
 * </script>
 * // ES6 Import
 * import { ComponentsUtil } from '{npm}';
 *
 * const result = ComponentsUtil.getFileType(fileName);
 * ```
 */
let ComponentsUtil = {
    /**
     * @function ComponentsUtil.getFileType
     * @description 获取上传文件类型。
     * @param {string} fileName - 文件名称。
     */
    getFileType(fileName) {
        let regCSV = /^.*\.(?:csv)$/i;
        let regExcel = /^.*\.(?:xls|xlsx)$/i; //文件名可以带空格
        let regGeojson = /^.*\.(?:geojson|json)$/i;
        if (regExcel.test(fileName)) { //校验不通过
            return CommonTypes_FileTypes.EXCEL;
        } else if (regCSV.test(fileName)) {
            return CommonTypes_FileTypes.CSV;
        } else if (regGeojson.test(fileName)) {
            return CommonTypes_FileTypes.GEOJSON;
        }
        return null;
    }

};

;// CONCATENATED MODULE: ./src/common/components/util/index.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/





;// CONCATENATED MODULE: ./src/common/components/index.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/
//数据

//组件

//提示框组件

//图表组件


//公用模板：











//工具类





















;// CONCATENATED MODULE: ./src/common/lang/index.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/








;// CONCATENATED MODULE: ./src/common/index.common.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/




































;// CONCATENATED MODULE: ./src/common/index.all.js








;// CONCATENATED MODULE: ./src/common/namespace.js
/* Copyright© 2000 - 2021 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/
/* Copyright© 2000 - 2021 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/







// Lang
SuperMap.Lang = Lang;
SuperMap.i18n = SuperMap.Lang.i18n;
// CommonUtil
SuperMap.Util = { ...SuperMap.Util, ...Util_Util };
SuperMap.Browser = Browser;
SuperMap.INCHES_PER_UNIT = INCHES_PER_UNIT;
SuperMap.METERS_PER_INCH = METERS_PER_INCH;
SuperMap.DOTS_PER_INCH = DOTS_PER_INCH;
SuperMap.IS_GECKO = IS_GECKO;

// FetchRequest
SuperMap.setCORS = setCORS;
SuperMap.isCORS = isCORS;
SuperMap.setRequestTimeout = setRequestTimeout;
SuperMap.getRequestTimeout = getRequestTimeout;
SuperMap.FetchRequest = FetchRequest;

// commontypes
SuperMap.inherit = inheritExt;
SuperMap.mixin = mixinExt;
SuperMap.String = StringExt;
SuperMap.Number = NumberExt;
SuperMap.Function = FunctionExt;
SuperMap.Array = ArrayExt;
SuperMap.Date = DateExt;
SuperMap.Event = Event_Event;
SuperMap.Bounds = Bounds;
SuperMap.Credential = Credential;
SuperMap.Events = Events;
SuperMap.Feature = Feature_Feature;
SuperMap.Geometry = Geometry_Geometry;
SuperMap.Geometry3D = Geometry3D;
SuperMap.Pixel = Pixel;
SuperMap.Size = Size;
SuperMap.Feature.Vector = Vector;
SuperMap.Geometry.Collection = Collection;
SuperMap.Geometry.Curve = Curve;
SuperMap.Geometry.GeoText = GeoText;
SuperMap.Geometry.LinearRing = LinearRing_LinearRing;
SuperMap.Geometry.LineString = LineString;
SuperMap.Geometry.MultiLineString = MultiLineString;
SuperMap.Geometry.MultiPoint = MultiPoint;
SuperMap.Geometry.MultiPolygon = MultiPolygon;
SuperMap.Geometry.Point = Point;
SuperMap.Geometry.Polygon = Polygon_Polygon;
SuperMap.Geometry.Rectangle = Rectangle;
// Components
SuperMap.Components.Chart = ChartView;
SuperMap.Components.ChartViewModel = ChartViewModel;
SuperMap.Components.MessageBox = MessageBox;
SuperMap.Components.AttributesPopContainer = AttributesPopContainer;
SuperMap.Components.CityTabsPage = CityTabsPage;
SuperMap.Components.CommonContainer = CommonContainer;
SuperMap.Components.DropDownBox = DropDownBox;
SuperMap.Components.IndexTabsPageContainer = IndexTabsPageContainer;
SuperMap.Components.NavTabsPage = NavTabsPage;
SuperMap.Components.PaginationContainer = PaginationContainer;
SuperMap.Components.PopContainer = PopContainer;
SuperMap.Components.Select = Select;
SuperMap.Components.TemplateBase = TemplateBase;
SuperMap.Components.FileReaderUtil = FileReaderUtil;
// control
SuperMap.TimeControlBase = TimeControlBase;
SuperMap.TimeFlowControl = TimeFlowControl;
// Format
SuperMap.Format = SuperMap.Format || Format;
SuperMap.Format.GeoJSON = GeoJSON;
SuperMap.Format.JSON = JSONFormat;
SuperMap.Format.WKT = WKT;
// iManager
SuperMap.iManager = IManager;
SuperMap.iManagerCreateNodeParam = IManagerCreateNodeParam;
SuperMap.iManagerServiceBase = IManagerServiceBase;
// iPortal
SuperMap.iPortal = IPortal;
SuperMap.iPortalAddDataParam = IPortalAddDataParam;
SuperMap.iPortalAddResourceParam = IPortalAddResourceParam;
SuperMap.iPortalDataConnectionInfoParam = IPortalDataConnectionInfoParam;
SuperMap.iPortalDataMetaInfoParam = IPortalDataMetaInfoParam;
SuperMap.iPortalDataStoreInfoParam = IPortalDataStoreInfoParam;
SuperMap.iPortalQueryParam = IPortalQueryParam;
SuperMap.iPortalQueryResult = IPortalQueryResult;
SuperMap.iPortalRegisterServiceParam = IPortalRegisterServiceParam;
SuperMap.iPortalResource = IPortalResource;
SuperMap.iPortalServiceBase = IPortalServiceBase;
SuperMap.iPortalShareEntity = IPortalShareEntity;
SuperMap.iPortalShareParam = IPortalShareParam;
SuperMap.iPortalUser = IPortalUser;
// iServer
SuperMap.AddressMatchService = AddressMatchService_AddressMatchService;
SuperMap.AggregationParameter = AggregationParameter;
SuperMap.AreaSolarRadiationParameters = AreaSolarRadiationParameters;
SuperMap.AreaSolarRadiationService = AreaSolarRadiationService;
SuperMap.BucketAggParameter = BucketAggParameter;
SuperMap.BufferAnalystParameters = BufferAnalystParameters;
SuperMap.BufferAnalystService = BufferAnalystService;
SuperMap.BufferDistance = BufferDistance;
SuperMap.BuffersAnalystJobsParameter = BuffersAnalystJobsParameter;
SuperMap.BuffersAnalystJobsService = BuffersAnalystJobsService;
SuperMap.BufferSetting = BufferSetting;
SuperMap.BurstPipelineAnalystParameters = BurstPipelineAnalystParameters;
SuperMap.BurstPipelineAnalystService = BurstPipelineAnalystService;
SuperMap.ChartFeatureInfoSpecsService = ChartFeatureInfoSpecsService;
SuperMap.ChartQueryFilterParameter = ChartQueryFilterParameter;
SuperMap.ChartQueryParameters = ChartQueryParameters;
SuperMap.ChartQueryService = ChartQueryService;
SuperMap.ClipParameter = ClipParameter;
SuperMap.ColorDictionary = ColorDictionary;
SuperMap.CommonServiceBase = CommonServiceBase;
SuperMap.ComputeWeightMatrixParameters = ComputeWeightMatrixParameters;
SuperMap.ComputeWeightMatrixService = ComputeWeightMatrixService;
SuperMap.CreateDatasetParameters = CreateDatasetParameters;
SuperMap.DataFlowService = DataFlowService_DataFlowService;
SuperMap.DataReturnOption = DataReturnOption;
SuperMap.DatasetBufferAnalystParameters = DatasetBufferAnalystParameters;
SuperMap.DatasetInfo = DatasetInfo;
SuperMap.DatasetOverlayAnalystParameters = DatasetOverlayAnalystParameters;
SuperMap.DatasetService = DatasetService_DatasetService;
SuperMap.DatasetSurfaceAnalystParameters = DatasetSurfaceAnalystParameters;
SuperMap.DatasetThiessenAnalystParameters = DatasetThiessenAnalystParameters;
SuperMap.DatasourceConnectionInfo = DatasourceConnectionInfo;
SuperMap.DatasourceService = DatasourceService_DatasourceService;
SuperMap.DensityAnalystService = DensityAnalystService;
SuperMap.DensityKernelAnalystParameters = DensityKernelAnalystParameters;
SuperMap.EditFeaturesParameters = EditFeaturesParameters;
SuperMap.EditFeaturesService = EditFeaturesService;
SuperMap.FacilityAnalyst3DParameters = FacilityAnalyst3DParameters;
SuperMap.FacilityAnalystSinks3DParameters = FacilityAnalystSinks3DParameters;
SuperMap.FacilityAnalystSinks3DService = FacilityAnalystSinks3DService;
SuperMap.FacilityAnalystSources3DParameters = FacilityAnalystSources3DParameters;
SuperMap.FacilityAnalystSources3DService = FacilityAnalystSources3DService;
SuperMap.FacilityAnalystStreamParameters = FacilityAnalystStreamParameters;
SuperMap.FacilityAnalystStreamService = FacilityAnalystStreamService;
SuperMap.FacilityAnalystTracedown3DParameters = FacilityAnalystTracedown3DParameters;
SuperMap.FacilityAnalystTracedown3DService = FacilityAnalystTracedown3DService;
SuperMap.FacilityAnalystTraceup3DParameters = FacilityAnalystTraceup3DParameters;
SuperMap.FacilityAnalystTraceup3DService = FacilityAnalystTraceup3DService;
SuperMap.FacilityAnalystUpstream3DParameters = FacilityAnalystUpstream3DParameters;
SuperMap.FacilityAnalystUpstream3DService = FacilityAnalystUpstream3DService;
SuperMap.FieldParameters = FieldParameters;
SuperMap.FieldsFilter = FieldsFilter;
SuperMap.FieldStatisticService = FieldStatisticService;
SuperMap.FieldStatisticsParameters = FieldStatisticsParameters;
SuperMap.FilterParameter = FilterParameter;
SuperMap.FindClosestFacilitiesParameters = FindClosestFacilitiesParameters;
SuperMap.FindClosestFacilitiesService = FindClosestFacilitiesService;
SuperMap.FindLocationParameters = FindLocationParameters;
SuperMap.FindLocationService = FindLocationService;
SuperMap.FindMTSPPathsParameters = FindMTSPPathsParameters;
SuperMap.FindMTSPPathsService = FindMTSPPathsService;
SuperMap.FindPathParameters = FindPathParameters;
SuperMap.FindPathService = FindPathService;
SuperMap.FindServiceAreasParameters = FindServiceAreasParameters;
SuperMap.FindServiceAreasService = FindServiceAreasService;
SuperMap.FindTSPPathsParameters = FindTSPPathsParameters;
SuperMap.FindTSPPathsService = FindTSPPathsService;
SuperMap.GenerateSpatialDataParameters = GenerateSpatialDataParameters;
SuperMap.GenerateSpatialDataService = GenerateSpatialDataService;
SuperMap.GeoCodingParameter = GeoCodingParameter;
SuperMap.GeoDecodingParameter = GeoDecodingParameter;
SuperMap.GeoHashGridAggParameter = GeoHashGridAggParameter;
SuperMap.GeometryBatchAnalystService = GeometryBatchAnalystService;
SuperMap.GeometryBufferAnalystParameters = GeometryBufferAnalystParameters;
SuperMap.GeometryOverlayAnalystParameters = GeometryOverlayAnalystParameters;
SuperMap.GeometrySurfaceAnalystParameters = GeometrySurfaceAnalystParameters;
SuperMap.GeometryThiessenAnalystParameters = GeometryThiessenAnalystParameters;
SuperMap.GeoprocessingService = GeoprocessingService_GeoprocessingService;
SuperMap.GeoRelationAnalystParameters = GeoRelationAnalystParameters;
SuperMap.GeoRelationAnalystService = GeoRelationAnalystService;
SuperMap.GetFeaturesByBoundsParameters = GetFeaturesByBoundsParameters;
SuperMap.GetFeaturesByBoundsService = GetFeaturesByBoundsService;
SuperMap.GetFeaturesByBufferParameters = GetFeaturesByBufferParameters;
SuperMap.GetFeaturesByBufferService = GetFeaturesByBufferService;
SuperMap.GetFeaturesByGeometryParameters = GetFeaturesByGeometryParameters;
SuperMap.GetFeaturesByGeometryService = GetFeaturesByGeometryService;
SuperMap.GetFeaturesByIDsParameters = GetFeaturesByIDsParameters;
SuperMap.GetFeaturesByIDsService = GetFeaturesByIDsService;
SuperMap.GetFeaturesBySQLParameters = GetFeaturesBySQLParameters;
SuperMap.GetFeaturesBySQLService = GetFeaturesBySQLService;
SuperMap.GetFeaturesParametersBase = GetFeaturesParametersBase;
SuperMap.GetFeaturesServiceBase = GetFeaturesServiceBase;
SuperMap.GetFieldsService = GetFieldsService;
SuperMap.GetGridCellInfosParameters = GetGridCellInfosParameters;
SuperMap.GetGridCellInfosService = GetGridCellInfosService;
SuperMap.GetLayersInfoService = GetLayersInfoService;
SuperMap.Grid = Grid;
SuperMap.HillshadeParameter = HillshadeParameter;
SuperMap.Image = UGCImage;
SuperMap.ImageCollectionService = ImageCollectionService_ImageCollectionService;
SuperMap.ImageGFAspect = ImageGFAspect;
SuperMap.ImageGFHillShade = ImageGFHillShade;
SuperMap.ImageGFOrtho = ImageGFOrtho;
SuperMap.ImageGFSlope = ImageGFSlope;
SuperMap.ImageRenderingRule = ImageRenderingRule;
SuperMap.ImageSearchParameter = ImageSearchParameter;
SuperMap.ImageService = ImageService_ImageService;
SuperMap.ImageStretchOption = ImageStretchOption;
SuperMap.InterpolationAnalystParameters = InterpolationAnalystParameters;
SuperMap.InterpolationAnalystService = InterpolationAnalystService;
SuperMap.InterpolationDensityAnalystParameters = InterpolationDensityAnalystParameters;
SuperMap.InterpolationIDWAnalystParameters = InterpolationIDWAnalystParameters;
SuperMap.InterpolationKrigingAnalystParameters = InterpolationKrigingAnalystParameters;
SuperMap.InterpolationRBFAnalystParameters = InterpolationRBFAnalystParameters;
SuperMap.JoinItem = JoinItem;
SuperMap.KernelDensityJobParameter = KernelDensityJobParameter;
SuperMap.KernelDensityJobsService = KernelDensityJobsService;
SuperMap.LabelImageCell = LabelImageCell;
SuperMap.LabelMatrixCell = LabelMatrixCell;
SuperMap.LabelMixedTextStyle = LabelMixedTextStyle;
SuperMap.LabelSymbolCell = LabelSymbolCell;
SuperMap.LabelThemeCell = LabelThemeCell;
SuperMap.LayerStatus = LayerStatus;
SuperMap.LinkItem = LinkItem;
SuperMap.MappingParameters = MappingParameters;
SuperMap.MapService = MapService_MapService;
SuperMap.MathExpressionAnalysisParameters = MathExpressionAnalysisParameters;
SuperMap.MathExpressionAnalysisService = MathExpressionAnalysisService;
SuperMap.MeasureParameters = MeasureParameters;
SuperMap.MeasureService = MeasureService_MeasureService;
SuperMap.MetricsAggParameter = MetricsAggParameter;
SuperMap.NDVIParameter = NDVIParameter;
SuperMap.NetworkAnalystServiceBase = NetworkAnalystServiceBase;
SuperMap.OutputSetting = OutputSetting;
SuperMap.OverlapDisplayedOptions = OverlapDisplayedOptions;
SuperMap.OverlayAnalystParameters = OverlayAnalystParameters;
SuperMap.OverlayAnalystService = OverlayAnalystService;
SuperMap.OverlayGeoJobParameter = OverlayGeoJobParameter;
SuperMap.OverlayGeoJobsService = OverlayGeoJobsService;
SuperMap.PointWithMeasure = PointWithMeasure;
SuperMap.ProcessingServiceBase = ProcessingServiceBase;
SuperMap.QueryByBoundsParameters = QueryByBoundsParameters;
SuperMap.QueryByBoundsService = QueryByBoundsService;
SuperMap.QueryByDistanceParameters = QueryByDistanceParameters;
SuperMap.QueryByDistanceService = QueryByDistanceService;
SuperMap.QueryByGeometryParameters = QueryByGeometryParameters;
SuperMap.QueryByGeometryService = QueryByGeometryService;
SuperMap.QueryBySQLParameters = QueryBySQLParameters;
SuperMap.QueryBySQLService = QueryBySQLService;
SuperMap.DatasetMinDistanceAnalystParameters = DatasetMinDistanceAnalystParameters;
SuperMap.MinDistanceAnalystService = MinDistanceAnalystService;
SuperMap.TerrainCutFillCalculationParameters = TerrainCutFillCalculationParameters;
SuperMap.TerrainCutFillCalculationService = TerrainCutFillCalculationService;
SuperMap.terrainAnalystSetting = terrainAnalystSetting;
SuperMap.TerrainAspectCalculationParameters = TerrainAspectCalculationParameters;
SuperMap.TerrainAspectCalculationService = TerrainAspectCalculationService;
SuperMap.TerrainSlopeCalculationParameters = TerrainSlopeCalculationParameters;
SuperMap.TerrainSlopeCalculationService = TerrainSlopeCalculationService;
SuperMap.GeometryMinDistanceAnalystParameters = GeometryMinDistanceAnalystParameters;
SuperMap.ConvexHullAnalystParameters = ConvexHullAnalystParameters;
SuperMap.ConvexHullAnalystService = ConvexHullAnalystService;
SuperMap.TraceAnalystParameters = TraceAnalystParameters;
SuperMap.TraceAnalystService = TraceAnalystService;
SuperMap.ConnectedEdgesAnalystParameters = ConnectedEdgesAnalystParameters;
SuperMap.ConnectedEdgesAnalystService = ConnectedEdgesAnalystService;
SuperMap.GetLayersLegendInfoParameters = GetLayersLegendInfoParameters;
SuperMap.GetLayersLegendInfoService = GetLayersLegendInfoService;
SuperMap.QueryParameters = QueryParameters;
SuperMap.QueryService = QueryService_QueryService;
SuperMap.RasterFunctionParameter = RasterFunctionParameter;
SuperMap.Route = Route;
SuperMap.RouteCalculateMeasureParameters = RouteCalculateMeasureParameters;
SuperMap.RouteCalculateMeasureService = RouteCalculateMeasureService;
SuperMap.RouteLocatorParameters = RouteLocatorParameters;
SuperMap.RouteLocatorService = RouteLocatorService;
SuperMap.ServerColor = ServerColor;
SuperMap.ServerFeature = ServerFeature;
SuperMap.ServerGeometry = ServerGeometry;
SuperMap.ServerStyle = ServerStyle;
SuperMap.ServerTextStyle = ServerTextStyle;
SuperMap.ServerTheme = ServerTheme;
SuperMap.SetDatasourceParameters = SetDatasourceParameters;
SuperMap.SetLayerInfoParameters = SetLayerInfoParameters;
SuperMap.SetLayerInfoService = SetLayerInfoService;
SuperMap.SetLayersInfoParameters = SetLayersInfoParameters;
SuperMap.SetLayersInfoService = SetLayersInfoService;
SuperMap.SetLayerStatusParameters = SetLayerStatusParameters;
SuperMap.SetLayerStatusService = SetLayerStatusService;
SuperMap.SingleObjectQueryJobsParameter = SingleObjectQueryJobsParameter;
SuperMap.SingleObjectQueryJobsService = SingleObjectQueryJobsService;
SuperMap.Sortby = Sortby;
SuperMap.SpatialAnalystBase = SpatialAnalystBase;
SuperMap.StopQueryParameters = StopQueryParameters;
SuperMap.StopQueryService = StopQueryService;
SuperMap.SummaryAttributesJobsParameter = SummaryAttributesJobsParameter;
SuperMap.SummaryAttributesJobsService = SummaryAttributesJobsService;
SuperMap.SummaryMeshJobParameter = SummaryMeshJobParameter;
SuperMap.SummaryMeshJobsService = SummaryMeshJobsService;
SuperMap.SummaryRegionJobParameter = SummaryRegionJobParameter;
SuperMap.SummaryRegionJobsService = SummaryRegionJobsService;
SuperMap.SupplyCenter = SupplyCenter;
SuperMap.SurfaceAnalystParameters = SurfaceAnalystParameters;
SuperMap.SurfaceAnalystParametersSetting = SurfaceAnalystParametersSetting;
SuperMap.SurfaceAnalystService = SurfaceAnalystService;
SuperMap.TerrainCurvatureCalculationParameters = TerrainCurvatureCalculationParameters;
SuperMap.TerrainCurvatureCalculationService = TerrainCurvatureCalculationService;
SuperMap.Theme = Theme_Theme;
SuperMap.ThemeDotDensity = ThemeDotDensity;
SuperMap.ThemeFlow = ThemeFlow;
SuperMap.ThemeGraduatedSymbol = ThemeGraduatedSymbol;
SuperMap.ThemeGraduatedSymbolStyle = ThemeGraduatedSymbolStyle;
SuperMap.ThemeGraph = ThemeGraph;
SuperMap.ThemeGraphAxes = ThemeGraphAxes;
SuperMap.ThemeGraphItem = ThemeGraphItem;
SuperMap.ThemeGraphSize = ThemeGraphSize;
SuperMap.ThemeGraphText = ThemeGraphText;
SuperMap.ThemeGridRange = ThemeGridRange;
SuperMap.ThemeGridRangeItem = ThemeGridRangeItem;
SuperMap.ThemeGridUnique = ThemeGridUnique;
SuperMap.ThemeGridUniqueItem = ThemeGridUniqueItem;
SuperMap.ThemeLabel = ThemeLabel;
SuperMap.ThemeLabelAlongLine = ThemeLabelAlongLine;
SuperMap.ThemeLabelBackground = ThemeLabelBackground;
SuperMap.ThemeLabelItem = ThemeLabelItem;
SuperMap.ThemeLabelText = ThemeLabelText;
SuperMap.ThemeLabelUniqueItem = ThemeLabelUniqueItem;
SuperMap.ThemeMemoryData = ThemeMemoryData;
SuperMap.ThemeOffset = ThemeOffset;
SuperMap.ThemeParameters = ThemeParameters;
SuperMap.ThemeRange = ThemeRange;
SuperMap.ThemeRangeItem = ThemeRangeItem;
SuperMap.ThemeService = ThemeService_ThemeService;
SuperMap.ThemeUnique = ThemeUnique;
SuperMap.ThemeUniqueItem = ThemeUniqueItem;
SuperMap.ThiessenAnalystParameters = ThiessenAnalystParameters;
SuperMap.ThiessenAnalystService = ThiessenAnalystService;
SuperMap.TilesetsService = TilesetsService;
SuperMap.TopologyValidatorJobsParameter = TopologyValidatorJobsParameter;
SuperMap.TopologyValidatorJobsService = TopologyValidatorJobsService;
SuperMap.TransferLine = TransferLine;
SuperMap.TransferPathParameters = TransferPathParameters;
SuperMap.TransferPathService = TransferPathService;
SuperMap.TransferSolutionParameters = TransferSolutionParameters;
SuperMap.TransferSolutionService = TransferSolutionService;
SuperMap.TransportationAnalystParameter = TransportationAnalystParameter;
SuperMap.TransportationAnalystResultSetting = TransportationAnalystResultSetting;
SuperMap.UGCLayer = UGCLayer;
SuperMap.UGCMapLayer = UGCMapLayer;
SuperMap.UGCSubLayer = UGCSubLayer;
SuperMap.UpdateDatasetParameters = UpdateDatasetParameters;
SuperMap.UpdateEdgeWeightParameters = UpdateEdgeWeightParameters;
SuperMap.UpdateEdgeWeightService = UpdateEdgeWeightService;
SuperMap.UpdateTurnNodeWeightParameters = UpdateTurnNodeWeightParameters;
SuperMap.UpdateTurnNodeWeightService = UpdateTurnNodeWeightService;
SuperMap.Vector = iServer_Vector_Vector;
SuperMap.VectorClipJobsParameter = VectorClipJobsParameter;
SuperMap.VectorClipJobsService = VectorClipJobsService;
SuperMap.WebPrintingJobContent = WebPrintingJobContent;
SuperMap.WebPrintingJobCustomItems = WebPrintingJobCustomItems;
SuperMap.WebPrintingJobExportOptions = WebPrintingJobExportOptions;
SuperMap.WebPrintingJobImage = WebPrintingJobImage;
SuperMap.WebPrintingJobLayers = WebPrintingJobLayers;
SuperMap.WebPrintingJobLayoutOptions = WebPrintingJobLayoutOptions;
SuperMap.WebPrintingJobLegendOptions = WebPrintingJobLegendOptions;
SuperMap.WebPrintingJobLittleMapOptions = WebPrintingJobLittleMapOptions;
SuperMap.WebPrintingJobNorthArrowOptions = WebPrintingJobNorthArrowOptions;
SuperMap.WebPrintingJobParameters = WebPrintingJobParameters;
SuperMap.WebPrintingJobScaleBarOptions = WebPrintingJobScaleBarOptions;
SuperMap.WebPrintingService = WebPrintingService;
//Online
SuperMap.Online = Online;
SuperMap.OnlineData = OnlineData;
SuperMap.OnlineQueryDatasParameter = OnlineQueryDatasParameter;
SuperMap.ServiceStatus = ServiceStatus;
// 包含online中的DataItemType数据类型
SuperMap.DataItemType = DataItemType;
SuperMap.DataItemOrderBy = DataItemOrderBy;
SuperMap.FilterField = FilterField;
SuperMap.OnlineServiceBase = OnlineServiceBase;
// overlay
SuperMap.Feature = SuperMap.Feature || {};
SuperMap.Feature.Theme = Theme;
SuperMap.Feature.Theme.Bar = Bar;
SuperMap.Feature.Theme.Bar3D = Bar3D;
SuperMap.Feature.Theme.Circle = Circle;
SuperMap.Feature.Theme.Graph = Graph_Graph;
SuperMap.Feature.Theme.Line = Line;
SuperMap.Feature.Theme.Pie = Pie;
SuperMap.Feature.Theme.Point = overlay_Point_Point;
SuperMap.Feature.Theme.RankSymbol = RankSymbol_RankSymbol;
SuperMap.Feature.Theme.Ring = Ring;
SuperMap.Feature.Theme.ThemeVector = ThemeVector;
SuperMap.Feature.ShapeParameters = ShapeParameters;
SuperMap.Feature.ShapeParameters.Circle = Circle_Circle;
SuperMap.Feature.ShapeParameters.Image = Image_Image;
SuperMap.Feature.ShapeParameters.Label = Label;
SuperMap.Feature.ShapeParameters.Line = Line_Line;
SuperMap.Feature.ShapeParameters.Point = Point_Point;
SuperMap.Feature.ShapeParameters.Polygon = feature_Polygon_Polygon;
SuperMap.Feature.ShapeParameters.Rectangle = Rectangle_Rectangle;
SuperMap.Feature.ShapeParameters.Sector = Sector;
SuperMap.Feature.ShapeFactory = ShapeFactory;
// LevelRenderer
SuperMap.LevelRenderer = LevelRenderer;

// security
SuperMap.KeyServiceParameter = KeyServiceParameter;
SuperMap.SecurityManager = SecurityManager;
SuperMap.ServerInfo = ServerInfo;
SuperMap.TokenServiceParameter = TokenServiceParameter;
// style
SuperMap.ThemeStyle = ThemeStyle;
SuperMap.CartoCSS = CartoCSS;
// thirdparty
// SuperMap.BinaryClassification = BinaryClassification;
// SuperMap.LandcoverClassification = LandcoverClassification;
// SuperMap.ObjectDetection = ObjectDetection;
// SuperMap.WebMachineLearning = WebMachineLearning;
SuperMap.ElasticSearch = ElasticSearch;
// util
SuperMap.ArrayStatistic = ArrayStatistic;
SuperMap.ColorsPickerUtil = ColorsPickerUtil;

// REST
SuperMap.DataFormat = DataFormat;
SuperMap.ServerType = ServerType;
SuperMap.GeometryType = REST_GeometryType;
SuperMap.QueryOption = QueryOption;
SuperMap.JoinType = JoinType;
SuperMap.SpatialQueryMode = SpatialQueryMode;
SuperMap.SpatialRelationType = SpatialRelationType;
SuperMap.MeasureMode = MeasureMode;
SuperMap.Unit = Unit;
SuperMap.BufferRadiusUnit = BufferRadiusUnit;
SuperMap.EngineType = EngineType;
SuperMap.ThemeGraphTextFormat = ThemeGraphTextFormat;
SuperMap.ThemeGraphType = ThemeGraphType;
SuperMap.GraphAxesTextDisplayMode = GraphAxesTextDisplayMode;
SuperMap.GraduatedMode = GraduatedMode;
SuperMap.RangeMode = RangeMode;
SuperMap.ThemeType = ThemeType;
SuperMap.ColorGradientType = ColorGradientType;
SuperMap.TextAlignment = TextAlignment;
SuperMap.FillGradientMode = FillGradientMode;
SuperMap.AlongLineDirection = AlongLineDirection;
SuperMap.LabelBackShape = LabelBackShape;
SuperMap.LabelOverLengthMode = LabelOverLengthMode;
SuperMap.DirectionType = DirectionType;
SuperMap.OverlayOperationType = OverlayOperationType;
SuperMap.OutputType = OutputType;
SuperMap.SideType = SideType;
SuperMap.SupplyCenterType = SupplyCenterType;
SuperMap.TurnType = TurnType;
SuperMap.BufferEndType = BufferEndType;
SuperMap.SmoothMethod = SmoothMethod;
SuperMap.SurfaceAnalystMethod = SurfaceAnalystMethod;
SuperMap.DataReturnMode = DataReturnMode;
SuperMap.EditType = EditType;
SuperMap.TransferTactic = TransferTactic;
SuperMap.TransferPreference = TransferPreference;
SuperMap.GridType = GridType;
SuperMap.ColorSpaceType = ColorSpaceType;
SuperMap.LayerType = LayerType;
SuperMap.UGCLayerType = UGCLayerType;
SuperMap.StatisticMode = StatisticMode;
SuperMap.PixelFormat = PixelFormat;
SuperMap.SearchMode = SearchMode;
SuperMap.InterpolationAlgorithmType = InterpolationAlgorithmType;
SuperMap.VariogramMode = VariogramMode;
SuperMap.Exponent = Exponent;
SuperMap.ClientType = ClientType;
SuperMap.ChartType = ChartType;
SuperMap.ClipAnalystMode = ClipAnalystMode;
SuperMap.AnalystAreaUnit = AnalystAreaUnit;
SuperMap.AnalystSizeUnit = AnalystSizeUnit;
SuperMap.StatisticAnalystMode = StatisticAnalystMode;
SuperMap.SummaryType = SummaryType;
SuperMap.TopologyValidatorRule = TopologyValidatorRule;
SuperMap.BucketAggType = BucketAggType;
SuperMap.MetricsAggType = MetricsAggType;
SuperMap.GetFeatureMode = GetFeatureMode;
SuperMap.RasterFunctionType = RasterFunctionType;
SuperMap.ResourceType = ResourceType;
SuperMap.OrderBy = OrderBy;
SuperMap.OrderType = OrderType;
SuperMap.SearchType = SearchType;
SuperMap.AggregationTypes = AggregationTypes;
SuperMap.PermissionType = PermissionType;
SuperMap.EntityType = EntityType;
SuperMap.WebExportFormatType = WebExportFormatType;
SuperMap.WebScaleOrientationType = WebScaleOrientationType;
SuperMap.WebScaleType = WebScaleType;
SuperMap.WebScaleUnit = WebScaleUnit;
SuperMap.KnowledgeGraph = KnowledgeGraph
SuperMap.BoundsType = BoundsType
SuperMap.CellSizeType = CellSizeType



;// CONCATENATED MODULE: ./src/common/util/FilterCondition.js
function getParseSpecialCharacter() {
  // 特殊字符字典
  const directory = ['(', ')', '（', '）', ',', '，'];
  const res = {};
  directory.forEach((item, index) => {
    res[item] = `$${index}`
  });
  return res;
}

function parseSpecialCharacter(str) {
  const directory = getParseSpecialCharacter();
  for (let key in directory) {
    const replaceValue = directory[key];
    const pattern = new RegExp(`\\${key}`, 'g');
    // eslint-disable-next-line
    while (pattern.test(str)) {
      str = str.replace(pattern, replaceValue);
    }
  }
  return str;
}

function parseCondition(filterCondition, keys) {
  const str = filterCondition.replace(/&|\||>|<|=|!/g, ' ');
  const arr = str.split(' ').filter((item) => item);
  let result = filterCondition;
  arr.forEach((item) => {
    const key = keys.find((val) => val === item);
    if (startsWithNumber(item) && key) {
      result = result.replace(key, '$' + key);
    }
    if (key) {
      const res = parseSpecialCharacter(key);
      result = result.replace(key, res);
    }
  });
  return result;
}

// 处理jsonsqlfeature, 加前缀
function parseConditionFeature(feature) {
  let copyValue = {};
  for (let key in feature) {
    let copyKey = key;
    if (startsWithNumber(key)) {
      copyKey = '$' + key;
    }
    copyKey = parseSpecialCharacter(copyKey);
    copyValue[copyKey] = feature[key];
  }
  return copyValue;
}

function startsWithNumber(str) {
  return /^\d/.test(str);
}



;// CONCATENATED MODULE: external "function(){try{return canvg}catch(e){return {}}}()"
const external_function_try_return_canvg_catch_e_return_namespaceObject = function(){try{return canvg}catch(e){return {}}}();
var external_function_try_return_canvg_catch_e_return_default = /*#__PURE__*/__webpack_require__.n(external_function_try_return_canvg_catch_e_return_namespaceObject);
// EXTERNAL MODULE: ./node_modules/fast-xml-parser/src/fxp.js
var fxp = __webpack_require__(932);
;// CONCATENATED MODULE: ./src/mapboxgl/mapping/WebMap.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/


















const MB_SCALEDENOMINATOR_3857 = [
	'559082264.0287178',
	'279541132.0143589',
	'139770566.0071794',
	'69885283.00358972',
	'34942641.50179486',
	'17471320.75089743',
	'8735660.375448715',
	'4367830.1877224357',
	'2183915.093862179',
	'1091957.546931089',
	'545978.7734655447',
	'272989.7734655447',
	'272989.3867327723',
	'136494.6933663862',
	'68247.34668319309',
	'34123.67334159654',
	'17061.83667079827',
	'8530.918335399136',
	'4265.459167699568',
	'2132.729583849784'
];
const MB_SCALEDENOMINATOR_4326 = [
	'5.590822640287176E8',
	'2.795411320143588E8',
	'1.397705660071794E8',
	'6.98852830035897E7',
	'3.494264150179485E7',
	'1.7471320750897426E7',
	'8735660.375448713',
	'4367830.187724357',
	'2183915.0938621783',
	'1091957.5469310891',
	'545978.7734655446',
	'272989.3867327723',
	'136494.69336638614',
	'68247.34668319307',
	'34123.673341596535',
	'17061.836670798268',
	'8530.918335399134'
];
const DEFAULT_WELLKNOWNSCALESET = ['GoogleCRS84Quad', 'GoogleMapsCompatible'];

/**
 * @class WebMap
 * @version 9.1.2
 * @category  iPortal/Online Resources Map
 * @classdesc 对接 iPortal/Online 地图类。目前支持地图坐标系包括：'EPSG:3857'，'EPSG:4326'，'EPSG:4490'，'EPSG:4214'，'EPSG:4610'。
 * <div style="padding: 20px;border: 1px solid #eee;border-left-width: 5px;border-radius: 3px;border-left-color: #ce4844;">
 *      <p style="color: #ce4844">Notice</p>
 *      <p style="font-size: 13px">该功能依赖 <a href='https://iclient.supermap.io/web/libs/geostats/geostats.js'>geostats</a> 和 <a href='https://iclient.supermap.io/web/libs/jsonsql/jsonsql.js'>JsonSql</a> 插件，请确认引入该插件。</p>
 *      <p style="font-size: 13px">&lt;script type="text/javascript" src="https://iclient.supermap.io/web/libs/geostats/geostats.js"&gt;&lt;/script&gt;</p>
 *      <p style="font-size: 13px">&lt;script type="text/javascript" src="https://iclient.supermap.io/web/libs/jsonsql/jsonsql.js"&gt;&lt;/script&gt;</p>
 * </div>
 * @modulecategory Mapping
 * @param {number} id - iPortal|Online 地图 ID。
 * @param {Object} options - 参数。
 * @param {string} [options.target='map'] - 地图容器 ID。
 * @param {string} [options.server="https://www.supermapol.com"] - 地图的地址。
 * @param {string} [options.credentialKey] - 凭证密钥。
 * @param {string} [options.credentialValue] - 凭证值。
 * @param {boolean} [options.withCredentials=false] - 请求是否携带 cookie。
 * @param {boolean} [options.excludePortalProxyUrl] - 服务端传递过来的 URL 是否带有代理。
 * @fires WebMap#getmapfailed
 * @fires WebMap#getwmtsfailed
 * @fires WebMap#getlayersfailed
 * @fires WebMap#getfeaturesfailed
 * @fires WebMap#addlayerssucceeded
 * @extends {mapboxgl.Evented}
 * @usage
 */
class WebMap extends (external_mapboxgl_default()).Evented {
	constructor(id, options) {
		super();
		this.mapId = id;
		options = options || {};
		this.server = options.server;
		this.credentialKey = options.credentialKey;
		this.credentialValue = options.credentialValue;
		this.withCredentials = options.withCredentials || false;
		this.target = options.target || 'map';
    this._canvgsV = [];
		this._createWebMap();
    this.on('mapinitialized', () => {
      this.map.on('remove', () => {
        this._stopCanvg();
      });
    });
	}
	/**
	 * @function WebMap.prototype.resize
	 * @description 地图 resize。
	 */
	resize() {
		this.map.resize();
  }

	/**
	 * @function WebMap.prototype.setMapId
	 * @param {string} mapId - webMap 地图 ID。
	 * @description 设置 WebMap ID。
	 */
	setMapId(mapId) {
		this.mapId = mapId;
		this._createWebMap();
  }

  /**
	 * @function WebMap.prototype.setWebMapOptions
	 * @param {Object} webMapOptions - webMap 参数。
	 * @description 设置 webMap 参数。
	 */
	setWebMapOptions(webMapOptions) {
		this.server = webMapOptions.server;
		this._createWebMap();
	}

  /**
	 * @function WebMap.prototype.setMapOptions
	 * @param {Object} mapOptions - map 参数。
	 * @description 设置 map 参数。
	 */
	setMapOptions(mapOptions) {
		let { center, zoom, maxBounds, minZoom, maxZoom, isWorldCopy, bearing, pitch } = mapOptions;
		center && center.length && this.map.setCenter(center);
		zoom && this.map.setZoom(zoom);
		maxBounds && this.map.setMaxBounds(maxBounds);
		minZoom && this.map.setMinZoom(minZoom);
		maxZoom && this.map.setMaxZoom(maxZoom);
		isWorldCopy && this.map.setRenderWorldCopies(isWorldCopy);
		bearing && this.map.setBearing(bearing);
		pitch && this.map.setPitch(pitch);
	}

	/**
	 * @private
	 * @function WebMap.prototype._createWebMap
	 * @description 登陆窗口后添加地图图层。
	 */
	_createWebMap() {
		let urlArr = this.server.split('');
		if (urlArr[urlArr.length - 1] !== '/') {
			this.server += '/';
		}
		let mapUrl = this.server + 'web/maps/' + this.mapId + '/map';
		if (this.credentialValue && this.credentialKey) {
			mapUrl += '?' + this.credentialKey + '=' + this.credentialValue;
		}
		let filter = 'getUrlResource.json?url=';
		if (this.excludePortalProxyUrl && this.server.indexOf(filter) > -1) {
			//大屏需求,或者有加上代理的
			let urlArray = this.server.split(filter);
			if (urlArray.length > 1) {
				mapUrl = urlArray[0] + filter + this.server + 'web/maps/' + this.mapId + '/map.json';
			}
		}
		this._getMapInfo(mapUrl);
	}

	/**
	 * @private
	 * @function WebMap.prototype._createMap
	 * @description 创建地图。
	 */
	_createMap(mapInfo) {
		// 获取字体样式
		let fonts = [];
		let layers = mapInfo.layers;
		// 获取 label 图层字体类型
		if (layers && layers.length > 0) {
			layers.forEach(layer => {
				layer.labelStyle && fonts.push(layer.labelStyle.fontFamily);
			}, this);
		}
		fonts.push("'supermapol-icons'");
		let fontFamilys = fonts.join(',');

		// zoom center
		let oldcenter = mapInfo.center,
			zoom = mapInfo.level || 0,
            center,
            zoomBase = 0;
        // zoom = zoom === 0 ? 0 : zoom - 1;
        if (mapInfo.minScale && mapInfo.maxScale) {
            zoomBase = this._transformScaleToZoom(mapInfo.minScale, (external_mapboxgl_default()).CRS ? external_mapboxgl_default().CRS.get(this.baseProjection):'EPSG:3857');
        } else {
			const e =
                this._getResolution(
                    (external_mapboxgl_default()).CRS
                        ? external_mapboxgl_default().CRS.get(this.baseProjection).getExtent()
                        : [-20037508.3427892, -20037508.3427892, 20037508.3427892, 20037508.3427892]
                ) / this._getResolution(mapInfo.extent);
            zoomBase = +Math.log(e) / Math.LN2.toFixed(2);
        }
        zoom += zoomBase;
		center = oldcenter ? this._unproject([oldcenter.x, oldcenter.y]) : new (external_mapboxgl_default()).LngLat(0, 0);
		// 初始化 map
		this.map = new (external_mapboxgl_default()).Map({
			container: this.target,
			center: center,
			zoom: zoom,
			style: {
				version: 8,
				sources: {},
				// "glyphs": 'https://iclient.supermap.io/iserver/services/map-beijing/rest/maps/beijingMap/tileFeature/sdffonts/{fontstack}/{range}.pbf',
				layers: []
			},
			crs: this.baseProjection,
			localIdeographFontFamily: fontFamilys || ''
		});
		this.fire('mapinitialized');
	}

	/**
	 * @private
	 * @function WebMap.prototype._getMapInfo
	 * @description 获取地图的 JSON 信息。
	 * @param {string} url - 请求地图的 url。
	 */
	_getMapInfo(url) {
		let mapUrl = url.indexOf('.json') === -1 ? `${url}.json` : url;
		FetchRequest.get(mapUrl, null, { withCredentials: this.withCredentials })
			.then(response => {
				return response.json();
			})
			.then(mapInfo => {
				this.baseProjection = mapInfo.projection;

				//存储地图的名称以及描述等信息，返回给用户
				this.mapParams = {
					title: mapInfo.title,
					description: mapInfo.description
				};
				const projectionMap = {
					'EPSG:4490': 'EPSG:4490',
					'EPSG:4214': 'EPSG:4214',
					'EPSG:4610': 'EPSG:4610',
					'EPSG:3857': 'EPSG:3857',
					'EPSG:4326': 'EPSG:4326'
				}; // 坐标系异常处理
				if (this.baseProjection in projectionMap) {
					this._createMap(mapInfo, this.mapSetting);
					let layers = mapInfo.layers;
					this.map.on('load', () => {
						this._addBaseMap(mapInfo);

						if (!layers || layers.length === 0) {
							this._sendMapToUser(0, 0);
						} else {
							this._addLayers(layers);
						}
					});
				} else {
					throw Error(Lang.i18n('msg_crsunsupport'));
				}
			})
			.catch(error => {
				/**
				 * @event WebMap#getmapfailed
				 * @description 获取地图信息失败。
				 * @property {Object} error - 失败原因。
				 */
				this.fire('getmapfailed', { error: error });
			});
	}

	/**
	 * @private
	 * @function WebMap.prototype._addBaseMap
	 * @description 添加底图。
	 * @param {Object} mapInfo - map 信息。
	 */
	_addBaseMap(mapInfo) {
		this._createBaseLayer(mapInfo);
	}

	/**
	 * @private
	 * @function WebMap.prototype._createBaseLayer
	 * @description 创建底图。
	 * @param {Object} mapInfo - map 信息。
	 */
	_createBaseLayer(mapInfo) {
		let layerInfo = mapInfo.baseLayer || mapInfo;
		let layerType = layerInfo.layerType; //底图和rest地图兼容
		if (
			layerType.indexOf('TIANDITU_VEC') > -1 ||
			layerType.indexOf('TIANDITU_IMG') > -1 ||
			layerType.indexOf('TIANDITU_TER') > -1
		) {
			layerType = layerType.substr(0, 12);
		}
		let mapUrls = {
				CLOUD: 'http://t2.dituhui.com/FileService/image?map=quanguo&type=web&x={x}&y={y}&z={z}',
				CLOUD_BLACK: 'http://t3.dituhui.com/MapService/getGdp?x={x}&y={y}&z={z}',
				OSM: 'http://{a-c}.tile.openstreetmap.org/{z}/{x}/{y}.png',
				GOOGLE:
					'https://www.google.cn/maps/vt/pb=!1m4!1m3!1i{z}!2i{x}!3i{y}!2m3!1e0!2sm!3i380072576!3m8!2szh-CN!3scn!5e1105!12m4!1e68!2m2!1sset!2sRoadmap!4e0!5m1!1e0',
				GOOGLE_CN: 'https://mt{0-3}.google.cn/vt/lyrs=m&hl=zh-CN&gl=cn&x={x}&y={y}&z={z}',
				JAPAN_STD: 'https://cyberjapandata.gsi.go.jp/xyz/std/{z}/{x}/{y}.png',
				JAPAN_PALE: 'https://cyberjapandata.gsi.go.jp/xyz/pale/{z}/{x}/{y}.png',
				JAPAN_RELIEF: 'https://cyberjapandata.gsi.go.jp/xyz/relief/{z}/{x}/{y}.png',
				JAPAN_ORT: 'https://cyberjapandata.gsi.go.jp/xyz/ort/{z}/{x}/{y}.jpg'
			},
			url;
		switch (layerType) {
			case 'TIANDITU_VEC':
			case 'TIANDITU_IMG':
			case 'TIANDITU_TER':
				this._createTiandituLayer(mapInfo);
				break;
			case 'BING':
				this._createBingLayer(layerInfo.name);
				break;
			case 'WMS':
				this._createWMSLayer(layerInfo);
				break;
			case 'WMTS':
				this._createWMTSLayer(layerInfo);
				break;
			case 'TILE':
			case 'SUPERMAP_REST':
				this._createDynamicTiledLayer(layerInfo);
				break;
			case 'CLOUD':
			case 'CLOUD_BLACK':
			case 'OSM':
			case 'JAPAN_ORT':
			case 'JAPAN_RELIEF':
			case 'JAPAN_PALE':
			case 'JAPAN_STD':
			case 'GOOGLE_CN':
			case 'GOOGLE':
				url = mapUrls[layerType];
				this._createXYZLayer(layerInfo, url);
				break;
			case 'MAPBOXSTYLE':
				this._createMapboxStyle(layerInfo);
				break;
			default:
				break;
		}
	}

	/**
	 * @private
	 * @function WebMap.prototype._createMapboxStyle
	 * @description 创建 Mapbox 样式。
	 * @param {Object} mapInfo - map 信息。
	 */
	_createMapboxStyle(mapInfo) {
		let _this = this,
			{ dataSource = {} } = mapInfo,
			{ serverId, url } = dataSource,
			styleUrl;
		styleUrl = serverId !== undefined ? `${this.server}web/datas/${serverId}/download` : url;
		FetchRequest.get(styleUrl, null, {
			withCredentials: this.withCredentials,
			withoutFormatSuffix: true,
			headers: {
				'Content-Type': 'application/json;chartset=uft-8'
			}
		}).then(response => {
			return response.json();
		}).then(style => {
			_this._matchStyleObject(style);
			_this.map.setStyle(style);
		})
	}

	/**
	 * @private
	 * @function WebMap.prototype._matchStyleObject
	 * @description 恢复 style 为标准格式。
	 * @param {Object} style - mapbox 样式。
	 */
	_matchStyleObject(style) {
		let { sprite, glyphs } = style;
		if (sprite && typeof sprite === 'object'){
			style.sprite = Object.values(sprite)[0];
		}
		if (glyphs && typeof glyphs === 'object'){
			style.glyphs = Object.values(glyphs)[0];
		}
	}

	/**
	 * @private
	 * @function WebMap.prototype._createTiandituLayer
	 * @description 创建天地图底图。
	 * @param {Object} mapInfo - map 信息。
	 */
	_createTiandituLayer(mapInfo) {
		let tiandituUrls = this._getTiandituUrl(mapInfo);
		let layerType = mapInfo.baseLayer.layerType;
		let isLabel = Boolean(mapInfo.baseLayer.labelLayerVisible);
		let labelUrl = tiandituUrls['labelUrl'];
		let tiandituUrl = tiandituUrls['tiandituUrl'];
		this._addBaselayer(tiandituUrl, 'tianditu-layers-' + layerType);
		isLabel && this._addBaselayer(labelUrl, 'tianditu-label-layers-' + layerType);
	}

	/**
	 * @private
	 * @function WebMap.prototype._createWMTSLayer
	 * @description 创建 WMTS 底图。
	 * @param {Object} mapInfo - map 信息。
	 */
	_createWMTSLayer(layerInfo) {
		let wmtsUrl = this._getWMTSUrl(layerInfo);
		this._filterWMTSIsMatched(layerInfo, (isMatched, matchMaxZoom) => {
			isMatched && this._addBaselayer([wmtsUrl], 'wmts-layers' + layerInfo.name, 0, matchMaxZoom);
		});
	}

	/**
	 * @private
	 * @function WebMap.prototype._filterWMTSIsMatched
	 * @description 过滤能够跟mapboxgl匹配的wmts服务。
	 * @param {Object} mapInfo - map 信息。
	 * @callback matchedCallback
	 */
	_filterWMTSIsMatched(mapInfo, matchedCallback) {
		let isMatched = false,
			matchMaxZoom = 22,
			url = mapInfo.url;
		let options = {
			withCredentials: false,
			withoutFormatSuffix: true
		};

		FetchRequest.get(url, null, options)
			.then(response => {
				return response.text();
			})
			.then(capabilitiesText => {
        const parser = new fxp.XMLParser({numberParseOptions:{hex : false, leadingZeros: false,eNotation: false},alwaysCreateTextNode: true, textNodeName: "_text"});
                let tileMatrixSet = parser.parse(capabilitiesText)
                    .Capabilities.Contents.TileMatrixSet;
                if (!Array.isArray(tileMatrixSet)) {
                    tileMatrixSet = [tileMatrixSet];
                }
				for (let i = 0; i < tileMatrixSet.length; i++) {
					if (
						tileMatrixSet[i]['ows:Identifier'] &&
						(tileMatrixSet[i]['ows:Identifier']['_text'] + '') === mapInfo.tileMatrixSet
					) {
						if (DEFAULT_WELLKNOWNSCALESET.indexOf(tileMatrixSet[i]['WellKnownScaleSet']['_text']) > -1) {
							isMatched = true;
						} else if (
							tileMatrixSet[i]['WellKnownScaleSet'] &&
							tileMatrixSet[i]['WellKnownScaleSet']['_text'] === 'Custom'
						) {
							let matchedScaleDenominator = [];
							//坐标系判断
							let defaultCRSScaleDenominators =
								this.map.crs === 'EPSG:3857' ? MB_SCALEDENOMINATOR_3857 : MB_SCALEDENOMINATOR_4326;

							for (let j = 0, len = defaultCRSScaleDenominators.length; j < len; j++) {
								if (!tileMatrixSet[i].TileMatrix[j]) {
									break;
								}
								if (
									defaultCRSScaleDenominators[j] !==
									(tileMatrixSet[i].TileMatrix[j]['ScaleDenominator']['_text'] + '')
								) {
									break;
								}
								matchedScaleDenominator.push(defaultCRSScaleDenominators[j]);
							}
							matchMaxZoom = matchedScaleDenominator.length - 1;
							if (matchedScaleDenominator.length !== 0) {
								isMatched = true;
							} else {
								throw Error(Lang.i18n('msg_tilematrixsetunsupport'));
							}
						} else {
							throw Error(Lang.i18n('msg_tilematrixsetunsupport'));
						}
					}
				}
				matchedCallback(isMatched, matchMaxZoom);
			})
			.catch(error => {
				/**
				 * @event WebMap#getwmtsfailed
				 * @description 获取 WMTS 图层信息失败。
				 * @property {Object} error - 失败原因。
				 * @property {mapboxgl.Map} map - MapBoxGL Map 对象。
				 */
				this.fire('getwmtsfailed', { error: error, map: this.map });
			});
	}

	/**
	 * @private
	 * @function WebMap.prototype._createBingLayer
	 * @description 创建 Bing 图层。
	 */
	_createBingLayer(layerName) {
		let bingUrl =
			'https://dynamic.t0.tiles.ditu.live.com/comp/ch/{quadkey}?it=G,TW,L,LA&mkt=zh-cn&og=109&cstl=w4c&ur=CN&n=z';
		this.addLayer([bingUrl], 'bing-layers-' + layerName);
	}

	/**
	 * @private
	 * @function WebMap.prototype._createXYZLayer
	 * @description 创建 XYZ 底图。
	 * @param {string} url - url 地址。
	 */
	_createXYZLayer(layerInfo, url) {
		let urlArr = [];
		if (layerInfo.layerType === 'OSM') {
			let res = url.match(/\w\-\w/g)[0];
			let start = res[0];
			let end = res[2];
			let alphabet = '';
			for (let i = 97; i < 123; i++) {
				alphabet += String.fromCharCode(i);
			}
			let alphabetArr = alphabet.split('');

			let startIndex = alphabetArr.indexOf(start);
			let endIndex = alphabetArr.indexOf(end);

			let res3 = alphabetArr.slice(startIndex, endIndex + 1);

			for (let i = 0; i < res3.length; i++) {
				let replaceRes = url.replace(/{\w\-\w}/g, res3[i]);
				urlArr.push(replaceRes);
			}
		} else if (layerInfo.layerType === 'GOOGLE_CN') {
			let res = url.match(/\d\-\d/g)[0];
			let start = res[0];
			let end = res[2];

			for (let i = start; i <= end; i++) {
				let replaceRes = url.replace(/{\d\-\d}/g, i);
				urlArr.push(replaceRes);
			}
		} else {
			urlArr = [url];
		}
		this._addBaselayer(urlArr, 'XYZ-layers-' + layerInfo.name);
	}

	/**
	 * @private
	 * @function WebMap.prototype._createDynamicTiledLayer
	 * @description 创建 iserver 底图。
	 * @param {Object} layerInfo - 图层信息。
	 */
	_createDynamicTiledLayer(layerInfo) {
        let url = layerInfo.url;
        const layerId = layerInfo.layerID || layerInfo.name;
        const { minzoom, maxzoom } = layerInfo;
        this._addBaselayer([url], layerId, minzoom, maxzoom, true);
	}

	/**
	 * @private
	 * @function WebMap.prototype._createWMSLayer
	 * @description 创建 WMS 图层。
	 * @param {Object} mapInfo - map 信息。
	 */
	_createWMSLayer(layerInfo) {
		let WMSUrl = this._getWMSUrl(layerInfo);
		this._addBaselayer([WMSUrl], 'WMS-layers-' + layerInfo.name);
	}

	/**
	 * @private
	 * @function WebMap.prototype._createVectorLayer
	 * @description 创建 Vector 图层。
	 * @param {Object} layerInfo - map 信息。
	 * @param {Array} features - 属性 信息。
	 */
	_createVectorLayer(layerInfo, features) {
		let style = layerInfo.style;
		let type = layerInfo.featureType;
		let layerID = layerInfo.layerID;
		let visible = layerInfo.visible;
		let layerStyle = {};
		layerStyle.style = this._transformStyleToMapBoxGl(style, type);
		layerStyle.layout = { visibility: visible };
		let source = {
			type: 'geojson',
			data: {
				type: 'FeatureCollection',
				features: features
			}
		};
		this._addOverlayToMap(type, source, layerID, layerStyle);
		// 如果面有边框
		type === 'POLYGON' &&
			style.strokeColor &&
			this._addStrokeLineForPoly(style, source, layerID + '-strokeLine', visible);
	}

	/**
	 * @function WebMap.prototype._getTiandituUrl
	 * @private
	 * @description 创建天地图url;
	 * @param {Object} mapInfo - map 信息。
	 */
	_getTiandituUrl(mapInfo) {
		let re = /t0/gi;
		let tiandituUrls = {};
		let layerType = mapInfo.baseLayer.layerType.split('_')[1].toLowerCase();
		let isLabel = Boolean(mapInfo.baseLayer.labelLayerVisible);
		// let isLabel = true;
		let url = 'https://t0.tianditu.gov.cn/{layer}_{proj}/wmts?';
		let labelUrl = url;
		let layerLabelMap = {
			vec: 'cva',
			ter: 'cta',
			img: 'cia'
		};
		let tilematrixSet = this.baseProjection === 'EPSG:4326' ? 'c' : 'w';
		let options = {
			service: 'WMTS',
			request: 'GetTile',
			style: 'default',
			version: '1.0.0',
			layer: layerType,
			tilematrixSet: tilematrixSet,
			format: 'tiles',
			width: 256,
			height: 256
		};

		url += this._getParamString(options, url) + '&tilematrix={z}&tilerow={y}&tilecol={x}';
		let tiandituUrl = url.replace('{layer}', layerType).replace('{proj}', tilematrixSet);
		let tiandituUrlArr = [];
		for (let i = 0; i < 8; i++) {
			tiandituUrlArr.push(tiandituUrl.replace(re, `t${i}`));
		}
		tiandituUrls['tiandituUrl'] = tiandituUrlArr;

		// 如果有 label 图层
		if (isLabel) {
			let labelLayer = layerLabelMap[layerType];
			options.layer = labelLayer;
			labelUrl += this._getParamString(options, labelUrl) + '&tilematrix={z}&tilerow={y}&tilecol={x}';
			labelUrl = labelUrl.replace('{layer}', labelLayer).replace('{proj}', tilematrixSet);
			let labelUrlArr = [];
			for (let i = 0; i < 8; i++) {
				labelUrlArr.push(labelUrl.replace(re, `t${i}`));
			}
			tiandituUrls['labelUrl'] = labelUrlArr;
		}

		return tiandituUrls;
	}

	/**
	 * @function WebMap.prototype._getWMSUrl
	 * @private
	 * @description 创建 WMS url;
	 * @param {Object} mapInfo - map 信息。
	 */
	_getWMSUrl(mapInfo) {
		let url = mapInfo.url;
		url = url.split('?')[0];
		let strArr = url.split('/');
		let options = {
			service: 'WMS',
			request: 'GetMap',
			layers: strArr[strArr.length - 1],
			styles: '',
			format: 'image/png',
			transparent: 'true',
			version: '1.1.1',
			width: 256,
			height: 256,
			srs: this.baseProjection
		};
		let bbox = this.baseProjection === 'EPSG:4326' ? '{bbox-epsg-4326}' : '{bbox-epsg-3857}';
		url += this._getParamString(options, url) + `&bbox=${bbox}`;
		return url;
	}

	/**
	 * @private
	 * @function WebMap.prototype._addLayers
	 * @description 添加叠加图层。
	 * @param {Object} mapInfo - 图层信息。
	 */
	_addLayers(layers) {
		//存储地图上所有的图层对象
		this.layers = layers;

		let features,
			layerAdded = 0,
			len = layers.length;
		layers.forEach((layer, index) => {
			if ((layer.dataSource && layer.dataSource.serverId) || layer.layerType === 'MARKER') {
				// 获取 serverID
				let serverId = layer.dataSource ? layer.dataSource.serverId : layer.serverId;
				let url = `${this.server}web/datas/${serverId}/content.json?pageSize=9999999&currentPage=1`;
				// 获取图层数据
				serverId &&
					FetchRequest.get(url, null, { withCredentials: this.withCredentials })
						.then(response => {
							return response.json();
						})
						.then(data => {
							if (data.succeed === false) {
								//请求失败
								layerAdded++;
								this._sendMapToUser(layerAdded, len);
								/**
								 * @event WebMap#getlayersfailed
								 * @description 获取图层信息失败。
								 * @property {Object} error - 失败原因。
								 * @property {mapboxgl.Map} map - MapBoxGL Map 对象。
								 */
								this.fire('getlayersfailed', { error: data.error, map: this.map });
								return;
							}
							if (data.type) {
								if (data.type === 'JSON' || data.type === 'GEOJSON') {
									data.content = JSON.parse(data.content.trim());
									features = this._formatGeoJSON(data.content, layer);
								} else if (data.type === 'EXCEL' || data.type === 'CSV') {
									features = this._excelData2Feature(data.content, layer);
								}
								this._addLayer(layer, features, index);
								layerAdded++;
								this._sendMapToUser(layerAdded, len);
							}
						})
						.catch(error => {
							layerAdded++;
							this._sendMapToUser(layerAdded, len);
							this.fire('getlayersfailed', { error: error, map: this.map });
						});
			} else if (
				layer.layerType === 'SUPERMAP_REST' ||
				layer.layerType === 'TILE' ||
				layer.layerType === 'WMS' ||
				layer.layerType === 'WMTS'
			) {
				this._createBaseLayer(layer);
				layerAdded++;
				this._sendMapToUser(layerAdded, len);
			} else if (layer.dataSource && layer.dataSource.type === 'REST_DATA') {
				let dataSource = layer.dataSource;
				//从restData获取数据
				this._getFeatureBySQL(
					dataSource.url,
					[dataSource.dataSourseName || layer.name],
					result => {
						features = this._parseGeoJsonData2Feature({
							allDatas: { features: result.result.features.features },
							fileCode: layer.projection,
							featureProjection: this.baseProjection
						});

						this._addLayer(layer, features, index);
						layerAdded++;
						this._sendMapToUser(layerAdded, len);
					},
					err => {
						layerAdded++;
						this._sendMapToUser(layerAdded, len);
						/**
						 * @event WebMap#getfeaturesfailed
						 * @description 获取图层要素失败。
						 * @property {Object} error - 失败原因。
						 */
						this.fire('getfeaturesfailed', { error: err });
					}
				);
			} else if (layer.dataSource && layer.dataSource.type === 'REST_MAP' && layer.dataSource.url) {
				this._queryFeatureBySQL(
					layer.dataSource.url,
					layer.dataSource.layerName,
					'smid=1',
					null,
					null,
					result => {
						let recordsets = result && result.result.recordsets;
						let recordset = recordsets && recordsets[0];
						let attributes = recordset.fields;
						if (recordset && attributes) {
							let fileterAttrs = [];
							for (let i in attributes) {
								let value = attributes[i];
								if (value.indexOf('Sm') !== 0 || value === 'SmID') {
									fileterAttrs.push(value);
								}
							}
							this._getFeatures(
								fileterAttrs,
								layer,
								features => {
									this._addLayer(layer, features, index);
									layerAdded++;
									this._sendMapToUser(layerAdded, len);
								},
								err => {
									layerAdded++;
									this.fire('getfeaturesfailed', { error: err, map: this.map });
								}
							);
						}
					},
					err => {
						this.fire('getlayersfailed', { error: err, map: this.map });
					}
				);
			}
		}, this);
	}
	/**
	 * @private
	 * @function WebMap.prototype._getFeatures
	 * @description 将单个图层添加到地图上。
	 * @param layerInfo  某个图层的图层信息
	 * @param {Array.<GeoJSON>} features - feature。
	 */
	_getFeatures(fields, layerInfo, resolve, reject) {
		let source = layerInfo.dataSource;
		//示例数据
		let fileCode = layerInfo.projection;
		this._queryFeatureBySQL(
			source.url,
			source.layerName,
			null,
			fields,
			null,
			result => {
				let recordsets = result.result.recordsets[0];
				let features = recordsets.features.features;

				let featuresObj = this._parseGeoJsonData2Feature(
					{
						allDatas: { features },
						fileCode: fileCode,
						featureProjection: this.baseProjection
					},
					'JSON'
				);
				resolve(featuresObj);
			},
			err => {
				reject(err);
			}
		);
	}

	/**
	 * @private
	 * @function WebMap.prototype._addLayer
	 * @description 将单个图层添加到地图上。
	 * @param layerInfo  某个图层的图层信息
	 * @param {Array.<GeoJSON>} features - feature。
	 */
	_addLayer(layerInfo, features, index) {
		let layerType = layerInfo.layerType;
		layerInfo.layerID = layerType + '-' + layerInfo.name + '-' + index;
		layerInfo.visible = layerInfo.visible ? 'visible' : 'none';
		// mbgl 目前不能处理 geojson 复杂面情况
		// mbgl isssue https://github.com/mapbox/mapbox-gl-js/issues/7023
		if (features[0] && features[0].geometry.type === 'Polygon') {
			features = this._handleMultyPolygon(features);
		}

		if (layerInfo.style && layerInfo.filterCondition) {
			//将 feature 根据过滤条件进行过滤, 分段专题图和单值专题图因为要计算 styleGroup 所以暂时不过滤
			if (layerType !== 'RANGE' && layerType !== 'UNIQUE') {
				features = this._getFiterFeatures(layerInfo.filterCondition, features);
			}
		}

		if (layerType === 'VECTOR') {
			if (layerInfo.featureType === 'POINT') {
				if (layerInfo.style.type === 'SYMBOL_POINT') {
					this._createSymbolLayer(layerInfo, features);
				} else {
					this._createGraphicLayer(layerInfo, features);
				}
			} else {
				//线和面
				this._createVectorLayer(layerInfo, features);
			}
		} else if (layerType === 'UNIQUE') {
			this._createUniqueLayer(layerInfo, features);
		} else if (layerType === 'RANGE') {
			this._createRangeLayer(layerInfo, features);
		} else if (layerType === 'HEAT') {
			this._createHeatLayer(layerInfo, features);
		} else if (layerType === 'MARKER') {
			this._createMarkerLayer(layerInfo, features);
		}
		if (layerInfo.labelStyle && layerInfo.labelStyle.labelField) {
			// 存在标签专题图
			this._addLabelLayer(layerInfo, features);
		}
	}

	/**
	 * @private
	 * @function WebMap.prototype._addLabelLayer
	 * @description 添加标签图层。
	 * @param layerInfo  某个图层的图层信息。
	 * @param {Array.<GeoJSON>} features - feature。
	 */
	_addLabelLayer(layerInfo, features) {
		let labelStyle = layerInfo.labelStyle;

		this.map.addLayer({
			id: layerInfo.layerID + 'label',
			type: 'symbol',
			source: {
				type: 'geojson',
				data: {
					type: 'FeatureCollection',
					features: features
				}
			},
			paint: {
				'text-color': labelStyle.fill
			},
			layout: {
				'text-field': `{${labelStyle.labelField}}`,
				'text-size': parseFloat(labelStyle.fontSize) || 12,
				'text-offset': labelStyle.offsetX
					? [labelStyle.offsetX / 10 || 0, labelStyle.offsetY / 10 || 0]
					: [0, -1.5],
				'text-font': ['DIN Offc Pro Italic', 'Arial Unicode MS Regular'],
				visibility: layerInfo.visible
			}
		});
	}

	/**
	 * @private
	 * @function WebMap.prototype._createSymbolLayer
	 * @description 添加 symbol 图层。
	 * @param layerInfo  某个图层的图层信息。
	 * @param {Array.<GeoJSON>} features - feature。
	 */
	_createSymbolLayer(layerInfo, features) {
		//用来请求symbol_point字体文件
		let target = document.getElementById(`${this.target}`);
		target.classList.add('supermapol-icons-map');

		let style = layerInfo.style;
		let unicode = layerInfo.style.unicode;
		let text = String.fromCharCode(parseInt(unicode.replace(/^&#x/, ''), 16));
		let layerID = layerInfo.layerID;
		this.map.addSource(layerID + '-source', {
			type: 'geojson',
			data: {
				type: 'FeatureCollection',
				features: []
			}
		});
		this.map.addLayer({
			id: layerID,
			type: 'symbol',
			source: layerID + '-source',
			paint: {
				'text-color': style.fillColor
			},
			layout: {
				'text-field': text,
				'text-font': ['DIN Offc Pro Italic', 'Arial Unicode MS Regular'],
				visibility: layerInfo.visible
			}
		});
		this.map.getSource(layerID + '-source').setData({
			type: 'FeatureCollection',
			features: features
		});
	}

	/**
	 * @private
	 * @function WebMap.prototype._createGraphicLayer
	 * @description 创建 Graphic 图层。
	 * @param {Object} layerInfo - map 信息。
	 * @param {Array} features - 属性 信息。
	 */
	_createGraphicLayer(layerInfo, features) {
		let style = layerInfo.style;
		let layerStyle = {};
		let layerID = layerInfo.layerID;
		let source = {
			type: 'geojson',
			data: {
				type: 'FeatureCollection',
				features: features
			}
		};

		if (style.type === 'IMAGE_POINT') {
			let imageInfo = style.imageInfo;
			let imgDom = imageInfo.img;
			if (!imgDom || !imgDom.src) {
				//要组装成完整的url
				imageInfo.url = this.server + imageInfo.url;
			}
			this.map.loadImage(imageInfo.url || imgDom.src, (error, image) => {
				if (error) {
					console.log(error);
				}
				let iconSize = Number.parseFloat((style.radius / image.height).toFixed(2)) * 2;
				this.map.addImage('imageIcon', image);
				this.map.addLayer({
					id: layerID,
					type: 'symbol',
					source: source,
					layout: {
						'icon-image': 'imageIcon',
						'icon-size': iconSize,
						visibility: layerInfo.visible
					}
				});
			});
		} else if (style.type === 'SVG_POINT') {
			let svg_url = style.url;
			if (!this.svgDiv) {
				this.svgDiv = document.createElement('div');
				document.body.appendChild(this.svgDiv);
			}
			this._getCanvasFromSVG(svg_url, this.svgDiv, canvas => {
				let imgUrl = canvas.toDataURL('img/png');
				imgUrl &&
					this.map.loadImage(
						imgUrl,
						(error, image) => {
							if (error) {
								console.log(error);
							}
							let iconSize = Number.parseFloat((style.radius / canvas.width).toFixed(2));
							this.map.addImage('imageIcon', image);
							this.map.addLayer({
								id: layerID,
								type: 'symbol',
								source: source,
								layout: {
									'icon-image': 'imageIcon',
									'icon-size': iconSize,
									visibility: layerInfo.visible
								}
							});
						},
						this
					);
			});
		} else {
			layerStyle.style = this._transformStyleToMapBoxGl(style, layerInfo.featureType);
			layerStyle.layout = { visibility: layerInfo.visible };
			this._addOverlayToMap('POINT', source, layerID, layerStyle);
		}
	}

	/**
	 * @private
	 * @function WebMap.prototype._createUniqueLayer
	 * @description 创建单值图层。
	 * @param layerInfo  某个图层的图层信息
	 * @param features   图层上的 feature
	 */
	_createUniqueLayer(layerInfo, features) {
		let styleGroup = this._getUniqueStyleGroup(layerInfo, features);
		features = this._getFiterFeatures(layerInfo.filterCondition, features);

		let style = layerInfo.style;
		let layerStyle = {};
		let themeField = layerInfo.themeSetting.themeField;
		let type = layerInfo.featureType;
		let expression = ['match', ['get', 'index']];
		let layerID = layerInfo.layerID;
		features.forEach(row => {
			styleGroup.forEach(item => {
				if (item.value === row.properties[themeField]) {
					expression.push(row.properties['index'], item.color);
				}
			});
		});
		expression.push('#ffffff');
		layerStyle.style = this._transformStyleToMapBoxGl(style, type, expression);
		let visible = layerInfo.visible;
		layerStyle.layout = { visibility: visible };
		let source = {
			type: 'geojson',
			data: {
				type: 'FeatureCollection',
				features: features
			}
		};
		this._addOverlayToMap(type, source, layerID, layerStyle);
		type === 'POLYGON' &&
			style.strokeColor &&
			this._addStrokeLineForPoly(style, source, layerID + '-strokeLine', visible);
	}

	/**
	 * @private
	 * @function WebMap.prototype._getUniqueStyleGroup
	 * @description 获取单值的目标字段与颜色的对应数组。
	 * @param layerInfo  某个图层的图层信息
	 * @param features   图层上的 feature
	 */
	_getUniqueStyleGroup(parameters, features) {
		// 找出所有的单值
		let featureType = parameters.featureType,
			style = parameters.style,
			themeSetting = parameters.themeSetting;
		let fieldName = themeSetting.themeField,
			colors = themeSetting.colors;

		let names = [],
			customSettings = themeSetting.customSettings;
		for (let i in features) {
			let properties = features[i].properties;
			let name = properties[fieldName];
			let isSaved = false;
			for (let j in names) {
				if (names[j] === name) {
					isSaved = true;
					break;
				}
			}
			if (!isSaved) {
				names.push(name);
			}
		}

		//获取一定量的颜色
		let curentColors = colors || this.defaultParameters.colors;
		curentColors = ColorsPickerUtil.getGradientColors(curentColors, names.length);

		//生成styleGroup
		let styleGroup = [];
		names.forEach((name, index) => {
			let color = curentColors[index];
			if (name in customSettings) {
				color = customSettings[name];
			}
			if (featureType === 'LINE') {
				style.strokeColor = color;
			} else {
				style.fillColor = color;
			}
			styleGroup.push({ color: color, value: name });
		}, this);

		return styleGroup;
	}

	/**
	 * @private
	 * @function WebMap.prototype._getWMTSUrl
	 * @description 根据传入的配置信息拼接wmts url。
	 * @param options 配置对象
	 */
	_getWMTSUrl(options) {
		let obj = {
			service: 'WMTS',
			request: 'GetTile',
			version: '1.0.0',
			style: 'default',
			layer: options.layer,
			tilematrixSet: options.tileMatrixSet,
			format: 'image/png'
		};
		let url = options.url;

		url += this._getParamString(obj, url) + '&tilematrix={z}&tilerow={y}&tilecol={x}';

		return url;
	}

	/**
	 * @private
	 * @function WebMap.prototype._createMarkerLayer
	 * @description 添加标记图层。
	 * @param {Array.<GeoJSON>} features - feature。
	 */
	_createMarkerLayer(layerInfo, features) {
		features &&
			features.forEach(feature => {
				let geomType = feature.geometry.type.toUpperCase();
				let defaultStyle = feature.dv_v5_markerStyle;
				if (geomType === 'POINT' && defaultStyle.text) {
					//说明是文字的feature类型
					geomType = 'TEXT';
				}
				let featureInfo = this.setFeatureInfo(feature);
				feature.properties['useStyle'] = defaultStyle;
				feature.properties['featureInfo'] = featureInfo;
				if (
					geomType === 'POINT' &&
					defaultStyle.src &&
					(defaultStyle.src.indexOf('http://') === -1 && defaultStyle.src.indexOf('https://') === -1)
				) {
					//说明地址不完整
					defaultStyle.src = this.server + defaultStyle.src;
				}

				let source = {
					type: 'geojson',
					data: feature
				};
				let index = feature.properties.index;
				let layerID = geomType + '-' + index;
				// image-marker
				geomType === 'POINT' &&
					defaultStyle.src &&
					defaultStyle.src.indexOf('svg') <= -1 &&
					this.map.loadImage(
						defaultStyle.src,
						(error, image) => {
							if (error) {
								console.log(error);
							}
							this.map.addImage(index + '', image);
							this.map.addLayer({
								id: layerID,
								type: 'symbol',
								source: source,
								layout: {
									'icon-image': index + '',
									'icon-size': defaultStyle.scale,
									visibility: layerInfo.visible
								}
							});
						},
						this
					);

				// svg-marker
				if (geomType === 'POINT' && defaultStyle.src && defaultStyle.src.indexOf('svg') > -1) {
					if (!this.svgDiv) {
						this.svgDiv = document.createElement('div');
						document.body.appendChild(this.svgDiv);
					}
					this._getCanvasFromSVG(defaultStyle.src, this.svgDiv, canvas => {
						let imgUrl = canvas.toDataURL('img/png');
						imgUrl &&
							this.map.loadImage(
								imgUrl,
								(error, image) => {
									if (error) {
										console.log(error);
									}
									this.map.addImage(index + '', image);
									this.map.addLayer({
										id: layerID,
										type: 'symbol',
										source: source,
										layout: {
											'icon-image': index + '',
											'icon-size': defaultStyle.scale,
											visibility: layerInfo.visible
										}
									});
								},
								this
							);
					});
				}
				// point-line-polygon-marker
				if (!defaultStyle.src) {
					let layeStyle = { layout: {} };
					if (geomType === 'LINESTRING' && defaultStyle.lineCap) {
						geomType = 'LINE';
						layeStyle.layout = { 'line-cap': defaultStyle.lineCap };
					}
					let visible = layerInfo.visible;
					layeStyle.layout.visibility = visible;
					// get style
					layeStyle.style = this._transformStyleToMapBoxGl(defaultStyle, geomType);
					this._addOverlayToMap(geomType, source, layerID, layeStyle);
					// 若面有边框
					geomType === 'POLYGON' &&
						defaultStyle.strokeColor &&
						this._addStrokeLineForPoly(defaultStyle, source, layerID + '-strokeLine', visible);
				}
			}, this);
	}

	/**
	 * @private
	 * @function WebMap.prototype.setFeatureInfo
	 * @description 设置 feature 信息。
	 * @param {Array.<GeoJSON>} features - feature。
	 */
	setFeatureInfo(feature) {
		let featureInfo;
		let info = feature.dv_v5_markerInfo;
		if (info && info.dataViz_title) {
			//有featureInfo信息就不需要再添加
			featureInfo = info;
		} else {
			// featureInfo = this.getDefaultAttribute();
			return info;
		}
		let properties = feature.properties;
		for (let key in featureInfo) {
			if (properties[key]) {
				featureInfo[key] = properties[key];
				delete properties[key];
			}
		}
		return featureInfo;
	}

	/**
	 * @private
	 * @function WebMap.prototype._createHeatLayer
	 * @description 添加热力图。
	 * @param {Array.<GeoJSON>} features - feature。
	 */
	_createHeatLayer(layerInfo, features) {
		let style = layerInfo.themeSetting;
		let layerOption = {};
		layerOption.gradient = style.colors.slice();
		layerOption.radius = parseInt(style.radius);
		//自定义颜色
		let customSettings = style.customSettings;
		for (let i in customSettings) {
			layerOption.gradient[i] = customSettings[i];
		}
		// 权重字段恢复
		if (style.weight) {
			this._changeWeight(features, style.weight);
		}

		let color = ['interpolate', ['linear'], ['heatmap-density']];
		let length = layerOption.gradient.length;
		let step = (1 / length).toFixed(2);
		layerOption.gradient.forEach((item, index) => {
			color.push(index * step);
			if (index === 0) {
				item = core_Util_Util.hexToRgba(item, 0);
			}
			color.push(item);
		});

		let paint = {
			'heatmap-color': color,
			'heatmap-radius': style.radius + 15,
			'heatmap-intensity': { base: 1, stops: [[0, 0.8], [22, 1]] }
		};
		if (features[0].weight && features.length >= 4) {
			let weight = [];
			features.forEach(item => {
				weight.push(item.weight);
			});
			let max = ArrayStatistic.getMax(weight);
			let min = ArrayStatistic.getMin(weight);
			paint['heatmap-weight'] = ['interpolate', ['linear'], ['get', 'weight'], min, 0, max, 1];
		}

		this.map.addLayer({
			id: layerInfo.layerID,
			type: 'heatmap',
			source: {
				type: 'geojson',
				data: {
					type: 'FeatureCollection',
					features: features
				}
			},
			paint: paint
		});
	}

	/**
	 * @private
	 * @function WebMap.prototype._changeWeight
	 * @description 改变当前权重字段
	 * @param {Array.<GeoJSON>} features - feature。
	 * @param {string} weightFeild - 权重字段
	 */
	_changeWeight(features, weightFeild) {
		this.fieldMaxValue = {};
		this._getMaxValue(features, weightFeild);
		let maxValue = this.fieldMaxValue[weightFeild];
		features.forEach(feature => {
			let attributes = feature.properties;
			let value = attributes[weightFeild];
			feature['weight'] = value / maxValue;
		});
	}

	/**
	 * @private
	 * @function WebMap.prototype._getMaxValue
	 * @description 获取当前字段对应的最大值，用于计算权重。
	 * @param {Array.<GeoJSON>} features - feature。
	 * @param {string} weightFeild - 权重字段
	 */
	_getMaxValue(features, weightField) {
		let values = [],
			attributes;
		let field = weightField;
		if (this.fieldMaxValue[field]) {
			return;
		}
		features.forEach(feature => {
			//收集当前权重字段对应的所有值
			attributes = feature.properties;
			attributes && parseFloat(attributes[field]) && values.push(parseFloat(attributes[field]));
		});
		this.fieldMaxValue[field] = ArrayStatistic.getArrayStatistic(values, 'Maximum');
	}

	/**
	 * @private
	 * @function WebMap.prototype._createRangeLayer
	 * @description 添加分段专题图。
	 * @param {Array.<GeoJSON>} features - feature。
	 */
	_createRangeLayer(layerInfo, features) {
		let fieldName = layerInfo.themeSetting.themeField;
		let style = layerInfo.style;
		let featureType = layerInfo.featureType;
		let styleGroups = this._getRangeStyleGroup(layerInfo, features);
		features = this._getFiterFeatures(layerInfo.filterCondition, features);

		let source = {
			type: 'geojson',
			data: {
				type: 'FeatureCollection',
				features: features
			}
		};

		// 获取 expression
		let expression = ['match', ['get', 'index']];
		features.forEach(row => {
			let tartget = parseFloat(row.properties[fieldName]);
			for (let i = 0; i < styleGroups.length; i++) {
				if (styleGroups[i].start <= tartget && tartget < styleGroups[i].end) {
					expression.push(row.properties['index'], styleGroups[i].color);
					// return;
				}
			}
			!tartget && expression.push(row.properties['index'], 'rgba(0, 0, 0, 0)');
		}, this);
		expression.push('rgba(0, 0, 0, 0)');

		// 获取样式
		let layerStyle = { layout: {} };
		if (featureType === 'LINE' && style.lineCap) {
			layerStyle.layout = { 'line-cap': style.lineCap };
		}
		let visible = layerInfo.visible;
		layerStyle.layout.visibility = visible;
		layerStyle.style = this._transformStyleToMapBoxGl(style, featureType, expression);
		// 添加图层
		let layerID = layerInfo.layerID;
		this._addOverlayToMap(featureType, source, layerID, layerStyle);
		// 如果面有边框
		featureType === 'POLYGON' &&
			style.strokeColor &&
			this._addStrokeLineForPoly(style, source, layerID + '-strokeline', visible);
	}

	/**
	 * @private
	 * @function WebMap.prototype._getFiterFeatures
	 * @description 通过过滤条件查询满足的 feature。
	 * @param {string} filterCondition - 过滤条件。
	 * @param {Array} allFeatures - 图层上的 feature 集合
	 */
	_getFiterFeatures(filterCondition, allFeatures) {
		if (!filterCondition) {
			return allFeatures;
		}
		let condition = this._replaceFilterCharacter(filterCondition);
		let filterFeatures = [];
		for (let i = 0; i < allFeatures.length; i++) {
			let feature = allFeatures[i];
			let filterResult = false;
			try {
        const properties = feature.properties;
        const conditions = parseCondition(condition, Object.keys(properties));
        const filterFeature = parseConditionFeature(properties);
        const sql = 'select * from json where (' + conditions + ')';
        filterResult = window.jsonsql.query(sql, { attr: filterFeature });
			} catch (err) {
				//必须把要过滤得内容封装成一个对象,主要是处理jsonsql(line : 62)中由于with语句遍历对象造成的问题
				continue;
			}
			if (filterResult && filterResult.length > 0) {
				//afterFilterFeatureIdx.push(i);
				filterFeatures.push(feature);
			}
		}
		return filterFeatures;
	}
	/**
	 * @private
	 * @function WebMap.prototype._replaceFilterCharacter
	 * @description 获取过滤字符串。
	 * @param {string} filterString - 过滤条件。
	 */
	_replaceFilterCharacter(filterString) {
		filterString = filterString
			.replace(/=/g, '==')
			.replace(/AND|and/g, '&&')
			.replace(/or|OR/g, '||')
			.replace(/<==/g, '<=')
			.replace(/>==/g, '>=');
		return filterString;
	}

	/**
	 * @private
	 * @function WebMap.prototype._getRangeStyleGroup
	 * @description 获取分段样式。
	 * @param {Array.<GeoJSON>} features - feature。
	 */
	_getRangeStyleGroup(layerInfo, features) {
		// 找出分段值
		let featureType = layerInfo.featureType;
		let style = layerInfo.style;
		let values = [],
			attributes;

		let themeSetting = layerInfo.themeSetting;
		let customSettings = themeSetting.customSettings;
		let fieldName = themeSetting.themeField;
		let segmentCount = themeSetting.segmentCount;

		features.forEach(feature => {
			attributes = feature.properties || feature.get('Properties');
			if (attributes) {
				//过滤掉非数值的数据
				attributes[fieldName] &&
					core_Util_Util.isNumber(attributes[fieldName]) &&
					values.push(parseFloat(attributes[fieldName]));
			} else if (feature.get(fieldName) && core_Util_Util.isNumber(feature.get(fieldName))) {
				feature.get(fieldName) && values.push(parseFloat(feature.get(fieldName)));
			}
		}, this);

		let segements = ArrayStatistic.getArraySegments(values, themeSetting.segmentMethod, segmentCount);
		if (segements) {
			let itemNum = segmentCount;
			if (attributes && segements[0] === segements[attributes.length - 1]) {
				itemNum = 1;
				segements.length = 2;
			}

			//保留两位有效数
			for (let key in segements) {
				let value = segements[key];
				value = key == 0 ? Math.floor(value * 100) / 100 : Math.ceil(value * 100) / 100 + 0.1; // 加0.1 解决最大值没有样式问题
				segements[key] = Number(value.toFixed(2));
			}

			//获取一定量的颜色
			let curentColors = themeSetting.colors;
			// curentColors = ColorsPickerUtil.getGradientColors(curentColors, itemNum, 'RANGE');

			for (let index = 0; index < itemNum; index++) {
				if (index in customSettings) {
					if (customSettings[index]['segment']['start']) {
						segements[index] = customSettings[index]['segment']['start'];
					}
					if (customSettings[index]['segment']['end']) {
						segements[index + 1] = customSettings[index]['segment']['end'];
					}
				}
			}
			//生成styleGroup
			let styleGroups = [];
			for (let i = 0; i < itemNum; i++) {
				let color = curentColors[i];
				if (i in customSettings) {
					if (customSettings[i].color) {
						color = customSettings[i].color;
					}
				}
				if (featureType === 'LINE') {
					style.strokeColor = color;
				} else {
					style.fillColor = color;
				}

				let start = segements[i];
				let end = segements[i + 1];
				let styleObj = JSON.parse(JSON.stringify(style));
				styleGroups.push({ style: styleObj, color: color, start: start, end: end });
			}
			return styleGroups;
		}
	}

	/**
	 * @private
	 * @function WebMap.prototype._formatGeoJSON
	 * @description 格式 GeoJSON。
	 * @param {GeoJSON} data - GeoJSON 数据。
	 */
	_formatGeoJSON(data) {
		let features = data.features;
		features.forEach((row, index) => {
			row.properties['index'] = index;
			// TODO 待优化 坐标转换
			// if (fileCode !== 'EPSG:4326') {
			//     if(row.geometry.coordinates[0] instanceof Array){
			//         row.geometry.coordinates.forEach((coords, index) => {
			//             let lnglat = this._unproject(coords);
			//             row.geometry.coordinates[index] = [lnglat.lng, lnglat.lat];
			//         }, this)
			//         return;
			//     }
			//     let lnglat = this._unproject(row.geometry.coordinates);
			//     row.geometry.coordinates = [lnglat.lng, lnglat.lat];
			// }
		});
		return features;
	}

	/**
	 * @private
	 * @function WebMap.prototype._excelData2Feature将
	 * @description csv 和 xls 文件内容转换成 geojson
	 * @param content  文件内容
	 * @param layerInfo  图层信息
	 * @returns {Array}  feature的数组集合
	 */
	_excelData2Feature(dataContent) {
		let fieldCaptions = dataContent.colTitles;
		// let fileCode = layerInfo.projection;
		//位置属性处理
		let xfieldIndex = -1,
			yfieldIndex = -1;
		for (let i = 0, len = fieldCaptions.length; i < len; i++) {
			if (this._isXField(fieldCaptions[i])) {
				xfieldIndex = i;
			}
			if (this._isYField(fieldCaptions[i])) {
				yfieldIndex = i;
			}
		}

		// feature 构建后期支持坐标系 4326/3857
		let features = [];

		for (let i = 0, len = dataContent.rows.length; i < len; i++) {
			let row = dataContent.rows[i];

			let x = Number(row[xfieldIndex]),
				y = Number(row[yfieldIndex]);
			// let coordinates = [x, y];
			// TODO 待优化 坐标转换
			// if (fileCode !== 'EPSG:4326') {
			//     if(row.geometry.coordinates[0] instanceof Array){
			//         row.geometry.coordinates.forEach((coords, index) => {
			//             let lnglat = this._unproject(coords);
			//             row.geometry.coordinates[index] = [lnglat.lng, lnglat.lat];
			//         }, this)
			//         return;
			//     }
			//     let lnglat = this._unproject(row.geometry.coordinates);
			//     row.geometry.coordinates = [lnglat.lng, lnglat.lat];
			// }

			//属性信息
			let attributes = {};
			for (let index in dataContent.colTitles) {
				let key = dataContent.colTitles[index];
				attributes[key] = dataContent.rows[i][index];
			}
			attributes['index'] = i + '';
			//目前csv 只支持处理点，所以先生成点类型的 geojson
			let feature = {
				type: 'Feature',
				geometry: {
					type: 'Point',
					coordinates: [x, y]
				},
				properties: attributes
			};
			features.push(feature);
		}
		return features;
	}

	/**
	 * @private
	 * @function WebMap.prototype._sendMapToUser
	 * @description 返回最终的 map 对象给用户，供他们操作使用。
	 * @param count
	 * @param layersLen
	 */
	_sendMapToUser(count, layersLen) {
		if (count === layersLen) {
			/**
			 * @event WebMap#addlayerssucceeded
			 * @description 添加图层成功。
			 * @property {mapboxgl.Map} map - MapBoxGL Map 对象。
			 * @property {Object} mapparams - 地图信息。
			 * @property {string} mapparams.title - 地图标题。
			 * @property {string} mapparams.description - 地图描述。
			 * @property {Array.<Object>} layers - 地图上所有的图层对象
			 */
			this.fire('addlayerssucceeded', { map: this.map, mapparams: this.mapParams, layers: this.layers });
		}
	}

	/**
	 * @function WebMap.prototype._unproject
	 * @private
	 * @description 墨卡托转经纬度。
	 * @param {} point - 待转换的点。
	 */
	_unproject(point) {
		var d = 180 / Math.PI,
			r = 6378137,
			ts = Math.exp(-point[1] / r),
			phi = Math.PI / 2 - 2 * Math.atan(ts);
		for (var i = 0, dphi = 0.1, con; i < 15 && Math.abs(dphi) > 1e-7; i++) {
			con = 1;
			dphi = Math.PI / 2 - 2 * Math.atan(ts * con) - phi;
			phi += dphi;
		}
		return new (external_mapboxgl_default()).LngLat((point[0] * d) / r, phi * d);
	}

	/**
	 * @function WebMap.prototype._getParamString
	 * @private
	 * @param {Object} obj - 待添加的参数。
	 * @param {string} existingUrl - 待添加参数的 url。
	 * @param {boolean} [uppercase] - 参数是否转换为大写。
	 */
	_getParamString(obj, existingUrl, uppercase) {
		var params = [];
		for (var i in obj) {
			params.push((uppercase ? i.toUpperCase() : i) + '=' + obj[i]);
		}
		return (!existingUrl || existingUrl.indexOf('?') === -1 ? '?' : '&') + params.join('&');
	}

	/**
	 * @private
	 * @description 判断是否地理X坐标
	 * @param data
	 */
	_isXField(data) {
		var lowerdata = data.toLowerCase();
		return (
			lowerdata === 'x' ||
			lowerdata === 'smx' ||
			lowerdata === 'jd' ||
			lowerdata === '经度' ||
			lowerdata === '东经' ||
			lowerdata === 'longitude' ||
			lowerdata === 'lot' ||
			lowerdata === 'lon' ||
			lowerdata === 'lng'
		);
	}

	/**
	 * @private
	 * @description 判断是否地理Y坐标
	 * @param data
	 */
	_isYField(data) {
		var lowerdata = data.toLowerCase();
		return (
			lowerdata === 'y' ||
			lowerdata === 'smy' ||
			lowerdata === 'wd' ||
			lowerdata === '纬度' ||
			lowerdata === '北纬' ||
			lowerdata === 'latitude' ||
			lowerdata === 'lat'
		);
	}

	/**
	 * @private
	 * @function WebMap.prototype._transformStyleToMapBoxGl
	 * @description 根据图层类型将 layerInfo 中的 style 属性格式转换为 mapboxgl 中的 style 格式。
	 * @param {Object} style - layerInfo中的style属性
	 * @param {string} type - 图层类型
	 * @param {Array} [expression] - 存储颜色值得表达式
	 */
	_transformStyleToMapBoxGl(style, type, expression) {
		let transTable = {};
		if ((style.type === 'POINT' || style.type === 'BASIC_POINT' || type === 'POINT') && type !== 'LINE') {
			transTable = {
				fillColor: 'circle-color',
				strokeWidth: 'circle-stroke-width',
				fillOpacity: 'circle-opacity',
				radius: 'circle-radius',
				strokeColor: 'circle-stroke-color',
				strokeOpacity: 'circle-stroke-opacity'
			};
		} else if (type === 'LINE') {
			transTable = {
				strokeWidth: 'line-width',
				strokeColor: 'line-color',
				strokeOpacity: 'line-opacity'
			};
		} else if (type === 'POLYGON') {
			transTable = {
				fillColor: 'fill-color',
				fillOpacity: 'fill-opacity',
				strokeColor: 'fill-outline-color'
			};
		}

		let newObj = {};
		for (let item in style) {
			if (transTable[item]) {
				newObj[transTable[item]] = style[item];
			}
		}
		if (expression) {
			if (newObj['circle-color']) {
				newObj['circle-color'] = expression;
			} else if (newObj['line-color']) {
				newObj['line-color'] = expression;
			} else {
				newObj['fill-color'] = expression;
			}
		}
		if (style.lineDash && style.lineDash !== 'solid' && type === 'LINE') {
			newObj['line-dasharray'] = this._dashStyle(style);
		}
		return newObj;
	}

	/**
	 * @private
	 * @function WebMap.prototype.._dashStyle
	 * @description 符号样式。
	 * @param {Object} style - 样式参数。
	 * @param {number} widthFactor - 宽度系数。
	 */
	_dashStyle(style) {
		if (!style) {
			return [];
		}
		// var w = style.strokeWidth * widthFactor;
		var w = 1;
		var str = style.strokeDashstyle || style.lineDash;
		switch (str) {
			case 'solid':
				return [];
			case 'dot':
				return [1, 4 * w];
			case 'dash':
				return [4 * w, 4 * w];
			case 'dashdot':
				return [4 * w, 4 * w, 1 * w, 4 * w];
			case 'longdash':
				return [8 * w, 4 * w];
			case 'longdashdot':
				return [8 * w, 4 * w, 1, 4 * w];
			default:
				if (!str) {
					return [];
				}
				if (Util_Util.isArray(str)) {
					return str;
				}
				str = StringExt.trim(str).replace(/\s+/g, ',');
				return str.replace(/\[|\]/gi, '').split(',');
		}
	}

	/**
	 * @private
	 * @description 将SVG转换成Canvas
	 * @param svgUrl
	 * @param divDom
	 * @param callBack
	 */
	_getCanvasFromSVG(svgUrl, divDom, callBack) {
		//一个图层对应一个canvas
		let canvas = document.createElement('canvas');
		canvas.id = 'dataviz-canvas-' + core_Util_Util.newGuid(8);
		canvas.style.display = 'none';
		divDom.appendChild(canvas);
    const canvgs = window.canvg && window.canvg.default ? window.canvg.default : (external_function_try_return_canvg_catch_e_return_default());
    const ctx = canvas.getContext('2d');
    canvgs.from(ctx, svgUrl, {
      ignoreMouse: true,
      ignoreAnimation: true,
      forceRedraw: () => false
    }).then(v => {
      v.start();
      this._canvgsV.push(v);
      if (canvas.width > 300 || canvas.height > 300) {
        return;
      }
      callBack(canvas);
    });
	}

  _stopCanvg() {
    this._canvgsV.forEach(v => v.stop());
    this._canvgsV = [];
  }
	/**
	 * @private
	 * @function WebMap.prototype._addOverlayToMap
	 * @description 添加基础矢量图层到 MAP
	 * @param {Object} style - mabgl style
	 * @param {string} type - 图层类型
	 */
	_addOverlayToMap(type, source, layerID, layerStyle) {
		let mbglTypeMap = {
			POINT: 'circle',
			LINE: 'line',
			POLYGON: 'fill'
		};
		type = mbglTypeMap[type];
		if (type === 'circle' || type === 'line' || type === 'fill') {
			this.map.addLayer({
				id: layerID,
				type: type,
				source: source,
				paint: layerStyle.style,
				layout: layerStyle.layout || {}
			});
		}
	}

	_addBaselayer(url, layerID, minzoom = 0, maxzoom = 22, isIserver) {
		this.map.addLayer({
			id: layerID,
			type: 'raster',
			source: {
				type: 'raster',
				tiles: url,
                tileSize: 256,
                rasterSource: isIserver ? 'iserver' : '',
                prjCoordSys: isIserver ? { epsgCode: this.baseProjection.split(':')[1] } : ''
			},
			minzoom: minzoom,
			maxzoom: maxzoom
		});
	}
	/**
	 * @private
	 * @function WebMap.prototype._addStrokeLineForPoly
	 * @description 添加面的边框。
	 * @param {Object} style - mabgl style
	 */
	_addStrokeLineForPoly(style, source, layerID, visible) {
		let lineStyle = {};
		lineStyle.style = this._transformStyleToMapBoxGl(style, 'LINE');
		lineStyle.layout = { visibility: visible };
		this._addOverlayToMap('LINE', source, layerID, lineStyle);
	}
	/**
	 * @private
	 * @function WebMap.prototype._parseGeoJsonData2Feature
	 * @description 将从restData地址上获取的json转换成feature（从iserver中获取的json转换成feature）
	 * @param {Object} metaData - json内容
	 * @returns {Array}  mabgl.feature的数组集合
	 */
	_parseGeoJsonData2Feature(metaData) {
		let allFeatures = metaData.allDatas.features,
			features = [];
		for (let i = 0, len = allFeatures.length; i < len; i++) {
			// TODO 坐标转换
			let feature = allFeatures[i];
			let coordinate = feature.geometry.coordinates;
			if (allFeatures[i].geometry.type === 'Point') {
				// 标注图层 还没有属性值时候不加
				if (allFeatures[i].properties) {
					allFeatures[i].properties.lon = coordinate[0];
					allFeatures[i].properties.lat = coordinate[1];
				}
			}
			feature.properties['index'] = i + '';
			features.push(feature);
		}
		return features;
	}

	/**
	 * @private
	 * @function WebMap.prototype._getFeatureBySQL
	 * @description 通过 sql 方式查询数据。
	 */
	_getFeatureBySQL(url, datasetNames, processCompleted, processFaild) {
		let getFeatureParam, getFeatureBySQLService, getFeatureBySQLParams;
		getFeatureParam = new FilterParameter({
			name: datasetNames.join().replace(':', '@'),
			attributeFilter: 'SMID > 0'
		});
		getFeatureBySQLParams = new GetFeaturesBySQLParameters({
			queryParameter: getFeatureParam,
			datasetNames: datasetNames,
			fromIndex: 0,
			toIndex: 100000,
			returnContent: true
		});
		getFeatureBySQLService = new GetFeaturesBySQLService(url);
		getFeatureBySQLService.processAsync(getFeatureBySQLParams, function(result) {
      if (result.type === 'processCompleted') {
        processCompleted(result);
      } else {
        processFaild(result);
      }
    });
	}

	/**
	 * @private
	 * @function WebMap.prototype._queryFeatureBySQL
	 * @description 通过 sql 方式查询数据。
	 */
	_queryFeatureBySQL(
		url,
		layerName,
		attributeFilter,
		fields,
		epsgCode,
		processCompleted,
		processFaild,
		startRecord,
		recordLength,
		onlyAttribute
	) {
		var queryParam, queryBySQLParams, queryBySQLService;
		queryParam = new FilterParameter({
			name: layerName,
			attributeFilter: attributeFilter
		});
		if (fields) {
			queryParam.fields = fields;
		}
		var params = {
			queryParams: [queryParam]
		};
		if (onlyAttribute) {
			params.queryOption = QueryOption.ATTRIBUTE;
		}
		startRecord && (params.startRecord = startRecord);
		recordLength && (params.expectCount = recordLength);
		if (epsgCode) {
			params.prjCoordSys = {
				epsgCode: epsgCode
			};
		}
		queryBySQLParams = new QueryBySQLParameters(params);
		queryBySQLService = new QueryService(url);
		queryBySQLService.queryBySQL(queryBySQLParams, data => {
			data.type === 'processCompleted' ? processCompleted(data) : processFaild(data);
		});
	}

	/**
	 * @private
	 * @function WebMap.prototype._handleMultyPolygon
	 * @description 处理复杂面情况
	 */
	_handleMultyPolygon(features) {
		features.forEach(feature => {
			if (feature.geometry.type !== 'Polygon') {
				return;
			}
			let coords = feature.geometry.coordinates;
			if (coords.length > 1) {
				let coordinates = [];
				coords.forEach(coord => {
					coordinates.push([coord]);
				});
				feature.geometry.coordinates = coordinates;
				feature.geometry.type = 'MultiPolygon';
			}
		});
		return features;
    }

    _transformScaleToZoom(scale, crs) {
        let scale_0 = 295829515.2024169;
        if ((crs || this.map.getCRS()).epsgCode !== 'EPSG:3857') {
          scale_0 = 295295895;
        }
        const scaleDenominator = scale.split(':')[1];
        return Math.min(24, +Math.log2(scale_0 / +scaleDenominator).toFixed(2));
    }

    _getResolution(bounds, tileSize = 512.0) {
        if (bounds.leftBottom && bounds.rightTop) {
            return Math.max(bounds.rightTop.x - bounds.leftBottom.x, bounds.rightTop.y - bounds.leftBottom.y) / tileSize;
        }
        return Math.max(bounds[2] - bounds[0], bounds[3] - bounds[1]) / tileSize;
    }
}


;// CONCATENATED MODULE: ./src/common/iServer/InitMapServiceBase.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/
 

/**
 * @private
 * @class InitMapServiceBase
 * @category iServer Map
 * @classdesc 初始化地图信息服务类。
 * @example
 * var initMapServiceBase = new InitMapServiceBase(url, MapService);
 *
 * @param {string} url - 服务地址。如：http://localhost:8090/iserver/services/map-world/rest/maps/World+Map 。
 * @param {MapService} MapService - 地图信息服务类。
 * @param {Object} options - 参数。
 * @param {string} [options.proxy] - 服务代理地址。
 * @param {boolean} [options.withCredentials=false] - 请求是否携带 cookie。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @usage
 */
class InitMapServiceBase {
  constructor(MapService, url, options) {
    this.MapService = MapService;
    this.url = url;
    this.options = options;

    this.CLASS_NAME = 'SuperMap.InitMapServiceBase';
  }

  /**
   * @function createMapService
   * @description 初始化 MapService。
   * @returns {MapService}
   */
  createMapService() {
    const MapService = this.MapService;
    const url = this.url;
    const options = this.options;
    return new MapService(url, {
      proxy: options.proxy,
      withCredentials: options.withCredentials,
      crossOrigin: options.crossOrigin,
      headers: options.headers,
      projection: options.projection
    });
  }

  /**
   * @function getMapInfo
   * @description 获取地图信息。
   * @returns {Promise}
   */
  getMapInfo(callback) {
    return new Promise((resolve, reject) => {
      const mapService = this.createMapService();
      mapService.getMapInfo((res) => {
        callback(res, resolve, reject);
      });
    });
  }

  /**
   * @function getMapInfo
   * @description 获取坐标投影 WKT。
   * @returns {Promise}
   */
  getWKT() {
    return new Promise((resolve, reject) => {
      const mapService = this.createMapService();
      mapService.getWKT((res) => {
        try {
          const wkt = res.result.data;
          resolve(wkt);
        } catch (error) {
          reject(error);
        }
      });
    });
  }
}

/**
 * @function isPlaneProjection
 * @description 是否是平面坐标系。
 * @param {string} type - 投影坐标系类型
 * @returns {boolean}
 */
function isPlaneProjection(type) {
  return type === 'PCS_NON_EARTH';
}

/**
 * @function getEpsgCode
 * @description 获取 EPSG Code。
 * @param {Object} prjCoordSys
 * @returns {string}
 */
function getEpsgCode(prjCoordSys) {
  const { type, epsgCode } = prjCoordSys;
  if (type == 'PCS_NON_EARTH') {
    // 平面投影
    return '';
  }
  return 'EPSG:' + epsgCode;
}


/**
 * @private
 * @function createMapOptions
 * @description mapboxgl maplibregl 获取地图resolutions。
 * @returns {Array} resolutions
 */
 function InitMapServiceBase_scalesToResolutions(bounds, maxZoom = 22, tileSize = 512) {
  var resolutions = [];
  const maxReolution = Math.abs(bounds.left - bounds.right) / tileSize;
  for (let i = 0; i < maxZoom; i++) {
    resolutions.push(maxReolution / Math.pow(2, i));
  }
  return resolutions.sort(function (a, b) {
    return b - a;
  });
}

/**
 * @private
 * @function getZoom
 * @description mapboxgl maplibregl 获取地图zoom。
 * @param {Object} resetServiceInfo - rest 地图服务信息。
 * @param {string} resetServiceInfo.scale - scale
 * @param {Object} resetServiceInfo.dpi - dpi
 * @param {Object} resetServiceInfo.coordUnit- coordUnit。
 * @param {Object} extent - extent。
 * @returns {number} zoom
 */
 function getZoom({ scale, dpi, coordUnit }, extent) {
  const resolutions = InitMapServiceBase_scalesToResolutions(extent);
  return getZoomByResolution(scaleToResolution(scale, dpi, coordUnit), resolutions);
}
;// CONCATENATED MODULE: ./node_modules/proj4/lib/global.js
/* harmony default export */ function global(defs) {
  defs('EPSG:4326', "+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees");
  defs('EPSG:4269', "+title=NAD83 (long/lat) +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees");
  defs('EPSG:3857', "+title=WGS 84 / Pseudo-Mercator +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs");

  defs.WGS84 = defs['EPSG:4326'];
  defs['EPSG:3785'] = defs['EPSG:3857']; // maintain backward compat, official code is 3857
  defs.GOOGLE = defs['EPSG:3857'];
  defs['EPSG:900913'] = defs['EPSG:3857'];
  defs['EPSG:102113'] = defs['EPSG:3857'];
}

;// CONCATENATED MODULE: ./node_modules/proj4/lib/constants/values.js
var PJD_3PARAM = 1;
var PJD_7PARAM = 2;
var PJD_GRIDSHIFT = 3;
var PJD_WGS84 = 4; // WGS84 or equivalent
var PJD_NODATUM = 5; // WGS84 or equivalent
var SRS_WGS84_SEMIMAJOR = 6378137.0;  // only used in grid shift transforms
var SRS_WGS84_SEMIMINOR = 6356752.314;  // only used in grid shift transforms
var SRS_WGS84_ESQUARED = 0.0066943799901413165; // only used in grid shift transforms
var SEC_TO_RAD = 4.84813681109535993589914102357e-6;
var HALF_PI = Math.PI/2;
// ellipoid pj_set_ell.c
var SIXTH = 0.1666666666666666667;
/* 1/6 */
var RA4 = 0.04722222222222222222;
/* 17/360 */
var RA6 = 0.02215608465608465608;
var EPSLN = 1.0e-10;
// you'd think you could use Number.EPSILON above but that makes
// Mollweide get into an infinate loop.

var D2R = 0.01745329251994329577;
var R2D = 57.29577951308232088;
var FORTPI = Math.PI/4;
var TWO_PI = Math.PI * 2;
// SPI is slightly greater than Math.PI, so values that exceed the -180..180
// degree range by a tiny amount don't get wrapped. This prevents points that
// have drifted from their original location along the 180th meridian (due to
// floating point error) from changing their sign.
var SPI = 3.14159265359;

;// CONCATENATED MODULE: ./node_modules/proj4/lib/constants/PrimeMeridian.js
var PrimeMeridian_exports = {};


PrimeMeridian_exports.greenwich = 0.0; //"0dE",
PrimeMeridian_exports.lisbon = -9.131906111111; //"9d07'54.862\"W",
PrimeMeridian_exports.paris = 2.337229166667; //"2d20'14.025\"E",
PrimeMeridian_exports.bogota = -74.080916666667; //"74d04'51.3\"W",
PrimeMeridian_exports.madrid = -3.687938888889; //"3d41'16.58\"W",
PrimeMeridian_exports.rome = 12.452333333333; //"12d27'8.4\"E",
PrimeMeridian_exports.bern = 7.439583333333; //"7d26'22.5\"E",
PrimeMeridian_exports.jakarta = 106.807719444444; //"106d48'27.79\"E",
PrimeMeridian_exports.ferro = -17.666666666667; //"17d40'W",
PrimeMeridian_exports.brussels = 4.367975; //"4d22'4.71\"E",
PrimeMeridian_exports.stockholm = 18.058277777778; //"18d3'29.8\"E",
PrimeMeridian_exports.athens = 23.7163375; //"23d42'58.815\"E",
PrimeMeridian_exports.oslo = 10.722916666667; //"10d43'22.5\"E"

;// CONCATENATED MODULE: ./node_modules/proj4/lib/constants/units.js
/* harmony default export */ const units = ({
  ft: {to_meter: 0.3048},
  'us-ft': {to_meter: 1200 / 3937}
});

;// CONCATENATED MODULE: ./node_modules/proj4/lib/match.js
var ignoredChar = /[\s_\-\/\(\)]/g;
function match(obj, key) {
  if (obj[key]) {
    return obj[key];
  }
  var keys = Object.keys(obj);
  var lkey = key.toLowerCase().replace(ignoredChar, '');
  var i = -1;
  var testkey, processedKey;
  while (++i < keys.length) {
    testkey = keys[i];
    processedKey = testkey.toLowerCase().replace(ignoredChar, '');
    if (processedKey === lkey) {
      return obj[testkey];
    }
  }
}

;// CONCATENATED MODULE: ./node_modules/proj4/lib/projString.js





/* harmony default export */ function projString(defData) {
  var self = {};
  var paramObj = defData.split('+').map(function(v) {
    return v.trim();
  }).filter(function(a) {
    return a;
  }).reduce(function(p, a) {
    var split = a.split('=');
    split.push(true);
    p[split[0].toLowerCase()] = split[1];
    return p;
  }, {});
  var paramName, paramVal, paramOutname;
  var params = {
    proj: 'projName',
    datum: 'datumCode',
    rf: function(v) {
      self.rf = parseFloat(v);
    },
    lat_0: function(v) {
      self.lat0 = v * D2R;
    },
    lat_1: function(v) {
      self.lat1 = v * D2R;
    },
    lat_2: function(v) {
      self.lat2 = v * D2R;
    },
    lat_ts: function(v) {
      self.lat_ts = v * D2R;
    },
    lon_0: function(v) {
      self.long0 = v * D2R;
    },
    lon_1: function(v) {
      self.long1 = v * D2R;
    },
    lon_2: function(v) {
      self.long2 = v * D2R;
    },
    alpha: function(v) {
      self.alpha = parseFloat(v) * D2R;
    },
    gamma: function(v) {
      self.rectified_grid_angle = parseFloat(v);
    },
    lonc: function(v) {
      self.longc = v * D2R;
    },
    x_0: function(v) {
      self.x0 = parseFloat(v);
    },
    y_0: function(v) {
      self.y0 = parseFloat(v);
    },
    k_0: function(v) {
      self.k0 = parseFloat(v);
    },
    k: function(v) {
      self.k0 = parseFloat(v);
    },
    a: function(v) {
      self.a = parseFloat(v);
    },
    b: function(v) {
      self.b = parseFloat(v);
    },
    r_a: function() {
      self.R_A = true;
    },
    zone: function(v) {
      self.zone = parseInt(v, 10);
    },
    south: function() {
      self.utmSouth = true;
    },
    towgs84: function(v) {
      self.datum_params = v.split(",").map(function(a) {
        return parseFloat(a);
      });
    },
    to_meter: function(v) {
      self.to_meter = parseFloat(v);
    },
    units: function(v) {
      self.units = v;
      var unit = match(units, v);
      if (unit) {
        self.to_meter = unit.to_meter;
      }
    },
    from_greenwich: function(v) {
      self.from_greenwich = v * D2R;
    },
    pm: function(v) {
      var pm = match(PrimeMeridian_exports, v);
      self.from_greenwich = (pm ? pm : parseFloat(v)) * D2R;
    },
    nadgrids: function(v) {
      if (v === '@null') {
        self.datumCode = 'none';
      }
      else {
        self.nadgrids = v;
      }
    },
    axis: function(v) {
      var legalAxis = "ewnsud";
      if (v.length === 3 && legalAxis.indexOf(v.substr(0, 1)) !== -1 && legalAxis.indexOf(v.substr(1, 1)) !== -1 && legalAxis.indexOf(v.substr(2, 1)) !== -1) {
        self.axis = v;
      }
    },
    approx: function() {
      self.approx = true;
    }
  };
  for (paramName in paramObj) {
    paramVal = paramObj[paramName];
    if (paramName in params) {
      paramOutname = params[paramName];
      if (typeof paramOutname === 'function') {
        paramOutname(paramVal);
      }
      else {
        self[paramOutname] = paramVal;
      }
    }
    else {
      self[paramName] = paramVal;
    }
  }
  if(typeof self.datumCode === 'string' && self.datumCode !== "WGS84"){
    self.datumCode = self.datumCode.toLowerCase();
  }
  return self;
}

;// CONCATENATED MODULE: ./node_modules/wkt-parser/parser.js
/* harmony default export */ const parser = (parseString);

var NEUTRAL = 1;
var KEYWORD = 2;
var NUMBER = 3;
var QUOTED = 4;
var AFTERQUOTE = 5;
var ENDED = -1;
var whitespace = /\s/;
var latin = /[A-Za-z]/;
var keyword = /[A-Za-z84_]/;
var endThings = /[,\]]/;
var digets = /[\d\.E\-\+]/;
// const ignoredChar = /[\s_\-\/\(\)]/g;
function Parser(text) {
  if (typeof text !== 'string') {
    throw new Error('not a string');
  }
  this.text = text.trim();
  this.level = 0;
  this.place = 0;
  this.root = null;
  this.stack = [];
  this.currentObject = null;
  this.state = NEUTRAL;
}
Parser.prototype.readCharicter = function() {
  var char = this.text[this.place++];
  if (this.state !== QUOTED) {
    while (whitespace.test(char)) {
      if (this.place >= this.text.length) {
        return;
      }
      char = this.text[this.place++];
    }
  }
  switch (this.state) {
    case NEUTRAL:
      return this.neutral(char);
    case KEYWORD:
      return this.keyword(char)
    case QUOTED:
      return this.quoted(char);
    case AFTERQUOTE:
      return this.afterquote(char);
    case NUMBER:
      return this.number(char);
    case ENDED:
      return;
  }
};
Parser.prototype.afterquote = function(char) {
  if (char === '"') {
    this.word += '"';
    this.state = QUOTED;
    return;
  }
  if (endThings.test(char)) {
    this.word = this.word.trim();
    this.afterItem(char);
    return;
  }
  throw new Error('havn\'t handled "' +char + '" in afterquote yet, index ' + this.place);
};
Parser.prototype.afterItem = function(char) {
  if (char === ',') {
    if (this.word !== null) {
      this.currentObject.push(this.word);
    }
    this.word = null;
    this.state = NEUTRAL;
    return;
  }
  if (char === ']') {
    this.level--;
    if (this.word !== null) {
      this.currentObject.push(this.word);
      this.word = null;
    }
    this.state = NEUTRAL;
    this.currentObject = this.stack.pop();
    if (!this.currentObject) {
      this.state = ENDED;
    }

    return;
  }
};
Parser.prototype.number = function(char) {
  if (digets.test(char)) {
    this.word += char;
    return;
  }
  if (endThings.test(char)) {
    this.word = parseFloat(this.word);
    this.afterItem(char);
    return;
  }
  throw new Error('havn\'t handled "' +char + '" in number yet, index ' + this.place);
};
Parser.prototype.quoted = function(char) {
  if (char === '"') {
    this.state = AFTERQUOTE;
    return;
  }
  this.word += char;
  return;
};
Parser.prototype.keyword = function(char) {
  if (keyword.test(char)) {
    this.word += char;
    return;
  }
  if (char === '[') {
    var newObjects = [];
    newObjects.push(this.word);
    this.level++;
    if (this.root === null) {
      this.root = newObjects;
    } else {
      this.currentObject.push(newObjects);
    }
    this.stack.push(this.currentObject);
    this.currentObject = newObjects;
    this.state = NEUTRAL;
    return;
  }
  if (endThings.test(char)) {
    this.afterItem(char);
    return;
  }
  throw new Error('havn\'t handled "' +char + '" in keyword yet, index ' + this.place);
};
Parser.prototype.neutral = function(char) {
  if (latin.test(char)) {
    this.word = char;
    this.state = KEYWORD;
    return;
  }
  if (char === '"') {
    this.word = '';
    this.state = QUOTED;
    return;
  }
  if (digets.test(char)) {
    this.word = char;
    this.state = NUMBER;
    return;
  }
  if (endThings.test(char)) {
    this.afterItem(char);
    return;
  }
  throw new Error('havn\'t handled "' +char + '" in neutral yet, index ' + this.place);
};
Parser.prototype.output = function() {
  while (this.place < this.text.length) {
    this.readCharicter();
  }
  if (this.state === ENDED) {
    return this.root;
  }
  throw new Error('unable to parse string "' +this.text + '". State is ' + this.state);
};

function parseString(txt) {
  var parser = new Parser(txt);
  return parser.output();
}

;// CONCATENATED MODULE: ./node_modules/wkt-parser/process.js


function mapit(obj, key, value) {
  if (Array.isArray(key)) {
    value.unshift(key);
    key = null;
  }
  var thing = key ? {} : obj;

  var out = value.reduce(function(newObj, item) {
    sExpr(item, newObj);
    return newObj
  }, thing);
  if (key) {
    obj[key] = out;
  }
}

function sExpr(v, obj) {
  if (!Array.isArray(v)) {
    obj[v] = true;
    return;
  }
  var key = v.shift();
  if (key === 'PARAMETER') {
    key = v.shift();
  }
  if (v.length === 1) {
    if (Array.isArray(v[0])) {
      obj[key] = {};
      sExpr(v[0], obj[key]);
      return;
    }
    obj[key] = v[0];
    return;
  }
  if (!v.length) {
    obj[key] = true;
    return;
  }
  if (key === 'TOWGS84') {
    obj[key] = v;
    return;
  }
  if (key === 'AXIS') {
    if (!(key in obj)) {
      obj[key] = [];
    }
    obj[key].push(v);
    return;
  }
  if (!Array.isArray(key)) {
    obj[key] = {};
  }

  var i;
  switch (key) {
    case 'UNIT':
    case 'PRIMEM':
    case 'VERT_DATUM':
      obj[key] = {
        name: v[0].toLowerCase(),
        convert: v[1]
      };
      if (v.length === 3) {
        sExpr(v[2], obj[key]);
      }
      return;
    case 'SPHEROID':
    case 'ELLIPSOID':
      obj[key] = {
        name: v[0],
        a: v[1],
        rf: v[2]
      };
      if (v.length === 4) {
        sExpr(v[3], obj[key]);
      }
      return;
    case 'PROJECTEDCRS':
    case 'PROJCRS':
    case 'GEOGCS':
    case 'GEOCCS':
    case 'PROJCS':
    case 'LOCAL_CS':
    case 'GEODCRS':
    case 'GEODETICCRS':
    case 'GEODETICDATUM':
    case 'EDATUM':
    case 'ENGINEERINGDATUM':
    case 'VERT_CS':
    case 'VERTCRS':
    case 'VERTICALCRS':
    case 'COMPD_CS':
    case 'COMPOUNDCRS':
    case 'ENGINEERINGCRS':
    case 'ENGCRS':
    case 'FITTED_CS':
    case 'LOCAL_DATUM':
    case 'DATUM':
      v[0] = ['name', v[0]];
      mapit(obj, key, v);
      return;
    default:
      i = -1;
      while (++i < v.length) {
        if (!Array.isArray(v[i])) {
          return sExpr(v, obj[key]);
        }
      }
      return mapit(obj, key, v);
  }
}

;// CONCATENATED MODULE: ./node_modules/wkt-parser/index.js
var wkt_parser_D2R = 0.01745329251994329577;





function rename(obj, params) {
  var outName = params[0];
  var inName = params[1];
  if (!(outName in obj) && (inName in obj)) {
    obj[outName] = obj[inName];
    if (params.length === 3) {
      obj[outName] = params[2](obj[outName]);
    }
  }
}

function d2r(input) {
  return input * wkt_parser_D2R;
}

function cleanWKT(wkt) {
  if (wkt.type === 'GEOGCS') {
    wkt.projName = 'longlat';
  } else if (wkt.type === 'LOCAL_CS') {
    wkt.projName = 'identity';
    wkt.local = true;
  } else {
    if (typeof wkt.PROJECTION === 'object') {
      wkt.projName = Object.keys(wkt.PROJECTION)[0];
    } else {
      wkt.projName = wkt.PROJECTION;
    }
  }
  if (wkt.AXIS) {
    var axisOrder = '';
    for (var i = 0, ii = wkt.AXIS.length; i < ii; ++i) {
      var axis = [wkt.AXIS[i][0].toLowerCase(), wkt.AXIS[i][1].toLowerCase()];
      if (axis[0].indexOf('north') !== -1 || ((axis[0] === 'y' || axis[0] === 'lat') && axis[1] === 'north')) {
        axisOrder += 'n';
      } else if (axis[0].indexOf('south') !== -1 || ((axis[0] === 'y' || axis[0] === 'lat') && axis[1] === 'south')) {
        axisOrder += 's';
      } else if (axis[0].indexOf('east') !== -1 || ((axis[0] === 'x' || axis[0] === 'lon') && axis[1] === 'east')) {
        axisOrder += 'e';
      } else if (axis[0].indexOf('west') !== -1 || ((axis[0] === 'x' || axis[0] === 'lon') && axis[1] === 'west')) {
        axisOrder += 'w';
      }
    }
    if (axisOrder.length === 2) {
      axisOrder += 'u';
    }
    if (axisOrder.length === 3) {
      wkt.axis = axisOrder;
    }
  }
  if (wkt.UNIT) {
    wkt.units = wkt.UNIT.name.toLowerCase();
    if (wkt.units === 'metre') {
      wkt.units = 'meter';
    }
    if (wkt.UNIT.convert) {
      if (wkt.type === 'GEOGCS') {
        if (wkt.DATUM && wkt.DATUM.SPHEROID) {
          wkt.to_meter = wkt.UNIT.convert*wkt.DATUM.SPHEROID.a;
        }
      } else {
        wkt.to_meter = wkt.UNIT.convert;
      }
    }
  }
  var geogcs = wkt.GEOGCS;
  if (wkt.type === 'GEOGCS') {
    geogcs = wkt;
  }
  if (geogcs) {
    //if(wkt.GEOGCS.PRIMEM&&wkt.GEOGCS.PRIMEM.convert){
    //  wkt.from_greenwich=wkt.GEOGCS.PRIMEM.convert*D2R;
    //}
    if (geogcs.DATUM) {
      wkt.datumCode = geogcs.DATUM.name.toLowerCase();
    } else {
      wkt.datumCode = geogcs.name.toLowerCase();
    }
    if (wkt.datumCode.slice(0, 2) === 'd_') {
      wkt.datumCode = wkt.datumCode.slice(2);
    }
    if (wkt.datumCode === 'new_zealand_geodetic_datum_1949' || wkt.datumCode === 'new_zealand_1949') {
      wkt.datumCode = 'nzgd49';
    }
    if (wkt.datumCode === 'wgs_1984' || wkt.datumCode === 'world_geodetic_system_1984') {
      if (wkt.PROJECTION === 'Mercator_Auxiliary_Sphere') {
        wkt.sphere = true;
      }
      wkt.datumCode = 'wgs84';
    }
    if (wkt.datumCode.slice(-6) === '_ferro') {
      wkt.datumCode = wkt.datumCode.slice(0, - 6);
    }
    if (wkt.datumCode.slice(-8) === '_jakarta') {
      wkt.datumCode = wkt.datumCode.slice(0, - 8);
    }
    if (~wkt.datumCode.indexOf('belge')) {
      wkt.datumCode = 'rnb72';
    }
    if (geogcs.DATUM && geogcs.DATUM.SPHEROID) {
      wkt.ellps = geogcs.DATUM.SPHEROID.name.replace('_19', '').replace(/[Cc]larke\_18/, 'clrk');
      if (wkt.ellps.toLowerCase().slice(0, 13) === 'international') {
        wkt.ellps = 'intl';
      }

      wkt.a = geogcs.DATUM.SPHEROID.a;
      wkt.rf = parseFloat(geogcs.DATUM.SPHEROID.rf, 10);
    }

    if (geogcs.DATUM && geogcs.DATUM.TOWGS84) {
      wkt.datum_params = geogcs.DATUM.TOWGS84;
    }
    if (~wkt.datumCode.indexOf('osgb_1936')) {
      wkt.datumCode = 'osgb36';
    }
    if (~wkt.datumCode.indexOf('osni_1952')) {
      wkt.datumCode = 'osni52';
    }
    if (~wkt.datumCode.indexOf('tm65')
      || ~wkt.datumCode.indexOf('geodetic_datum_of_1965')) {
      wkt.datumCode = 'ire65';
    }
    if (wkt.datumCode === 'ch1903+') {
      wkt.datumCode = 'ch1903';
    }
    if (~wkt.datumCode.indexOf('israel')) {
      wkt.datumCode = 'isr93';
    }
  }
  if (wkt.b && !isFinite(wkt.b)) {
    wkt.b = wkt.a;
  }

  function toMeter(input) {
    var ratio = wkt.to_meter || 1;
    return input * ratio;
  }
  var renamer = function(a) {
    return rename(wkt, a);
  };
  var list = [
    ['standard_parallel_1', 'Standard_Parallel_1'],
    ['standard_parallel_1', 'Latitude of 1st standard parallel'],
    ['standard_parallel_2', 'Standard_Parallel_2'],
    ['standard_parallel_2', 'Latitude of 2nd standard parallel'],
    ['false_easting', 'False_Easting'],
    ['false_easting', 'False easting'],
    ['false-easting', 'Easting at false origin'],
    ['false_northing', 'False_Northing'],
    ['false_northing', 'False northing'],
    ['false_northing', 'Northing at false origin'],
    ['central_meridian', 'Central_Meridian'],
    ['central_meridian', 'Longitude of natural origin'],
    ['central_meridian', 'Longitude of false origin'],
    ['latitude_of_origin', 'Latitude_Of_Origin'],
    ['latitude_of_origin', 'Central_Parallel'],
    ['latitude_of_origin', 'Latitude of natural origin'],
    ['latitude_of_origin', 'Latitude of false origin'],
    ['scale_factor', 'Scale_Factor'],
    ['k0', 'scale_factor'],
    ['latitude_of_center', 'Latitude_Of_Center'],
    ['latitude_of_center', 'Latitude_of_center'],
    ['lat0', 'latitude_of_center', d2r],
    ['longitude_of_center', 'Longitude_Of_Center'],
    ['longitude_of_center', 'Longitude_of_center'],
    ['longc', 'longitude_of_center', d2r],
    ['x0', 'false_easting', toMeter],
    ['y0', 'false_northing', toMeter],
    ['long0', 'central_meridian', d2r],
    ['lat0', 'latitude_of_origin', d2r],
    ['lat0', 'standard_parallel_1', d2r],
    ['lat1', 'standard_parallel_1', d2r],
    ['lat2', 'standard_parallel_2', d2r],
    ['azimuth', 'Azimuth'],
    ['alpha', 'azimuth', d2r],
    ['srsCode', 'name']
  ];
  list.forEach(renamer);
  if (!wkt.long0 && wkt.longc && (wkt.projName === 'Albers_Conic_Equal_Area' || wkt.projName === 'Lambert_Azimuthal_Equal_Area')) {
    wkt.long0 = wkt.longc;
  }
  if (!wkt.lat_ts && wkt.lat1 && (wkt.projName === 'Stereographic_South_Pole' || wkt.projName === 'Polar Stereographic (variant B)')) {
    wkt.lat0 = d2r(wkt.lat1 > 0 ? 90 : -90);
    wkt.lat_ts = wkt.lat1;
  } else if (!wkt.lat_ts && wkt.lat0 && wkt.projName === 'Polar_Stereographic') {
    wkt.lat_ts = wkt.lat0;
    wkt.lat0 = d2r(wkt.lat0 > 0 ? 90 : -90);
  }
}
/* harmony default export */ function wkt_parser(wkt) {
  var lisp = parser(wkt);
  var type = lisp.shift();
  var name = lisp.shift();
  lisp.unshift(['name', name]);
  lisp.unshift(['type', type]);
  var obj = {};
  sExpr(lisp, obj);
  cleanWKT(obj);
  return obj;
}

;// CONCATENATED MODULE: ./node_modules/proj4/lib/defs.js




function defs(name) {
  /*global console*/
  var that = this;
  if (arguments.length === 2) {
    var def = arguments[1];
    if (typeof def === 'string') {
      if (def.charAt(0) === '+') {
        defs[name] = projString(arguments[1]);
      }
      else {
        defs[name] = wkt_parser(arguments[1]);
      }
    } else {
      defs[name] = def;
    }
  }
  else if (arguments.length === 1) {
    if (Array.isArray(name)) {
      return name.map(function(v) {
        if (Array.isArray(v)) {
          defs.apply(that, v);
        }
        else {
          defs(v);
        }
      });
    }
    else if (typeof name === 'string') {
      if (name in defs) {
        return defs[name];
      }
    }
    else if ('EPSG' in name) {
      defs['EPSG:' + name.EPSG] = name;
    }
    else if ('ESRI' in name) {
      defs['ESRI:' + name.ESRI] = name;
    }
    else if ('IAU2000' in name) {
      defs['IAU2000:' + name.IAU2000] = name;
    }
    else {
      console.log(name);
    }
    return;
  }


}
global(defs);
/* harmony default export */ const lib_defs = (defs);

;// CONCATENATED MODULE: ./node_modules/proj4/lib/parseCode.js




function testObj(code){
  return typeof code === 'string';
}
function testDef(code){
  return code in lib_defs;
}
var codeWords = ['PROJECTEDCRS', 'PROJCRS', 'GEOGCS','GEOCCS','PROJCS','LOCAL_CS', 'GEODCRS', 'GEODETICCRS', 'GEODETICDATUM', 'ENGCRS', 'ENGINEERINGCRS'];
function testWKT(code){
  return codeWords.some(function (word) {
    return code.indexOf(word) > -1;
  });
}
var codes = ['3857', '900913', '3785', '102113'];
function checkMercator(item) {
  var auth = match(item, 'authority');
  if (!auth) {
    return;
  }
  var code = match(auth, 'epsg');
  return code && codes.indexOf(code) > -1;
}
function checkProjStr(item) {
  var ext = match(item, 'extension');
  if (!ext) {
    return;
  }
  return match(ext, 'proj4');
}
function testProj(code){
  return code[0] === '+';
}
function parse(code){
  if (testObj(code)) {
    //check to see if this is a WKT string
    if (testDef(code)) {
      return lib_defs[code];
    }
    if (testWKT(code)) {
      var out = wkt_parser(code);
      // test of spetial case, due to this being a very common and often malformed
      if (checkMercator(out)) {
        return lib_defs['EPSG:3857'];
      }
      var maybeProjStr = checkProjStr(out);
      if (maybeProjStr) {
        return projString(maybeProjStr);
      }
      return out;
    }
    if (testProj(code)) {
      return projString(code);
    }
  }else{
    return code;
  }
}

/* harmony default export */ const parseCode = (parse);

;// CONCATENATED MODULE: ./node_modules/proj4/lib/extend.js
/* harmony default export */ function lib_extend(destination, source) {
  destination = destination || {};
  var value, property;
  if (!source) {
    return destination;
  }
  for (property in source) {
    value = source[property];
    if (value !== undefined) {
      destination[property] = value;
    }
  }
  return destination;
}

;// CONCATENATED MODULE: ./node_modules/proj4/lib/common/msfnz.js
/* harmony default export */ function msfnz(eccent, sinphi, cosphi) {
  var con = eccent * sinphi;
  return cosphi / (Math.sqrt(1 - con * con));
}
;// CONCATENATED MODULE: ./node_modules/proj4/lib/common/sign.js
/* harmony default export */ function sign(x) {
  return x<0 ? -1 : 1;
}
;// CONCATENATED MODULE: ./node_modules/proj4/lib/common/adjust_lon.js




/* harmony default export */ function adjust_lon(x) {
  return (Math.abs(x) <= SPI) ? x : (x - (sign(x) * TWO_PI));
}

;// CONCATENATED MODULE: ./node_modules/proj4/lib/common/tsfnz.js


/* harmony default export */ function tsfnz(eccent, phi, sinphi) {
  var con = eccent * sinphi;
  var com = 0.5 * eccent;
  con = Math.pow(((1 - con) / (1 + con)), com);
  return (Math.tan(0.5 * (HALF_PI - phi)) / con);
}

;// CONCATENATED MODULE: ./node_modules/proj4/lib/common/phi2z.js


/* harmony default export */ function phi2z(eccent, ts) {
  var eccnth = 0.5 * eccent;
  var con, dphi;
  var phi = HALF_PI - 2 * Math.atan(ts);
  for (var i = 0; i <= 15; i++) {
    con = eccent * Math.sin(phi);
    dphi = HALF_PI - 2 * Math.atan(ts * (Math.pow(((1 - con) / (1 + con)), eccnth))) - phi;
    phi += dphi;
    if (Math.abs(dphi) <= 0.0000000001) {
      return phi;
    }
  }
  //console.log("phi2z has NoConvergence");
  return -9999;
}

;// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/merc.js






function init() {
  var con = this.b / this.a;
  this.es = 1 - con * con;
  if(!('x0' in this)){
    this.x0 = 0;
  }
  if(!('y0' in this)){
    this.y0 = 0;
  }
  this.e = Math.sqrt(this.es);
  if (this.lat_ts) {
    if (this.sphere) {
      this.k0 = Math.cos(this.lat_ts);
    }
    else {
      this.k0 = msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));
    }
  }
  else {
    if (!this.k0) {
      if (this.k) {
        this.k0 = this.k;
      }
      else {
        this.k0 = 1;
      }
    }
  }
}

/* Mercator forward equations--mapping lat,long to x,y
  --------------------------------------------------*/

function forward(p) {
  var lon = p.x;
  var lat = p.y;
  // convert to radians
  if (lat * R2D > 90 && lat * R2D < -90 && lon * R2D > 180 && lon * R2D < -180) {
    return null;
  }

  var x, y;
  if (Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN) {
    return null;
  }
  else {
    if (this.sphere) {
      x = this.x0 + this.a * this.k0 * adjust_lon(lon - this.long0);
      y = this.y0 + this.a * this.k0 * Math.log(Math.tan(FORTPI + 0.5 * lat));
    }
    else {
      var sinphi = Math.sin(lat);
      var ts = tsfnz(this.e, lat, sinphi);
      x = this.x0 + this.a * this.k0 * adjust_lon(lon - this.long0);
      y = this.y0 - this.a * this.k0 * Math.log(ts);
    }
    p.x = x;
    p.y = y;
    return p;
  }
}

/* Mercator inverse equations--mapping x,y to lat/long
  --------------------------------------------------*/
function inverse(p) {

  var x = p.x - this.x0;
  var y = p.y - this.y0;
  var lon, lat;

  if (this.sphere) {
    lat = HALF_PI - 2 * Math.atan(Math.exp(-y / (this.a * this.k0)));
  }
  else {
    var ts = Math.exp(-y / (this.a * this.k0));
    lat = phi2z(this.e, ts);
    if (lat === -9999) {
      return null;
    }
  }
  lon = adjust_lon(this.long0 + x / (this.a * this.k0));

  p.x = lon;
  p.y = lat;
  return p;
}

var names = ["Mercator", "Popular Visualisation Pseudo Mercator", "Mercator_1SP", "Mercator_Auxiliary_Sphere", "merc"];
/* harmony default export */ const merc = ({
  init: init,
  forward: forward,
  inverse: inverse,
  names: names
});

;// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/longlat.js
function longlat_init() {
  //no-op for longlat
}

function identity(pt) {
  return pt;
}


var longlat_names = ["longlat", "identity"];
/* harmony default export */ const longlat = ({
  init: longlat_init,
  forward: identity,
  inverse: identity,
  names: longlat_names
});

;// CONCATENATED MODULE: ./node_modules/proj4/lib/projections.js


var projs = [merc, longlat];
var projections_names = {};
var projStore = [];

function add(proj, i) {
  var len = projStore.length;
  if (!proj.names) {
    console.log(i);
    return true;
  }
  projStore[len] = proj;
  proj.names.forEach(function(n) {
    projections_names[n.toLowerCase()] = len;
  });
  return this;
}



function get(name) {
  if (!name) {
    return false;
  }
  var n = name.toLowerCase();
  if (typeof projections_names[n] !== 'undefined' && projStore[projections_names[n]]) {
    return projStore[projections_names[n]];
  }
}

function start() {
  projs.forEach(add);
}
/* harmony default export */ const projections = ({
  start: start,
  add: add,
  get: get
});

;// CONCATENATED MODULE: ./node_modules/proj4/lib/constants/Ellipsoid.js
var Ellipsoid_exports = {};

Ellipsoid_exports.MERIT = {
  a: 6378137.0,
  rf: 298.257,
  ellipseName: "MERIT 1983"
};

Ellipsoid_exports.SGS85 = {
  a: 6378136.0,
  rf: 298.257,
  ellipseName: "Soviet Geodetic System 85"
};

Ellipsoid_exports.GRS80 = {
  a: 6378137.0,
  rf: 298.257222101,
  ellipseName: "GRS 1980(IUGG, 1980)"
};

Ellipsoid_exports.IAU76 = {
  a: 6378140.0,
  rf: 298.257,
  ellipseName: "IAU 1976"
};

Ellipsoid_exports.airy = {
  a: 6377563.396,
  b: 6356256.910,
  ellipseName: "Airy 1830"
};

Ellipsoid_exports.APL4 = {
  a: 6378137,
  rf: 298.25,
  ellipseName: "Appl. Physics. 1965"
};

Ellipsoid_exports.NWL9D = {
  a: 6378145.0,
  rf: 298.25,
  ellipseName: "Naval Weapons Lab., 1965"
};

Ellipsoid_exports.mod_airy = {
  a: 6377340.189,
  b: 6356034.446,
  ellipseName: "Modified Airy"
};

Ellipsoid_exports.andrae = {
  a: 6377104.43,
  rf: 300.0,
  ellipseName: "Andrae 1876 (Den., Iclnd.)"
};

Ellipsoid_exports.aust_SA = {
  a: 6378160.0,
  rf: 298.25,
  ellipseName: "Australian Natl & S. Amer. 1969"
};

Ellipsoid_exports.GRS67 = {
  a: 6378160.0,
  rf: 298.2471674270,
  ellipseName: "GRS 67(IUGG 1967)"
};

Ellipsoid_exports.bessel = {
  a: 6377397.155,
  rf: 299.1528128,
  ellipseName: "Bessel 1841"
};

Ellipsoid_exports.bess_nam = {
  a: 6377483.865,
  rf: 299.1528128,
  ellipseName: "Bessel 1841 (Namibia)"
};

Ellipsoid_exports.clrk66 = {
  a: 6378206.4,
  b: 6356583.8,
  ellipseName: "Clarke 1866"
};

Ellipsoid_exports.clrk80 = {
  a: 6378249.145,
  rf: 293.4663,
  ellipseName: "Clarke 1880 mod."
};

Ellipsoid_exports.clrk80ign = {
  a: 6378249.2,
  b: 6356515,
  rf: 293.4660213,
  ellipseName: "Clarke 1880 (IGN)"
};

Ellipsoid_exports.clrk58 = {
  a: 6378293.645208759,
  rf: 294.2606763692654,
  ellipseName: "Clarke 1858"
};

Ellipsoid_exports.CPM = {
  a: 6375738.7,
  rf: 334.29,
  ellipseName: "Comm. des Poids et Mesures 1799"
};

Ellipsoid_exports.delmbr = {
  a: 6376428.0,
  rf: 311.5,
  ellipseName: "Delambre 1810 (Belgium)"
};

Ellipsoid_exports.engelis = {
  a: 6378136.05,
  rf: 298.2566,
  ellipseName: "Engelis 1985"
};

Ellipsoid_exports.evrst30 = {
  a: 6377276.345,
  rf: 300.8017,
  ellipseName: "Everest 1830"
};

Ellipsoid_exports.evrst48 = {
  a: 6377304.063,
  rf: 300.8017,
  ellipseName: "Everest 1948"
};

Ellipsoid_exports.evrst56 = {
  a: 6377301.243,
  rf: 300.8017,
  ellipseName: "Everest 1956"
};

Ellipsoid_exports.evrst69 = {
  a: 6377295.664,
  rf: 300.8017,
  ellipseName: "Everest 1969"
};

Ellipsoid_exports.evrstSS = {
  a: 6377298.556,
  rf: 300.8017,
  ellipseName: "Everest (Sabah & Sarawak)"
};

Ellipsoid_exports.fschr60 = {
  a: 6378166.0,
  rf: 298.3,
  ellipseName: "Fischer (Mercury Datum) 1960"
};

Ellipsoid_exports.fschr60m = {
  a: 6378155.0,
  rf: 298.3,
  ellipseName: "Fischer 1960"
};

Ellipsoid_exports.fschr68 = {
  a: 6378150.0,
  rf: 298.3,
  ellipseName: "Fischer 1968"
};

Ellipsoid_exports.helmert = {
  a: 6378200.0,
  rf: 298.3,
  ellipseName: "Helmert 1906"
};

Ellipsoid_exports.hough = {
  a: 6378270.0,
  rf: 297.0,
  ellipseName: "Hough"
};

Ellipsoid_exports.intl = {
  a: 6378388.0,
  rf: 297.0,
  ellipseName: "International 1909 (Hayford)"
};

Ellipsoid_exports.kaula = {
  a: 6378163.0,
  rf: 298.24,
  ellipseName: "Kaula 1961"
};

Ellipsoid_exports.lerch = {
  a: 6378139.0,
  rf: 298.257,
  ellipseName: "Lerch 1979"
};

Ellipsoid_exports.mprts = {
  a: 6397300.0,
  rf: 191.0,
  ellipseName: "Maupertius 1738"
};

Ellipsoid_exports.new_intl = {
  a: 6378157.5,
  b: 6356772.2,
  ellipseName: "New International 1967"
};

Ellipsoid_exports.plessis = {
  a: 6376523.0,
  rf: 6355863.0,
  ellipseName: "Plessis 1817 (France)"
};

Ellipsoid_exports.krass = {
  a: 6378245.0,
  rf: 298.3,
  ellipseName: "Krassovsky, 1942"
};

Ellipsoid_exports.SEasia = {
  a: 6378155.0,
  b: 6356773.3205,
  ellipseName: "Southeast Asia"
};

Ellipsoid_exports.walbeck = {
  a: 6376896.0,
  b: 6355834.8467,
  ellipseName: "Walbeck"
};

Ellipsoid_exports.WGS60 = {
  a: 6378165.0,
  rf: 298.3,
  ellipseName: "WGS 60"
};

Ellipsoid_exports.WGS66 = {
  a: 6378145.0,
  rf: 298.25,
  ellipseName: "WGS 66"
};

Ellipsoid_exports.WGS7 = {
  a: 6378135.0,
  rf: 298.26,
  ellipseName: "WGS 72"
};

var WGS84 = Ellipsoid_exports.WGS84 = {
  a: 6378137.0,
  rf: 298.257223563,
  ellipseName: "WGS 84"
};

Ellipsoid_exports.sphere = {
  a: 6370997.0,
  b: 6370997.0,
  ellipseName: "Normal Sphere (r=6370997)"
};

;// CONCATENATED MODULE: ./node_modules/proj4/lib/deriveConstants.js




function eccentricity(a, b, rf, R_A) {
  var a2 = a * a; // used in geocentric
  var b2 = b * b; // used in geocentric
  var es = (a2 - b2) / a2; // e ^ 2
  var e = 0;
  if (R_A) {
    a *= 1 - es * (SIXTH + es * (RA4 + es * RA6));
    a2 = a * a;
    es = 0;
  } else {
    e = Math.sqrt(es); // eccentricity
  }
  var ep2 = (a2 - b2) / b2; // used in geocentric
  return {
    es: es,
    e: e,
    ep2: ep2
  };
}
function sphere(a, b, rf, ellps, sphere) {
  if (!a) { // do we have an ellipsoid?
    var ellipse = match(Ellipsoid_exports, ellps);
    if (!ellipse) {
      ellipse = WGS84;
    }
    a = ellipse.a;
    b = ellipse.b;
    rf = ellipse.rf;
  }

  if (rf && !b) {
    b = (1.0 - 1.0 / rf) * a;
  }
  if (rf === 0 || Math.abs(a - b) < EPSLN) {
    sphere = true;
    b = a;
  }
  return {
    a: a,
    b: b,
    rf: rf,
    sphere: sphere
  };
}

;// CONCATENATED MODULE: ./node_modules/proj4/lib/constants/Datum.js
var Datum_exports = {};

Datum_exports.wgs84 = {
  towgs84: "0,0,0",
  ellipse: "WGS84",
  datumName: "WGS84"
};

Datum_exports.ch1903 = {
  towgs84: "674.374,15.056,405.346",
  ellipse: "bessel",
  datumName: "swiss"
};

Datum_exports.ggrs87 = {
  towgs84: "-199.87,74.79,246.62",
  ellipse: "GRS80",
  datumName: "Greek_Geodetic_Reference_System_1987"
};

Datum_exports.nad83 = {
  towgs84: "0,0,0",
  ellipse: "GRS80",
  datumName: "North_American_Datum_1983"
};

Datum_exports.nad27 = {
  nadgrids: "@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat",
  ellipse: "clrk66",
  datumName: "North_American_Datum_1927"
};

Datum_exports.potsdam = {
  towgs84: "598.1,73.7,418.2,0.202,0.045,-2.455,6.7",
  ellipse: "bessel",
  datumName: "Potsdam Rauenberg 1950 DHDN"
};

Datum_exports.carthage = {
  towgs84: "-263.0,6.0,431.0",
  ellipse: "clark80",
  datumName: "Carthage 1934 Tunisia"
};

Datum_exports.hermannskogel = {
  towgs84: "577.326,90.129,463.919,5.137,1.474,5.297,2.4232",
  ellipse: "bessel",
  datumName: "Hermannskogel"
};

Datum_exports.osni52 = {
  towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
  ellipse: "airy",
  datumName: "Irish National"
};

Datum_exports.ire65 = {
  towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
  ellipse: "mod_airy",
  datumName: "Ireland 1965"
};

Datum_exports.rassadiran = {
  towgs84: "-133.63,-157.5,-158.62",
  ellipse: "intl",
  datumName: "Rassadiran"
};

Datum_exports.nzgd49 = {
  towgs84: "59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993",
  ellipse: "intl",
  datumName: "New Zealand Geodetic Datum 1949"
};

Datum_exports.osgb36 = {
  towgs84: "446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894",
  ellipse: "airy",
  datumName: "Airy 1830"
};

Datum_exports.s_jtsk = {
  towgs84: "589,76,480",
  ellipse: 'bessel',
  datumName: 'S-JTSK (Ferro)'
};

Datum_exports.beduaram = {
  towgs84: '-106,-87,188',
  ellipse: 'clrk80',
  datumName: 'Beduaram'
};

Datum_exports.gunung_segara = {
  towgs84: '-403,684,41',
  ellipse: 'bessel',
  datumName: 'Gunung Segara Jakarta'
};

Datum_exports.rnb72 = {
  towgs84: "106.869,-52.2978,103.724,-0.33657,0.456955,-1.84218,1",
  ellipse: "intl",
  datumName: "Reseau National Belge 1972"
};

;// CONCATENATED MODULE: ./node_modules/proj4/lib/datum.js


function datum(datumCode, datum_params, a, b, es, ep2, nadgrids) {
  var out = {};

  if (datumCode === undefined || datumCode === 'none') {
    out.datum_type = PJD_NODATUM;
  } else {
    out.datum_type = PJD_WGS84;
  }

  if (datum_params) {
    out.datum_params = datum_params.map(parseFloat);
    if (out.datum_params[0] !== 0 || out.datum_params[1] !== 0 || out.datum_params[2] !== 0) {
      out.datum_type = PJD_3PARAM;
    }
    if (out.datum_params.length > 3) {
      if (out.datum_params[3] !== 0 || out.datum_params[4] !== 0 || out.datum_params[5] !== 0 || out.datum_params[6] !== 0) {
        out.datum_type = PJD_7PARAM;
        out.datum_params[3] *= SEC_TO_RAD;
        out.datum_params[4] *= SEC_TO_RAD;
        out.datum_params[5] *= SEC_TO_RAD;
        out.datum_params[6] = (out.datum_params[6] / 1000000.0) + 1.0;
      }
    }
  }

  if (nadgrids) {
    out.datum_type = PJD_GRIDSHIFT;
    out.grids = nadgrids;
  }
  out.a = a; //datum object also uses these values
  out.b = b;
  out.es = es;
  out.ep2 = ep2;
  return out;
}

/* harmony default export */ const lib_datum = (datum);

;// CONCATENATED MODULE: ./node_modules/proj4/lib/nadgrid.js
/**
 * Resources for details of NTv2 file formats:
 * - https://web.archive.org/web/20140127204822if_/http://www.mgs.gov.on.ca:80/stdprodconsume/groups/content/@mgs/@iandit/documents/resourcelist/stel02_047447.pdf
 * - http://mimaka.com/help/gs/html/004_NTV2%20Data%20Format.htm
 */

var loadedNadgrids = {};

/**
 * Load a binary NTv2 file (.gsb) to a key that can be used in a proj string like +nadgrids=<key>. Pass the NTv2 file
 * as an ArrayBuffer.
 */
function nadgrid(key, data) {
  var view = new DataView(data);
  var isLittleEndian = detectLittleEndian(view);
  var header = readHeader(view, isLittleEndian);
  if (header.nSubgrids > 1) {
    console.log('Only single NTv2 subgrids are currently supported, subsequent sub grids are ignored');
  }
  var subgrids = readSubgrids(view, header, isLittleEndian);
  var nadgrid = {header: header, subgrids: subgrids};
  loadedNadgrids[key] = nadgrid;
  return nadgrid;
}

/**
 * Given a proj4 value for nadgrids, return an array of loaded grids
 */
function getNadgrids(nadgrids) {
  // Format details: http://proj.maptools.org/gen_parms.html
  if (nadgrids === undefined) { return null; }
  var grids = nadgrids.split(',');
  return grids.map(parseNadgridString);
}

function parseNadgridString(value) {
  if (value.length === 0) {
    return null;
  }
  var optional = value[0] === '@';
  if (optional) {
    value = value.slice(1);
  }
  if (value === 'null') {
    return {name: 'null', mandatory: !optional, grid: null, isNull: true};
  }
  return {
    name: value,
    mandatory: !optional,
    grid: loadedNadgrids[value] || null,
    isNull: false
  };
}

function secondsToRadians(seconds) {
  return (seconds / 3600) * Math.PI / 180;
}

function detectLittleEndian(view) {
  var nFields = view.getInt32(8, false);
  if (nFields === 11) {
    return false;
  }
  nFields = view.getInt32(8, true);
  if (nFields !== 11) {
    console.warn('Failed to detect nadgrid endian-ness, defaulting to little-endian');
  }
  return true;
}

function readHeader(view, isLittleEndian) {
  return {
    nFields: view.getInt32(8, isLittleEndian),
    nSubgridFields: view.getInt32(24, isLittleEndian),
    nSubgrids: view.getInt32(40, isLittleEndian),
    shiftType: decodeString(view, 56, 56 + 8).trim(),
    fromSemiMajorAxis: view.getFloat64(120, isLittleEndian),
    fromSemiMinorAxis: view.getFloat64(136, isLittleEndian),
    toSemiMajorAxis: view.getFloat64(152, isLittleEndian),
    toSemiMinorAxis: view.getFloat64(168, isLittleEndian),
  };
}

function decodeString(view, start, end) {
  return String.fromCharCode.apply(null, new Uint8Array(view.buffer.slice(start, end)));
}

function readSubgrids(view, header, isLittleEndian) {
  var gridOffset = 176;
  var grids = [];
  for (var i = 0; i < header.nSubgrids; i++) {
    var subHeader = readGridHeader(view, gridOffset, isLittleEndian);
    var nodes = readGridNodes(view, gridOffset, subHeader, isLittleEndian);
    var lngColumnCount = Math.round(
      1 + (subHeader.upperLongitude - subHeader.lowerLongitude) / subHeader.longitudeInterval);
    var latColumnCount = Math.round(
      1 + (subHeader.upperLatitude - subHeader.lowerLatitude) / subHeader.latitudeInterval);
    // Proj4 operates on radians whereas the coordinates are in seconds in the grid
    grids.push({
      ll: [secondsToRadians(subHeader.lowerLongitude), secondsToRadians(subHeader.lowerLatitude)],
      del: [secondsToRadians(subHeader.longitudeInterval), secondsToRadians(subHeader.latitudeInterval)],
      lim: [lngColumnCount, latColumnCount],
      count: subHeader.gridNodeCount,
      cvs: mapNodes(nodes)
    });
  }
  return grids;
}

function mapNodes(nodes) {
  return nodes.map(function (r) {return [secondsToRadians(r.longitudeShift), secondsToRadians(r.latitudeShift)];});
}

function readGridHeader(view, offset, isLittleEndian) {
  return {
    name: decodeString(view, offset + 8, offset + 16).trim(),
    parent: decodeString(view, offset + 24, offset + 24 + 8).trim(),
    lowerLatitude: view.getFloat64(offset + 72, isLittleEndian),
    upperLatitude: view.getFloat64(offset + 88, isLittleEndian),
    lowerLongitude: view.getFloat64(offset + 104, isLittleEndian),
    upperLongitude: view.getFloat64(offset + 120, isLittleEndian),
    latitudeInterval: view.getFloat64(offset + 136, isLittleEndian),
    longitudeInterval: view.getFloat64(offset + 152, isLittleEndian),
    gridNodeCount: view.getInt32(offset + 168, isLittleEndian)
  };
}

function readGridNodes(view, offset, gridHeader, isLittleEndian) {
  var nodesOffset = offset + 176;
  var gridRecordLength = 16;
  var gridShiftRecords = [];
  for (var i = 0; i < gridHeader.gridNodeCount; i++) {
    var record = {
      latitudeShift: view.getFloat32(nodesOffset + i * gridRecordLength, isLittleEndian),
      longitudeShift: view.getFloat32(nodesOffset + i * gridRecordLength + 4, isLittleEndian),
      latitudeAccuracy: view.getFloat32(nodesOffset + i * gridRecordLength + 8, isLittleEndian),
      longitudeAccuracy: view.getFloat32(nodesOffset + i * gridRecordLength + 12, isLittleEndian),
    };
    gridShiftRecords.push(record);
  }
  return gridShiftRecords;
}

;// CONCATENATED MODULE: ./node_modules/proj4/lib/Proj.js









function Proj_Projection(srsCode,callback) {
  if (!(this instanceof Proj_Projection)) {
    return new Proj_Projection(srsCode);
  }
  callback = callback || function(error){
    if(error){
      throw error;
    }
  };
  var json = parseCode(srsCode);
  if(typeof json !== 'object'){
    callback(srsCode);
    return;
  }
  var ourProj = Proj_Projection.projections.get(json.projName);
  if(!ourProj){
    callback(srsCode);
    return;
  }
  if (json.datumCode && json.datumCode !== 'none') {
    var datumDef = match(Datum_exports, json.datumCode);
    if (datumDef) {
      json.datum_params = json.datum_params || (datumDef.towgs84 ? datumDef.towgs84.split(',') : null);
      json.ellps = datumDef.ellipse;
      json.datumName = datumDef.datumName ? datumDef.datumName : json.datumCode;
    }
  }
  json.k0 = json.k0 || 1.0;
  json.axis = json.axis || 'enu';
  json.ellps = json.ellps || 'wgs84';
  json.lat1 = json.lat1 || json.lat0; // Lambert_Conformal_Conic_1SP, for example, needs this

  var sphere_ = sphere(json.a, json.b, json.rf, json.ellps, json.sphere);
  var ecc = eccentricity(sphere_.a, sphere_.b, sphere_.rf, json.R_A);
  var nadgrids = getNadgrids(json.nadgrids);
  var datumObj = json.datum || lib_datum(json.datumCode, json.datum_params, sphere_.a, sphere_.b, ecc.es, ecc.ep2,
    nadgrids);

  lib_extend(this, json); // transfer everything over from the projection because we don't know what we'll need
  lib_extend(this, ourProj); // transfer all the methods from the projection

  // copy the 4 things over we calculated in deriveConstants.sphere
  this.a = sphere_.a;
  this.b = sphere_.b;
  this.rf = sphere_.rf;
  this.sphere = sphere_.sphere;

  // copy the 3 things we calculated in deriveConstants.eccentricity
  this.es = ecc.es;
  this.e = ecc.e;
  this.ep2 = ecc.ep2;

  // add in the datum object
  this.datum = datumObj;

  // init the projection
  this.init();

  // legecy callback from back in the day when it went to spatialreference.org
  callback(null, this);

}
Proj_Projection.projections = projections;
Proj_Projection.projections.start();
/* harmony default export */ const Proj = (Proj_Projection);

;// CONCATENATED MODULE: ./node_modules/proj4/lib/datumUtils.js


function compareDatums(source, dest) {
  if (source.datum_type !== dest.datum_type) {
    return false; // false, datums are not equal
  } else if (source.a !== dest.a || Math.abs(source.es - dest.es) > 0.000000000050) {
    // the tolerance for es is to ensure that GRS80 and WGS84
    // are considered identical
    return false;
  } else if (source.datum_type === PJD_3PARAM) {
    return (source.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2]);
  } else if (source.datum_type === PJD_7PARAM) {
    return (source.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2] && source.datum_params[3] === dest.datum_params[3] && source.datum_params[4] === dest.datum_params[4] && source.datum_params[5] === dest.datum_params[5] && source.datum_params[6] === dest.datum_params[6]);
  } else {
    return true; // datums are equal
  }
} // cs_compare_datums()

/*
 * The function Convert_Geodetic_To_Geocentric converts geodetic coordinates
 * (latitude, longitude, and height) to geocentric coordinates (X, Y, Z),
 * according to the current ellipsoid parameters.
 *
 *    Latitude  : Geodetic latitude in radians                     (input)
 *    Longitude : Geodetic longitude in radians                    (input)
 *    Height    : Geodetic height, in meters                       (input)
 *    X         : Calculated Geocentric X coordinate, in meters    (output)
 *    Y         : Calculated Geocentric Y coordinate, in meters    (output)
 *    Z         : Calculated Geocentric Z coordinate, in meters    (output)
 *
 */
function geodeticToGeocentric(p, es, a) {
  var Longitude = p.x;
  var Latitude = p.y;
  var Height = p.z ? p.z : 0; //Z value not always supplied

  var Rn; /*  Earth radius at location  */
  var Sin_Lat; /*  Math.sin(Latitude)  */
  var Sin2_Lat; /*  Square of Math.sin(Latitude)  */
  var Cos_Lat; /*  Math.cos(Latitude)  */

  /*
   ** Don't blow up if Latitude is just a little out of the value
   ** range as it may just be a rounding issue.  Also removed longitude
   ** test, it should be wrapped by Math.cos() and Math.sin().  NFW for PROJ.4, Sep/2001.
   */
  if (Latitude < -HALF_PI && Latitude > -1.001 * HALF_PI) {
    Latitude = -HALF_PI;
  } else if (Latitude > HALF_PI && Latitude < 1.001 * HALF_PI) {
    Latitude = HALF_PI;
  } else if (Latitude < -HALF_PI) {
    /* Latitude out of range */
    //..reportError('geocent:lat out of range:' + Latitude);
    return { x: -Infinity, y: -Infinity, z: p.z };
  } else if (Latitude > HALF_PI) {
    /* Latitude out of range */
    return { x: Infinity, y: Infinity, z: p.z };
  }

  if (Longitude > Math.PI) {
    Longitude -= (2 * Math.PI);
  }
  Sin_Lat = Math.sin(Latitude);
  Cos_Lat = Math.cos(Latitude);
  Sin2_Lat = Sin_Lat * Sin_Lat;
  Rn = a / (Math.sqrt(1.0e0 - es * Sin2_Lat));
  return {
    x: (Rn + Height) * Cos_Lat * Math.cos(Longitude),
    y: (Rn + Height) * Cos_Lat * Math.sin(Longitude),
    z: ((Rn * (1 - es)) + Height) * Sin_Lat
  };
} // cs_geodetic_to_geocentric()

function geocentricToGeodetic(p, es, a, b) {
  /* local defintions and variables */
  /* end-criterium of loop, accuracy of sin(Latitude) */
  var genau = 1e-12;
  var genau2 = (genau * genau);
  var maxiter = 30;

  var P; /* distance between semi-minor axis and location */
  var RR; /* distance between center and location */
  var CT; /* sin of geocentric latitude */
  var ST; /* cos of geocentric latitude */
  var RX;
  var RK;
  var RN; /* Earth radius at location */
  var CPHI0; /* cos of start or old geodetic latitude in iterations */
  var SPHI0; /* sin of start or old geodetic latitude in iterations */
  var CPHI; /* cos of searched geodetic latitude */
  var SPHI; /* sin of searched geodetic latitude */
  var SDPHI; /* end-criterium: addition-theorem of sin(Latitude(iter)-Latitude(iter-1)) */
  var iter; /* # of continous iteration, max. 30 is always enough (s.a.) */

  var X = p.x;
  var Y = p.y;
  var Z = p.z ? p.z : 0.0; //Z value not always supplied
  var Longitude;
  var Latitude;
  var Height;

  P = Math.sqrt(X * X + Y * Y);
  RR = Math.sqrt(X * X + Y * Y + Z * Z);

  /*      special cases for latitude and longitude */
  if (P / a < genau) {

    /*  special case, if P=0. (X=0., Y=0.) */
    Longitude = 0.0;

    /*  if (X,Y,Z)=(0.,0.,0.) then Height becomes semi-minor axis
     *  of ellipsoid (=center of mass), Latitude becomes PI/2 */
    if (RR / a < genau) {
      Latitude = HALF_PI;
      Height = -b;
      return {
        x: p.x,
        y: p.y,
        z: p.z
      };
    }
  } else {
    /*  ellipsoidal (geodetic) longitude
     *  interval: -PI < Longitude <= +PI */
    Longitude = Math.atan2(Y, X);
  }

  /* --------------------------------------------------------------
   * Following iterative algorithm was developped by
   * "Institut for Erdmessung", University of Hannover, July 1988.
   * Internet: www.ife.uni-hannover.de
   * Iterative computation of CPHI,SPHI and Height.
   * Iteration of CPHI and SPHI to 10**-12 radian resp.
   * 2*10**-7 arcsec.
   * --------------------------------------------------------------
   */
  CT = Z / RR;
  ST = P / RR;
  RX = 1.0 / Math.sqrt(1.0 - es * (2.0 - es) * ST * ST);
  CPHI0 = ST * (1.0 - es) * RX;
  SPHI0 = CT * RX;
  iter = 0;

  /* loop to find sin(Latitude) resp. Latitude
   * until |sin(Latitude(iter)-Latitude(iter-1))| < genau */
  do {
    iter++;
    RN = a / Math.sqrt(1.0 - es * SPHI0 * SPHI0);

    /*  ellipsoidal (geodetic) height */
    Height = P * CPHI0 + Z * SPHI0 - RN * (1.0 - es * SPHI0 * SPHI0);

    RK = es * RN / (RN + Height);
    RX = 1.0 / Math.sqrt(1.0 - RK * (2.0 - RK) * ST * ST);
    CPHI = ST * (1.0 - RK) * RX;
    SPHI = CT * RX;
    SDPHI = SPHI * CPHI0 - CPHI * SPHI0;
    CPHI0 = CPHI;
    SPHI0 = SPHI;
  }
  while (SDPHI * SDPHI > genau2 && iter < maxiter);

  /*      ellipsoidal (geodetic) latitude */
  Latitude = Math.atan(SPHI / Math.abs(CPHI));
  return {
    x: Longitude,
    y: Latitude,
    z: Height
  };
} // cs_geocentric_to_geodetic()

/****************************************************************/
// pj_geocentic_to_wgs84( p )
//  p = point to transform in geocentric coordinates (x,y,z)


/** point object, nothing fancy, just allows values to be
    passed back and forth by reference rather than by value.
    Other point classes may be used as long as they have
    x and y properties, which will get modified in the transform method.
*/
function geocentricToWgs84(p, datum_type, datum_params) {

  if (datum_type === PJD_3PARAM) {
    // if( x[io] === HUGE_VAL )
    //    continue;
    return {
      x: p.x + datum_params[0],
      y: p.y + datum_params[1],
      z: p.z + datum_params[2],
    };
  } else if (datum_type === PJD_7PARAM) {
    var Dx_BF = datum_params[0];
    var Dy_BF = datum_params[1];
    var Dz_BF = datum_params[2];
    var Rx_BF = datum_params[3];
    var Ry_BF = datum_params[4];
    var Rz_BF = datum_params[5];
    var M_BF = datum_params[6];
    // if( x[io] === HUGE_VAL )
    //    continue;
    return {
      x: M_BF * (p.x - Rz_BF * p.y + Ry_BF * p.z) + Dx_BF,
      y: M_BF * (Rz_BF * p.x + p.y - Rx_BF * p.z) + Dy_BF,
      z: M_BF * (-Ry_BF * p.x + Rx_BF * p.y + p.z) + Dz_BF
    };
  }
} // cs_geocentric_to_wgs84

/****************************************************************/
// pj_geocentic_from_wgs84()
//  coordinate system definition,
//  point to transform in geocentric coordinates (x,y,z)
function geocentricFromWgs84(p, datum_type, datum_params) {

  if (datum_type === PJD_3PARAM) {
    //if( x[io] === HUGE_VAL )
    //    continue;
    return {
      x: p.x - datum_params[0],
      y: p.y - datum_params[1],
      z: p.z - datum_params[2],
    };

  } else if (datum_type === PJD_7PARAM) {
    var Dx_BF = datum_params[0];
    var Dy_BF = datum_params[1];
    var Dz_BF = datum_params[2];
    var Rx_BF = datum_params[3];
    var Ry_BF = datum_params[4];
    var Rz_BF = datum_params[5];
    var M_BF = datum_params[6];
    var x_tmp = (p.x - Dx_BF) / M_BF;
    var y_tmp = (p.y - Dy_BF) / M_BF;
    var z_tmp = (p.z - Dz_BF) / M_BF;
    //if( x[io] === HUGE_VAL )
    //    continue;

    return {
      x: x_tmp + Rz_BF * y_tmp - Ry_BF * z_tmp,
      y: -Rz_BF * x_tmp + y_tmp + Rx_BF * z_tmp,
      z: Ry_BF * x_tmp - Rx_BF * y_tmp + z_tmp
    };
  } //cs_geocentric_from_wgs84()
}

;// CONCATENATED MODULE: ./node_modules/proj4/lib/datum_transform.js




function checkParams(type) {
  return (type === PJD_3PARAM || type === PJD_7PARAM);
}

/* harmony default export */ function datum_transform(source, dest, point) {
  // Short cut if the datums are identical.
  if (compareDatums(source, dest)) {
    return point; // in this case, zero is sucess,
    // whereas cs_compare_datums returns 1 to indicate TRUE
    // confusing, should fix this
  }

  // Explicitly skip datum transform by setting 'datum=none' as parameter for either source or dest
  if (source.datum_type === PJD_NODATUM || dest.datum_type === PJD_NODATUM) {
    return point;
  }

  // If this datum requires grid shifts, then apply it to geodetic coordinates.
  var source_a = source.a;
  var source_es = source.es;
  if (source.datum_type === PJD_GRIDSHIFT) {
    var gridShiftCode = applyGridShift(source, false, point);
    if (gridShiftCode !== 0) {
      return undefined;
    }
    source_a = SRS_WGS84_SEMIMAJOR;
    source_es = SRS_WGS84_ESQUARED;
  }

  var dest_a = dest.a;
  var dest_b = dest.b;
  var dest_es = dest.es;
  if (dest.datum_type === PJD_GRIDSHIFT) {
    dest_a = SRS_WGS84_SEMIMAJOR;
    dest_b = SRS_WGS84_SEMIMINOR;
    dest_es = SRS_WGS84_ESQUARED;
  }

  // Do we need to go through geocentric coordinates?
  if (source_es === dest_es && source_a === dest_a && !checkParams(source.datum_type) &&  !checkParams(dest.datum_type)) {
    return point;
  }

  // Convert to geocentric coordinates.
  point = geodeticToGeocentric(point, source_es, source_a);
  // Convert between datums
  if (checkParams(source.datum_type)) {
    point = geocentricToWgs84(point, source.datum_type, source.datum_params);
  }
  if (checkParams(dest.datum_type)) {
    point = geocentricFromWgs84(point, dest.datum_type, dest.datum_params);
  }
  point = geocentricToGeodetic(point, dest_es, dest_a, dest_b);

  if (dest.datum_type === PJD_GRIDSHIFT) {
    var destGridShiftResult = applyGridShift(dest, true, point);
    if (destGridShiftResult !== 0) {
      return undefined;
    }
  }

  return point;
}

function applyGridShift(source, inverse, point) {
  if (source.grids === null || source.grids.length === 0) {
    console.log('Grid shift grids not found');
    return -1;
  }
  var input = {x: -point.x, y: point.y};
  var output = {x: Number.NaN, y: Number.NaN};
  var onlyMandatoryGrids = false;
  var attemptedGrids = [];
  for (var i = 0; i < source.grids.length; i++) {
    var grid = source.grids[i];
    attemptedGrids.push(grid.name);
    if (grid.isNull) {
      output = input;
      break;
    }
    onlyMandatoryGrids = grid.mandatory;
    if (grid.grid === null) {
      if (grid.mandatory) {
        console.log("Unable to find mandatory grid '" + grid.name + "'");
        return -1;
      }
      continue;
    }
    var subgrid = grid.grid.subgrids[0];
    // skip tables that don't match our point at all
    var epsilon = (Math.abs(subgrid.del[1]) + Math.abs(subgrid.del[0])) / 10000.0;
    var minX = subgrid.ll[0] - epsilon;
    var minY = subgrid.ll[1] - epsilon;
    var maxX = subgrid.ll[0] + (subgrid.lim[0] - 1) * subgrid.del[0] + epsilon;
    var maxY = subgrid.ll[1] + (subgrid.lim[1] - 1) * subgrid.del[1] + epsilon;
    if (minY > input.y || minX > input.x || maxY < input.y || maxX < input.x ) {
      continue;
    }
    output = applySubgridShift(input, inverse, subgrid);
    if (!isNaN(output.x)) {
      break;
    }
  }
  if (isNaN(output.x)) {
    console.log("Failed to find a grid shift table for location '"+
      -input.x * R2D + " " + input.y * R2D + " tried: '" + attemptedGrids + "'");
    return -1;
  }
  point.x = -output.x;
  point.y = output.y;
  return 0;
}

function applySubgridShift(pin, inverse, ct) {
  var val = {x: Number.NaN, y: Number.NaN};
  if (isNaN(pin.x)) { return val; }
  var tb = {x: pin.x, y: pin.y};
  tb.x -= ct.ll[0];
  tb.y -= ct.ll[1];
  tb.x = adjust_lon(tb.x - Math.PI) + Math.PI;
  var t = nadInterpolate(tb, ct);
  if (inverse) {
    if (isNaN(t.x)) {
      return val;
    }
    t.x = tb.x - t.x;
    t.y = tb.y - t.y;
    var i = 9, tol = 1e-12;
    var dif, del;
    do {
      del = nadInterpolate(t, ct);
      if (isNaN(del.x)) {
        console.log("Inverse grid shift iteration failed, presumably at grid edge.  Using first approximation.");
        break;
      }
      dif = {x: tb.x - (del.x + t.x), y: tb.y - (del.y + t.y)};
      t.x += dif.x;
      t.y += dif.y;
    } while (i-- && Math.abs(dif.x) > tol && Math.abs(dif.y) > tol);
    if (i < 0) {
      console.log("Inverse grid shift iterator failed to converge.");
      return val;
    }
    val.x = adjust_lon(t.x + ct.ll[0]);
    val.y = t.y + ct.ll[1];
  } else {
    if (!isNaN(t.x)) {
      val.x = pin.x + t.x;
      val.y = pin.y + t.y;
    }
  }
  return val;
}

function nadInterpolate(pin, ct) {
  var t = {x: pin.x / ct.del[0], y: pin.y / ct.del[1]};
  var indx = {x: Math.floor(t.x), y: Math.floor(t.y)};
  var frct = {x: t.x - 1.0 * indx.x, y: t.y - 1.0 * indx.y};
  var val= {x: Number.NaN, y: Number.NaN};
  var inx;
  if (indx.x < 0 || indx.x >= ct.lim[0]) {
    return val;
  }
  if (indx.y < 0 || indx.y >= ct.lim[1]) {
    return val;
  }
  inx = (indx.y * ct.lim[0]) + indx.x;
  var f00 = {x: ct.cvs[inx][0], y: ct.cvs[inx][1]};
  inx++;
  var f10= {x: ct.cvs[inx][0], y: ct.cvs[inx][1]};
  inx += ct.lim[0];
  var f11 = {x: ct.cvs[inx][0], y: ct.cvs[inx][1]};
  inx--;
  var f01 = {x: ct.cvs[inx][0], y: ct.cvs[inx][1]};
  var m11 = frct.x * frct.y, m10 = frct.x * (1.0 - frct.y),
    m00 = (1.0 - frct.x) * (1.0 - frct.y), m01 = (1.0 - frct.x) * frct.y;
  val.x = (m00 * f00.x + m10 * f10.x + m01 * f01.x + m11 * f11.x);
  val.y = (m00 * f00.y + m10 * f10.y + m01 * f01.y + m11 * f11.y);
  return val;
}

;// CONCATENATED MODULE: ./node_modules/proj4/lib/adjust_axis.js
/* harmony default export */ function adjust_axis(crs, denorm, point) {
  var xin = point.x,
    yin = point.y,
    zin = point.z || 0.0;
  var v, t, i;
  var out = {};
  for (i = 0; i < 3; i++) {
    if (denorm && i === 2 && point.z === undefined) {
      continue;
    }
    if (i === 0) {
      v = xin;
      if ("ew".indexOf(crs.axis[i]) !== -1) {
        t = 'x';
      } else {
        t = 'y';
      }

    }
    else if (i === 1) {
      v = yin;
      if ("ns".indexOf(crs.axis[i]) !== -1) {
        t = 'y';
      } else {
        t = 'x';
      }
    }
    else {
      v = zin;
      t = 'z';
    }
    switch (crs.axis[i]) {
    case 'e':
      out[t] = v;
      break;
    case 'w':
      out[t] = -v;
      break;
    case 'n':
      out[t] = v;
      break;
    case 's':
      out[t] = -v;
      break;
    case 'u':
      if (point[t] !== undefined) {
        out.z = v;
      }
      break;
    case 'd':
      if (point[t] !== undefined) {
        out.z = -v;
      }
      break;
    default:
      //console.log("ERROR: unknow axis ("+crs.axis[i]+") - check definition of "+crs.projName);
      return null;
    }
  }
  return out;
}

;// CONCATENATED MODULE: ./node_modules/proj4/lib/common/toPoint.js
/* harmony default export */ function toPoint(array){
  var out = {
    x: array[0],
    y: array[1]
  };
  if (array.length>2) {
    out.z = array[2];
  }
  if (array.length>3) {
    out.m = array[3];
  }
  return out;
}
;// CONCATENATED MODULE: ./node_modules/proj4/lib/checkSanity.js
/* harmony default export */ function checkSanity(point) {
  checkCoord(point.x);
  checkCoord(point.y);
}
function checkCoord(num) {
  if (typeof Number.isFinite === 'function') {
    if (Number.isFinite(num)) {
      return;
    }
    throw new TypeError('coordinates must be finite numbers');
  }
  if (typeof num !== 'number' || num !== num || !isFinite(num)) {
    throw new TypeError('coordinates must be finite numbers');
  }
}

;// CONCATENATED MODULE: ./node_modules/proj4/lib/transform.js







function checkNotWGS(source, dest) {
  return (
    (source.datum.datum_type === PJD_3PARAM || source.datum.datum_type === PJD_7PARAM || source.datum.datum_type === PJD_GRIDSHIFT) && dest.datumCode !== 'WGS84') ||
    ((dest.datum.datum_type === PJD_3PARAM || dest.datum.datum_type === PJD_7PARAM || dest.datum.datum_type === PJD_GRIDSHIFT) && source.datumCode !== 'WGS84');
}

function transform(source, dest, point, enforceAxis) {
  var wgs84;
  if (Array.isArray(point)) {
    point = toPoint(point);
  } else {
    // Clone the point object so inputs don't get modified
    point = {
      x: point.x,
      y: point.y,
      z: point.z,
      m: point.m
    };
  }
  var hasZ = point.z !== undefined;
  checkSanity(point);
  // Workaround for datum shifts towgs84, if either source or destination projection is not wgs84
  if (source.datum && dest.datum && checkNotWGS(source, dest)) {
    wgs84 = new Proj('WGS84');
    point = transform(source, wgs84, point, enforceAxis);
    source = wgs84;
  }
  // DGR, 2010/11/12
  if (enforceAxis && source.axis !== 'enu') {
    point = adjust_axis(source, false, point);
  }
  // Transform source points to long/lat, if they aren't already.
  if (source.projName === 'longlat') {
    point = {
      x: point.x * D2R,
      y: point.y * D2R,
      z: point.z || 0
    };
  } else {
    if (source.to_meter) {
      point = {
        x: point.x * source.to_meter,
        y: point.y * source.to_meter,
        z: point.z || 0
      };
    }
    point = source.inverse(point); // Convert Cartesian to longlat
    if (!point) {
      return;
    }
  }
  // Adjust for the prime meridian if necessary
  if (source.from_greenwich) {
    point.x += source.from_greenwich;
  }

  // Convert datums if needed, and if possible.
  point = datum_transform(source.datum, dest.datum, point);
  if (!point) {
    return;
  }

  // Adjust for the prime meridian if necessary
  if (dest.from_greenwich) {
    point = {
      x: point.x - dest.from_greenwich,
      y: point.y,
      z: point.z || 0
    };
  }

  if (dest.projName === 'longlat') {
    // convert radians to decimal degrees
    point = {
      x: point.x * R2D,
      y: point.y * R2D,
      z: point.z || 0
    };
  } else { // else project
    point = dest.forward(point);
    if (dest.to_meter) {
      point = {
        x: point.x / dest.to_meter,
        y: point.y / dest.to_meter,
        z: point.z || 0
      };
    }
  }

  // DGR, 2010/11/12
  if (enforceAxis && dest.axis !== 'enu') {
    return adjust_axis(dest, true, point);
  }

  if (!hasZ) {
    delete point.z;
  }
  return point;
}

;// CONCATENATED MODULE: ./node_modules/proj4/lib/core.js


var wgs84 = Proj('WGS84');

function transformer(from, to, coords, enforceAxis) {
  var transformedArray, out, keys;
  if (Array.isArray(coords)) {
    transformedArray = transform(from, to, coords, enforceAxis) || {x: NaN, y: NaN};
    if (coords.length > 2) {
      if ((typeof from.name !== 'undefined' && from.name === 'geocent') || (typeof to.name !== 'undefined' && to.name === 'geocent')) {
        if (typeof transformedArray.z === 'number') {
          return [transformedArray.x, transformedArray.y, transformedArray.z].concat(coords.splice(3));
        } else {
          return [transformedArray.x, transformedArray.y, coords[2]].concat(coords.splice(3));
        }
      } else {
        return [transformedArray.x, transformedArray.y].concat(coords.splice(2));
      }
    } else {
      return [transformedArray.x, transformedArray.y];
    }
  } else {
    out = transform(from, to, coords, enforceAxis);
    keys = Object.keys(coords);
    if (keys.length === 2) {
      return out;
    }
    keys.forEach(function (key) {
      if ((typeof from.name !== 'undefined' && from.name === 'geocent') || (typeof to.name !== 'undefined' && to.name === 'geocent')) {
        if (key === 'x' || key === 'y' || key === 'z') {
          return;
        }
      } else {
        if (key === 'x' || key === 'y') {
          return;
        }
      }
      out[key] = coords[key];
    });
    return out;
  }
}

function checkProj(item) {
  if (item instanceof Proj) {
    return item;
  }
  if (item.oProj) {
    return item.oProj;
  }
  return Proj(item);
}

function proj4(fromProj, toProj, coord) {
  fromProj = checkProj(fromProj);
  var single = false;
  var obj;
  if (typeof toProj === 'undefined') {
    toProj = fromProj;
    fromProj = wgs84;
    single = true;
  } else if (typeof toProj.x !== 'undefined' || Array.isArray(toProj)) {
    coord = toProj;
    toProj = fromProj;
    fromProj = wgs84;
    single = true;
  }
  toProj = checkProj(toProj);
  if (coord) {
    return transformer(fromProj, toProj, coord);
  } else {
    obj = {
      forward: function (coords, enforceAxis) {
        return transformer(fromProj, toProj, coords, enforceAxis);
      },
      inverse: function (coords, enforceAxis) {
        return transformer(toProj, fromProj, coords, enforceAxis);
      }
    };
    if (single) {
      obj.oProj = toProj;
    }
    return obj;
  }
}
/* harmony default export */ const core = (proj4);
;// CONCATENATED MODULE: ./node_modules/mgrs/mgrs.js



/**
 * UTM zones are grouped, and assigned to one of a group of 6
 * sets.
 *
 * {int} @private
 */
var NUM_100K_SETS = 6;

/**
 * The column letters (for easting) of the lower left value, per
 * set.
 *
 * {string} @private
 */
var SET_ORIGIN_COLUMN_LETTERS = 'AJSAJS';

/**
 * The row letters (for northing) of the lower left value, per
 * set.
 *
 * {string} @private
 */
var SET_ORIGIN_ROW_LETTERS = 'AFAFAF';

var A = 65; // A
var I = 73; // I
var O = 79; // O
var V = 86; // V
var Z = 90; // Z
/* harmony default export */ const mgrs = ({
  forward: mgrs_forward,
  inverse: mgrs_inverse,
  toPoint: mgrs_toPoint
});
/**
 * Conversion of lat/lon to MGRS.
 *
 * @param {object} ll Object literal with lat and lon properties on a
 *     WGS84 ellipsoid.
 * @param {int} accuracy Accuracy in digits (5 for 1 m, 4 for 10 m, 3 for
 *      100 m, 2 for 1000 m or 1 for 10000 m). Optional, default is 5.
 * @return {string} the MGRS string for the given location and accuracy.
 */
function mgrs_forward(ll, accuracy) {
  accuracy = accuracy || 5; // default accuracy 1m
  return encode(LLtoUTM({
    lat: ll[1],
    lon: ll[0]
  }), accuracy);
};

/**
 * Conversion of MGRS to lat/lon.
 *
 * @param {string} mgrs MGRS string.
 * @return {array} An array with left (longitude), bottom (latitude), right
 *     (longitude) and top (latitude) values in WGS84, representing the
 *     bounding box for the provided MGRS reference.
 */
function mgrs_inverse(mgrs) {
  var bbox = UTMtoLL(decode(mgrs.toUpperCase()));
  if (bbox.lat && bbox.lon) {
    return [bbox.lon, bbox.lat, bbox.lon, bbox.lat];
  }
  return [bbox.left, bbox.bottom, bbox.right, bbox.top];
};

function mgrs_toPoint(mgrs) {
  var bbox = UTMtoLL(decode(mgrs.toUpperCase()));
  if (bbox.lat && bbox.lon) {
    return [bbox.lon, bbox.lat];
  }
  return [(bbox.left + bbox.right) / 2, (bbox.top + bbox.bottom) / 2];
};
/**
 * Conversion from degrees to radians.
 *
 * @private
 * @param {number} deg the angle in degrees.
 * @return {number} the angle in radians.
 */
function degToRad(deg) {
  return (deg * (Math.PI / 180.0));
}

/**
 * Conversion from radians to degrees.
 *
 * @private
 * @param {number} rad the angle in radians.
 * @return {number} the angle in degrees.
 */
function radToDeg(rad) {
  return (180.0 * (rad / Math.PI));
}

/**
 * Converts a set of Longitude and Latitude co-ordinates to UTM
 * using the WGS84 ellipsoid.
 *
 * @private
 * @param {object} ll Object literal with lat and lon properties
 *     representing the WGS84 coordinate to be converted.
 * @return {object} Object literal containing the UTM value with easting,
 *     northing, zoneNumber and zoneLetter properties, and an optional
 *     accuracy property in digits. Returns null if the conversion failed.
 */
function LLtoUTM(ll) {
  var Lat = ll.lat;
  var Long = ll.lon;
  var a = 6378137.0; //ellip.radius;
  var eccSquared = 0.00669438; //ellip.eccsq;
  var k0 = 0.9996;
  var LongOrigin;
  var eccPrimeSquared;
  var N, T, C, A, M;
  var LatRad = degToRad(Lat);
  var LongRad = degToRad(Long);
  var LongOriginRad;
  var ZoneNumber;
  // (int)
  ZoneNumber = Math.floor((Long + 180) / 6) + 1;

  //Make sure the longitude 180.00 is in Zone 60
  if (Long === 180) {
    ZoneNumber = 60;
  }

  // Special zone for Norway
  if (Lat >= 56.0 && Lat < 64.0 && Long >= 3.0 && Long < 12.0) {
    ZoneNumber = 32;
  }

  // Special zones for Svalbard
  if (Lat >= 72.0 && Lat < 84.0) {
    if (Long >= 0.0 && Long < 9.0) {
      ZoneNumber = 31;
    }
    else if (Long >= 9.0 && Long < 21.0) {
      ZoneNumber = 33;
    }
    else if (Long >= 21.0 && Long < 33.0) {
      ZoneNumber = 35;
    }
    else if (Long >= 33.0 && Long < 42.0) {
      ZoneNumber = 37;
    }
  }

  LongOrigin = (ZoneNumber - 1) * 6 - 180 + 3; //+3 puts origin
  // in middle of
  // zone
  LongOriginRad = degToRad(LongOrigin);

  eccPrimeSquared = (eccSquared) / (1 - eccSquared);

  N = a / Math.sqrt(1 - eccSquared * Math.sin(LatRad) * Math.sin(LatRad));
  T = Math.tan(LatRad) * Math.tan(LatRad);
  C = eccPrimeSquared * Math.cos(LatRad) * Math.cos(LatRad);
  A = Math.cos(LatRad) * (LongRad - LongOriginRad);

  M = a * ((1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256) * LatRad - (3 * eccSquared / 8 + 3 * eccSquared * eccSquared / 32 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(2 * LatRad) + (15 * eccSquared * eccSquared / 256 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(4 * LatRad) - (35 * eccSquared * eccSquared * eccSquared / 3072) * Math.sin(6 * LatRad));

  var UTMEasting = (k0 * N * (A + (1 - T + C) * A * A * A / 6.0 + (5 - 18 * T + T * T + 72 * C - 58 * eccPrimeSquared) * A * A * A * A * A / 120.0) + 500000.0);

  var UTMNorthing = (k0 * (M + N * Math.tan(LatRad) * (A * A / 2 + (5 - T + 9 * C + 4 * C * C) * A * A * A * A / 24.0 + (61 - 58 * T + T * T + 600 * C - 330 * eccPrimeSquared) * A * A * A * A * A * A / 720.0)));
  if (Lat < 0.0) {
    UTMNorthing += 10000000.0; //10000000 meter offset for
    // southern hemisphere
  }

  return {
    northing: Math.round(UTMNorthing),
    easting: Math.round(UTMEasting),
    zoneNumber: ZoneNumber,
    zoneLetter: getLetterDesignator(Lat)
  };
}

/**
 * Converts UTM coords to lat/long, using the WGS84 ellipsoid. This is a convenience
 * class where the Zone can be specified as a single string eg."60N" which
 * is then broken down into the ZoneNumber and ZoneLetter.
 *
 * @private
 * @param {object} utm An object literal with northing, easting, zoneNumber
 *     and zoneLetter properties. If an optional accuracy property is
 *     provided (in meters), a bounding box will be returned instead of
 *     latitude and longitude.
 * @return {object} An object literal containing either lat and lon values
 *     (if no accuracy was provided), or top, right, bottom and left values
 *     for the bounding box calculated according to the provided accuracy.
 *     Returns null if the conversion failed.
 */
function UTMtoLL(utm) {

  var UTMNorthing = utm.northing;
  var UTMEasting = utm.easting;
  var zoneLetter = utm.zoneLetter;
  var zoneNumber = utm.zoneNumber;
  // check the ZoneNummber is valid
  if (zoneNumber < 0 || zoneNumber > 60) {
    return null;
  }

  var k0 = 0.9996;
  var a = 6378137.0; //ellip.radius;
  var eccSquared = 0.00669438; //ellip.eccsq;
  var eccPrimeSquared;
  var e1 = (1 - Math.sqrt(1 - eccSquared)) / (1 + Math.sqrt(1 - eccSquared));
  var N1, T1, C1, R1, D, M;
  var LongOrigin;
  var mu, phi1Rad;

  // remove 500,000 meter offset for longitude
  var x = UTMEasting - 500000.0;
  var y = UTMNorthing;

  // We must know somehow if we are in the Northern or Southern
  // hemisphere, this is the only time we use the letter So even
  // if the Zone letter isn't exactly correct it should indicate
  // the hemisphere correctly
  if (zoneLetter < 'N') {
    y -= 10000000.0; // remove 10,000,000 meter offset used
    // for southern hemisphere
  }

  // There are 60 zones with zone 1 being at West -180 to -174
  LongOrigin = (zoneNumber - 1) * 6 - 180 + 3; // +3 puts origin
  // in middle of
  // zone

  eccPrimeSquared = (eccSquared) / (1 - eccSquared);

  M = y / k0;
  mu = M / (a * (1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256));

  phi1Rad = mu + (3 * e1 / 2 - 27 * e1 * e1 * e1 / 32) * Math.sin(2 * mu) + (21 * e1 * e1 / 16 - 55 * e1 * e1 * e1 * e1 / 32) * Math.sin(4 * mu) + (151 * e1 * e1 * e1 / 96) * Math.sin(6 * mu);
  // double phi1 = ProjMath.radToDeg(phi1Rad);

  N1 = a / Math.sqrt(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad));
  T1 = Math.tan(phi1Rad) * Math.tan(phi1Rad);
  C1 = eccPrimeSquared * Math.cos(phi1Rad) * Math.cos(phi1Rad);
  R1 = a * (1 - eccSquared) / Math.pow(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad), 1.5);
  D = x / (N1 * k0);

  var lat = phi1Rad - (N1 * Math.tan(phi1Rad) / R1) * (D * D / 2 - (5 + 3 * T1 + 10 * C1 - 4 * C1 * C1 - 9 * eccPrimeSquared) * D * D * D * D / 24 + (61 + 90 * T1 + 298 * C1 + 45 * T1 * T1 - 252 * eccPrimeSquared - 3 * C1 * C1) * D * D * D * D * D * D / 720);
  lat = radToDeg(lat);

  var lon = (D - (1 + 2 * T1 + C1) * D * D * D / 6 + (5 - 2 * C1 + 28 * T1 - 3 * C1 * C1 + 8 * eccPrimeSquared + 24 * T1 * T1) * D * D * D * D * D / 120) / Math.cos(phi1Rad);
  lon = LongOrigin + radToDeg(lon);

  var result;
  if (utm.accuracy) {
    var topRight = UTMtoLL({
      northing: utm.northing + utm.accuracy,
      easting: utm.easting + utm.accuracy,
      zoneLetter: utm.zoneLetter,
      zoneNumber: utm.zoneNumber
    });
    result = {
      top: topRight.lat,
      right: topRight.lon,
      bottom: lat,
      left: lon
    };
  }
  else {
    result = {
      lat: lat,
      lon: lon
    };
  }
  return result;
}

/**
 * Calculates the MGRS letter designator for the given latitude.
 *
 * @private
 * @param {number} lat The latitude in WGS84 to get the letter designator
 *     for.
 * @return {char} The letter designator.
 */
function getLetterDesignator(lat) {
  //This is here as an error flag to show that the Latitude is
  //outside MGRS limits
  var LetterDesignator = 'Z';

  if ((84 >= lat) && (lat >= 72)) {
    LetterDesignator = 'X';
  }
  else if ((72 > lat) && (lat >= 64)) {
    LetterDesignator = 'W';
  }
  else if ((64 > lat) && (lat >= 56)) {
    LetterDesignator = 'V';
  }
  else if ((56 > lat) && (lat >= 48)) {
    LetterDesignator = 'U';
  }
  else if ((48 > lat) && (lat >= 40)) {
    LetterDesignator = 'T';
  }
  else if ((40 > lat) && (lat >= 32)) {
    LetterDesignator = 'S';
  }
  else if ((32 > lat) && (lat >= 24)) {
    LetterDesignator = 'R';
  }
  else if ((24 > lat) && (lat >= 16)) {
    LetterDesignator = 'Q';
  }
  else if ((16 > lat) && (lat >= 8)) {
    LetterDesignator = 'P';
  }
  else if ((8 > lat) && (lat >= 0)) {
    LetterDesignator = 'N';
  }
  else if ((0 > lat) && (lat >= -8)) {
    LetterDesignator = 'M';
  }
  else if ((-8 > lat) && (lat >= -16)) {
    LetterDesignator = 'L';
  }
  else if ((-16 > lat) && (lat >= -24)) {
    LetterDesignator = 'K';
  }
  else if ((-24 > lat) && (lat >= -32)) {
    LetterDesignator = 'J';
  }
  else if ((-32 > lat) && (lat >= -40)) {
    LetterDesignator = 'H';
  }
  else if ((-40 > lat) && (lat >= -48)) {
    LetterDesignator = 'G';
  }
  else if ((-48 > lat) && (lat >= -56)) {
    LetterDesignator = 'F';
  }
  else if ((-56 > lat) && (lat >= -64)) {
    LetterDesignator = 'E';
  }
  else if ((-64 > lat) && (lat >= -72)) {
    LetterDesignator = 'D';
  }
  else if ((-72 > lat) && (lat >= -80)) {
    LetterDesignator = 'C';
  }
  return LetterDesignator;
}

/**
 * Encodes a UTM location as MGRS string.
 *
 * @private
 * @param {object} utm An object literal with easting, northing,
 *     zoneLetter, zoneNumber
 * @param {number} accuracy Accuracy in digits (1-5).
 * @return {string} MGRS string for the given UTM location.
 */
function encode(utm, accuracy) {
  // prepend with leading zeroes
  var seasting = "00000" + utm.easting,
    snorthing = "00000" + utm.northing;

  return utm.zoneNumber + utm.zoneLetter + get100kID(utm.easting, utm.northing, utm.zoneNumber) + seasting.substr(seasting.length - 5, accuracy) + snorthing.substr(snorthing.length - 5, accuracy);
}

/**
 * Get the two letter 100k designator for a given UTM easting,
 * northing and zone number value.
 *
 * @private
 * @param {number} easting
 * @param {number} northing
 * @param {number} zoneNumber
 * @return the two letter 100k designator for the given UTM location.
 */
function get100kID(easting, northing, zoneNumber) {
  var setParm = get100kSetForZone(zoneNumber);
  var setColumn = Math.floor(easting / 100000);
  var setRow = Math.floor(northing / 100000) % 20;
  return getLetter100kID(setColumn, setRow, setParm);
}

/**
 * Given a UTM zone number, figure out the MGRS 100K set it is in.
 *
 * @private
 * @param {number} i An UTM zone number.
 * @return {number} the 100k set the UTM zone is in.
 */
function get100kSetForZone(i) {
  var setParm = i % NUM_100K_SETS;
  if (setParm === 0) {
    setParm = NUM_100K_SETS;
  }

  return setParm;
}

/**
 * Get the two-letter MGRS 100k designator given information
 * translated from the UTM northing, easting and zone number.
 *
 * @private
 * @param {number} column the column index as it relates to the MGRS
 *        100k set spreadsheet, created from the UTM easting.
 *        Values are 1-8.
 * @param {number} row the row index as it relates to the MGRS 100k set
 *        spreadsheet, created from the UTM northing value. Values
 *        are from 0-19.
 * @param {number} parm the set block, as it relates to the MGRS 100k set
 *        spreadsheet, created from the UTM zone. Values are from
 *        1-60.
 * @return two letter MGRS 100k code.
 */
function getLetter100kID(column, row, parm) {
  // colOrigin and rowOrigin are the letters at the origin of the set
  var index = parm - 1;
  var colOrigin = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(index);
  var rowOrigin = SET_ORIGIN_ROW_LETTERS.charCodeAt(index);

  // colInt and rowInt are the letters to build to return
  var colInt = colOrigin + column - 1;
  var rowInt = rowOrigin + row;
  var rollover = false;

  if (colInt > Z) {
    colInt = colInt - Z + A - 1;
    rollover = true;
  }

  if (colInt === I || (colOrigin < I && colInt > I) || ((colInt > I || colOrigin < I) && rollover)) {
    colInt++;
  }

  if (colInt === O || (colOrigin < O && colInt > O) || ((colInt > O || colOrigin < O) && rollover)) {
    colInt++;

    if (colInt === I) {
      colInt++;
    }
  }

  if (colInt > Z) {
    colInt = colInt - Z + A - 1;
  }

  if (rowInt > V) {
    rowInt = rowInt - V + A - 1;
    rollover = true;
  }
  else {
    rollover = false;
  }

  if (((rowInt === I) || ((rowOrigin < I) && (rowInt > I))) || (((rowInt > I) || (rowOrigin < I)) && rollover)) {
    rowInt++;
  }

  if (((rowInt === O) || ((rowOrigin < O) && (rowInt > O))) || (((rowInt > O) || (rowOrigin < O)) && rollover)) {
    rowInt++;

    if (rowInt === I) {
      rowInt++;
    }
  }

  if (rowInt > V) {
    rowInt = rowInt - V + A - 1;
  }

  var twoLetter = String.fromCharCode(colInt) + String.fromCharCode(rowInt);
  return twoLetter;
}

/**
 * Decode the UTM parameters from a MGRS string.
 *
 * @private
 * @param {string} mgrsString an UPPERCASE coordinate string is expected.
 * @return {object} An object literal with easting, northing, zoneLetter,
 *     zoneNumber and accuracy (in meters) properties.
 */
function decode(mgrsString) {

  if (mgrsString && mgrsString.length === 0) {
    throw ("MGRSPoint coverting from nothing");
  }

  var length = mgrsString.length;

  var hunK = null;
  var sb = "";
  var testChar;
  var i = 0;

  // get Zone number
  while (!(/[A-Z]/).test(testChar = mgrsString.charAt(i))) {
    if (i >= 2) {
      throw ("MGRSPoint bad conversion from: " + mgrsString);
    }
    sb += testChar;
    i++;
  }

  var zoneNumber = parseInt(sb, 10);

  if (i === 0 || i + 3 > length) {
    // A good MGRS string has to be 4-5 digits long,
    // ##AAA/#AAA at least.
    throw ("MGRSPoint bad conversion from: " + mgrsString);
  }

  var zoneLetter = mgrsString.charAt(i++);

  // Should we check the zone letter here? Why not.
  if (zoneLetter <= 'A' || zoneLetter === 'B' || zoneLetter === 'Y' || zoneLetter >= 'Z' || zoneLetter === 'I' || zoneLetter === 'O') {
    throw ("MGRSPoint zone letter " + zoneLetter + " not handled: " + mgrsString);
  }

  hunK = mgrsString.substring(i, i += 2);

  var set = get100kSetForZone(zoneNumber);

  var east100k = getEastingFromChar(hunK.charAt(0), set);
  var north100k = getNorthingFromChar(hunK.charAt(1), set);

  // We have a bug where the northing may be 2000000 too low.
  // How
  // do we know when to roll over?

  while (north100k < getMinNorthing(zoneLetter)) {
    north100k += 2000000;
  }

  // calculate the char index for easting/northing separator
  var remainder = length - i;

  if (remainder % 2 !== 0) {
    throw ("MGRSPoint has to have an even number \nof digits after the zone letter and two 100km letters - front \nhalf for easting meters, second half for \nnorthing meters" + mgrsString);
  }

  var sep = remainder / 2;

  var sepEasting = 0.0;
  var sepNorthing = 0.0;
  var accuracyBonus, sepEastingString, sepNorthingString, easting, northing;
  if (sep > 0) {
    accuracyBonus = 100000.0 / Math.pow(10, sep);
    sepEastingString = mgrsString.substring(i, i + sep);
    sepEasting = parseFloat(sepEastingString) * accuracyBonus;
    sepNorthingString = mgrsString.substring(i + sep);
    sepNorthing = parseFloat(sepNorthingString) * accuracyBonus;
  }

  easting = sepEasting + east100k;
  northing = sepNorthing + north100k;

  return {
    easting: easting,
    northing: northing,
    zoneLetter: zoneLetter,
    zoneNumber: zoneNumber,
    accuracy: accuracyBonus
  };
}

/**
 * Given the first letter from a two-letter MGRS 100k zone, and given the
 * MGRS table set for the zone number, figure out the easting value that
 * should be added to the other, secondary easting value.
 *
 * @private
 * @param {char} e The first letter from a two-letter MGRS 100´k zone.
 * @param {number} set The MGRS table set for the zone number.
 * @return {number} The easting value for the given letter and set.
 */
function getEastingFromChar(e, set) {
  // colOrigin is the letter at the origin of the set for the
  // column
  var curCol = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(set - 1);
  var eastingValue = 100000.0;
  var rewindMarker = false;

  while (curCol !== e.charCodeAt(0)) {
    curCol++;
    if (curCol === I) {
      curCol++;
    }
    if (curCol === O) {
      curCol++;
    }
    if (curCol > Z) {
      if (rewindMarker) {
        throw ("Bad character: " + e);
      }
      curCol = A;
      rewindMarker = true;
    }
    eastingValue += 100000.0;
  }

  return eastingValue;
}

/**
 * Given the second letter from a two-letter MGRS 100k zone, and given the
 * MGRS table set for the zone number, figure out the northing value that
 * should be added to the other, secondary northing value. You have to
 * remember that Northings are determined from the equator, and the vertical
 * cycle of letters mean a 2000000 additional northing meters. This happens
 * approx. every 18 degrees of latitude. This method does *NOT* count any
 * additional northings. You have to figure out how many 2000000 meters need
 * to be added for the zone letter of the MGRS coordinate.
 *
 * @private
 * @param {char} n Second letter of the MGRS 100k zone
 * @param {number} set The MGRS table set number, which is dependent on the
 *     UTM zone number.
 * @return {number} The northing value for the given letter and set.
 */
function getNorthingFromChar(n, set) {

  if (n > 'V') {
    throw ("MGRSPoint given invalid Northing " + n);
  }

  // rowOrigin is the letter at the origin of the set for the
  // column
  var curRow = SET_ORIGIN_ROW_LETTERS.charCodeAt(set - 1);
  var northingValue = 0.0;
  var rewindMarker = false;

  while (curRow !== n.charCodeAt(0)) {
    curRow++;
    if (curRow === I) {
      curRow++;
    }
    if (curRow === O) {
      curRow++;
    }
    // fixing a bug making whole application hang in this loop
    // when 'n' is a wrong character
    if (curRow > V) {
      if (rewindMarker) { // making sure that this loop ends
        throw ("Bad character: " + n);
      }
      curRow = A;
      rewindMarker = true;
    }
    northingValue += 100000.0;
  }

  return northingValue;
}

/**
 * The function getMinNorthing returns the minimum northing value of a MGRS
 * zone.
 *
 * Ported from Geotrans' c Lattitude_Band_Value structure table.
 *
 * @private
 * @param {char} zoneLetter The MGRS zone to get the min northing for.
 * @return {number}
 */
function getMinNorthing(zoneLetter) {
  var northing;
  switch (zoneLetter) {
  case 'C':
    northing = 1100000.0;
    break;
  case 'D':
    northing = 2000000.0;
    break;
  case 'E':
    northing = 2800000.0;
    break;
  case 'F':
    northing = 3700000.0;
    break;
  case 'G':
    northing = 4600000.0;
    break;
  case 'H':
    northing = 5500000.0;
    break;
  case 'J':
    northing = 6400000.0;
    break;
  case 'K':
    northing = 7300000.0;
    break;
  case 'L':
    northing = 8200000.0;
    break;
  case 'M':
    northing = 9100000.0;
    break;
  case 'N':
    northing = 0.0;
    break;
  case 'P':
    northing = 800000.0;
    break;
  case 'Q':
    northing = 1700000.0;
    break;
  case 'R':
    northing = 2600000.0;
    break;
  case 'S':
    northing = 3500000.0;
    break;
  case 'T':
    northing = 4400000.0;
    break;
  case 'U':
    northing = 5300000.0;
    break;
  case 'V':
    northing = 6200000.0;
    break;
  case 'W':
    northing = 7000000.0;
    break;
  case 'X':
    northing = 7900000.0;
    break;
  default:
    northing = -1.0;
  }
  if (northing >= 0.0) {
    return northing;
  }
  else {
    throw ("Invalid zone letter: " + zoneLetter);
  }

}

;// CONCATENATED MODULE: ./node_modules/proj4/lib/Point.js


function lib_Point_Point(x, y, z) {
  if (!(this instanceof lib_Point_Point)) {
    return new lib_Point_Point(x, y, z);
  }
  if (Array.isArray(x)) {
    this.x = x[0];
    this.y = x[1];
    this.z = x[2] || 0.0;
  } else if(typeof x === 'object') {
    this.x = x.x;
    this.y = x.y;
    this.z = x.z || 0.0;
  } else if (typeof x === 'string' && typeof y === 'undefined') {
    var coords = x.split(',');
    this.x = parseFloat(coords[0], 10);
    this.y = parseFloat(coords[1], 10);
    this.z = parseFloat(coords[2], 10) || 0.0;
  } else {
    this.x = x;
    this.y = y;
    this.z = z || 0.0;
  }
  console.warn('proj4.Point will be removed in version 3, use proj4.toPoint');
}

lib_Point_Point.fromMGRS = function(mgrsStr) {
  return new lib_Point_Point(mgrs_toPoint(mgrsStr));
};
lib_Point_Point.prototype.toMGRS = function(accuracy) {
  return mgrs_forward([this.x, this.y], accuracy);
};
/* harmony default export */ const lib_Point = (lib_Point_Point);

;// CONCATENATED MODULE: ./node_modules/proj4/lib/common/pj_enfn.js
var C00 = 1;
var C02 = 0.25;
var C04 = 0.046875;
var C06 = 0.01953125;
var C08 = 0.01068115234375;
var C22 = 0.75;
var C44 = 0.46875;
var C46 = 0.01302083333333333333;
var C48 = 0.00712076822916666666;
var C66 = 0.36458333333333333333;
var C68 = 0.00569661458333333333;
var C88 = 0.3076171875;

/* harmony default export */ function pj_enfn(es) {
  var en = [];
  en[0] = C00 - es * (C02 + es * (C04 + es * (C06 + es * C08)));
  en[1] = es * (C22 - es * (C04 + es * (C06 + es * C08)));
  var t = es * es;
  en[2] = t * (C44 - es * (C46 + es * C48));
  t *= es;
  en[3] = t * (C66 - es * C68);
  en[4] = t * es * C88;
  return en;
}
;// CONCATENATED MODULE: ./node_modules/proj4/lib/common/pj_mlfn.js
/* harmony default export */ function pj_mlfn(phi, sphi, cphi, en) {
  cphi *= sphi;
  sphi *= sphi;
  return (en[0] * phi - cphi * (en[1] + sphi * (en[2] + sphi * (en[3] + sphi * en[4]))));
}
;// CONCATENATED MODULE: ./node_modules/proj4/lib/common/pj_inv_mlfn.js



var MAX_ITER = 20;

/* harmony default export */ function pj_inv_mlfn(arg, es, en) {
  var k = 1 / (1 - es);
  var phi = arg;
  for (var i = MAX_ITER; i; --i) { /* rarely goes over 2 iterations */
    var s = Math.sin(phi);
    var t = 1 - es * s * s;
    //t = this.pj_mlfn(phi, s, Math.cos(phi), en) - arg;
    //phi -= t * (t * Math.sqrt(t)) * k;
    t = (pj_mlfn(phi, s, Math.cos(phi), en) - arg) * (t * Math.sqrt(t)) * k;
    phi -= t;
    if (Math.abs(t) < EPSLN) {
      return phi;
    }
  }
  //..reportError("cass:pj_inv_mlfn: Convergence error");
  return phi;
}

;// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/tmerc.js
// Heavily based on this tmerc projection implementation
// https://github.com/mbloch/mapshaper-proj/blob/master/src/projections/tmerc.js









function tmerc_init() {
  this.x0 = this.x0 !== undefined ? this.x0 : 0;
  this.y0 = this.y0 !== undefined ? this.y0 : 0;
  this.long0 = this.long0 !== undefined ? this.long0 : 0;
  this.lat0 = this.lat0 !== undefined ? this.lat0 : 0;

  if (this.es) {
    this.en = pj_enfn(this.es);
    this.ml0 = pj_mlfn(this.lat0, Math.sin(this.lat0), Math.cos(this.lat0), this.en);
  }
}

/**
    Transverse Mercator Forward  - long/lat to x/y
    long/lat in radians
  */
function tmerc_forward(p) {
  var lon = p.x;
  var lat = p.y;

  var delta_lon = adjust_lon(lon - this.long0);
  var con;
  var x, y;
  var sin_phi = Math.sin(lat);
  var cos_phi = Math.cos(lat);

  if (!this.es) {
    var b = cos_phi * Math.sin(delta_lon);

    if ((Math.abs(Math.abs(b) - 1)) < EPSLN) {
      return (93);
    }
    else {
      x = 0.5 * this.a * this.k0 * Math.log((1 + b) / (1 - b)) + this.x0;
      y = cos_phi * Math.cos(delta_lon) / Math.sqrt(1 - Math.pow(b, 2));
      b = Math.abs(y);

      if (b >= 1) {
        if ((b - 1) > EPSLN) {
          return (93);
        }
        else {
          y = 0;
        }
      }
      else {
        y = Math.acos(y);
      }

      if (lat < 0) {
        y = -y;
      }

      y = this.a * this.k0 * (y - this.lat0) + this.y0;
    }
  }
  else {
    var al = cos_phi * delta_lon;
    var als = Math.pow(al, 2);
    var c = this.ep2 * Math.pow(cos_phi, 2);
    var cs = Math.pow(c, 2);
    var tq = Math.abs(cos_phi) > EPSLN ? Math.tan(lat) : 0;
    var t = Math.pow(tq, 2);
    var ts = Math.pow(t, 2);
    con = 1 - this.es * Math.pow(sin_phi, 2);
    al = al / Math.sqrt(con);
    var ml = pj_mlfn(lat, sin_phi, cos_phi, this.en);

    x = this.a * (this.k0 * al * (1 +
      als / 6 * (1 - t + c +
      als / 20 * (5 - 18 * t + ts + 14 * c - 58 * t * c +
      als / 42 * (61 + 179 * ts - ts * t - 479 * t))))) +
      this.x0;

    y = this.a * (this.k0 * (ml - this.ml0 +
      sin_phi * delta_lon * al / 2 * (1 +
      als / 12 * (5 - t + 9 * c + 4 * cs +
      als / 30 * (61 + ts - 58 * t + 270 * c - 330 * t * c +
      als / 56 * (1385 + 543 * ts - ts * t - 3111 * t)))))) +
      this.y0;
  }

  p.x = x;
  p.y = y;

  return p;
}

/**
    Transverse Mercator Inverse  -  x/y to long/lat
  */
function tmerc_inverse(p) {
  var con, phi;
  var lat, lon;
  var x = (p.x - this.x0) * (1 / this.a);
  var y = (p.y - this.y0) * (1 / this.a);

  if (!this.es) {
    var f = Math.exp(x / this.k0);
    var g = 0.5 * (f - 1 / f);
    var temp = this.lat0 + y / this.k0;
    var h = Math.cos(temp);
    con = Math.sqrt((1 - Math.pow(h, 2)) / (1 + Math.pow(g, 2)));
    lat = Math.asin(con);

    if (y < 0) {
      lat = -lat;
    }

    if ((g === 0) && (h === 0)) {
      lon = 0;
    }
    else {
      lon = adjust_lon(Math.atan2(g, h) + this.long0);
    }
  }
  else { // ellipsoidal form
    con = this.ml0 + y / this.k0;
    phi = pj_inv_mlfn(con, this.es, this.en);

    if (Math.abs(phi) < HALF_PI) {
      var sin_phi = Math.sin(phi);
      var cos_phi = Math.cos(phi);
      var tan_phi = Math.abs(cos_phi) > EPSLN ? Math.tan(phi) : 0;
      var c = this.ep2 * Math.pow(cos_phi, 2);
      var cs = Math.pow(c, 2);
      var t = Math.pow(tan_phi, 2);
      var ts = Math.pow(t, 2);
      con = 1 - this.es * Math.pow(sin_phi, 2);
      var d = x * Math.sqrt(con) / this.k0;
      var ds = Math.pow(d, 2);
      con = con * tan_phi;

      lat = phi - (con * ds / (1 - this.es)) * 0.5 * (1 -
        ds / 12 * (5 + 3 * t - 9 * c * t + c - 4 * cs -
        ds / 30 * (61 + 90 * t - 252 * c * t + 45 * ts + 46 * c -
        ds / 56 * (1385 + 3633 * t + 4095 * ts + 1574 * ts * t))));

      lon = adjust_lon(this.long0 + (d * (1 -
        ds / 6 * (1 + 2 * t + c -
        ds / 20 * (5 + 28 * t + 24 * ts + 8 * c * t + 6 * c -
        ds / 42 * (61 + 662 * t + 1320 * ts + 720 * ts * t)))) / cos_phi));
    }
    else {
      lat = HALF_PI * sign(y);
      lon = 0;
    }
  }

  p.x = lon;
  p.y = lat;

  return p;
}

var tmerc_names = ["Fast_Transverse_Mercator", "Fast Transverse Mercator"];
/* harmony default export */ const tmerc = ({
  init: tmerc_init,
  forward: tmerc_forward,
  inverse: tmerc_inverse,
  names: tmerc_names
});

;// CONCATENATED MODULE: ./node_modules/proj4/lib/common/sinh.js
/* harmony default export */ function sinh(x) {
  var r = Math.exp(x);
  r = (r - 1 / r) / 2;
  return r;
}
;// CONCATENATED MODULE: ./node_modules/proj4/lib/common/hypot.js
/* harmony default export */ function hypot(x, y) {
  x = Math.abs(x);
  y = Math.abs(y);
  var a = Math.max(x, y);
  var b = Math.min(x, y) / (a ? a : 1);

  return a * Math.sqrt(1 + Math.pow(b, 2));
}

;// CONCATENATED MODULE: ./node_modules/proj4/lib/common/log1py.js
/* harmony default export */ function log1py(x) {
  var y = 1 + x;
  var z = y - 1;

  return z === 0 ? x : x * Math.log(y) / z;
}

;// CONCATENATED MODULE: ./node_modules/proj4/lib/common/asinhy.js



/* harmony default export */ function asinhy(x) {
  var y = Math.abs(x);
  y = log1py(y * (1 + y / (hypot(1, y) + 1)));

  return x < 0 ? -y : y;
}

;// CONCATENATED MODULE: ./node_modules/proj4/lib/common/gatg.js
/* harmony default export */ function gatg(pp, B) {
  var cos_2B = 2 * Math.cos(2 * B);
  var i = pp.length - 1;
  var h1 = pp[i];
  var h2 = 0;
  var h;

  while (--i >= 0) {
    h = -h2 + cos_2B * h1 + pp[i];
    h2 = h1;
    h1 = h;
  }

  return (B + h * Math.sin(2 * B));
}

;// CONCATENATED MODULE: ./node_modules/proj4/lib/common/clens.js
/* harmony default export */ function clens(pp, arg_r) {
  var r = 2 * Math.cos(arg_r);
  var i = pp.length - 1;
  var hr1 = pp[i];
  var hr2 = 0;
  var hr;

  while (--i >= 0) {
    hr = -hr2 + r * hr1 + pp[i];
    hr2 = hr1;
    hr1 = hr;
  }

  return Math.sin(arg_r) * hr;
}

;// CONCATENATED MODULE: ./node_modules/proj4/lib/common/cosh.js
/* harmony default export */ function cosh(x) {
  var r = Math.exp(x);
  r = (r + 1 / r) / 2;
  return r;
}
;// CONCATENATED MODULE: ./node_modules/proj4/lib/common/clens_cmplx.js



/* harmony default export */ function clens_cmplx(pp, arg_r, arg_i) {
  var sin_arg_r = Math.sin(arg_r);
  var cos_arg_r = Math.cos(arg_r);
  var sinh_arg_i = sinh(arg_i);
  var cosh_arg_i = cosh(arg_i);
  var r = 2 * cos_arg_r * cosh_arg_i;
  var i = -2 * sin_arg_r * sinh_arg_i;
  var j = pp.length - 1;
  var hr = pp[j];
  var hi1 = 0;
  var hr1 = 0;
  var hi = 0;
  var hr2;
  var hi2;

  while (--j >= 0) {
    hr2 = hr1;
    hi2 = hi1;
    hr1 = hr;
    hi1 = hi;
    hr = -hr2 + r * hr1 - i * hi1 + pp[j];
    hi = -hi2 + i * hr1 + r * hi1;
  }

  r = sin_arg_r * cosh_arg_i;
  i = cos_arg_r * sinh_arg_i;

  return [r * hr - i * hi, r * hi + i * hr];
}

;// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/etmerc.js
// Heavily based on this etmerc projection implementation
// https://github.com/mbloch/mapshaper-proj/blob/master/src/projections/etmerc.js










function etmerc_init() {
  if (!this.approx && (isNaN(this.es) || this.es <= 0)) {
    throw new Error('Incorrect elliptical usage. Try using the +approx option in the proj string, or PROJECTION["Fast_Transverse_Mercator"] in the WKT.');
  }
  if (this.approx) {
    // When '+approx' is set, use tmerc instead
    tmerc.init.apply(this);
    this.forward = tmerc.forward;
    this.inverse = tmerc.inverse;
  }

  this.x0 = this.x0 !== undefined ? this.x0 : 0;
  this.y0 = this.y0 !== undefined ? this.y0 : 0;
  this.long0 = this.long0 !== undefined ? this.long0 : 0;
  this.lat0 = this.lat0 !== undefined ? this.lat0 : 0;

  this.cgb = [];
  this.cbg = [];
  this.utg = [];
  this.gtu = [];

  var f = this.es / (1 + Math.sqrt(1 - this.es));
  var n = f / (2 - f);
  var np = n;

  this.cgb[0] = n * (2 + n * (-2 / 3 + n * (-2 + n * (116 / 45 + n * (26 / 45 + n * (-2854 / 675 ))))));
  this.cbg[0] = n * (-2 + n * ( 2 / 3 + n * ( 4 / 3 + n * (-82 / 45 + n * (32 / 45 + n * (4642 / 4725))))));

  np = np * n;
  this.cgb[1] = np * (7 / 3 + n * (-8 / 5 + n * (-227 / 45 + n * (2704 / 315 + n * (2323 / 945)))));
  this.cbg[1] = np * (5 / 3 + n * (-16 / 15 + n * ( -13 / 9 + n * (904 / 315 + n * (-1522 / 945)))));

  np = np * n;
  this.cgb[2] = np * (56 / 15 + n * (-136 / 35 + n * (-1262 / 105 + n * (73814 / 2835))));
  this.cbg[2] = np * (-26 / 15 + n * (34 / 21 + n * (8 / 5 + n * (-12686 / 2835))));

  np = np * n;
  this.cgb[3] = np * (4279 / 630 + n * (-332 / 35 + n * (-399572 / 14175)));
  this.cbg[3] = np * (1237 / 630 + n * (-12 / 5 + n * ( -24832 / 14175)));

  np = np * n;
  this.cgb[4] = np * (4174 / 315 + n * (-144838 / 6237));
  this.cbg[4] = np * (-734 / 315 + n * (109598 / 31185));

  np = np * n;
  this.cgb[5] = np * (601676 / 22275);
  this.cbg[5] = np * (444337 / 155925);

  np = Math.pow(n, 2);
  this.Qn = this.k0 / (1 + n) * (1 + np * (1 / 4 + np * (1 / 64 + np / 256)));

  this.utg[0] = n * (-0.5 + n * ( 2 / 3 + n * (-37 / 96 + n * ( 1 / 360 + n * (81 / 512 + n * (-96199 / 604800))))));
  this.gtu[0] = n * (0.5 + n * (-2 / 3 + n * (5 / 16 + n * (41 / 180 + n * (-127 / 288 + n * (7891 / 37800))))));

  this.utg[1] = np * (-1 / 48 + n * (-1 / 15 + n * (437 / 1440 + n * (-46 / 105 + n * (1118711 / 3870720)))));
  this.gtu[1] = np * (13 / 48 + n * (-3 / 5 + n * (557 / 1440 + n * (281 / 630 + n * (-1983433 / 1935360)))));

  np = np * n;
  this.utg[2] = np * (-17 / 480 + n * (37 / 840 + n * (209 / 4480 + n * (-5569 / 90720 ))));
  this.gtu[2] = np * (61 / 240 + n * (-103 / 140 + n * (15061 / 26880 + n * (167603 / 181440))));

  np = np * n;
  this.utg[3] = np * (-4397 / 161280 + n * (11 / 504 + n * (830251 / 7257600)));
  this.gtu[3] = np * (49561 / 161280 + n * (-179 / 168 + n * (6601661 / 7257600)));

  np = np * n;
  this.utg[4] = np * (-4583 / 161280 + n * (108847 / 3991680));
  this.gtu[4] = np * (34729 / 80640 + n * (-3418889 / 1995840));

  np = np * n;
  this.utg[5] = np * (-20648693 / 638668800);
  this.gtu[5] = np * (212378941 / 319334400);

  var Z = gatg(this.cbg, this.lat0);
  this.Zb = -this.Qn * (Z + clens(this.gtu, 2 * Z));
}

function etmerc_forward(p) {
  var Ce = adjust_lon(p.x - this.long0);
  var Cn = p.y;

  Cn = gatg(this.cbg, Cn);
  var sin_Cn = Math.sin(Cn);
  var cos_Cn = Math.cos(Cn);
  var sin_Ce = Math.sin(Ce);
  var cos_Ce = Math.cos(Ce);

  Cn = Math.atan2(sin_Cn, cos_Ce * cos_Cn);
  Ce = Math.atan2(sin_Ce * cos_Cn, hypot(sin_Cn, cos_Cn * cos_Ce));
  Ce = asinhy(Math.tan(Ce));

  var tmp = clens_cmplx(this.gtu, 2 * Cn, 2 * Ce);

  Cn = Cn + tmp[0];
  Ce = Ce + tmp[1];

  var x;
  var y;

  if (Math.abs(Ce) <= 2.623395162778) {
    x = this.a * (this.Qn * Ce) + this.x0;
    y = this.a * (this.Qn * Cn + this.Zb) + this.y0;
  }
  else {
    x = Infinity;
    y = Infinity;
  }

  p.x = x;
  p.y = y;

  return p;
}

function etmerc_inverse(p) {
  var Ce = (p.x - this.x0) * (1 / this.a);
  var Cn = (p.y - this.y0) * (1 / this.a);

  Cn = (Cn - this.Zb) / this.Qn;
  Ce = Ce / this.Qn;

  var lon;
  var lat;

  if (Math.abs(Ce) <= 2.623395162778) {
    var tmp = clens_cmplx(this.utg, 2 * Cn, 2 * Ce);

    Cn = Cn + tmp[0];
    Ce = Ce + tmp[1];
    Ce = Math.atan(sinh(Ce));

    var sin_Cn = Math.sin(Cn);
    var cos_Cn = Math.cos(Cn);
    var sin_Ce = Math.sin(Ce);
    var cos_Ce = Math.cos(Ce);

    Cn = Math.atan2(sin_Cn * cos_Ce, hypot(sin_Ce, cos_Ce * cos_Cn));
    Ce = Math.atan2(sin_Ce, cos_Ce * cos_Cn);

    lon = adjust_lon(Ce + this.long0);
    lat = gatg(this.cgb, Cn);
  }
  else {
    lon = Infinity;
    lat = Infinity;
  }

  p.x = lon;
  p.y = lat;

  return p;
}

var etmerc_names = ["Extended_Transverse_Mercator", "Extended Transverse Mercator", "etmerc", "Transverse_Mercator", "Transverse Mercator", "tmerc"];
/* harmony default export */ const etmerc = ({
  init: etmerc_init,
  forward: etmerc_forward,
  inverse: etmerc_inverse,
  names: etmerc_names
});

;// CONCATENATED MODULE: ./node_modules/proj4/lib/common/adjust_zone.js


/* harmony default export */ function adjust_zone(zone, lon) {
  if (zone === undefined) {
    zone = Math.floor((adjust_lon(lon) + Math.PI) * 30 / Math.PI) + 1;

    if (zone < 0) {
      return 0;
    } else if (zone > 60) {
      return 60;
    }
  }
  return zone;
}

;// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/utm.js


var dependsOn = 'etmerc';



function utm_init() {
  var zone = adjust_zone(this.zone, this.long0);
  if (zone === undefined) {
    throw new Error('unknown utm zone');
  }
  this.lat0 = 0;
  this.long0 =  ((6 * Math.abs(zone)) - 183) * D2R;
  this.x0 = 500000;
  this.y0 = this.utmSouth ? 10000000 : 0;
  this.k0 = 0.9996;

  etmerc.init.apply(this);
  this.forward = etmerc.forward;
  this.inverse = etmerc.inverse;
}

var utm_names = ["Universal Transverse Mercator System", "utm"];
/* harmony default export */ const utm = ({
  init: utm_init,
  names: utm_names,
  dependsOn: dependsOn
});

;// CONCATENATED MODULE: ./node_modules/proj4/lib/common/srat.js
/* harmony default export */ function srat(esinp, exp) {
  return (Math.pow((1 - esinp) / (1 + esinp), exp));
}
;// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/gauss.js

var gauss_MAX_ITER = 20;


function gauss_init() {
  var sphi = Math.sin(this.lat0);
  var cphi = Math.cos(this.lat0);
  cphi *= cphi;
  this.rc = Math.sqrt(1 - this.es) / (1 - this.es * sphi * sphi);
  this.C = Math.sqrt(1 + this.es * cphi * cphi / (1 - this.es));
  this.phic0 = Math.asin(sphi / this.C);
  this.ratexp = 0.5 * this.C * this.e;
  this.K = Math.tan(0.5 * this.phic0 + FORTPI) / (Math.pow(Math.tan(0.5 * this.lat0 + FORTPI), this.C) * srat(this.e * sphi, this.ratexp));
}

function gauss_forward(p) {
  var lon = p.x;
  var lat = p.y;

  p.y = 2 * Math.atan(this.K * Math.pow(Math.tan(0.5 * lat + FORTPI), this.C) * srat(this.e * Math.sin(lat), this.ratexp)) - HALF_PI;
  p.x = this.C * lon;
  return p;
}

function gauss_inverse(p) {
  var DEL_TOL = 1e-14;
  var lon = p.x / this.C;
  var lat = p.y;
  var num = Math.pow(Math.tan(0.5 * lat + FORTPI) / this.K, 1 / this.C);
  for (var i = gauss_MAX_ITER; i > 0; --i) {
    lat = 2 * Math.atan(num * srat(this.e * Math.sin(p.y), - 0.5 * this.e)) - HALF_PI;
    if (Math.abs(lat - p.y) < DEL_TOL) {
      break;
    }
    p.y = lat;
  }
  /* convergence failed */
  if (!i) {
    return null;
  }
  p.x = lon;
  p.y = lat;
  return p;
}

var gauss_names = ["gauss"];
/* harmony default export */ const gauss = ({
  init: gauss_init,
  forward: gauss_forward,
  inverse: gauss_inverse,
  names: gauss_names
});

;// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/sterea.js



function sterea_init() {
  gauss.init.apply(this);
  if (!this.rc) {
    return;
  }
  this.sinc0 = Math.sin(this.phic0);
  this.cosc0 = Math.cos(this.phic0);
  this.R2 = 2 * this.rc;
  if (!this.title) {
    this.title = "Oblique Stereographic Alternative";
  }
}

function sterea_forward(p) {
  var sinc, cosc, cosl, k;
  p.x = adjust_lon(p.x - this.long0);
  gauss.forward.apply(this, [p]);
  sinc = Math.sin(p.y);
  cosc = Math.cos(p.y);
  cosl = Math.cos(p.x);
  k = this.k0 * this.R2 / (1 + this.sinc0 * sinc + this.cosc0 * cosc * cosl);
  p.x = k * cosc * Math.sin(p.x);
  p.y = k * (this.cosc0 * sinc - this.sinc0 * cosc * cosl);
  p.x = this.a * p.x + this.x0;
  p.y = this.a * p.y + this.y0;
  return p;
}

function sterea_inverse(p) {
  var sinc, cosc, lon, lat, rho;
  p.x = (p.x - this.x0) / this.a;
  p.y = (p.y - this.y0) / this.a;

  p.x /= this.k0;
  p.y /= this.k0;
  if ((rho = Math.sqrt(p.x * p.x + p.y * p.y))) {
    var c = 2 * Math.atan2(rho, this.R2);
    sinc = Math.sin(c);
    cosc = Math.cos(c);
    lat = Math.asin(cosc * this.sinc0 + p.y * sinc * this.cosc0 / rho);
    lon = Math.atan2(p.x * sinc, rho * this.cosc0 * cosc - p.y * this.sinc0 * sinc);
  }
  else {
    lat = this.phic0;
    lon = 0;
  }

  p.x = lon;
  p.y = lat;
  gauss.inverse.apply(this, [p]);
  p.x = adjust_lon(p.x + this.long0);
  return p;
}

var sterea_names = ["Stereographic_North_Pole", "Oblique_Stereographic", "Polar_Stereographic", "sterea","Oblique Stereographic Alternative","Double_Stereographic"];
/* harmony default export */ const sterea = ({
  init: sterea_init,
  forward: sterea_forward,
  inverse: sterea_inverse,
  names: sterea_names
});

;// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/stere.js








function ssfn_(phit, sinphi, eccen) {
  sinphi *= eccen;
  return (Math.tan(0.5 * (HALF_PI + phit)) * Math.pow((1 - sinphi) / (1 + sinphi), 0.5 * eccen));
}

function stere_init() {
  this.coslat0 = Math.cos(this.lat0);
  this.sinlat0 = Math.sin(this.lat0);
  if (this.sphere) {
    if (this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= EPSLN) {
      this.k0 = 0.5 * (1 + sign(this.lat0) * Math.sin(this.lat_ts));
    }
  }
  else {
    if (Math.abs(this.coslat0) <= EPSLN) {
      if (this.lat0 > 0) {
        //North pole
        //trace('stere:north pole');
        this.con = 1;
      }
      else {
        //South pole
        //trace('stere:south pole');
        this.con = -1;
      }
    }
    this.cons = Math.sqrt(Math.pow(1 + this.e, 1 + this.e) * Math.pow(1 - this.e, 1 - this.e));
    if (this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= EPSLN) {
      this.k0 = 0.5 * this.cons * msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) / tsfnz(this.e, this.con * this.lat_ts, this.con * Math.sin(this.lat_ts));
    }
    this.ms1 = msfnz(this.e, this.sinlat0, this.coslat0);
    this.X0 = 2 * Math.atan(this.ssfn_(this.lat0, this.sinlat0, this.e)) - HALF_PI;
    this.cosX0 = Math.cos(this.X0);
    this.sinX0 = Math.sin(this.X0);
  }
}

// Stereographic forward equations--mapping lat,long to x,y
function stere_forward(p) {
  var lon = p.x;
  var lat = p.y;
  var sinlat = Math.sin(lat);
  var coslat = Math.cos(lat);
  var A, X, sinX, cosX, ts, rh;
  var dlon = adjust_lon(lon - this.long0);

  if (Math.abs(Math.abs(lon - this.long0) - Math.PI) <= EPSLN && Math.abs(lat + this.lat0) <= EPSLN) {
    //case of the origine point
    //trace('stere:this is the origin point');
    p.x = NaN;
    p.y = NaN;
    return p;
  }
  if (this.sphere) {
    //trace('stere:sphere case');
    A = 2 * this.k0 / (1 + this.sinlat0 * sinlat + this.coslat0 * coslat * Math.cos(dlon));
    p.x = this.a * A * coslat * Math.sin(dlon) + this.x0;
    p.y = this.a * A * (this.coslat0 * sinlat - this.sinlat0 * coslat * Math.cos(dlon)) + this.y0;
    return p;
  }
  else {
    X = 2 * Math.atan(this.ssfn_(lat, sinlat, this.e)) - HALF_PI;
    cosX = Math.cos(X);
    sinX = Math.sin(X);
    if (Math.abs(this.coslat0) <= EPSLN) {
      ts = tsfnz(this.e, lat * this.con, this.con * sinlat);
      rh = 2 * this.a * this.k0 * ts / this.cons;
      p.x = this.x0 + rh * Math.sin(lon - this.long0);
      p.y = this.y0 - this.con * rh * Math.cos(lon - this.long0);
      //trace(p.toString());
      return p;
    }
    else if (Math.abs(this.sinlat0) < EPSLN) {
      //Eq
      //trace('stere:equateur');
      A = 2 * this.a * this.k0 / (1 + cosX * Math.cos(dlon));
      p.y = A * sinX;
    }
    else {
      //other case
      //trace('stere:normal case');
      A = 2 * this.a * this.k0 * this.ms1 / (this.cosX0 * (1 + this.sinX0 * sinX + this.cosX0 * cosX * Math.cos(dlon)));
      p.y = A * (this.cosX0 * sinX - this.sinX0 * cosX * Math.cos(dlon)) + this.y0;
    }
    p.x = A * cosX * Math.sin(dlon) + this.x0;
  }
  //trace(p.toString());
  return p;
}

//* Stereographic inverse equations--mapping x,y to lat/long
function stere_inverse(p) {
  p.x -= this.x0;
  p.y -= this.y0;
  var lon, lat, ts, ce, Chi;
  var rh = Math.sqrt(p.x * p.x + p.y * p.y);
  if (this.sphere) {
    var c = 2 * Math.atan(rh / (2 * this.a * this.k0));
    lon = this.long0;
    lat = this.lat0;
    if (rh <= EPSLN) {
      p.x = lon;
      p.y = lat;
      return p;
    }
    lat = Math.asin(Math.cos(c) * this.sinlat0 + p.y * Math.sin(c) * this.coslat0 / rh);
    if (Math.abs(this.coslat0) < EPSLN) {
      if (this.lat0 > 0) {
        lon = adjust_lon(this.long0 + Math.atan2(p.x, - 1 * p.y));
      }
      else {
        lon = adjust_lon(this.long0 + Math.atan2(p.x, p.y));
      }
    }
    else {
      lon = adjust_lon(this.long0 + Math.atan2(p.x * Math.sin(c), rh * this.coslat0 * Math.cos(c) - p.y * this.sinlat0 * Math.sin(c)));
    }
    p.x = lon;
    p.y = lat;
    return p;
  }
  else {
    if (Math.abs(this.coslat0) <= EPSLN) {
      if (rh <= EPSLN) {
        lat = this.lat0;
        lon = this.long0;
        p.x = lon;
        p.y = lat;
        //trace(p.toString());
        return p;
      }
      p.x *= this.con;
      p.y *= this.con;
      ts = rh * this.cons / (2 * this.a * this.k0);
      lat = this.con * phi2z(this.e, ts);
      lon = this.con * adjust_lon(this.con * this.long0 + Math.atan2(p.x, - 1 * p.y));
    }
    else {
      ce = 2 * Math.atan(rh * this.cosX0 / (2 * this.a * this.k0 * this.ms1));
      lon = this.long0;
      if (rh <= EPSLN) {
        Chi = this.X0;
      }
      else {
        Chi = Math.asin(Math.cos(ce) * this.sinX0 + p.y * Math.sin(ce) * this.cosX0 / rh);
        lon = adjust_lon(this.long0 + Math.atan2(p.x * Math.sin(ce), rh * this.cosX0 * Math.cos(ce) - p.y * this.sinX0 * Math.sin(ce)));
      }
      lat = -1 * phi2z(this.e, Math.tan(0.5 * (HALF_PI + Chi)));
    }
  }
  p.x = lon;
  p.y = lat;

  //trace(p.toString());
  return p;

}

var stere_names = ["stere", "Stereographic_South_Pole", "Polar Stereographic (variant B)"];
/* harmony default export */ const stere = ({
  init: stere_init,
  forward: stere_forward,
  inverse: stere_inverse,
  names: stere_names,
  ssfn_: ssfn_
});

;// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/somerc.js
/*
  references:
    Formules et constantes pour le Calcul pour la
    projection cylindrique conforme à axe oblique et pour la transformation entre
    des systèmes de référence.
    http://www.swisstopo.admin.ch/internet/swisstopo/fr/home/topics/survey/sys/refsys/switzerland.parsysrelated1.31216.downloadList.77004.DownloadFile.tmp/swissprojectionfr.pdf
  */

function somerc_init() {
  var phy0 = this.lat0;
  this.lambda0 = this.long0;
  var sinPhy0 = Math.sin(phy0);
  var semiMajorAxis = this.a;
  var invF = this.rf;
  var flattening = 1 / invF;
  var e2 = 2 * flattening - Math.pow(flattening, 2);
  var e = this.e = Math.sqrt(e2);
  this.R = this.k0 * semiMajorAxis * Math.sqrt(1 - e2) / (1 - e2 * Math.pow(sinPhy0, 2));
  this.alpha = Math.sqrt(1 + e2 / (1 - e2) * Math.pow(Math.cos(phy0), 4));
  this.b0 = Math.asin(sinPhy0 / this.alpha);
  var k1 = Math.log(Math.tan(Math.PI / 4 + this.b0 / 2));
  var k2 = Math.log(Math.tan(Math.PI / 4 + phy0 / 2));
  var k3 = Math.log((1 + e * sinPhy0) / (1 - e * sinPhy0));
  this.K = k1 - this.alpha * k2 + this.alpha * e / 2 * k3;
}

function somerc_forward(p) {
  var Sa1 = Math.log(Math.tan(Math.PI / 4 - p.y / 2));
  var Sa2 = this.e / 2 * Math.log((1 + this.e * Math.sin(p.y)) / (1 - this.e * Math.sin(p.y)));
  var S = -this.alpha * (Sa1 + Sa2) + this.K;

  // spheric latitude
  var b = 2 * (Math.atan(Math.exp(S)) - Math.PI / 4);

  // spheric longitude
  var I = this.alpha * (p.x - this.lambda0);

  // psoeudo equatorial rotation
  var rotI = Math.atan(Math.sin(I) / (Math.sin(this.b0) * Math.tan(b) + Math.cos(this.b0) * Math.cos(I)));

  var rotB = Math.asin(Math.cos(this.b0) * Math.sin(b) - Math.sin(this.b0) * Math.cos(b) * Math.cos(I));

  p.y = this.R / 2 * Math.log((1 + Math.sin(rotB)) / (1 - Math.sin(rotB))) + this.y0;
  p.x = this.R * rotI + this.x0;
  return p;
}

function somerc_inverse(p) {
  var Y = p.x - this.x0;
  var X = p.y - this.y0;

  var rotI = Y / this.R;
  var rotB = 2 * (Math.atan(Math.exp(X / this.R)) - Math.PI / 4);

  var b = Math.asin(Math.cos(this.b0) * Math.sin(rotB) + Math.sin(this.b0) * Math.cos(rotB) * Math.cos(rotI));
  var I = Math.atan(Math.sin(rotI) / (Math.cos(this.b0) * Math.cos(rotI) - Math.sin(this.b0) * Math.tan(rotB)));

  var lambda = this.lambda0 + I / this.alpha;

  var S = 0;
  var phy = b;
  var prevPhy = -1000;
  var iteration = 0;
  while (Math.abs(phy - prevPhy) > 0.0000001) {
    if (++iteration > 20) {
      //...reportError("omercFwdInfinity");
      return;
    }
    //S = Math.log(Math.tan(Math.PI / 4 + phy / 2));
    S = 1 / this.alpha * (Math.log(Math.tan(Math.PI / 4 + b / 2)) - this.K) + this.e * Math.log(Math.tan(Math.PI / 4 + Math.asin(this.e * Math.sin(phy)) / 2));
    prevPhy = phy;
    phy = 2 * Math.atan(Math.exp(S)) - Math.PI / 2;
  }

  p.x = lambda;
  p.y = phy;
  return p;
}

var somerc_names = ["somerc"];
/* harmony default export */ const somerc = ({
  init: somerc_init,
  forward: somerc_forward,
  inverse: somerc_inverse,
  names: somerc_names
});

;// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/omerc.js





var TOL = 1e-7;

function isTypeA(P) {
  var typeAProjections = ['Hotine_Oblique_Mercator','Hotine_Oblique_Mercator_Azimuth_Natural_Origin'];
  var projectionName = typeof P.PROJECTION === "object" ? Object.keys(P.PROJECTION)[0] : P.PROJECTION;
  
  return 'no_uoff' in P || 'no_off' in P || typeAProjections.indexOf(projectionName) !== -1;
}


/* Initialize the Oblique Mercator  projection
    ------------------------------------------*/
function omerc_init() {  
  var con, com, cosph0, D, F, H, L, sinph0, p, J, gamma = 0,
    gamma0, lamc = 0, lam1 = 0, lam2 = 0, phi1 = 0, phi2 = 0, alpha_c = 0, AB;
  
  // only Type A uses the no_off or no_uoff property
  // https://github.com/OSGeo/proj.4/issues/104
  this.no_off = isTypeA(this);
  this.no_rot = 'no_rot' in this;
  
  var alp = false;
  if ("alpha" in this) {
    alp = true;
  }

  var gam = false;
  if ("rectified_grid_angle" in this) {
    gam = true;
  }

  if (alp) {
    alpha_c = this.alpha;
  }
  
  if (gam) {
    gamma = (this.rectified_grid_angle * D2R);
  }
  
  if (alp || gam) {
    lamc = this.longc;
  } else {
    lam1 = this.long1;
    phi1 = this.lat1;
    lam2 = this.long2;
    phi2 = this.lat2;
    
    if (Math.abs(phi1 - phi2) <= TOL || (con = Math.abs(phi1)) <= TOL ||
        Math.abs(con - HALF_PI) <= TOL || Math.abs(Math.abs(this.lat0) - HALF_PI) <= TOL ||
        Math.abs(Math.abs(phi2) - HALF_PI) <= TOL) {
      throw new Error();
    }
  }
  
  var one_es = 1.0 - this.es;
  com = Math.sqrt(one_es);
  
  if (Math.abs(this.lat0) > EPSLN) {
    sinph0 = Math.sin(this.lat0);
    cosph0 = Math.cos(this.lat0);
    con = 1 - this.es * sinph0 * sinph0;
    this.B = cosph0 * cosph0;
    this.B = Math.sqrt(1 + this.es * this.B * this.B / one_es);
    this.A = this.B * this.k0 * com / con;
    D = this.B * com / (cosph0 * Math.sqrt(con));
    F = D * D -1;
    
    if (F <= 0) {
      F = 0;
    } else {
      F = Math.sqrt(F);
      if (this.lat0 < 0) {
        F = -F;
      }
    }
    
    this.E = F += D;
    this.E *= Math.pow(tsfnz(this.e, this.lat0, sinph0), this.B);
  } else {
    this.B = 1 / com;
    this.A = this.k0;
    this.E = D = F = 1;
  }
  
  if (alp || gam) {
    if (alp) {
      gamma0 = Math.asin(Math.sin(alpha_c) / D);
      if (!gam) {
        gamma = alpha_c;
      }
    } else {
      gamma0 = gamma;
      alpha_c = Math.asin(D * Math.sin(gamma0));
    }
    this.lam0 = lamc - Math.asin(0.5 * (F - 1 / F) * Math.tan(gamma0)) / this.B;
  } else {
    H = Math.pow(tsfnz(this.e, phi1, Math.sin(phi1)), this.B);
    L = Math.pow(tsfnz(this.e, phi2, Math.sin(phi2)), this.B);
    F = this.E / H;
    p = (L - H) / (L + H);
    J = this.E * this.E;
    J = (J - L * H) / (J + L * H);
    con = lam1 - lam2;
    
    if (con < -Math.pi) {
      lam2 -=TWO_PI;
    } else if (con > Math.pi) {
      lam2 += TWO_PI;
    }
    
    this.lam0 = adjust_lon(0.5 * (lam1 + lam2) - Math.atan(J * Math.tan(0.5 * this.B * (lam1 - lam2)) / p) / this.B);
    gamma0 = Math.atan(2 * Math.sin(this.B * adjust_lon(lam1 - this.lam0)) / (F - 1 / F));
    gamma = alpha_c = Math.asin(D * Math.sin(gamma0));
  }
  
  this.singam = Math.sin(gamma0);
  this.cosgam = Math.cos(gamma0);
  this.sinrot = Math.sin(gamma);
  this.cosrot = Math.cos(gamma);
  
  this.rB = 1 / this.B;
  this.ArB = this.A * this.rB;
  this.BrA = 1 / this.ArB;
  AB = this.A * this.B;
  
  if (this.no_off) {
    this.u_0 = 0;
  } else {
    this.u_0 = Math.abs(this.ArB * Math.atan(Math.sqrt(D * D - 1) / Math.cos(alpha_c)));
    
    if (this.lat0 < 0) {
      this.u_0 = - this.u_0;
    }  
  }
    
  F = 0.5 * gamma0;
  this.v_pole_n = this.ArB * Math.log(Math.tan(FORTPI - F));
  this.v_pole_s = this.ArB * Math.log(Math.tan(FORTPI + F));
}


/* Oblique Mercator forward equations--mapping lat,long to x,y
    ----------------------------------------------------------*/
function omerc_forward(p) {
  var coords = {};
  var S, T, U, V, W, temp, u, v;
  p.x = p.x - this.lam0;
  
  if (Math.abs(Math.abs(p.y) - HALF_PI) > EPSLN) {
    W = this.E / Math.pow(tsfnz(this.e, p.y, Math.sin(p.y)), this.B);
    
    temp = 1 / W;
    S = 0.5 * (W - temp);
    T = 0.5 * (W + temp);
    V = Math.sin(this.B * p.x);
    U = (S * this.singam - V * this.cosgam) / T;
        
    if (Math.abs(Math.abs(U) - 1.0) < EPSLN) {
      throw new Error();
    }
    
    v = 0.5 * this.ArB * Math.log((1 - U)/(1 + U));
    temp = Math.cos(this.B * p.x);
    
    if (Math.abs(temp) < TOL) {
      u = this.A * p.x;
    } else {
      u = this.ArB * Math.atan2((S * this.cosgam + V * this.singam), temp);
    }    
  } else {
    v = p.y > 0 ? this.v_pole_n : this.v_pole_s;
    u = this.ArB * p.y;
  }
     
  if (this.no_rot) {
    coords.x = u;
    coords.y = v;
  } else {
    u -= this.u_0;
    coords.x = v * this.cosrot + u * this.sinrot;
    coords.y = u * this.cosrot - v * this.sinrot;
  }
  
  coords.x = (this.a * coords.x + this.x0);
  coords.y = (this.a * coords.y + this.y0);
  
  return coords;
}

function omerc_inverse(p) {
  var u, v, Qp, Sp, Tp, Vp, Up;
  var coords = {};
  
  p.x = (p.x - this.x0) * (1.0 / this.a);
  p.y = (p.y - this.y0) * (1.0 / this.a);

  if (this.no_rot) {
    v = p.y;
    u = p.x;
  } else {
    v = p.x * this.cosrot - p.y * this.sinrot;
    u = p.y * this.cosrot + p.x * this.sinrot + this.u_0;
  }
  
  Qp = Math.exp(-this.BrA * v);
  Sp = 0.5 * (Qp - 1 / Qp);
  Tp = 0.5 * (Qp + 1 / Qp);
  Vp = Math.sin(this.BrA * u);
  Up = (Vp * this.cosgam + Sp * this.singam) / Tp;
  
  if (Math.abs(Math.abs(Up) - 1) < EPSLN) {
    coords.x = 0;
    coords.y = Up < 0 ? -HALF_PI : HALF_PI;
  } else {
    coords.y = this.E / Math.sqrt((1 + Up) / (1 - Up));
    coords.y = phi2z(this.e, Math.pow(coords.y, 1 / this.B));
    
    if (coords.y === Infinity) {
      throw new Error();
    }
        
    coords.x = -this.rB * Math.atan2((Sp * this.cosgam - Vp * this.singam), Math.cos(this.BrA * u));
  }
  
  coords.x += this.lam0;
  
  return coords;
}

var omerc_names = ["Hotine_Oblique_Mercator", "Hotine Oblique Mercator", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin", "Hotine_Oblique_Mercator_Two_Point_Natural_Origin", "Hotine_Oblique_Mercator_Azimuth_Center", "Oblique_Mercator", "omerc"];
/* harmony default export */ const omerc = ({
  init: omerc_init,
  forward: omerc_forward,
  inverse: omerc_inverse,
  names: omerc_names
});

;// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/lcc.js






function lcc_init() {
  
  //double lat0;                    /* the reference latitude               */
  //double long0;                   /* the reference longitude              */
  //double lat1;                    /* first standard parallel              */
  //double lat2;                    /* second standard parallel             */
  //double r_maj;                   /* major axis                           */
  //double r_min;                   /* minor axis                           */
  //double false_east;              /* x offset in meters                   */
  //double false_north;             /* y offset in meters                   */
  
  //the above value can be set with proj4.defs
  //example: proj4.defs("EPSG:2154","+proj=lcc +lat_1=49 +lat_2=44 +lat_0=46.5 +lon_0=3 +x_0=700000 +y_0=6600000 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs");

  if (!this.lat2) {
    this.lat2 = this.lat1;
  } //if lat2 is not defined
  if (!this.k0) {
    this.k0 = 1;
  }
  this.x0 = this.x0 || 0;
  this.y0 = this.y0 || 0;
  // Standard Parallels cannot be equal and on opposite sides of the equator
  if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
    return;
  }

  var temp = this.b / this.a;
  this.e = Math.sqrt(1 - temp * temp);

  var sin1 = Math.sin(this.lat1);
  var cos1 = Math.cos(this.lat1);
  var ms1 = msfnz(this.e, sin1, cos1);
  var ts1 = tsfnz(this.e, this.lat1, sin1);

  var sin2 = Math.sin(this.lat2);
  var cos2 = Math.cos(this.lat2);
  var ms2 = msfnz(this.e, sin2, cos2);
  var ts2 = tsfnz(this.e, this.lat2, sin2);

  var ts0 = tsfnz(this.e, this.lat0, Math.sin(this.lat0));

  if (Math.abs(this.lat1 - this.lat2) > EPSLN) {
    this.ns = Math.log(ms1 / ms2) / Math.log(ts1 / ts2);
  }
  else {
    this.ns = sin1;
  }
  if (isNaN(this.ns)) {
    this.ns = sin1;
  }
  this.f0 = ms1 / (this.ns * Math.pow(ts1, this.ns));
  this.rh = this.a * this.f0 * Math.pow(ts0, this.ns);
  if (!this.title) {
    this.title = "Lambert Conformal Conic";
  }
}

// Lambert Conformal conic forward equations--mapping lat,long to x,y
// -----------------------------------------------------------------
function lcc_forward(p) {

  var lon = p.x;
  var lat = p.y;

  // singular cases :
  if (Math.abs(2 * Math.abs(lat) - Math.PI) <= EPSLN) {
    lat = sign(lat) * (HALF_PI - 2 * EPSLN);
  }

  var con = Math.abs(Math.abs(lat) - HALF_PI);
  var ts, rh1;
  if (con > EPSLN) {
    ts = tsfnz(this.e, lat, Math.sin(lat));
    rh1 = this.a * this.f0 * Math.pow(ts, this.ns);
  }
  else {
    con = lat * this.ns;
    if (con <= 0) {
      return null;
    }
    rh1 = 0;
  }
  var theta = this.ns * adjust_lon(lon - this.long0);
  p.x = this.k0 * (rh1 * Math.sin(theta)) + this.x0;
  p.y = this.k0 * (this.rh - rh1 * Math.cos(theta)) + this.y0;

  return p;
}

// Lambert Conformal Conic inverse equations--mapping x,y to lat/long
// -----------------------------------------------------------------
function lcc_inverse(p) {

  var rh1, con, ts;
  var lat, lon;
  var x = (p.x - this.x0) / this.k0;
  var y = (this.rh - (p.y - this.y0) / this.k0);
  if (this.ns > 0) {
    rh1 = Math.sqrt(x * x + y * y);
    con = 1;
  }
  else {
    rh1 = -Math.sqrt(x * x + y * y);
    con = -1;
  }
  var theta = 0;
  if (rh1 !== 0) {
    theta = Math.atan2((con * x), (con * y));
  }
  if ((rh1 !== 0) || (this.ns > 0)) {
    con = 1 / this.ns;
    ts = Math.pow((rh1 / (this.a * this.f0)), con);
    lat = phi2z(this.e, ts);
    if (lat === -9999) {
      return null;
    }
  }
  else {
    lat = -HALF_PI;
  }
  lon = adjust_lon(theta / this.ns + this.long0);

  p.x = lon;
  p.y = lat;
  return p;
}

var lcc_names = [
  "Lambert Tangential Conformal Conic Projection",
  "Lambert_Conformal_Conic",
  "Lambert_Conformal_Conic_1SP",
  "Lambert_Conformal_Conic_2SP",
  "lcc",
  "Lambert Conic Conformal (1SP)",
  "Lambert Conic Conformal (2SP)"
];

/* harmony default export */ const lcc = ({
  init: lcc_init,
  forward: lcc_forward,
  inverse: lcc_inverse,
  names: lcc_names
});

;// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/krovak.js


function krovak_init() {
  this.a = 6377397.155;
  this.es = 0.006674372230614;
  this.e = Math.sqrt(this.es);
  if (!this.lat0) {
    this.lat0 = 0.863937979737193;
  }
  if (!this.long0) {
    this.long0 = 0.7417649320975901 - 0.308341501185665;
  }
  /* if scale not set default to 0.9999 */
  if (!this.k0) {
    this.k0 = 0.9999;
  }
  this.s45 = 0.785398163397448; /* 45 */
  this.s90 = 2 * this.s45;
  this.fi0 = this.lat0;
  this.e2 = this.es;
  this.e = Math.sqrt(this.e2);
  this.alfa = Math.sqrt(1 + (this.e2 * Math.pow(Math.cos(this.fi0), 4)) / (1 - this.e2));
  this.uq = 1.04216856380474;
  this.u0 = Math.asin(Math.sin(this.fi0) / this.alfa);
  this.g = Math.pow((1 + this.e * Math.sin(this.fi0)) / (1 - this.e * Math.sin(this.fi0)), this.alfa * this.e / 2);
  this.k = Math.tan(this.u0 / 2 + this.s45) / Math.pow(Math.tan(this.fi0 / 2 + this.s45), this.alfa) * this.g;
  this.k1 = this.k0;
  this.n0 = this.a * Math.sqrt(1 - this.e2) / (1 - this.e2 * Math.pow(Math.sin(this.fi0), 2));
  this.s0 = 1.37008346281555;
  this.n = Math.sin(this.s0);
  this.ro0 = this.k1 * this.n0 / Math.tan(this.s0);
  this.ad = this.s90 - this.uq;
}

/* ellipsoid */
/* calculate xy from lat/lon */
/* Constants, identical to inverse transform function */
function krovak_forward(p) {
  var gfi, u, deltav, s, d, eps, ro;
  var lon = p.x;
  var lat = p.y;
  var delta_lon = adjust_lon(lon - this.long0);
  /* Transformation */
  gfi = Math.pow(((1 + this.e * Math.sin(lat)) / (1 - this.e * Math.sin(lat))), (this.alfa * this.e / 2));
  u = 2 * (Math.atan(this.k * Math.pow(Math.tan(lat / 2 + this.s45), this.alfa) / gfi) - this.s45);
  deltav = -delta_lon * this.alfa;
  s = Math.asin(Math.cos(this.ad) * Math.sin(u) + Math.sin(this.ad) * Math.cos(u) * Math.cos(deltav));
  d = Math.asin(Math.cos(u) * Math.sin(deltav) / Math.cos(s));
  eps = this.n * d;
  ro = this.ro0 * Math.pow(Math.tan(this.s0 / 2 + this.s45), this.n) / Math.pow(Math.tan(s / 2 + this.s45), this.n);
  p.y = ro * Math.cos(eps) / 1;
  p.x = ro * Math.sin(eps) / 1;

  if (!this.czech) {
    p.y *= -1;
    p.x *= -1;
  }
  return (p);
}

/* calculate lat/lon from xy */
function krovak_inverse(p) {
  var u, deltav, s, d, eps, ro, fi1;
  var ok;

  /* Transformation */
  /* revert y, x*/
  var tmp = p.x;
  p.x = p.y;
  p.y = tmp;
  if (!this.czech) {
    p.y *= -1;
    p.x *= -1;
  }
  ro = Math.sqrt(p.x * p.x + p.y * p.y);
  eps = Math.atan2(p.y, p.x);
  d = eps / Math.sin(this.s0);
  s = 2 * (Math.atan(Math.pow(this.ro0 / ro, 1 / this.n) * Math.tan(this.s0 / 2 + this.s45)) - this.s45);
  u = Math.asin(Math.cos(this.ad) * Math.sin(s) - Math.sin(this.ad) * Math.cos(s) * Math.cos(d));
  deltav = Math.asin(Math.cos(s) * Math.sin(d) / Math.cos(u));
  p.x = this.long0 - deltav / this.alfa;
  fi1 = u;
  ok = 0;
  var iter = 0;
  do {
    p.y = 2 * (Math.atan(Math.pow(this.k, - 1 / this.alfa) * Math.pow(Math.tan(u / 2 + this.s45), 1 / this.alfa) * Math.pow((1 + this.e * Math.sin(fi1)) / (1 - this.e * Math.sin(fi1)), this.e / 2)) - this.s45);
    if (Math.abs(fi1 - p.y) < 0.0000000001) {
      ok = 1;
    }
    fi1 = p.y;
    iter += 1;
  } while (ok === 0 && iter < 15);
  if (iter >= 15) {
    return null;
  }

  return (p);
}

var krovak_names = ["Krovak", "krovak"];
/* harmony default export */ const krovak = ({
  init: krovak_init,
  forward: krovak_forward,
  inverse: krovak_inverse,
  names: krovak_names
});

;// CONCATENATED MODULE: ./node_modules/proj4/lib/common/mlfn.js
/* harmony default export */ function mlfn(e0, e1, e2, e3, phi) {
  return (e0 * phi - e1 * Math.sin(2 * phi) + e2 * Math.sin(4 * phi) - e3 * Math.sin(6 * phi));
}
;// CONCATENATED MODULE: ./node_modules/proj4/lib/common/e0fn.js
/* harmony default export */ function e0fn(x) {
  return (1 - 0.25 * x * (1 + x / 16 * (3 + 1.25 * x)));
}
;// CONCATENATED MODULE: ./node_modules/proj4/lib/common/e1fn.js
/* harmony default export */ function e1fn(x) {
  return (0.375 * x * (1 + 0.25 * x * (1 + 0.46875 * x)));
}
;// CONCATENATED MODULE: ./node_modules/proj4/lib/common/e2fn.js
/* harmony default export */ function e2fn(x) {
  return (0.05859375 * x * x * (1 + 0.75 * x));
}
;// CONCATENATED MODULE: ./node_modules/proj4/lib/common/e3fn.js
/* harmony default export */ function e3fn(x) {
  return (x * x * x * (35 / 3072));
}
;// CONCATENATED MODULE: ./node_modules/proj4/lib/common/gN.js
/* harmony default export */ function gN(a, e, sinphi) {
  var temp = e * sinphi;
  return a / Math.sqrt(1 - temp * temp);
}
;// CONCATENATED MODULE: ./node_modules/proj4/lib/common/adjust_lat.js



/* harmony default export */ function adjust_lat(x) {
  return (Math.abs(x) < HALF_PI) ? x : (x - (sign(x) * Math.PI));
}

;// CONCATENATED MODULE: ./node_modules/proj4/lib/common/imlfn.js
/* harmony default export */ function imlfn(ml, e0, e1, e2, e3) {
  var phi;
  var dphi;

  phi = ml / e0;
  for (var i = 0; i < 15; i++) {
    dphi = (ml - (e0 * phi - e1 * Math.sin(2 * phi) + e2 * Math.sin(4 * phi) - e3 * Math.sin(6 * phi))) / (e0 - 2 * e1 * Math.cos(2 * phi) + 4 * e2 * Math.cos(4 * phi) - 6 * e3 * Math.cos(6 * phi));
    phi += dphi;
    if (Math.abs(dphi) <= 0.0000000001) {
      return phi;
    }
  }

  //..reportError("IMLFN-CONV:Latitude failed to converge after 15 iterations");
  return NaN;
}
;// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/cass.js











function cass_init() {
  if (!this.sphere) {
    this.e0 = e0fn(this.es);
    this.e1 = e1fn(this.es);
    this.e2 = e2fn(this.es);
    this.e3 = e3fn(this.es);
    this.ml0 = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0);
  }
}

/* Cassini forward equations--mapping lat,long to x,y
  -----------------------------------------------------------------------*/
function cass_forward(p) {

  /* Forward equations
      -----------------*/
  var x, y;
  var lam = p.x;
  var phi = p.y;
  lam = adjust_lon(lam - this.long0);

  if (this.sphere) {
    x = this.a * Math.asin(Math.cos(phi) * Math.sin(lam));
    y = this.a * (Math.atan2(Math.tan(phi), Math.cos(lam)) - this.lat0);
  }
  else {
    //ellipsoid
    var sinphi = Math.sin(phi);
    var cosphi = Math.cos(phi);
    var nl = gN(this.a, this.e, sinphi);
    var tl = Math.tan(phi) * Math.tan(phi);
    var al = lam * Math.cos(phi);
    var asq = al * al;
    var cl = this.es * cosphi * cosphi / (1 - this.es);
    var ml = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, phi);

    x = nl * al * (1 - asq * tl * (1 / 6 - (8 - tl + 8 * cl) * asq / 120));
    y = ml - this.ml0 + nl * sinphi / cosphi * asq * (0.5 + (5 - tl + 6 * cl) * asq / 24);


  }

  p.x = x + this.x0;
  p.y = y + this.y0;
  return p;
}

/* Inverse equations
  -----------------*/
function cass_inverse(p) {
  p.x -= this.x0;
  p.y -= this.y0;
  var x = p.x / this.a;
  var y = p.y / this.a;
  var phi, lam;

  if (this.sphere) {
    var dd = y + this.lat0;
    phi = Math.asin(Math.sin(dd) * Math.cos(x));
    lam = Math.atan2(Math.tan(x), Math.cos(dd));
  }
  else {
    /* ellipsoid */
    var ml1 = this.ml0 / this.a + y;
    var phi1 = imlfn(ml1, this.e0, this.e1, this.e2, this.e3);
    if (Math.abs(Math.abs(phi1) - HALF_PI) <= EPSLN) {
      p.x = this.long0;
      p.y = HALF_PI;
      if (y < 0) {
        p.y *= -1;
      }
      return p;
    }
    var nl1 = gN(this.a, this.e, Math.sin(phi1));

    var rl1 = nl1 * nl1 * nl1 / this.a / this.a * (1 - this.es);
    var tl1 = Math.pow(Math.tan(phi1), 2);
    var dl = x * this.a / nl1;
    var dsq = dl * dl;
    phi = phi1 - nl1 * Math.tan(phi1) / rl1 * dl * dl * (0.5 - (1 + 3 * tl1) * dl * dl / 24);
    lam = dl * (1 - dsq * (tl1 / 3 + (1 + 3 * tl1) * tl1 * dsq / 15)) / Math.cos(phi1);

  }

  p.x = adjust_lon(lam + this.long0);
  p.y = adjust_lat(phi);
  return p;

}

var cass_names = ["Cassini", "Cassini_Soldner", "cass"];
/* harmony default export */ const cass = ({
  init: cass_init,
  forward: cass_forward,
  inverse: cass_inverse,
  names: cass_names
});

;// CONCATENATED MODULE: ./node_modules/proj4/lib/common/qsfnz.js
/* harmony default export */ function qsfnz(eccent, sinphi) {
  var con;
  if (eccent > 1.0e-7) {
    con = eccent * sinphi;
    return ((1 - eccent * eccent) * (sinphi / (1 - con * con) - (0.5 / eccent) * Math.log((1 - con) / (1 + con))));
  }
  else {
    return (2 * sinphi);
  }
}
;// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/laea.js






/*
  reference
    "New Equal-Area Map Projections for Noncircular Regions", John P. Snyder,
    The American Cartographer, Vol 15, No. 4, October 1988, pp. 341-355.
  */

var S_POLE = 1;

var N_POLE = 2;
var EQUIT = 3;
var OBLIQ = 4;

/* Initialize the Lambert Azimuthal Equal Area projection
  ------------------------------------------------------*/
function laea_init() {
  var t = Math.abs(this.lat0);
  if (Math.abs(t - HALF_PI) < EPSLN) {
    this.mode = this.lat0 < 0 ? this.S_POLE : this.N_POLE;
  }
  else if (Math.abs(t) < EPSLN) {
    this.mode = this.EQUIT;
  }
  else {
    this.mode = this.OBLIQ;
  }
  if (this.es > 0) {
    var sinphi;

    this.qp = qsfnz(this.e, 1);
    this.mmf = 0.5 / (1 - this.es);
    this.apa = authset(this.es);
    switch (this.mode) {
    case this.N_POLE:
      this.dd = 1;
      break;
    case this.S_POLE:
      this.dd = 1;
      break;
    case this.EQUIT:
      this.rq = Math.sqrt(0.5 * this.qp);
      this.dd = 1 / this.rq;
      this.xmf = 1;
      this.ymf = 0.5 * this.qp;
      break;
    case this.OBLIQ:
      this.rq = Math.sqrt(0.5 * this.qp);
      sinphi = Math.sin(this.lat0);
      this.sinb1 = qsfnz(this.e, sinphi) / this.qp;
      this.cosb1 = Math.sqrt(1 - this.sinb1 * this.sinb1);
      this.dd = Math.cos(this.lat0) / (Math.sqrt(1 - this.es * sinphi * sinphi) * this.rq * this.cosb1);
      this.ymf = (this.xmf = this.rq) / this.dd;
      this.xmf *= this.dd;
      break;
    }
  }
  else {
    if (this.mode === this.OBLIQ) {
      this.sinph0 = Math.sin(this.lat0);
      this.cosph0 = Math.cos(this.lat0);
    }
  }
}

/* Lambert Azimuthal Equal Area forward equations--mapping lat,long to x,y
  -----------------------------------------------------------------------*/
function laea_forward(p) {

  /* Forward equations
      -----------------*/
  var x, y, coslam, sinlam, sinphi, q, sinb, cosb, b, cosphi;
  var lam = p.x;
  var phi = p.y;

  lam = adjust_lon(lam - this.long0);
  if (this.sphere) {
    sinphi = Math.sin(phi);
    cosphi = Math.cos(phi);
    coslam = Math.cos(lam);
    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      y = (this.mode === this.EQUIT) ? 1 + cosphi * coslam : 1 + this.sinph0 * sinphi + this.cosph0 * cosphi * coslam;
      if (y <= EPSLN) {
        return null;
      }
      y = Math.sqrt(2 / y);
      x = y * cosphi * Math.sin(lam);
      y *= (this.mode === this.EQUIT) ? sinphi : this.cosph0 * sinphi - this.sinph0 * cosphi * coslam;
    }
    else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
      if (this.mode === this.N_POLE) {
        coslam = -coslam;
      }
      if (Math.abs(phi + this.lat0) < EPSLN) {
        return null;
      }
      y = FORTPI - phi * 0.5;
      y = 2 * ((this.mode === this.S_POLE) ? Math.cos(y) : Math.sin(y));
      x = y * Math.sin(lam);
      y *= coslam;
    }
  }
  else {
    sinb = 0;
    cosb = 0;
    b = 0;
    coslam = Math.cos(lam);
    sinlam = Math.sin(lam);
    sinphi = Math.sin(phi);
    q = qsfnz(this.e, sinphi);
    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      sinb = q / this.qp;
      cosb = Math.sqrt(1 - sinb * sinb);
    }
    switch (this.mode) {
    case this.OBLIQ:
      b = 1 + this.sinb1 * sinb + this.cosb1 * cosb * coslam;
      break;
    case this.EQUIT:
      b = 1 + cosb * coslam;
      break;
    case this.N_POLE:
      b = HALF_PI + phi;
      q = this.qp - q;
      break;
    case this.S_POLE:
      b = phi - HALF_PI;
      q = this.qp + q;
      break;
    }
    if (Math.abs(b) < EPSLN) {
      return null;
    }
    switch (this.mode) {
    case this.OBLIQ:
    case this.EQUIT:
      b = Math.sqrt(2 / b);
      if (this.mode === this.OBLIQ) {
        y = this.ymf * b * (this.cosb1 * sinb - this.sinb1 * cosb * coslam);
      }
      else {
        y = (b = Math.sqrt(2 / (1 + cosb * coslam))) * sinb * this.ymf;
      }
      x = this.xmf * b * cosb * sinlam;
      break;
    case this.N_POLE:
    case this.S_POLE:
      if (q >= 0) {
        x = (b = Math.sqrt(q)) * sinlam;
        y = coslam * ((this.mode === this.S_POLE) ? b : -b);
      }
      else {
        x = y = 0;
      }
      break;
    }
  }

  p.x = this.a * x + this.x0;
  p.y = this.a * y + this.y0;
  return p;
}

/* Inverse equations
  -----------------*/
function laea_inverse(p) {
  p.x -= this.x0;
  p.y -= this.y0;
  var x = p.x / this.a;
  var y = p.y / this.a;
  var lam, phi, cCe, sCe, q, rho, ab;
  if (this.sphere) {
    var cosz = 0,
      rh, sinz = 0;

    rh = Math.sqrt(x * x + y * y);
    phi = rh * 0.5;
    if (phi > 1) {
      return null;
    }
    phi = 2 * Math.asin(phi);
    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      sinz = Math.sin(phi);
      cosz = Math.cos(phi);
    }
    switch (this.mode) {
    case this.EQUIT:
      phi = (Math.abs(rh) <= EPSLN) ? 0 : Math.asin(y * sinz / rh);
      x *= sinz;
      y = cosz * rh;
      break;
    case this.OBLIQ:
      phi = (Math.abs(rh) <= EPSLN) ? this.lat0 : Math.asin(cosz * this.sinph0 + y * sinz * this.cosph0 / rh);
      x *= sinz * this.cosph0;
      y = (cosz - Math.sin(phi) * this.sinph0) * rh;
      break;
    case this.N_POLE:
      y = -y;
      phi = HALF_PI - phi;
      break;
    case this.S_POLE:
      phi -= HALF_PI;
      break;
    }
    lam = (y === 0 && (this.mode === this.EQUIT || this.mode === this.OBLIQ)) ? 0 : Math.atan2(x, y);
  }
  else {
    ab = 0;
    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
      x /= this.dd;
      y *= this.dd;
      rho = Math.sqrt(x * x + y * y);
      if (rho < EPSLN) {
        p.x = this.long0;
        p.y = this.lat0;
        return p;
      }
      sCe = 2 * Math.asin(0.5 * rho / this.rq);
      cCe = Math.cos(sCe);
      x *= (sCe = Math.sin(sCe));
      if (this.mode === this.OBLIQ) {
        ab = cCe * this.sinb1 + y * sCe * this.cosb1 / rho;
        q = this.qp * ab;
        y = rho * this.cosb1 * cCe - y * this.sinb1 * sCe;
      }
      else {
        ab = y * sCe / rho;
        q = this.qp * ab;
        y = rho * cCe;
      }
    }
    else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
      if (this.mode === this.N_POLE) {
        y = -y;
      }
      q = (x * x + y * y);
      if (!q) {
        p.x = this.long0;
        p.y = this.lat0;
        return p;
      }
      ab = 1 - q / this.qp;
      if (this.mode === this.S_POLE) {
        ab = -ab;
      }
    }
    lam = Math.atan2(x, y);
    phi = authlat(Math.asin(ab), this.apa);
  }

  p.x = adjust_lon(this.long0 + lam);
  p.y = phi;
  return p;
}

/* determine latitude from authalic latitude */
var P00 = 0.33333333333333333333;

var P01 = 0.17222222222222222222;
var P02 = 0.10257936507936507936;
var P10 = 0.06388888888888888888;
var P11 = 0.06640211640211640211;
var P20 = 0.01641501294219154443;

function authset(es) {
  var t;
  var APA = [];
  APA[0] = es * P00;
  t = es * es;
  APA[0] += t * P01;
  APA[1] = t * P10;
  t *= es;
  APA[0] += t * P02;
  APA[1] += t * P11;
  APA[2] = t * P20;
  return APA;
}

function authlat(beta, APA) {
  var t = beta + beta;
  return (beta + APA[0] * Math.sin(t) + APA[1] * Math.sin(t + t) + APA[2] * Math.sin(t + t + t));
}

var laea_names = ["Lambert Azimuthal Equal Area", "Lambert_Azimuthal_Equal_Area", "laea"];
/* harmony default export */ const laea = ({
  init: laea_init,
  forward: laea_forward,
  inverse: laea_inverse,
  names: laea_names,
  S_POLE: S_POLE,
  N_POLE: N_POLE,
  EQUIT: EQUIT,
  OBLIQ: OBLIQ
});

;// CONCATENATED MODULE: ./node_modules/proj4/lib/common/asinz.js
/* harmony default export */ function asinz(x) {
  if (Math.abs(x) > 1) {
    x = (x > 1) ? 1 : -1;
  }
  return Math.asin(x);
}
;// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/aea.js






function aea_init() {

  if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
    return;
  }
  this.temp = this.b / this.a;
  this.es = 1 - Math.pow(this.temp, 2);
  this.e3 = Math.sqrt(this.es);

  this.sin_po = Math.sin(this.lat1);
  this.cos_po = Math.cos(this.lat1);
  this.t1 = this.sin_po;
  this.con = this.sin_po;
  this.ms1 = msfnz(this.e3, this.sin_po, this.cos_po);
  this.qs1 = qsfnz(this.e3, this.sin_po);

  this.sin_po = Math.sin(this.lat2);
  this.cos_po = Math.cos(this.lat2);
  this.t2 = this.sin_po;
  this.ms2 = msfnz(this.e3, this.sin_po, this.cos_po);
  this.qs2 = qsfnz(this.e3, this.sin_po);

  this.sin_po = Math.sin(this.lat0);
  this.cos_po = Math.cos(this.lat0);
  this.t3 = this.sin_po;
  this.qs0 = qsfnz(this.e3, this.sin_po);

  if (Math.abs(this.lat1 - this.lat2) > EPSLN) {
    this.ns0 = (this.ms1 * this.ms1 - this.ms2 * this.ms2) / (this.qs2 - this.qs1);
  }
  else {
    this.ns0 = this.con;
  }
  this.c = this.ms1 * this.ms1 + this.ns0 * this.qs1;
  this.rh = this.a * Math.sqrt(this.c - this.ns0 * this.qs0) / this.ns0;
}

/* Albers Conical Equal Area forward equations--mapping lat,long to x,y
  -------------------------------------------------------------------*/
function aea_forward(p) {

  var lon = p.x;
  var lat = p.y;

  this.sin_phi = Math.sin(lat);
  this.cos_phi = Math.cos(lat);

  var qs = qsfnz(this.e3, this.sin_phi);
  var rh1 = this.a * Math.sqrt(this.c - this.ns0 * qs) / this.ns0;
  var theta = this.ns0 * adjust_lon(lon - this.long0);
  var x = rh1 * Math.sin(theta) + this.x0;
  var y = this.rh - rh1 * Math.cos(theta) + this.y0;

  p.x = x;
  p.y = y;
  return p;
}

function aea_inverse(p) {
  var rh1, qs, con, theta, lon, lat;

  p.x -= this.x0;
  p.y = this.rh - p.y + this.y0;
  if (this.ns0 >= 0) {
    rh1 = Math.sqrt(p.x * p.x + p.y * p.y);
    con = 1;
  }
  else {
    rh1 = -Math.sqrt(p.x * p.x + p.y * p.y);
    con = -1;
  }
  theta = 0;
  if (rh1 !== 0) {
    theta = Math.atan2(con * p.x, con * p.y);
  }
  con = rh1 * this.ns0 / this.a;
  if (this.sphere) {
    lat = Math.asin((this.c - con * con) / (2 * this.ns0));
  }
  else {
    qs = (this.c - con * con) / this.ns0;
    lat = this.phi1z(this.e3, qs);
  }

  lon = adjust_lon(theta / this.ns0 + this.long0);
  p.x = lon;
  p.y = lat;
  return p;
}

/* Function to compute phi1, the latitude for the inverse of the
   Albers Conical Equal-Area projection.
-------------------------------------------*/
function phi1z(eccent, qs) {
  var sinphi, cosphi, con, com, dphi;
  var phi = asinz(0.5 * qs);
  if (eccent < EPSLN) {
    return phi;
  }

  var eccnts = eccent * eccent;
  for (var i = 1; i <= 25; i++) {
    sinphi = Math.sin(phi);
    cosphi = Math.cos(phi);
    con = eccent * sinphi;
    com = 1 - con * con;
    dphi = 0.5 * com * com / cosphi * (qs / (1 - eccnts) - sinphi / com + 0.5 / eccent * Math.log((1 - con) / (1 + con)));
    phi = phi + dphi;
    if (Math.abs(dphi) <= 1e-7) {
      return phi;
    }
  }
  return null;
}

var aea_names = ["Albers_Conic_Equal_Area", "Albers", "aea"];
/* harmony default export */ const aea = ({
  init: aea_init,
  forward: aea_forward,
  inverse: aea_inverse,
  names: aea_names,
  phi1z: phi1z
});

;// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/gnom.js




/*
  reference:
    Wolfram Mathworld "Gnomonic Projection"
    http://mathworld.wolfram.com/GnomonicProjection.html
    Accessed: 12th November 2009
  */
function gnom_init() {

  /* Place parameters in static storage for common use
      -------------------------------------------------*/
  this.sin_p14 = Math.sin(this.lat0);
  this.cos_p14 = Math.cos(this.lat0);
  // Approximation for projecting points to the horizon (infinity)
  this.infinity_dist = 1000 * this.a;
  this.rc = 1;
}

/* Gnomonic forward equations--mapping lat,long to x,y
    ---------------------------------------------------*/
function gnom_forward(p) {
  var sinphi, cosphi; /* sin and cos value        */
  var dlon; /* delta longitude value      */
  var coslon; /* cos of longitude        */
  var ksp; /* scale factor          */
  var g;
  var x, y;
  var lon = p.x;
  var lat = p.y;
  /* Forward equations
      -----------------*/
  dlon = adjust_lon(lon - this.long0);

  sinphi = Math.sin(lat);
  cosphi = Math.cos(lat);

  coslon = Math.cos(dlon);
  g = this.sin_p14 * sinphi + this.cos_p14 * cosphi * coslon;
  ksp = 1;
  if ((g > 0) || (Math.abs(g) <= EPSLN)) {
    x = this.x0 + this.a * ksp * cosphi * Math.sin(dlon) / g;
    y = this.y0 + this.a * ksp * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon) / g;
  }
  else {

    // Point is in the opposing hemisphere and is unprojectable
    // We still need to return a reasonable point, so we project
    // to infinity, on a bearing
    // equivalent to the northern hemisphere equivalent
    // This is a reasonable approximation for short shapes and lines that
    // straddle the horizon.

    x = this.x0 + this.infinity_dist * cosphi * Math.sin(dlon);
    y = this.y0 + this.infinity_dist * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon);

  }
  p.x = x;
  p.y = y;
  return p;
}

function gnom_inverse(p) {
  var rh; /* Rho */
  var sinc, cosc;
  var c;
  var lon, lat;

  /* Inverse equations
      -----------------*/
  p.x = (p.x - this.x0) / this.a;
  p.y = (p.y - this.y0) / this.a;

  p.x /= this.k0;
  p.y /= this.k0;

  if ((rh = Math.sqrt(p.x * p.x + p.y * p.y))) {
    c = Math.atan2(rh, this.rc);
    sinc = Math.sin(c);
    cosc = Math.cos(c);

    lat = asinz(cosc * this.sin_p14 + (p.y * sinc * this.cos_p14) / rh);
    lon = Math.atan2(p.x * sinc, rh * this.cos_p14 * cosc - p.y * this.sin_p14 * sinc);
    lon = adjust_lon(this.long0 + lon);
  }
  else {
    lat = this.phic0;
    lon = 0;
  }

  p.x = lon;
  p.y = lat;
  return p;
}

var gnom_names = ["gnom"];
/* harmony default export */ const gnom = ({
  init: gnom_init,
  forward: gnom_forward,
  inverse: gnom_inverse,
  names: gnom_names
});

;// CONCATENATED MODULE: ./node_modules/proj4/lib/common/iqsfnz.js


/* harmony default export */ function iqsfnz(eccent, q) {
  var temp = 1 - (1 - eccent * eccent) / (2 * eccent) * Math.log((1 - eccent) / (1 + eccent));
  if (Math.abs(Math.abs(q) - temp) < 1.0E-6) {
    if (q < 0) {
      return (-1 * HALF_PI);
    }
    else {
      return HALF_PI;
    }
  }
  //var phi = 0.5* q/(1-eccent*eccent);
  var phi = Math.asin(0.5 * q);
  var dphi;
  var sin_phi;
  var cos_phi;
  var con;
  for (var i = 0; i < 30; i++) {
    sin_phi = Math.sin(phi);
    cos_phi = Math.cos(phi);
    con = eccent * sin_phi;
    dphi = Math.pow(1 - con * con, 2) / (2 * cos_phi) * (q / (1 - eccent * eccent) - sin_phi / (1 - con * con) + 0.5 / eccent * Math.log((1 - con) / (1 + con)));
    phi += dphi;
    if (Math.abs(dphi) <= 0.0000000001) {
      return phi;
    }
  }

  //console.log("IQSFN-CONV:Latitude failed to converge after 30 iterations");
  return NaN;
}

;// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/cea.js





/*
  reference:
    "Cartographic Projection Procedures for the UNIX Environment-
    A User's Manual" by Gerald I. Evenden,
    USGS Open File Report 90-284and Release 4 Interim Reports (2003)
*/
function cea_init() {
  //no-op
  if (!this.sphere) {
    this.k0 = msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));
  }
}

/* Cylindrical Equal Area forward equations--mapping lat,long to x,y
    ------------------------------------------------------------*/
function cea_forward(p) {
  var lon = p.x;
  var lat = p.y;
  var x, y;
  /* Forward equations
      -----------------*/
  var dlon = adjust_lon(lon - this.long0);
  if (this.sphere) {
    x = this.x0 + this.a * dlon * Math.cos(this.lat_ts);
    y = this.y0 + this.a * Math.sin(lat) / Math.cos(this.lat_ts);
  }
  else {
    var qs = qsfnz(this.e, Math.sin(lat));
    x = this.x0 + this.a * this.k0 * dlon;
    y = this.y0 + this.a * qs * 0.5 / this.k0;
  }

  p.x = x;
  p.y = y;
  return p;
}

/* Cylindrical Equal Area inverse equations--mapping x,y to lat/long
    ------------------------------------------------------------*/
function cea_inverse(p) {
  p.x -= this.x0;
  p.y -= this.y0;
  var lon, lat;

  if (this.sphere) {
    lon = adjust_lon(this.long0 + (p.x / this.a) / Math.cos(this.lat_ts));
    lat = Math.asin((p.y / this.a) * Math.cos(this.lat_ts));
  }
  else {
    lat = iqsfnz(this.e, 2 * p.y * this.k0 / this.a);
    lon = adjust_lon(this.long0 + p.x / (this.a * this.k0));
  }

  p.x = lon;
  p.y = lat;
  return p;
}

var cea_names = ["cea"];
/* harmony default export */ const cea = ({
  init: cea_init,
  forward: cea_forward,
  inverse: cea_inverse,
  names: cea_names
});

;// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/eqc.js



function eqc_init() {

  this.x0 = this.x0 || 0;
  this.y0 = this.y0 || 0;
  this.lat0 = this.lat0 || 0;
  this.long0 = this.long0 || 0;
  this.lat_ts = this.lat_ts || 0;
  this.title = this.title || "Equidistant Cylindrical (Plate Carre)";

  this.rc = Math.cos(this.lat_ts);
}

// forward equations--mapping lat,long to x,y
// -----------------------------------------------------------------
function eqc_forward(p) {

  var lon = p.x;
  var lat = p.y;

  var dlon = adjust_lon(lon - this.long0);
  var dlat = adjust_lat(lat - this.lat0);
  p.x = this.x0 + (this.a * dlon * this.rc);
  p.y = this.y0 + (this.a * dlat);
  return p;
}

// inverse equations--mapping x,y to lat/long
// -----------------------------------------------------------------
function eqc_inverse(p) {

  var x = p.x;
  var y = p.y;

  p.x = adjust_lon(this.long0 + ((x - this.x0) / (this.a * this.rc)));
  p.y = adjust_lat(this.lat0 + ((y - this.y0) / (this.a)));
  return p;
}

var eqc_names = ["Equirectangular", "Equidistant_Cylindrical", "eqc"];
/* harmony default export */ const eqc = ({
  init: eqc_init,
  forward: eqc_forward,
  inverse: eqc_inverse,
  names: eqc_names
});

;// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/poly.js










var poly_MAX_ITER = 20;

function poly_init() {
  /* Place parameters in static storage for common use
      -------------------------------------------------*/
  this.temp = this.b / this.a;
  this.es = 1 - Math.pow(this.temp, 2); // devait etre dans tmerc.js mais n y est pas donc je commente sinon retour de valeurs nulles
  this.e = Math.sqrt(this.es);
  this.e0 = e0fn(this.es);
  this.e1 = e1fn(this.es);
  this.e2 = e2fn(this.es);
  this.e3 = e3fn(this.es);
  this.ml0 = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0); //si que des zeros le calcul ne se fait pas
}

/* Polyconic forward equations--mapping lat,long to x,y
    ---------------------------------------------------*/
function poly_forward(p) {
  var lon = p.x;
  var lat = p.y;
  var x, y, el;
  var dlon = adjust_lon(lon - this.long0);
  el = dlon * Math.sin(lat);
  if (this.sphere) {
    if (Math.abs(lat) <= EPSLN) {
      x = this.a * dlon;
      y = -1 * this.a * this.lat0;
    }
    else {
      x = this.a * Math.sin(el) / Math.tan(lat);
      y = this.a * (adjust_lat(lat - this.lat0) + (1 - Math.cos(el)) / Math.tan(lat));
    }
  }
  else {
    if (Math.abs(lat) <= EPSLN) {
      x = this.a * dlon;
      y = -1 * this.ml0;
    }
    else {
      var nl = gN(this.a, this.e, Math.sin(lat)) / Math.tan(lat);
      x = nl * Math.sin(el);
      y = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, lat) - this.ml0 + nl * (1 - Math.cos(el));
    }

  }
  p.x = x + this.x0;
  p.y = y + this.y0;
  return p;
}

/* Inverse equations
  -----------------*/
function poly_inverse(p) {
  var lon, lat, x, y, i;
  var al, bl;
  var phi, dphi;
  x = p.x - this.x0;
  y = p.y - this.y0;

  if (this.sphere) {
    if (Math.abs(y + this.a * this.lat0) <= EPSLN) {
      lon = adjust_lon(x / this.a + this.long0);
      lat = 0;
    }
    else {
      al = this.lat0 + y / this.a;
      bl = x * x / this.a / this.a + al * al;
      phi = al;
      var tanphi;
      for (i = poly_MAX_ITER; i; --i) {
        tanphi = Math.tan(phi);
        dphi = -1 * (al * (phi * tanphi + 1) - phi - 0.5 * (phi * phi + bl) * tanphi) / ((phi - al) / tanphi - 1);
        phi += dphi;
        if (Math.abs(dphi) <= EPSLN) {
          lat = phi;
          break;
        }
      }
      lon = adjust_lon(this.long0 + (Math.asin(x * Math.tan(phi) / this.a)) / Math.sin(lat));
    }
  }
  else {
    if (Math.abs(y + this.ml0) <= EPSLN) {
      lat = 0;
      lon = adjust_lon(this.long0 + x / this.a);
    }
    else {

      al = (this.ml0 + y) / this.a;
      bl = x * x / this.a / this.a + al * al;
      phi = al;
      var cl, mln, mlnp, ma;
      var con;
      for (i = poly_MAX_ITER; i; --i) {
        con = this.e * Math.sin(phi);
        cl = Math.sqrt(1 - con * con) * Math.tan(phi);
        mln = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, phi);
        mlnp = this.e0 - 2 * this.e1 * Math.cos(2 * phi) + 4 * this.e2 * Math.cos(4 * phi) - 6 * this.e3 * Math.cos(6 * phi);
        ma = mln / this.a;
        dphi = (al * (cl * ma + 1) - ma - 0.5 * cl * (ma * ma + bl)) / (this.es * Math.sin(2 * phi) * (ma * ma + bl - 2 * al * ma) / (4 * cl) + (al - ma) * (cl * mlnp - 2 / Math.sin(2 * phi)) - mlnp);
        phi -= dphi;
        if (Math.abs(dphi) <= EPSLN) {
          lat = phi;
          break;
        }
      }

      //lat=phi4z(this.e,this.e0,this.e1,this.e2,this.e3,al,bl,0,0);
      cl = Math.sqrt(1 - this.es * Math.pow(Math.sin(lat), 2)) * Math.tan(lat);
      lon = adjust_lon(this.long0 + Math.asin(x * cl / this.a) / Math.sin(lat));
    }
  }

  p.x = lon;
  p.y = lat;
  return p;
}

var poly_names = ["Polyconic", "poly"];
/* harmony default export */ const poly = ({
  init: poly_init,
  forward: poly_forward,
  inverse: poly_inverse,
  names: poly_names
});

;// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/nzmg.js


/*
  reference
    Department of Land and Survey Technical Circular 1973/32
      http://www.linz.govt.nz/docs/miscellaneous/nz-map-definition.pdf
    OSG Technical Report 4.1
      http://www.linz.govt.nz/docs/miscellaneous/nzmg.pdf
  */

/**
 * iterations: Number of iterations to refine inverse transform.
 *     0 -> km accuracy
 *     1 -> m accuracy -- suitable for most mapping applications
 *     2 -> mm accuracy
 */
var iterations = 1;

function nzmg_init() {
  this.A = [];
  this.A[1] = 0.6399175073;
  this.A[2] = -0.1358797613;
  this.A[3] = 0.063294409;
  this.A[4] = -0.02526853;
  this.A[5] = 0.0117879;
  this.A[6] = -0.0055161;
  this.A[7] = 0.0026906;
  this.A[8] = -0.001333;
  this.A[9] = 0.00067;
  this.A[10] = -0.00034;

  this.B_re = [];
  this.B_im = [];
  this.B_re[1] = 0.7557853228;
  this.B_im[1] = 0;
  this.B_re[2] = 0.249204646;
  this.B_im[2] = 0.003371507;
  this.B_re[3] = -0.001541739;
  this.B_im[3] = 0.041058560;
  this.B_re[4] = -0.10162907;
  this.B_im[4] = 0.01727609;
  this.B_re[5] = -0.26623489;
  this.B_im[5] = -0.36249218;
  this.B_re[6] = -0.6870983;
  this.B_im[6] = -1.1651967;

  this.C_re = [];
  this.C_im = [];
  this.C_re[1] = 1.3231270439;
  this.C_im[1] = 0;
  this.C_re[2] = -0.577245789;
  this.C_im[2] = -0.007809598;
  this.C_re[3] = 0.508307513;
  this.C_im[3] = -0.112208952;
  this.C_re[4] = -0.15094762;
  this.C_im[4] = 0.18200602;
  this.C_re[5] = 1.01418179;
  this.C_im[5] = 1.64497696;
  this.C_re[6] = 1.9660549;
  this.C_im[6] = 2.5127645;

  this.D = [];
  this.D[1] = 1.5627014243;
  this.D[2] = 0.5185406398;
  this.D[3] = -0.03333098;
  this.D[4] = -0.1052906;
  this.D[5] = -0.0368594;
  this.D[6] = 0.007317;
  this.D[7] = 0.01220;
  this.D[8] = 0.00394;
  this.D[9] = -0.0013;
}

/**
    New Zealand Map Grid Forward  - long/lat to x/y
    long/lat in radians
  */
function nzmg_forward(p) {
  var n;
  var lon = p.x;
  var lat = p.y;

  var delta_lat = lat - this.lat0;
  var delta_lon = lon - this.long0;

  // 1. Calculate d_phi and d_psi    ...                          // and d_lambda
  // For this algorithm, delta_latitude is in seconds of arc x 10-5, so we need to scale to those units. Longitude is radians.
  var d_phi = delta_lat / SEC_TO_RAD * 1E-5;
  var d_lambda = delta_lon;
  var d_phi_n = 1; // d_phi^0

  var d_psi = 0;
  for (n = 1; n <= 10; n++) {
    d_phi_n = d_phi_n * d_phi;
    d_psi = d_psi + this.A[n] * d_phi_n;
  }

  // 2. Calculate theta
  var th_re = d_psi;
  var th_im = d_lambda;

  // 3. Calculate z
  var th_n_re = 1;
  var th_n_im = 0; // theta^0
  var th_n_re1;
  var th_n_im1;

  var z_re = 0;
  var z_im = 0;
  for (n = 1; n <= 6; n++) {
    th_n_re1 = th_n_re * th_re - th_n_im * th_im;
    th_n_im1 = th_n_im * th_re + th_n_re * th_im;
    th_n_re = th_n_re1;
    th_n_im = th_n_im1;
    z_re = z_re + this.B_re[n] * th_n_re - this.B_im[n] * th_n_im;
    z_im = z_im + this.B_im[n] * th_n_re + this.B_re[n] * th_n_im;
  }

  // 4. Calculate easting and northing
  p.x = (z_im * this.a) + this.x0;
  p.y = (z_re * this.a) + this.y0;

  return p;
}

/**
    New Zealand Map Grid Inverse  -  x/y to long/lat
  */
function nzmg_inverse(p) {
  var n;
  var x = p.x;
  var y = p.y;

  var delta_x = x - this.x0;
  var delta_y = y - this.y0;

  // 1. Calculate z
  var z_re = delta_y / this.a;
  var z_im = delta_x / this.a;

  // 2a. Calculate theta - first approximation gives km accuracy
  var z_n_re = 1;
  var z_n_im = 0; // z^0
  var z_n_re1;
  var z_n_im1;

  var th_re = 0;
  var th_im = 0;
  for (n = 1; n <= 6; n++) {
    z_n_re1 = z_n_re * z_re - z_n_im * z_im;
    z_n_im1 = z_n_im * z_re + z_n_re * z_im;
    z_n_re = z_n_re1;
    z_n_im = z_n_im1;
    th_re = th_re + this.C_re[n] * z_n_re - this.C_im[n] * z_n_im;
    th_im = th_im + this.C_im[n] * z_n_re + this.C_re[n] * z_n_im;
  }

  // 2b. Iterate to refine the accuracy of the calculation
  //        0 iterations gives km accuracy
  //        1 iteration gives m accuracy -- good enough for most mapping applications
  //        2 iterations bives mm accuracy
  for (var i = 0; i < this.iterations; i++) {
    var th_n_re = th_re;
    var th_n_im = th_im;
    var th_n_re1;
    var th_n_im1;

    var num_re = z_re;
    var num_im = z_im;
    for (n = 2; n <= 6; n++) {
      th_n_re1 = th_n_re * th_re - th_n_im * th_im;
      th_n_im1 = th_n_im * th_re + th_n_re * th_im;
      th_n_re = th_n_re1;
      th_n_im = th_n_im1;
      num_re = num_re + (n - 1) * (this.B_re[n] * th_n_re - this.B_im[n] * th_n_im);
      num_im = num_im + (n - 1) * (this.B_im[n] * th_n_re + this.B_re[n] * th_n_im);
    }

    th_n_re = 1;
    th_n_im = 0;
    var den_re = this.B_re[1];
    var den_im = this.B_im[1];
    for (n = 2; n <= 6; n++) {
      th_n_re1 = th_n_re * th_re - th_n_im * th_im;
      th_n_im1 = th_n_im * th_re + th_n_re * th_im;
      th_n_re = th_n_re1;
      th_n_im = th_n_im1;
      den_re = den_re + n * (this.B_re[n] * th_n_re - this.B_im[n] * th_n_im);
      den_im = den_im + n * (this.B_im[n] * th_n_re + this.B_re[n] * th_n_im);
    }

    // Complex division
    var den2 = den_re * den_re + den_im * den_im;
    th_re = (num_re * den_re + num_im * den_im) / den2;
    th_im = (num_im * den_re - num_re * den_im) / den2;
  }

  // 3. Calculate d_phi              ...                                    // and d_lambda
  var d_psi = th_re;
  var d_lambda = th_im;
  var d_psi_n = 1; // d_psi^0

  var d_phi = 0;
  for (n = 1; n <= 9; n++) {
    d_psi_n = d_psi_n * d_psi;
    d_phi = d_phi + this.D[n] * d_psi_n;
  }

  // 4. Calculate latitude and longitude
  // d_phi is calcuated in second of arc * 10^-5, so we need to scale back to radians. d_lambda is in radians.
  var lat = this.lat0 + (d_phi * SEC_TO_RAD * 1E5);
  var lon = this.long0 + d_lambda;

  p.x = lon;
  p.y = lat;

  return p;
}

var nzmg_names = ["New_Zealand_Map_Grid", "nzmg"];
/* harmony default export */ const nzmg = ({
  init: nzmg_init,
  forward: nzmg_forward,
  inverse: nzmg_inverse,
  names: nzmg_names
});

;// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/mill.js


/*
  reference
    "New Equal-Area Map Projections for Noncircular Regions", John P. Snyder,
    The American Cartographer, Vol 15, No. 4, October 1988, pp. 341-355.
  */


/* Initialize the Miller Cylindrical projection
  -------------------------------------------*/
function mill_init() {
  //no-op
}

/* Miller Cylindrical forward equations--mapping lat,long to x,y
    ------------------------------------------------------------*/
function mill_forward(p) {
  var lon = p.x;
  var lat = p.y;
  /* Forward equations
      -----------------*/
  var dlon = adjust_lon(lon - this.long0);
  var x = this.x0 + this.a * dlon;
  var y = this.y0 + this.a * Math.log(Math.tan((Math.PI / 4) + (lat / 2.5))) * 1.25;

  p.x = x;
  p.y = y;
  return p;
}

/* Miller Cylindrical inverse equations--mapping x,y to lat/long
    ------------------------------------------------------------*/
function mill_inverse(p) {
  p.x -= this.x0;
  p.y -= this.y0;

  var lon = adjust_lon(this.long0 + p.x / this.a);
  var lat = 2.5 * (Math.atan(Math.exp(0.8 * p.y / this.a)) - Math.PI / 4);

  p.x = lon;
  p.y = lat;
  return p;
}

var mill_names = ["Miller_Cylindrical", "mill"];
/* harmony default export */ const mill = ({
  init: mill_init,
  forward: mill_forward,
  inverse: mill_inverse,
  names: mill_names
});

;// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/sinu.js



var sinu_MAX_ITER = 20;







function sinu_init() {
  /* Place parameters in static storage for common use
    -------------------------------------------------*/


  if (!this.sphere) {
    this.en = pj_enfn(this.es);
  }
  else {
    this.n = 1;
    this.m = 0;
    this.es = 0;
    this.C_y = Math.sqrt((this.m + 1) / this.n);
    this.C_x = this.C_y / (this.m + 1);
  }

}

/* Sinusoidal forward equations--mapping lat,long to x,y
  -----------------------------------------------------*/
function sinu_forward(p) {
  var x, y;
  var lon = p.x;
  var lat = p.y;
  /* Forward equations
    -----------------*/
  lon = adjust_lon(lon - this.long0);

  if (this.sphere) {
    if (!this.m) {
      lat = this.n !== 1 ? Math.asin(this.n * Math.sin(lat)) : lat;
    }
    else {
      var k = this.n * Math.sin(lat);
      for (var i = sinu_MAX_ITER; i; --i) {
        var V = (this.m * lat + Math.sin(lat) - k) / (this.m + Math.cos(lat));
        lat -= V;
        if (Math.abs(V) < EPSLN) {
          break;
        }
      }
    }
    x = this.a * this.C_x * lon * (this.m + Math.cos(lat));
    y = this.a * this.C_y * lat;

  }
  else {

    var s = Math.sin(lat);
    var c = Math.cos(lat);
    y = this.a * pj_mlfn(lat, s, c, this.en);
    x = this.a * lon * c / Math.sqrt(1 - this.es * s * s);
  }

  p.x = x;
  p.y = y;
  return p;
}

function sinu_inverse(p) {
  var lat, temp, lon, s;

  p.x -= this.x0;
  lon = p.x / this.a;
  p.y -= this.y0;
  lat = p.y / this.a;

  if (this.sphere) {
    lat /= this.C_y;
    lon = lon / (this.C_x * (this.m + Math.cos(lat)));
    if (this.m) {
      lat = asinz((this.m * lat + Math.sin(lat)) / this.n);
    }
    else if (this.n !== 1) {
      lat = asinz(Math.sin(lat) / this.n);
    }
    lon = adjust_lon(lon + this.long0);
    lat = adjust_lat(lat);
  }
  else {
    lat = pj_inv_mlfn(p.y / this.a, this.es, this.en);
    s = Math.abs(lat);
    if (s < HALF_PI) {
      s = Math.sin(lat);
      temp = this.long0 + p.x * Math.sqrt(1 - this.es * s * s) / (this.a * Math.cos(lat));
      //temp = this.long0 + p.x / (this.a * Math.cos(lat));
      lon = adjust_lon(temp);
    }
    else if ((s - EPSLN) < HALF_PI) {
      lon = this.long0;
    }
  }
  p.x = lon;
  p.y = lat;
  return p;
}

var sinu_names = ["Sinusoidal", "sinu"];
/* harmony default export */ const sinu = ({
  init: sinu_init,
  forward: sinu_forward,
  inverse: sinu_inverse,
  names: sinu_names
});

;// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/moll.js

function moll_init() {}

/* Mollweide forward equations--mapping lat,long to x,y
    ----------------------------------------------------*/
function moll_forward(p) {

  /* Forward equations
      -----------------*/
  var lon = p.x;
  var lat = p.y;

  var delta_lon = adjust_lon(lon - this.long0);
  var theta = lat;
  var con = Math.PI * Math.sin(lat);

  /* Iterate using the Newton-Raphson method to find theta
      -----------------------------------------------------*/
  while (true) {
    var delta_theta = -(theta + Math.sin(theta) - con) / (1 + Math.cos(theta));
    theta += delta_theta;
    if (Math.abs(delta_theta) < EPSLN) {
      break;
    }
  }
  theta /= 2;

  /* If the latitude is 90 deg, force the x coordinate to be "0 + false easting"
       this is done here because of precision problems with "cos(theta)"
       --------------------------------------------------------------------------*/
  if (Math.PI / 2 - Math.abs(lat) < EPSLN) {
    delta_lon = 0;
  }
  var x = 0.900316316158 * this.a * delta_lon * Math.cos(theta) + this.x0;
  var y = 1.4142135623731 * this.a * Math.sin(theta) + this.y0;

  p.x = x;
  p.y = y;
  return p;
}

function moll_inverse(p) {
  var theta;
  var arg;

  /* Inverse equations
      -----------------*/
  p.x -= this.x0;
  p.y -= this.y0;
  arg = p.y / (1.4142135623731 * this.a);

  /* Because of division by zero problems, 'arg' can not be 1.  Therefore
       a number very close to one is used instead.
       -------------------------------------------------------------------*/
  if (Math.abs(arg) > 0.999999999999) {
    arg = 0.999999999999;
  }
  theta = Math.asin(arg);
  var lon = adjust_lon(this.long0 + (p.x / (0.900316316158 * this.a * Math.cos(theta))));
  if (lon < (-Math.PI)) {
    lon = -Math.PI;
  }
  if (lon > Math.PI) {
    lon = Math.PI;
  }
  arg = (2 * theta + Math.sin(2 * theta)) / Math.PI;
  if (Math.abs(arg) > 1) {
    arg = 1;
  }
  var lat = Math.asin(arg);

  p.x = lon;
  p.y = lat;
  return p;
}

var moll_names = ["Mollweide", "moll"];
/* harmony default export */ const moll = ({
  init: moll_init,
  forward: moll_forward,
  inverse: moll_inverse,
  names: moll_names
});

;// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/eqdc.js











function eqdc_init() {

  /* Place parameters in static storage for common use
      -------------------------------------------------*/
  // Standard Parallels cannot be equal and on opposite sides of the equator
  if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
    return;
  }
  this.lat2 = this.lat2 || this.lat1;
  this.temp = this.b / this.a;
  this.es = 1 - Math.pow(this.temp, 2);
  this.e = Math.sqrt(this.es);
  this.e0 = e0fn(this.es);
  this.e1 = e1fn(this.es);
  this.e2 = e2fn(this.es);
  this.e3 = e3fn(this.es);

  this.sinphi = Math.sin(this.lat1);
  this.cosphi = Math.cos(this.lat1);

  this.ms1 = msfnz(this.e, this.sinphi, this.cosphi);
  this.ml1 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat1);

  if (Math.abs(this.lat1 - this.lat2) < EPSLN) {
    this.ns = this.sinphi;
  }
  else {
    this.sinphi = Math.sin(this.lat2);
    this.cosphi = Math.cos(this.lat2);
    this.ms2 = msfnz(this.e, this.sinphi, this.cosphi);
    this.ml2 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat2);
    this.ns = (this.ms1 - this.ms2) / (this.ml2 - this.ml1);
  }
  this.g = this.ml1 + this.ms1 / this.ns;
  this.ml0 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0);
  this.rh = this.a * (this.g - this.ml0);
}

/* Equidistant Conic forward equations--mapping lat,long to x,y
  -----------------------------------------------------------*/
function eqdc_forward(p) {
  var lon = p.x;
  var lat = p.y;
  var rh1;

  /* Forward equations
      -----------------*/
  if (this.sphere) {
    rh1 = this.a * (this.g - lat);
  }
  else {
    var ml = mlfn(this.e0, this.e1, this.e2, this.e3, lat);
    rh1 = this.a * (this.g - ml);
  }
  var theta = this.ns * adjust_lon(lon - this.long0);
  var x = this.x0 + rh1 * Math.sin(theta);
  var y = this.y0 + this.rh - rh1 * Math.cos(theta);
  p.x = x;
  p.y = y;
  return p;
}

/* Inverse equations
  -----------------*/
function eqdc_inverse(p) {
  p.x -= this.x0;
  p.y = this.rh - p.y + this.y0;
  var con, rh1, lat, lon;
  if (this.ns >= 0) {
    rh1 = Math.sqrt(p.x * p.x + p.y * p.y);
    con = 1;
  }
  else {
    rh1 = -Math.sqrt(p.x * p.x + p.y * p.y);
    con = -1;
  }
  var theta = 0;
  if (rh1 !== 0) {
    theta = Math.atan2(con * p.x, con * p.y);
  }

  if (this.sphere) {
    lon = adjust_lon(this.long0 + theta / this.ns);
    lat = adjust_lat(this.g - rh1 / this.a);
    p.x = lon;
    p.y = lat;
    return p;
  }
  else {
    var ml = this.g - rh1 / this.a;
    lat = imlfn(ml, this.e0, this.e1, this.e2, this.e3);
    lon = adjust_lon(this.long0 + theta / this.ns);
    p.x = lon;
    p.y = lat;
    return p;
  }

}

var eqdc_names = ["Equidistant_Conic", "eqdc"];
/* harmony default export */ const eqdc = ({
  init: eqdc_init,
  forward: eqdc_forward,
  inverse: eqdc_inverse,
  names: eqdc_names
});

;// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/vandg.js






/* Initialize the Van Der Grinten projection
  ----------------------------------------*/
function vandg_init() {
  //this.R = 6370997; //Radius of earth
  this.R = this.a;
}

function vandg_forward(p) {

  var lon = p.x;
  var lat = p.y;

  /* Forward equations
    -----------------*/
  var dlon = adjust_lon(lon - this.long0);
  var x, y;

  if (Math.abs(lat) <= EPSLN) {
    x = this.x0 + this.R * dlon;
    y = this.y0;
  }
  var theta = asinz(2 * Math.abs(lat / Math.PI));
  if ((Math.abs(dlon) <= EPSLN) || (Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN)) {
    x = this.x0;
    if (lat >= 0) {
      y = this.y0 + Math.PI * this.R * Math.tan(0.5 * theta);
    }
    else {
      y = this.y0 + Math.PI * this.R * -Math.tan(0.5 * theta);
    }
    //  return(OK);
  }
  var al = 0.5 * Math.abs((Math.PI / dlon) - (dlon / Math.PI));
  var asq = al * al;
  var sinth = Math.sin(theta);
  var costh = Math.cos(theta);

  var g = costh / (sinth + costh - 1);
  var gsq = g * g;
  var m = g * (2 / sinth - 1);
  var msq = m * m;
  var con = Math.PI * this.R * (al * (g - msq) + Math.sqrt(asq * (g - msq) * (g - msq) - (msq + asq) * (gsq - msq))) / (msq + asq);
  if (dlon < 0) {
    con = -con;
  }
  x = this.x0 + con;
  //con = Math.abs(con / (Math.PI * this.R));
  var q = asq + g;
  con = Math.PI * this.R * (m * q - al * Math.sqrt((msq + asq) * (asq + 1) - q * q)) / (msq + asq);
  if (lat >= 0) {
    //y = this.y0 + Math.PI * this.R * Math.sqrt(1 - con * con - 2 * al * con);
    y = this.y0 + con;
  }
  else {
    //y = this.y0 - Math.PI * this.R * Math.sqrt(1 - con * con - 2 * al * con);
    y = this.y0 - con;
  }
  p.x = x;
  p.y = y;
  return p;
}

/* Van Der Grinten inverse equations--mapping x,y to lat/long
  ---------------------------------------------------------*/
function vandg_inverse(p) {
  var lon, lat;
  var xx, yy, xys, c1, c2, c3;
  var a1;
  var m1;
  var con;
  var th1;
  var d;

  /* inverse equations
    -----------------*/
  p.x -= this.x0;
  p.y -= this.y0;
  con = Math.PI * this.R;
  xx = p.x / con;
  yy = p.y / con;
  xys = xx * xx + yy * yy;
  c1 = -Math.abs(yy) * (1 + xys);
  c2 = c1 - 2 * yy * yy + xx * xx;
  c3 = -2 * c1 + 1 + 2 * yy * yy + xys * xys;
  d = yy * yy / c3 + (2 * c2 * c2 * c2 / c3 / c3 / c3 - 9 * c1 * c2 / c3 / c3) / 27;
  a1 = (c1 - c2 * c2 / 3 / c3) / c3;
  m1 = 2 * Math.sqrt(-a1 / 3);
  con = ((3 * d) / a1) / m1;
  if (Math.abs(con) > 1) {
    if (con >= 0) {
      con = 1;
    }
    else {
      con = -1;
    }
  }
  th1 = Math.acos(con) / 3;
  if (p.y >= 0) {
    lat = (-m1 * Math.cos(th1 + Math.PI / 3) - c2 / 3 / c3) * Math.PI;
  }
  else {
    lat = -(-m1 * Math.cos(th1 + Math.PI / 3) - c2 / 3 / c3) * Math.PI;
  }

  if (Math.abs(xx) < EPSLN) {
    lon = this.long0;
  }
  else {
    lon = adjust_lon(this.long0 + Math.PI * (xys - 1 + Math.sqrt(1 + 2 * (xx * xx - yy * yy) + xys * xys)) / 2 / xx);
  }

  p.x = lon;
  p.y = lat;
  return p;
}

var vandg_names = ["Van_der_Grinten_I", "VanDerGrinten", "vandg"];
/* harmony default export */ const vandg = ({
  init: vandg_init,
  forward: vandg_forward,
  inverse: vandg_inverse,
  names: vandg_names
});

;// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/aeqd.js














function aeqd_init() {
  this.sin_p12 = Math.sin(this.lat0);
  this.cos_p12 = Math.cos(this.lat0);
}

function aeqd_forward(p) {
  var lon = p.x;
  var lat = p.y;
  var sinphi = Math.sin(p.y);
  var cosphi = Math.cos(p.y);
  var dlon = adjust_lon(lon - this.long0);
  var e0, e1, e2, e3, Mlp, Ml, tanphi, Nl1, Nl, psi, Az, G, H, GH, Hs, c, kp, cos_c, s, s2, s3, s4, s5;
  if (this.sphere) {
    if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
      //North Pole case
      p.x = this.x0 + this.a * (HALF_PI - lat) * Math.sin(dlon);
      p.y = this.y0 - this.a * (HALF_PI - lat) * Math.cos(dlon);
      return p;
    }
    else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
      //South Pole case
      p.x = this.x0 + this.a * (HALF_PI + lat) * Math.sin(dlon);
      p.y = this.y0 + this.a * (HALF_PI + lat) * Math.cos(dlon);
      return p;
    }
    else {
      //default case
      cos_c = this.sin_p12 * sinphi + this.cos_p12 * cosphi * Math.cos(dlon);
      c = Math.acos(cos_c);
      kp = c ? c / Math.sin(c) : 1;
      p.x = this.x0 + this.a * kp * cosphi * Math.sin(dlon);
      p.y = this.y0 + this.a * kp * (this.cos_p12 * sinphi - this.sin_p12 * cosphi * Math.cos(dlon));
      return p;
    }
  }
  else {
    e0 = e0fn(this.es);
    e1 = e1fn(this.es);
    e2 = e2fn(this.es);
    e3 = e3fn(this.es);
    if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
      //North Pole case
      Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
      Ml = this.a * mlfn(e0, e1, e2, e3, lat);
      p.x = this.x0 + (Mlp - Ml) * Math.sin(dlon);
      p.y = this.y0 - (Mlp - Ml) * Math.cos(dlon);
      return p;
    }
    else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
      //South Pole case
      Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
      Ml = this.a * mlfn(e0, e1, e2, e3, lat);
      p.x = this.x0 + (Mlp + Ml) * Math.sin(dlon);
      p.y = this.y0 + (Mlp + Ml) * Math.cos(dlon);
      return p;
    }
    else {
      //Default case
      tanphi = sinphi / cosphi;
      Nl1 = gN(this.a, this.e, this.sin_p12);
      Nl = gN(this.a, this.e, sinphi);
      psi = Math.atan((1 - this.es) * tanphi + this.es * Nl1 * this.sin_p12 / (Nl * cosphi));
      Az = Math.atan2(Math.sin(dlon), this.cos_p12 * Math.tan(psi) - this.sin_p12 * Math.cos(dlon));
      if (Az === 0) {
        s = Math.asin(this.cos_p12 * Math.sin(psi) - this.sin_p12 * Math.cos(psi));
      }
      else if (Math.abs(Math.abs(Az) - Math.PI) <= EPSLN) {
        s = -Math.asin(this.cos_p12 * Math.sin(psi) - this.sin_p12 * Math.cos(psi));
      }
      else {
        s = Math.asin(Math.sin(dlon) * Math.cos(psi) / Math.sin(Az));
      }
      G = this.e * this.sin_p12 / Math.sqrt(1 - this.es);
      H = this.e * this.cos_p12 * Math.cos(Az) / Math.sqrt(1 - this.es);
      GH = G * H;
      Hs = H * H;
      s2 = s * s;
      s3 = s2 * s;
      s4 = s3 * s;
      s5 = s4 * s;
      c = Nl1 * s * (1 - s2 * Hs * (1 - Hs) / 6 + s3 / 8 * GH * (1 - 2 * Hs) + s4 / 120 * (Hs * (4 - 7 * Hs) - 3 * G * G * (1 - 7 * Hs)) - s5 / 48 * GH);
      p.x = this.x0 + c * Math.sin(Az);
      p.y = this.y0 + c * Math.cos(Az);
      return p;
    }
  }


}

function aeqd_inverse(p) {
  p.x -= this.x0;
  p.y -= this.y0;
  var rh, z, sinz, cosz, lon, lat, con, e0, e1, e2, e3, Mlp, M, N1, psi, Az, cosAz, tmp, A, B, D, Ee, F, sinpsi;
  if (this.sphere) {
    rh = Math.sqrt(p.x * p.x + p.y * p.y);
    if (rh > (2 * HALF_PI * this.a)) {
      return;
    }
    z = rh / this.a;

    sinz = Math.sin(z);
    cosz = Math.cos(z);

    lon = this.long0;
    if (Math.abs(rh) <= EPSLN) {
      lat = this.lat0;
    }
    else {
      lat = asinz(cosz * this.sin_p12 + (p.y * sinz * this.cos_p12) / rh);
      con = Math.abs(this.lat0) - HALF_PI;
      if (Math.abs(con) <= EPSLN) {
        if (this.lat0 >= 0) {
          lon = adjust_lon(this.long0 + Math.atan2(p.x, - p.y));
        }
        else {
          lon = adjust_lon(this.long0 - Math.atan2(-p.x, p.y));
        }
      }
      else {
        /*con = cosz - this.sin_p12 * Math.sin(lat);
        if ((Math.abs(con) < EPSLN) && (Math.abs(p.x) < EPSLN)) {
          //no-op, just keep the lon value as is
        } else {
          var temp = Math.atan2((p.x * sinz * this.cos_p12), (con * rh));
          lon = adjust_lon(this.long0 + Math.atan2((p.x * sinz * this.cos_p12), (con * rh)));
        }*/
        lon = adjust_lon(this.long0 + Math.atan2(p.x * sinz, rh * this.cos_p12 * cosz - p.y * this.sin_p12 * sinz));
      }
    }

    p.x = lon;
    p.y = lat;
    return p;
  }
  else {
    e0 = e0fn(this.es);
    e1 = e1fn(this.es);
    e2 = e2fn(this.es);
    e3 = e3fn(this.es);
    if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
      //North pole case
      Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
      rh = Math.sqrt(p.x * p.x + p.y * p.y);
      M = Mlp - rh;
      lat = imlfn(M / this.a, e0, e1, e2, e3);
      lon = adjust_lon(this.long0 + Math.atan2(p.x, - 1 * p.y));
      p.x = lon;
      p.y = lat;
      return p;
    }
    else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
      //South pole case
      Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
      rh = Math.sqrt(p.x * p.x + p.y * p.y);
      M = rh - Mlp;

      lat = imlfn(M / this.a, e0, e1, e2, e3);
      lon = adjust_lon(this.long0 + Math.atan2(p.x, p.y));
      p.x = lon;
      p.y = lat;
      return p;
    }
    else {
      //default case
      rh = Math.sqrt(p.x * p.x + p.y * p.y);
      Az = Math.atan2(p.x, p.y);
      N1 = gN(this.a, this.e, this.sin_p12);
      cosAz = Math.cos(Az);
      tmp = this.e * this.cos_p12 * cosAz;
      A = -tmp * tmp / (1 - this.es);
      B = 3 * this.es * (1 - A) * this.sin_p12 * this.cos_p12 * cosAz / (1 - this.es);
      D = rh / N1;
      Ee = D - A * (1 + A) * Math.pow(D, 3) / 6 - B * (1 + 3 * A) * Math.pow(D, 4) / 24;
      F = 1 - A * Ee * Ee / 2 - D * Ee * Ee * Ee / 6;
      psi = Math.asin(this.sin_p12 * Math.cos(Ee) + this.cos_p12 * Math.sin(Ee) * cosAz);
      lon = adjust_lon(this.long0 + Math.asin(Math.sin(Az) * Math.sin(Ee) / Math.cos(psi)));
      sinpsi = Math.sin(psi);
      lat = Math.atan2((sinpsi - this.es * F * this.sin_p12) * Math.tan(psi), sinpsi * (1 - this.es));
      p.x = lon;
      p.y = lat;
      return p;
    }
  }

}

var aeqd_names = ["Azimuthal_Equidistant", "aeqd"];
/* harmony default export */ const aeqd = ({
  init: aeqd_init,
  forward: aeqd_forward,
  inverse: aeqd_inverse,
  names: aeqd_names
});

;// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/ortho.js




function ortho_init() {
  //double temp;      /* temporary variable    */

  /* Place parameters in static storage for common use
      -------------------------------------------------*/
  this.sin_p14 = Math.sin(this.lat0);
  this.cos_p14 = Math.cos(this.lat0);
}

/* Orthographic forward equations--mapping lat,long to x,y
    ---------------------------------------------------*/
function ortho_forward(p) {
  var sinphi, cosphi; /* sin and cos value        */
  var dlon; /* delta longitude value      */
  var coslon; /* cos of longitude        */
  var ksp; /* scale factor          */
  var g, x, y;
  var lon = p.x;
  var lat = p.y;
  /* Forward equations
      -----------------*/
  dlon = adjust_lon(lon - this.long0);

  sinphi = Math.sin(lat);
  cosphi = Math.cos(lat);

  coslon = Math.cos(dlon);
  g = this.sin_p14 * sinphi + this.cos_p14 * cosphi * coslon;
  ksp = 1;
  if ((g > 0) || (Math.abs(g) <= EPSLN)) {
    x = this.a * ksp * cosphi * Math.sin(dlon);
    y = this.y0 + this.a * ksp * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon);
  }
  p.x = x;
  p.y = y;
  return p;
}

function ortho_inverse(p) {
  var rh; /* height above ellipsoid      */
  var z; /* angle          */
  var sinz, cosz; /* sin of z and cos of z      */
  var con;
  var lon, lat;
  /* Inverse equations
      -----------------*/
  p.x -= this.x0;
  p.y -= this.y0;
  rh = Math.sqrt(p.x * p.x + p.y * p.y);
  z = asinz(rh / this.a);

  sinz = Math.sin(z);
  cosz = Math.cos(z);

  lon = this.long0;
  if (Math.abs(rh) <= EPSLN) {
    lat = this.lat0;
    p.x = lon;
    p.y = lat;
    return p;
  }
  lat = asinz(cosz * this.sin_p14 + (p.y * sinz * this.cos_p14) / rh);
  con = Math.abs(this.lat0) - HALF_PI;
  if (Math.abs(con) <= EPSLN) {
    if (this.lat0 >= 0) {
      lon = adjust_lon(this.long0 + Math.atan2(p.x, - p.y));
    }
    else {
      lon = adjust_lon(this.long0 - Math.atan2(-p.x, p.y));
    }
    p.x = lon;
    p.y = lat;
    return p;
  }
  lon = adjust_lon(this.long0 + Math.atan2((p.x * sinz), rh * this.cos_p14 * cosz - p.y * this.sin_p14 * sinz));
  p.x = lon;
  p.y = lat;
  return p;
}

var ortho_names = ["ortho"];
/* harmony default export */ const ortho = ({
  init: ortho_init,
  forward: ortho_forward,
  inverse: ortho_inverse,
  names: ortho_names
});

;// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/qsc.js
// QSC projection rewritten from the original PROJ4
// https://github.com/OSGeo/proj.4/blob/master/src/PJ_qsc.c



/* constants */
var FACE_ENUM = {
    FRONT: 1,
    RIGHT: 2,
    BACK: 3,
    LEFT: 4,
    TOP: 5,
    BOTTOM: 6
};

var AREA_ENUM = {
    AREA_0: 1,
    AREA_1: 2,
    AREA_2: 3,
    AREA_3: 4
};

function qsc_init() {

  this.x0 = this.x0 || 0;
  this.y0 = this.y0 || 0;
  this.lat0 = this.lat0 || 0;
  this.long0 = this.long0 || 0;
  this.lat_ts = this.lat_ts || 0;
  this.title = this.title || "Quadrilateralized Spherical Cube";

  /* Determine the cube face from the center of projection. */
  if (this.lat0 >= HALF_PI - FORTPI / 2.0) {
    this.face = FACE_ENUM.TOP;
  } else if (this.lat0 <= -(HALF_PI - FORTPI / 2.0)) {
    this.face = FACE_ENUM.BOTTOM;
  } else if (Math.abs(this.long0) <= FORTPI) {
    this.face = FACE_ENUM.FRONT;
  } else if (Math.abs(this.long0) <= HALF_PI + FORTPI) {
    this.face = this.long0 > 0.0 ? FACE_ENUM.RIGHT : FACE_ENUM.LEFT;
  } else {
    this.face = FACE_ENUM.BACK;
  }

  /* Fill in useful values for the ellipsoid <-> sphere shift
   * described in [LK12]. */
  if (this.es !== 0) {
    this.one_minus_f = 1 - (this.a - this.b) / this.a;
    this.one_minus_f_squared = this.one_minus_f * this.one_minus_f;
  }
}

// QSC forward equations--mapping lat,long to x,y
// -----------------------------------------------------------------
function qsc_forward(p) {
  var xy = {x: 0, y: 0};
  var lat, lon;
  var theta, phi;
  var t, mu;
  /* nu; */
  var area = {value: 0};

  // move lon according to projection's lon
  p.x -= this.long0;

  /* Convert the geodetic latitude to a geocentric latitude.
   * This corresponds to the shift from the ellipsoid to the sphere
   * described in [LK12]. */
  if (this.es !== 0) {//if (P->es != 0) {
    lat = Math.atan(this.one_minus_f_squared * Math.tan(p.y));
  } else {
    lat = p.y;
  }

  /* Convert the input lat, lon into theta, phi as used by QSC.
   * This depends on the cube face and the area on it.
   * For the top and bottom face, we can compute theta and phi
   * directly from phi, lam. For the other faces, we must use
   * unit sphere cartesian coordinates as an intermediate step. */
  lon = p.x; //lon = lp.lam;
  if (this.face === FACE_ENUM.TOP) {
    phi = HALF_PI - lat;
    if (lon >= FORTPI && lon <= HALF_PI + FORTPI) {
      area.value = AREA_ENUM.AREA_0;
      theta = lon - HALF_PI;
    } else if (lon > HALF_PI + FORTPI || lon <= -(HALF_PI + FORTPI)) {
      area.value = AREA_ENUM.AREA_1;
      theta = (lon > 0.0 ? lon - SPI : lon + SPI);
    } else if (lon > -(HALF_PI + FORTPI) && lon <= -FORTPI) {
      area.value = AREA_ENUM.AREA_2;
      theta = lon + HALF_PI;
    } else {
      area.value = AREA_ENUM.AREA_3;
      theta = lon;
    }
  } else if (this.face === FACE_ENUM.BOTTOM) {
    phi = HALF_PI + lat;
    if (lon >= FORTPI && lon <= HALF_PI + FORTPI) {
      area.value = AREA_ENUM.AREA_0;
      theta = -lon + HALF_PI;
    } else if (lon < FORTPI && lon >= -FORTPI) {
      area.value = AREA_ENUM.AREA_1;
      theta = -lon;
    } else if (lon < -FORTPI && lon >= -(HALF_PI + FORTPI)) {
      area.value = AREA_ENUM.AREA_2;
      theta = -lon - HALF_PI;
    } else {
      area.value = AREA_ENUM.AREA_3;
      theta = (lon > 0.0 ? -lon + SPI : -lon - SPI);
    }
  } else {
    var q, r, s;
    var sinlat, coslat;
    var sinlon, coslon;

    if (this.face === FACE_ENUM.RIGHT) {
      lon = qsc_shift_lon_origin(lon, +HALF_PI);
    } else if (this.face === FACE_ENUM.BACK) {
      lon = qsc_shift_lon_origin(lon, +SPI);
    } else if (this.face === FACE_ENUM.LEFT) {
      lon = qsc_shift_lon_origin(lon, -HALF_PI);
    }
    sinlat = Math.sin(lat);
    coslat = Math.cos(lat);
    sinlon = Math.sin(lon);
    coslon = Math.cos(lon);
    q = coslat * coslon;
    r = coslat * sinlon;
    s = sinlat;

    if (this.face === FACE_ENUM.FRONT) {
      phi = Math.acos(q);
      theta = qsc_fwd_equat_face_theta(phi, s, r, area);
    } else if (this.face === FACE_ENUM.RIGHT) {
      phi = Math.acos(r);
      theta = qsc_fwd_equat_face_theta(phi, s, -q, area);
    } else if (this.face === FACE_ENUM.BACK) {
      phi = Math.acos(-q);
      theta = qsc_fwd_equat_face_theta(phi, s, -r, area);
    } else if (this.face === FACE_ENUM.LEFT) {
      phi = Math.acos(-r);
      theta = qsc_fwd_equat_face_theta(phi, s, q, area);
    } else {
      /* Impossible */
      phi = theta = 0;
      area.value = AREA_ENUM.AREA_0;
    }
  }

  /* Compute mu and nu for the area of definition.
   * For mu, see Eq. (3-21) in [OL76], but note the typos:
   * compare with Eq. (3-14). For nu, see Eq. (3-38). */
  mu = Math.atan((12 / SPI) * (theta + Math.acos(Math.sin(theta) * Math.cos(FORTPI)) - HALF_PI));
  t = Math.sqrt((1 - Math.cos(phi)) / (Math.cos(mu) * Math.cos(mu)) / (1 - Math.cos(Math.atan(1 / Math.cos(theta)))));

  /* Apply the result to the real area. */
  if (area.value === AREA_ENUM.AREA_1) {
    mu += HALF_PI;
  } else if (area.value === AREA_ENUM.AREA_2) {
    mu += SPI;
  } else if (area.value === AREA_ENUM.AREA_3) {
    mu += 1.5 * SPI;
  }

  /* Now compute x, y from mu and nu */
  xy.x = t * Math.cos(mu);
  xy.y = t * Math.sin(mu);
  xy.x = xy.x * this.a + this.x0;
  xy.y = xy.y * this.a + this.y0;

  p.x = xy.x;
  p.y = xy.y;
  return p;
}

// QSC inverse equations--mapping x,y to lat/long
// -----------------------------------------------------------------
function qsc_inverse(p) {
  var lp = {lam: 0, phi: 0};
  var mu, nu, cosmu, tannu;
  var tantheta, theta, cosphi, phi;
  var t;
  var area = {value: 0};

  /* de-offset */
  p.x = (p.x - this.x0) / this.a;
  p.y = (p.y - this.y0) / this.a;

  /* Convert the input x, y to the mu and nu angles as used by QSC.
   * This depends on the area of the cube face. */
  nu = Math.atan(Math.sqrt(p.x * p.x + p.y * p.y));
  mu = Math.atan2(p.y, p.x);
  if (p.x >= 0.0 && p.x >= Math.abs(p.y)) {
    area.value = AREA_ENUM.AREA_0;
  } else if (p.y >= 0.0 && p.y >= Math.abs(p.x)) {
    area.value = AREA_ENUM.AREA_1;
    mu -= HALF_PI;
  } else if (p.x < 0.0 && -p.x >= Math.abs(p.y)) {
    area.value = AREA_ENUM.AREA_2;
    mu = (mu < 0.0 ? mu + SPI : mu - SPI);
  } else {
    area.value = AREA_ENUM.AREA_3;
    mu += HALF_PI;
  }

  /* Compute phi and theta for the area of definition.
   * The inverse projection is not described in the original paper, but some
   * good hints can be found here (as of 2011-12-14):
   * http://fits.gsfc.nasa.gov/fitsbits/saf.93/saf.9302
   * (search for "Message-Id: <9302181759.AA25477 at fits.cv.nrao.edu>") */
  t = (SPI / 12) * Math.tan(mu);
  tantheta = Math.sin(t) / (Math.cos(t) - (1 / Math.sqrt(2)));
  theta = Math.atan(tantheta);
  cosmu = Math.cos(mu);
  tannu = Math.tan(nu);
  cosphi = 1 - cosmu * cosmu * tannu * tannu * (1 - Math.cos(Math.atan(1 / Math.cos(theta))));
  if (cosphi < -1) {
    cosphi = -1;
  } else if (cosphi > +1) {
    cosphi = +1;
  }

  /* Apply the result to the real area on the cube face.
   * For the top and bottom face, we can compute phi and lam directly.
   * For the other faces, we must use unit sphere cartesian coordinates
   * as an intermediate step. */
  if (this.face === FACE_ENUM.TOP) {
    phi = Math.acos(cosphi);
    lp.phi = HALF_PI - phi;
    if (area.value === AREA_ENUM.AREA_0) {
      lp.lam = theta + HALF_PI;
    } else if (area.value === AREA_ENUM.AREA_1) {
      lp.lam = (theta < 0.0 ? theta + SPI : theta - SPI);
    } else if (area.value === AREA_ENUM.AREA_2) {
      lp.lam = theta - HALF_PI;
    } else /* area.value == AREA_ENUM.AREA_3 */ {
      lp.lam = theta;
    }
  } else if (this.face === FACE_ENUM.BOTTOM) {
    phi = Math.acos(cosphi);
    lp.phi = phi - HALF_PI;
    if (area.value === AREA_ENUM.AREA_0) {
      lp.lam = -theta + HALF_PI;
    } else if (area.value === AREA_ENUM.AREA_1) {
      lp.lam = -theta;
    } else if (area.value === AREA_ENUM.AREA_2) {
      lp.lam = -theta - HALF_PI;
    } else /* area.value == AREA_ENUM.AREA_3 */ {
      lp.lam = (theta < 0.0 ? -theta - SPI : -theta + SPI);
    }
  } else {
    /* Compute phi and lam via cartesian unit sphere coordinates. */
    var q, r, s;
    q = cosphi;
    t = q * q;
    if (t >= 1) {
      s = 0;
    } else {
      s = Math.sqrt(1 - t) * Math.sin(theta);
    }
    t += s * s;
    if (t >= 1) {
      r = 0;
    } else {
      r = Math.sqrt(1 - t);
    }
    /* Rotate q,r,s into the correct area. */
    if (area.value === AREA_ENUM.AREA_1) {
      t = r;
      r = -s;
      s = t;
    } else if (area.value === AREA_ENUM.AREA_2) {
      r = -r;
      s = -s;
    } else if (area.value === AREA_ENUM.AREA_3) {
      t = r;
      r = s;
      s = -t;
    }
    /* Rotate q,r,s into the correct cube face. */
    if (this.face === FACE_ENUM.RIGHT) {
      t = q;
      q = -r;
      r = t;
    } else if (this.face === FACE_ENUM.BACK) {
      q = -q;
      r = -r;
    } else if (this.face === FACE_ENUM.LEFT) {
      t = q;
      q = r;
      r = -t;
    }
    /* Now compute phi and lam from the unit sphere coordinates. */
    lp.phi = Math.acos(-s) - HALF_PI;
    lp.lam = Math.atan2(r, q);
    if (this.face === FACE_ENUM.RIGHT) {
      lp.lam = qsc_shift_lon_origin(lp.lam, -HALF_PI);
    } else if (this.face === FACE_ENUM.BACK) {
      lp.lam = qsc_shift_lon_origin(lp.lam, -SPI);
    } else if (this.face === FACE_ENUM.LEFT) {
      lp.lam = qsc_shift_lon_origin(lp.lam, +HALF_PI);
    }
  }

  /* Apply the shift from the sphere to the ellipsoid as described
   * in [LK12]. */
  if (this.es !== 0) {
    var invert_sign;
    var tanphi, xa;
    invert_sign = (lp.phi < 0 ? 1 : 0);
    tanphi = Math.tan(lp.phi);
    xa = this.b / Math.sqrt(tanphi * tanphi + this.one_minus_f_squared);
    lp.phi = Math.atan(Math.sqrt(this.a * this.a - xa * xa) / (this.one_minus_f * xa));
    if (invert_sign) {
      lp.phi = -lp.phi;
    }
  }

  lp.lam += this.long0;
  p.x = lp.lam;
  p.y = lp.phi;
  return p;
}

/* Helper function for forward projection: compute the theta angle
 * and determine the area number. */
function qsc_fwd_equat_face_theta(phi, y, x, area) {
  var theta;
  if (phi < EPSLN) {
    area.value = AREA_ENUM.AREA_0;
    theta = 0.0;
  } else {
    theta = Math.atan2(y, x);
    if (Math.abs(theta) <= FORTPI) {
      area.value = AREA_ENUM.AREA_0;
    } else if (theta > FORTPI && theta <= HALF_PI + FORTPI) {
      area.value = AREA_ENUM.AREA_1;
      theta -= HALF_PI;
    } else if (theta > HALF_PI + FORTPI || theta <= -(HALF_PI + FORTPI)) {
      area.value = AREA_ENUM.AREA_2;
      theta = (theta >= 0.0 ? theta - SPI : theta + SPI);
    } else {
      area.value = AREA_ENUM.AREA_3;
      theta += HALF_PI;
    }
  }
  return theta;
}

/* Helper function: shift the longitude. */
function qsc_shift_lon_origin(lon, offset) {
  var slon = lon + offset;
  if (slon < -SPI) {
    slon += TWO_PI;
  } else if (slon > +SPI) {
    slon -= TWO_PI;
  }
  return slon;
}

var qsc_names = ["Quadrilateralized Spherical Cube", "Quadrilateralized_Spherical_Cube", "qsc"];
/* harmony default export */ const qsc = ({
  init: qsc_init,
  forward: qsc_forward,
  inverse: qsc_inverse,
  names: qsc_names
});


;// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/robin.js
// Robinson projection
// Based on https://github.com/OSGeo/proj.4/blob/master/src/PJ_robin.c
// Polynomial coeficients from http://article.gmane.org/gmane.comp.gis.proj-4.devel/6039




var COEFS_X = [
    [1.0000, 2.2199e-17, -7.15515e-05, 3.1103e-06],
    [0.9986, -0.000482243, -2.4897e-05, -1.3309e-06],
    [0.9954, -0.00083103, -4.48605e-05, -9.86701e-07],
    [0.9900, -0.00135364, -5.9661e-05, 3.6777e-06],
    [0.9822, -0.00167442, -4.49547e-06, -5.72411e-06],
    [0.9730, -0.00214868, -9.03571e-05, 1.8736e-08],
    [0.9600, -0.00305085, -9.00761e-05, 1.64917e-06],
    [0.9427, -0.00382792, -6.53386e-05, -2.6154e-06],
    [0.9216, -0.00467746, -0.00010457, 4.81243e-06],
    [0.8962, -0.00536223, -3.23831e-05, -5.43432e-06],
    [0.8679, -0.00609363, -0.000113898, 3.32484e-06],
    [0.8350, -0.00698325, -6.40253e-05, 9.34959e-07],
    [0.7986, -0.00755338, -5.00009e-05, 9.35324e-07],
    [0.7597, -0.00798324, -3.5971e-05, -2.27626e-06],
    [0.7186, -0.00851367, -7.01149e-05, -8.6303e-06],
    [0.6732, -0.00986209, -0.000199569, 1.91974e-05],
    [0.6213, -0.010418, 8.83923e-05, 6.24051e-06],
    [0.5722, -0.00906601, 0.000182, 6.24051e-06],
    [0.5322, -0.00677797, 0.000275608, 6.24051e-06]
];

var COEFS_Y = [
    [-5.20417e-18, 0.0124, 1.21431e-18, -8.45284e-11],
    [0.0620, 0.0124, -1.26793e-09, 4.22642e-10],
    [0.1240, 0.0124, 5.07171e-09, -1.60604e-09],
    [0.1860, 0.0123999, -1.90189e-08, 6.00152e-09],
    [0.2480, 0.0124002, 7.10039e-08, -2.24e-08],
    [0.3100, 0.0123992, -2.64997e-07, 8.35986e-08],
    [0.3720, 0.0124029, 9.88983e-07, -3.11994e-07],
    [0.4340, 0.0123893, -3.69093e-06, -4.35621e-07],
    [0.4958, 0.0123198, -1.02252e-05, -3.45523e-07],
    [0.5571, 0.0121916, -1.54081e-05, -5.82288e-07],
    [0.6176, 0.0119938, -2.41424e-05, -5.25327e-07],
    [0.6769, 0.011713, -3.20223e-05, -5.16405e-07],
    [0.7346, 0.0113541, -3.97684e-05, -6.09052e-07],
    [0.7903, 0.0109107, -4.89042e-05, -1.04739e-06],
    [0.8435, 0.0103431, -6.4615e-05, -1.40374e-09],
    [0.8936, 0.00969686, -6.4636e-05, -8.547e-06],
    [0.9394, 0.00840947, -0.000192841, -4.2106e-06],
    [0.9761, 0.00616527, -0.000256, -4.2106e-06],
    [1.0000, 0.00328947, -0.000319159, -4.2106e-06]
];

var FXC = 0.8487;
var FYC = 1.3523;
var C1 = R2D/5; // rad to 5-degree interval
var RC1 = 1/C1;
var NODES = 18;

var poly3_val = function(coefs, x) {
    return coefs[0] + x * (coefs[1] + x * (coefs[2] + x * coefs[3]));
};

var poly3_der = function(coefs, x) {
    return coefs[1] + x * (2 * coefs[2] + x * 3 * coefs[3]);
};

function newton_rapshon(f_df, start, max_err, iters) {
    var x = start;
    for (; iters; --iters) {
        var upd = f_df(x);
        x -= upd;
        if (Math.abs(upd) < max_err) {
            break;
        }
    }
    return x;
}

function robin_init() {
    this.x0 = this.x0 || 0;
    this.y0 = this.y0 || 0;
    this.long0 = this.long0 || 0;
    this.es = 0;
    this.title = this.title || "Robinson";
}

function robin_forward(ll) {
    var lon = adjust_lon(ll.x - this.long0);

    var dphi = Math.abs(ll.y);
    var i = Math.floor(dphi * C1);
    if (i < 0) {
        i = 0;
    } else if (i >= NODES) {
        i = NODES - 1;
    }
    dphi = R2D * (dphi - RC1 * i);
    var xy = {
        x: poly3_val(COEFS_X[i], dphi) * lon,
        y: poly3_val(COEFS_Y[i], dphi)
    };
    if (ll.y < 0) {
        xy.y = -xy.y;
    }

    xy.x = xy.x * this.a * FXC + this.x0;
    xy.y = xy.y * this.a * FYC + this.y0;
    return xy;
}

function robin_inverse(xy) {
    var ll = {
        x: (xy.x - this.x0) / (this.a * FXC),
        y: Math.abs(xy.y - this.y0) / (this.a * FYC)
    };

    if (ll.y >= 1) { // pathologic case
        ll.x /= COEFS_X[NODES][0];
        ll.y = xy.y < 0 ? -HALF_PI : HALF_PI;
    } else {
        // find table interval
        var i = Math.floor(ll.y * NODES);
        if (i < 0) {
            i = 0;
        } else if (i >= NODES) {
            i = NODES - 1;
        }
        for (;;) {
            if (COEFS_Y[i][0] > ll.y) {
                --i;
            } else if (COEFS_Y[i+1][0] <= ll.y) {
                ++i;
            } else {
                break;
            }
        }
        // linear interpolation in 5 degree interval
        var coefs = COEFS_Y[i];
        var t = 5 * (ll.y - coefs[0]) / (COEFS_Y[i+1][0] - coefs[0]);
        // find t so that poly3_val(coefs, t) = ll.y
        t = newton_rapshon(function(x) {
            return (poly3_val(coefs, x) - ll.y) / poly3_der(coefs, x);
        }, t, EPSLN, 100);

        ll.x /= poly3_val(COEFS_X[i], t);
        ll.y = (5 * i + t) * D2R;
        if (xy.y < 0) {
            ll.y = -ll.y;
        }
    }

    ll.x = adjust_lon(ll.x + this.long0);
    return ll;
}

var robin_names = ["Robinson", "robin"];
/* harmony default export */ const robin = ({
  init: robin_init,
  forward: robin_forward,
  inverse: robin_inverse,
  names: robin_names
});

;// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/geocent.js


function geocent_init() {
    this.name = 'geocent';

}

function geocent_forward(p) {
    var point = geodeticToGeocentric(p, this.es, this.a);
    return point;
}

function geocent_inverse(p) {
    var point = geocentricToGeodetic(p, this.es, this.a, this.b);
    return point;
}

var geocent_names = ["Geocentric", 'geocentric', "geocent", "Geocent"];
/* harmony default export */ const geocent = ({
    init: geocent_init,
    forward: geocent_forward,
    inverse: geocent_inverse,
    names: geocent_names
});
;// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/tpers.js

var mode = {
  N_POLE: 0,
  S_POLE: 1,
  EQUIT: 2,
  OBLIQ: 3
};




var params = {
  h:     { def: 100000, num: true },           // default is Karman line, no default in PROJ.7
  azi:   { def: 0, num: true, degrees: true }, // default is North
  tilt:  { def: 0, num: true, degrees: true }, // default is Nadir
  long0: { def: 0, num: true },                // default is Greenwich, conversion to rad is automatic
  lat0:  { def: 0, num: true }                 // default is Equator, conversion to rad is automatic
};

function tpers_init() {
  Object.keys(params).forEach(function (p) {
    if (typeof this[p] === "undefined") {
      this[p] = params[p].def;
    } else if (params[p].num && isNaN(this[p])) {
      throw new Error("Invalid parameter value, must be numeric " + p + " = " + this[p]);
    } else if (params[p].num) {
      this[p] = parseFloat(this[p]);
    }
    if (params[p].degrees) {
      this[p] = this[p] * D2R;
    }
  }.bind(this));

  if (Math.abs((Math.abs(this.lat0) - HALF_PI)) < EPSLN) {
    this.mode = this.lat0 < 0 ? mode.S_POLE : mode.N_POLE;
  } else if (Math.abs(this.lat0) < EPSLN) {
    this.mode = mode.EQUIT;
  } else {
    this.mode = mode.OBLIQ;
    this.sinph0 = Math.sin(this.lat0);
    this.cosph0 = Math.cos(this.lat0);
  }

  this.pn1 = this.h / this.a;  // Normalize relative to the Earth's radius

  if (this.pn1 <= 0 || this.pn1 > 1e10) {
    throw new Error("Invalid height");
  }
  
  this.p = 1 + this.pn1;
  this.rp = 1 / this.p;
  this.h1 = 1 / this.pn1;
  this.pfact = (this.p + 1) * this.h1;
  this.es = 0;

  var omega = this.tilt;
  var gamma = this.azi;
  this.cg = Math.cos(gamma);
  this.sg = Math.sin(gamma);
  this.cw = Math.cos(omega);
  this.sw = Math.sin(omega);
}

function tpers_forward(p) {
  p.x -= this.long0;
  var sinphi = Math.sin(p.y);
  var cosphi = Math.cos(p.y);
  var coslam = Math.cos(p.x);
  var x, y;
  switch (this.mode) {
    case mode.OBLIQ:
      y = this.sinph0 * sinphi + this.cosph0 * cosphi * coslam;
      break;
    case mode.EQUIT:
      y = cosphi * coslam;
      break;
    case mode.S_POLE:
      y = -sinphi;
      break;
    case mode.N_POLE:
      y = sinphi;
      break;
  }
  y = this.pn1 / (this.p - y);
  x = y * cosphi * Math.sin(p.x);

  switch (this.mode) {
    case mode.OBLIQ:
      y *= this.cosph0 * sinphi - this.sinph0 * cosphi * coslam;
      break;
    case mode.EQUIT:
      y *= sinphi;
      break;
    case mode.N_POLE:
      y *= -(cosphi * coslam);
      break;
    case mode.S_POLE:
      y *= cosphi * coslam;
      break;
  }

  // Tilt 
  var yt, ba;
  yt = y * this.cg + x * this.sg;
  ba = 1 / (yt * this.sw * this.h1 + this.cw);
  x = (x * this.cg - y * this.sg) * this.cw * ba;
  y = yt * ba;

  p.x = x * this.a;
  p.y = y * this.a;
  return p;
}

function tpers_inverse(p) {
  p.x /= this.a;
  p.y /= this.a;
  var r = { x: p.x, y: p.y };

  // Un-Tilt
  var bm, bq, yt;
  yt = 1 / (this.pn1 - p.y * this.sw);
  bm = this.pn1 * p.x * yt;
  bq = this.pn1 * p.y * this.cw * yt;
  p.x = bm * this.cg + bq * this.sg;
  p.y = bq * this.cg - bm * this.sg;

  var rh = hypot(p.x, p.y);
  if (Math.abs(rh) < EPSLN) {
    r.x = 0;
    r.y = p.y;
  } else {
    var cosz, sinz;
    sinz = 1 - rh * rh * this.pfact;
    sinz = (this.p - Math.sqrt(sinz)) / (this.pn1 / rh + rh / this.pn1);
    cosz = Math.sqrt(1 - sinz * sinz);
    switch (this.mode) {
      case mode.OBLIQ:
        r.y = Math.asin(cosz * this.sinph0 + p.y * sinz * this.cosph0 / rh);
        p.y = (cosz - this.sinph0 * Math.sin(r.y)) * rh;
        p.x *= sinz * this.cosph0;
        break;
      case mode.EQUIT:
        r.y = Math.asin(p.y * sinz / rh);
        p.y = cosz * rh;
        p.x *= sinz;
        break;
      case mode.N_POLE:
        r.y = Math.asin(cosz);
        p.y = -p.y;
        break;
      case mode.S_POLE:
        r.y = -Math.asin(cosz);
        break;
    }
    r.x = Math.atan2(p.x, p.y);
  }

  p.x = r.x + this.long0;
  p.y = r.y;
  return p;
}

var tpers_names = ["Tilted_Perspective", "tpers"];
/* harmony default export */ const tpers = ({
  init: tpers_init,
  forward: tpers_forward,
  inverse: tpers_inverse,
  names: tpers_names
});

;// CONCATENATED MODULE: ./node_modules/proj4/lib/projections/geos.js


function geos_init() {
    this.flip_axis = (this.sweep === 'x' ? 1 : 0);
    this.h = Number(this.h);
    this.radius_g_1 = this.h / this.a;

    if (this.radius_g_1 <= 0 || this.radius_g_1 > 1e10) {
        throw new Error();
    }

    this.radius_g = 1.0 + this.radius_g_1;
    this.C = this.radius_g * this.radius_g - 1.0;

    if (this.es !== 0.0) {
        var one_es = 1.0 - this.es;
        var rone_es = 1 / one_es;

        this.radius_p = Math.sqrt(one_es);
        this.radius_p2 = one_es;
        this.radius_p_inv2 = rone_es;

        this.shape = 'ellipse'; // Use as a condition in the forward and inverse functions.
    } else {
        this.radius_p = 1.0;
        this.radius_p2 = 1.0;
        this.radius_p_inv2 = 1.0;

        this.shape = 'sphere';  // Use as a condition in the forward and inverse functions.
    }

    if (!this.title) {
        this.title = "Geostationary Satellite View";
    }
}

function geos_forward(p) {
    var lon = p.x;
    var lat = p.y;
    var tmp, v_x, v_y, v_z;
    lon = lon - this.long0;

    if (this.shape === 'ellipse') {
        lat = Math.atan(this.radius_p2 * Math.tan(lat));
        var r = this.radius_p / hypot(this.radius_p * Math.cos(lat), Math.sin(lat));

        v_x = r * Math.cos(lon) * Math.cos(lat);
        v_y = r * Math.sin(lon) * Math.cos(lat);
        v_z = r * Math.sin(lat);

        if (((this.radius_g - v_x) * v_x - v_y * v_y - v_z * v_z * this.radius_p_inv2) < 0.0) {
            p.x = Number.NaN;
            p.y = Number.NaN;
            return p;
        }

        tmp = this.radius_g - v_x;
        if (this.flip_axis) {
            p.x = this.radius_g_1 * Math.atan(v_y / hypot(v_z, tmp));
            p.y = this.radius_g_1 * Math.atan(v_z / tmp);
        } else {
            p.x = this.radius_g_1 * Math.atan(v_y / tmp);
            p.y = this.radius_g_1 * Math.atan(v_z / hypot(v_y, tmp));
        }
    } else if (this.shape === 'sphere') {
        tmp = Math.cos(lat);
        v_x = Math.cos(lon) * tmp;
        v_y = Math.sin(lon) * tmp;
        v_z = Math.sin(lat);
        tmp = this.radius_g - v_x;

        if (this.flip_axis) {
            p.x = this.radius_g_1 * Math.atan(v_y / hypot(v_z, tmp));
            p.y = this.radius_g_1 * Math.atan(v_z / tmp);
        } else {
            p.x = this.radius_g_1 * Math.atan(v_y / tmp);
            p.y = this.radius_g_1 * Math.atan(v_z / hypot(v_y, tmp));
        }
    }
    p.x = p.x * this.a;
    p.y = p.y * this.a;
    return p;
}

function geos_inverse(p) {
    var v_x = -1.0;
    var v_y = 0.0;
    var v_z = 0.0;
    var a, b, det, k;

    p.x = p.x / this.a;
    p.y = p.y / this.a;

    if (this.shape === 'ellipse') {
        if (this.flip_axis) {
            v_z = Math.tan(p.y / this.radius_g_1);
            v_y = Math.tan(p.x / this.radius_g_1) * hypot(1.0, v_z);
        } else {
            v_y = Math.tan(p.x / this.radius_g_1);
            v_z = Math.tan(p.y / this.radius_g_1) * hypot(1.0, v_y);
        }

        var v_zp = v_z / this.radius_p;
        a = v_y * v_y + v_zp * v_zp + v_x * v_x;
        b = 2 * this.radius_g * v_x;
        det = (b * b) - 4 * a * this.C;

        if (det < 0.0) {
            p.x = Number.NaN;
            p.y = Number.NaN;
            return p;
        }

        k = (-b - Math.sqrt(det)) / (2.0 * a);
        v_x = this.radius_g + k * v_x;
        v_y *= k;
        v_z *= k;

        p.x = Math.atan2(v_y, v_x);
        p.y = Math.atan(v_z * Math.cos(p.x) / v_x);
        p.y = Math.atan(this.radius_p_inv2 * Math.tan(p.y));
    } else if (this.shape === 'sphere') {
        if (this.flip_axis) {
            v_z = Math.tan(p.y / this.radius_g_1);
            v_y = Math.tan(p.x / this.radius_g_1) * Math.sqrt(1.0 + v_z * v_z);
        } else {
            v_y = Math.tan(p.x / this.radius_g_1);
            v_z = Math.tan(p.y / this.radius_g_1) * Math.sqrt(1.0 + v_y * v_y);
        }

        a = v_y * v_y + v_z * v_z + v_x * v_x;
        b = 2 * this.radius_g * v_x;
        det = (b * b) - 4 * a * this.C;
        if (det < 0.0) {
            p.x = Number.NaN;
            p.y = Number.NaN;
            return p;
        }

        k = (-b - Math.sqrt(det)) / (2.0 * a);
        v_x = this.radius_g + k * v_x;
        v_y *= k;
        v_z *= k;

        p.x = Math.atan2(v_y, v_x);
        p.y = Math.atan(v_z * Math.cos(p.x) / v_x);
    }
    p.x = p.x + this.long0;
    return p;
}

var geos_names = ["Geostationary Satellite View", "Geostationary_Satellite", "geos"];
/* harmony default export */ const geos = ({
    init: geos_init,
    forward: geos_forward,
    inverse: geos_inverse,
    names: geos_names,
});


;// CONCATENATED MODULE: ./node_modules/proj4/projs.js





























/* harmony default export */ function proj4_projs(proj4){
  proj4.Proj.projections.add(tmerc);
  proj4.Proj.projections.add(etmerc);
  proj4.Proj.projections.add(utm);
  proj4.Proj.projections.add(sterea);
  proj4.Proj.projections.add(stere);
  proj4.Proj.projections.add(somerc);
  proj4.Proj.projections.add(omerc);
  proj4.Proj.projections.add(lcc);
  proj4.Proj.projections.add(krovak);
  proj4.Proj.projections.add(cass);
  proj4.Proj.projections.add(laea);
  proj4.Proj.projections.add(aea);
  proj4.Proj.projections.add(gnom);
  proj4.Proj.projections.add(cea);
  proj4.Proj.projections.add(eqc);
  proj4.Proj.projections.add(poly);
  proj4.Proj.projections.add(nzmg);
  proj4.Proj.projections.add(mill);
  proj4.Proj.projections.add(sinu);
  proj4.Proj.projections.add(moll);
  proj4.Proj.projections.add(eqdc);
  proj4.Proj.projections.add(vandg);
  proj4.Proj.projections.add(aeqd);
  proj4.Proj.projections.add(ortho);
  proj4.Proj.projections.add(qsc);
  proj4.Proj.projections.add(robin);
  proj4.Proj.projections.add(geocent);
  proj4.Proj.projections.add(tpers);
  proj4.Proj.projections.add(geos);
}
;// CONCATENATED MODULE: ./node_modules/proj4/lib/index.js










core.defaultDatum = 'WGS84'; //default datum
core.Proj = Proj;
core.WGS84 = new core.Proj('WGS84');
core.Point = lib_Point;
core.toPoint = toPoint;
core.defs = lib_defs;
core.nadgrid = nadgrid;
core.transform = transform;
core.mgrs = mgrs;
core.version = '__VERSION__';
proj4_projs(core);
/* harmony default export */ const lib = (core);

;// CONCATENATED MODULE: ./src/mapboxgl/mapping/InitMap.js






/**
 * @function initMap
 * @description 根据 SuperMap iServer 服务参数，创建地图与图层。目前仅支持SuperMap iServer 地图服务。
 * @category BaseTypes Util
 * @version 11.1.1
 * @param {number} url - rest 地图服务地址。例如: http://{ip}:{port}/iserver/services/map-world/rest/maps/World。
 * @param {Object} options - 参数。
 * @param {Object} [options.type] - 地图类型。可选值 'raster' | 'vector-tile'。默认 'raster'。
 * @param {Object} [options.mapOptions] - 地图配置，参数设置参考 {@link https://docs.mapbox.com/mapbox-gl-js/api/map/}。
 * @param {string} [options.proxy] - 服务代理地址。
 * @param {boolean} [options.withCredentials=false] - 请求是否携带 cookie。
 * @param {boolean} [options.crossOrigin] - 是否允许跨域请求。
 * @param {Object} [options.headers] - 请求头。
 * @returns {Object} 实例对象。对象包括地图实例。
 * @usage
 * ```
 * // 浏览器
 * <script type="text/javascript" src="{cdn}"></script>
 * <script>
 *   const initMap = {namespace}.initMap(url, { mapOptions });
 *
 * </script>
 * // ES6 Import
 * import { initMap } from '{npm}';
 *
 * initMap(url, { mapOptions })
 * ```
 * */
function initMap(url, options = {}) {
  const initMapService = new InitMapServiceBase(MapService, url, options);
  return initMapService.getMapInfo(async (res, resolve, reject) => {
    try {
      if (res.type === 'processCompleted') {
        const {
          dynamicProjection,
          prjCoordSys: { epsgCode, type }
        } = res.result;
        if (isPlaneProjection(type)) {
          reject(new Error('mapbox-gl cannot support plane coordinate system.'));
          return;
        }
        if (epsgCode !== 3857 && !dynamicProjection && !(external_mapboxgl_default()).CRS) {
          reject(
            new Error(
              `The EPSG code ${epsgCode} needs to include mapbox-gl-enhance.js. Refer to the example: https://iclient.supermap.io/examples/mapboxgl/editor.html#mvtVectorTile_2362`
            )
          );
          return;
        }
        const mapOptions = await createMapOptions(url, res.result, { ...options, initMapService });
        const map = new (external_mapboxgl_default()).Map(mapOptions);
        if (mapOptions.style && mapOptions.style.layers && mapOptions.style.layers.length > 0) {
          map.on('load', () => {
            resolve({ map });
          });
        } else {
          resolve({ map });
        }
        return;
      }
      reject(new Error('Fetch mapService is failed.'));
    } catch (error) {
      reject(error);
    }
  });
}

/**
 * @private
 * @function getCrsExtent
 * @description 获取当前坐标系范围，[左，下，右，上]。
 * @param {Object|Array} extent -坐标系范围。
 * @returns {Array}
 */
function getCRSExtent(extent) {
  if (extent instanceof Array) {
    return extent;
  }
  if (extent.leftBottom && extent.rightTop) {
    return [extent.leftBottom.x, extent.leftBottom.y, extent.rightTop.x, extent.rightTop.y];
  }
  return [extent.left, extent.bottom, extent.right, extent.top];
}

/**
 * @private
 * @function defineCRSByWKT
 * @description 定义crs。
 * @param {string} crsName - 投影名称。
 * @param {string} wkt - wkt。
 * @param {Object} extent - 坐标系范围。
 * @returns {string}
 */
function defineCRSByWKT(crsName, wkt, extent) {
  const crsExtent = getCRSExtent(extent);
  const defineCRS = new (external_mapboxgl_default()).CRS(crsName, wkt, crsExtent);
  return defineCRS;
}

/**
 * @private
 * @function transformMapCenter
 * @description 转换center。
 * @param {Object} mapInfoCenter - 中心点。
 * @param {string} baseProjection - 坐标投影。
 * @returns {Array}
 */
function transformMapCenter(mapInfoCenter, sourceProjection) {
  let center = mapInfoCenter;
  if (sourceProjection === 'EPSG:3857') {
    return lib(sourceProjection, 'EPSG:4326', mapInfoCenter);
  }
  if (sourceProjection !== 'EPSG:4326') {
    return external_mapboxgl_default().proj4(sourceProjection, 'EPSG:4326', mapInfoCenter);
  }
  return center;
}

/**
 * @private
 * @function getVectorTileCRSExtent
 * @description 获取矢量瓦片坐标系范围。
 * @param {string} vectorStyleUrl - 矢量瓦片 style json 服务地址。
 * @param {string} restMapUrl - 矢量瓦片 rest 地图服务地址。
 * @returns {Object}
 */
async function getVectorTileCRSExtent(vectorStyleUrl, restMapUrl) {
  try {
    const vectorStyleDataRes = await FetchRequest.get(vectorStyleUrl);
    const vectorStyleData = await vectorStyleDataRes.json();
    if (vectorStyleData.metadata && vectorStyleData.metadata.indexbounds) {
      return { extent: vectorStyleData.metadata.indexbounds };
    }
    const vectorExtentDataRes = await FetchRequest.get(`${restMapUrl}/prjCoordSys/projection/extent.json`);
    const vectorExtentData = await vectorExtentDataRes.json();
    return { extent: vectorExtentData, center: vectorStyleData.center };
  } catch (error) {
    return { extent: [] };
  }
}

/**
 * @private
 * @function createMapOptions
 * @description 获取地图参数。
 * @param {string} url - rest 地图服务地址。
 * @param {Object} resetServiceInfo - rest 地图服务信息。
 * @param {Object} [options] - 参数。
 * @param {string} [options.type] - 服务代理地址。
 * @param {Object} [options.mapOptions] - 地图配置。
 * @param {Object} [options.initMapService] - InitMapServiceBase 实例。
 * @returns {Object} mapParams。
 */
async function createMapOptions(url, resetServiceInfo, options) {
  if (options.type && !['raster', 'vector-tile'].includes(options.type)) {
    return Promise.reject(new Error('type must be "raster" or "vector-tile".'));
  }
  const sourceType = options.type || 'raster';
  const mapOptions = options.mapOptions || {};
  const {
    prjCoordSys: { epsgCode },
    bounds,
    center,
    dpi,
    coordUnit,
    scale
  } = resetServiceInfo;
  let mapCenter = center ? [center.x, center.y] : [0, 0];
  let crs = `EPSG:${epsgCode}`;
  let extent = bounds;
  let tileUrl =
    sourceType === 'vector-tile'
      ? url + '/tileFeature/vectorstyles.json?type=MapBox_GL&styleonly=true&tileURLTemplate=ZXY'
      : url;
  let nonEnhanceExtraInfo = {};
  let enhanceExtraInfo = {};
  if ((external_mapboxgl_default()).CRS) {
    const baseProjection = crs;
    const wkt = await options.initMapService.getWKT();
    let vectorTileInfo;
    if (sourceType === 'vector-tile') {
      vectorTileInfo = await getVectorTileCRSExtent(tileUrl, url);
      extent = vectorTileInfo.extent;
    }
    crs = defineCRSByWKT(baseProjection, wkt, extent);
    if (sourceType === 'raster') {
      enhanceExtraInfo.rasterSource = 'iserver';
    }
    if (vectorTileInfo && vectorTileInfo.center) {
      mapCenter = vectorTileInfo.center;
    } else {
      mapCenter = transformMapCenter(mapCenter, baseProjection);
    }
  } else {
    crs = 'EPSG:3857';
    mapCenter = transformMapCenter(mapCenter, crs);
    if (sourceType === 'raster') {
      const tileSize = 256;
      nonEnhanceExtraInfo.tileSize = tileSize;
      const transparent = mapOptions.transparent !== false;
      tileUrl += `/zxyTileImage.png?z={z}&x={x}&y={y}&width=${tileSize}&height=${tileSize}&transparent=${transparent}`;
    }
  }
  const zoom = getZoom({ scale, dpi, coordUnit }, extent);
  return {
    container: 'map',
    crs,
    center: mapCenter,
    zoom,
    style:
      sourceType === 'raster'
        ? {
            version: 8,
            sources: {
              'smaples-source': {
                type: 'raster',
                tiles: [tileUrl],
                ...nonEnhanceExtraInfo,
                ...enhanceExtraInfo
              }
            },
            layers: [
              {
                id: 'sample-layer',
                type: 'raster',
                source: 'smaples-source',
                minzoom: 0,
                maxzoom: 22
              }
            ]
          }
        : tileUrl,
    ...mapOptions
  };
}



;// CONCATENATED MODULE: ./src/mapboxgl/mapping/index.js



;// CONCATENATED MODULE: ./src/mapboxgl/index.js
/* Copyright© 2000 - 2023 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/







;// CONCATENATED MODULE: ./src/mapboxgl/namespace.js
/* Copyright© 2000 - 2021 SuperMap Software Co.Ltd. All rights reserved.
 * This program are made available under the terms of the Apache License, Version 2.0
 * which accompanies this distribution and is available at http://www.apache.org/licenses/LICENSE-2.0.html.*/










(external_mapboxgl_default()).supermap = {...SuperMap, ...(external_mapboxgl_default()).supermap};
(external_mapboxgl_default()).supermap.map = (external_mapboxgl_default()).supermap.map || {};

(external_mapboxgl_default()).supermap.LogoControl = Logo;
(external_mapboxgl_default()).supermap.Logo = Logo;
(external_mapboxgl_default()).supermap.Util = core_Util_Util;
(external_mapboxgl_default()).supermap.WebMap = WebMap;
(external_mapboxgl_default()).supermap.initMap = initMap;
(external_mapboxgl_default()).supermap.Graphic = Graphic;
(external_mapboxgl_default()).supermap.map.getDefaultVectorTileStyle = getDefaultVectorTileStyle;
(external_mapboxgl_default()).supermap.map.setBackground = setBackground;
(external_mapboxgl_default()).supermap.map.setPaintProperty = setPaintProperty;
(external_mapboxgl_default()).supermap.MapvDataSet = MapvDataSet;
(external_mapboxgl_default()).supermap.GeoFeatureThemeLayer = GeoFeature;
(external_mapboxgl_default()).supermap.Theme3DLayer = Theme3DLayer;
(external_mapboxgl_default()).supermap.ThemeFeature = ThemeFeature;
(external_mapboxgl_default()).supermap.ThemeLayer = ThemeLayer_Theme;
(external_mapboxgl_default()).supermap.Transform = Transform;
(external_mapboxgl_default()).supermap.WebSymbol = WebSymbol;
(external_mapboxgl_default()).supermap.DeckglLayer = DeckglLayer;
(external_mapboxgl_default()).supermap.GraphicLayer = GraphicLayer;
(external_mapboxgl_default()).supermap.GraphThemeLayer = Graph;
(external_mapboxgl_default()).supermap.GraticuleLayer = GraticuleLayer;
(external_mapboxgl_default()).supermap.HeatMapLayer = HeatMapLayer;
(external_mapboxgl_default()).supermap.LabelThemeLayer = LabelThemeLayer_Label;
(external_mapboxgl_default()).supermap.MapvLayer = MapvLayer;
(external_mapboxgl_default()).supermap.FGBLayer = FGBLayer;
(external_mapboxgl_default()).supermap.RangeTheme3DLayer = RangeTheme3DLayer;
(external_mapboxgl_default()).supermap.RangeThemeLayer = Range;
(external_mapboxgl_default()).supermap.RankSymbolThemeLayer = RankSymbol;
(external_mapboxgl_default()).supermap.ThreeLayer = ThreeLayer;
(external_mapboxgl_default()).supermap.UniqueTheme3DLayer = UniqueTheme3DLayer;
(external_mapboxgl_default()).supermap.UniqueThemeLayer = Unique;
(external_mapboxgl_default()).supermap.GraphMap = GraphMap;

(external_mapboxgl_default()).supermap.AddressMatchService = AddressMatchService;
(external_mapboxgl_default()).supermap.ChartService = ChartService;
(external_mapboxgl_default()).supermap.DataFlowService = DataFlowService;
(external_mapboxgl_default()).supermap.DatasetService = DatasetService;
(external_mapboxgl_default()).supermap.DatasourceService = DatasourceService;
(external_mapboxgl_default()).supermap.FeatureService = FeatureService;
(external_mapboxgl_default()).supermap.FieldService = FieldService;
(external_mapboxgl_default()).supermap.GeoprocessingService = GeoprocessingService;
(external_mapboxgl_default()).supermap.GridCellInfosService = GridCellInfosService;
(external_mapboxgl_default()).supermap.ImageCollectionService = ImageCollectionService;
(external_mapboxgl_default()).supermap.ImageService = ImageService;
(external_mapboxgl_default()).supermap.LayerInfoService = LayerInfoService;
(external_mapboxgl_default()).supermap.MapService = MapService;
(external_mapboxgl_default()).supermap.MeasureService = MeasureService;
(external_mapboxgl_default()).supermap.NetworkAnalyst3DService = NetworkAnalyst3DService;
(external_mapboxgl_default()).supermap.NetworkAnalystService = NetworkAnalystService;
(external_mapboxgl_default()).supermap.ProcessingService = ProcessingService;
(external_mapboxgl_default()).supermap.QueryService = QueryService;
(external_mapboxgl_default()).supermap.ServiceBase = ServiceBase;
(external_mapboxgl_default()).supermap.SpatialAnalystService = SpatialAnalystService;
(external_mapboxgl_default()).supermap.ThemeService = ThemeService;
(external_mapboxgl_default()).supermap.TrafficTransferAnalystService = TrafficTransferAnalystService;
(external_mapboxgl_default()).supermap.WebPrintingJobService = WebPrintingJobService;
(external_mapboxgl_default()).supermap.KnowledgeGraphService = KnowledgeGraphService;

(external_mapboxgl_default()).supermap.Components.ChartView = ChartView;

// 处理命名空间重名
(external_mapboxgl_default()).supermap.CommonUtil = Util_Util;


})();

// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";


})();

/******/ })()
;